{"bugs": {"690633": {"comments": [{"count": 0, "id": 5748483, "is_private": false, "author": "jduell.mcbugs@gmail.com", "time": "2011-09-30T02:19:17Z", "creation_time": "2011-09-30T02:19:17Z", "creator": "jduell.mcbugs@gmail.com", "raw_text": "In search of enlightenment on how to properly upload a file from the filesystem onto a socket (I need to do this for Blob support in Websockets), I looked at how our HTTP code does it.\n\nIt turns out we block the entire socket transport thread on file I/O whenever we do HTTP file uploads (or send XHR Blobs that are backed by a file).  I'm assuming that's a Bad Thing (and if it's not a big deal now for occasional file uploads, it'll be one for Web 6.0++, when the Blobs are a-flyin' freely).\n\nHere's the stack trace from hitting POST on a form with a file upload:\n\n#0  nsFileInputStream::Read at /netwerk/base/src/nsFileStreams.cpp:367 \n    -- Calls PR_Read(), which blocks until it returns data from disk.\n#1  in nsBufferedInputStream::Fill at /netwerk/base/src/nsBufferedStreams.cpp:399\n#2  in nsBufferedInputStream::ReadSegments at /netwerk/base/src/nsBufferedStreams.cpp:363\n#3  in nsBufferedInputStream::Read at /netwerk/base/src/nsBufferedStreams.cpp:335\n#4  in nsMultiplexInputStream::Read at /xpcom/io/nsMultiplexInputStream.cpp:224\n#5  in nsMultiplexInputStream::Read  at /xpcom/io/nsMultiplexInputStream.cpp:224\n#6  in nsMIMEInputStream::Read at /netwerk/base/src/nsMIMEInputStream.cpp:282\n#7  in nsMultiplexInputStream::Read at /xpcom/io/nsMultiplexInputStream.cpp:224\n#8  in nsBufferedInputStream::Fill at /netwerk/base/src/nsBufferedStreams.cpp:399\n#9  in nsBufferedInputStream::ReadSegments at /netwerk/base/src/nsBufferedStreams.cpp:363\n#10 in nsHttpTransaction::ReadSegments at /netwerk/protocol/http/nsHttpTransaction.cpp:488\n#11 in nsHttpConnection::OnSocketWritable  at /netwerk/protocol/http/nsHttpConnection.cpp:709\n#12 in nsHttpConnection::OnOutputStreamReady  at /netwerk/protocol/http/nsHttpConnection.cpp:940\n#13 in nsHttpConnection::Activate at /netwerk/protocol/http/nsHttpConnection.cpp:191\n#14 in nsHttpConnectionMgr::DispatchTransaction at /netwerk/protocol/http/nsHttpConnectionMgr.cpp:866\n#15 in nsHttpConnectionMgr::nsHalfOpenSocket::OnOutputStreamReady at /netwerk/protocol/http/nsHttpConnectionMgr.cpp:1577\n#16 in nsSocketOutputStream::OnSocketReady at /netwerk/base/src/nsSocketTransport2.cpp:514\n#17 in nsSocketTransport::OnSocketReady at /netwerk/base/src/nsSocketTransport2.cpp:1531\n#18 in nsSocketTransportService::DoPollIteration at /netwerk/base/src/nsSocketTransportService2.cpp:738\n#19 in nsSocketTransportService::Run at /netwerk/base/src/nsSocketTransportService2.cpp:631\n\nIt looks like we didn't intend this to happen: nsHttpTransaction::ReadSegments has code that checks to see if mRequestStream->ReadSegments() returns NS_BASE_STREAM_WOULD_BLOCK, and if so we do\n\n    // if read would block then we need to AsyncWait on the request stream.\n    // have callback occur on socket thread so we stay synchronized.\n    if (rv == NS_BASE_STREAM_WOULD_BLOCK) {\n        nsCOMPtr<nsIAsyncInputStream> asyncIn =\n                do_QueryInterface(mRequestStream);\n        if (asyncIn) {\n            nsCOMPtr<nsIEventTarget> target;\n            gHttpHandler->GetSocketThreadTarget(getter_AddRefs(target));\n            if (target)\n                asyncIn->AsyncWait(this, 0, 0, target);\n\nBut this is defeated by the fact that nothing in the big pile 'o streams returns NS_BASE_STREAM_WOULD_BLOCK.\n\nI can think of two solutions here:\n\n1) add a new nsNonBlockingBufferedInputStream class (or add nsIAsyncInputStream support into the existing nsBufferedInputStream class), and instead of having its ReadSegments() function call Fill() when its buffer is empty (which does a blocking Read), it should return NS_BASE_STREAM_WOULD_BLOCK and arrange to fill it's buffer in a non-blocking way, presumably by sending the I/O to a reader thread.\n\n2) We already have a class that's devoted to turning blocking streams into async ones: nsIStreamTransportService.  If we determine that the upload stream contains a blocking stream, we should probably use this class instead of reading from the stream directly.  However, this will at a mimumum require us to change the implementation of nsMultiplexInputStream::IsNonBlocking().  Right now it returns \"true\" if *any* of the streams it wraps are nonblocking.  Instead it would only return true if *all* of its substreams are nonblocking (that makes a whole lot more sense to me anyway, no?).  I haven't looked into what this change might break, however, and I also don't know how well nsIStreamTransportService plays with streams that are already nonblocking (there's a mix of blocking/nonblocking streams in a form POST): the IDL says the stream 'must implement \"blocking\" stream semantics': not clear on what that means in practice.\n\n#2 sounds better to me, but the changes for #1 sound narrower in scope.\n\nThoughts?", "attachment_id": null, "bug_id": 690633, "text": "In search of enlightenment on how to properly upload a file from the filesystem onto a socket (I need to do this for Blob support in Websockets), I looked at how our HTTP code does it.\n\nIt turns out we block the entire socket transport thread on file I/O whenever we do HTTP file uploads (or send XHR Blobs that are backed by a file).  I'm assuming that's a Bad Thing (and if it's not a big deal now for occasional file uploads, it'll be one for Web 6.0++, when the Blobs are a-flyin' freely).\n\nHere's the stack trace from hitting POST on a form with a file upload:\n\n#0  nsFileInputStream::Read at /netwerk/base/src/nsFileStreams.cpp:367 \n    -- Calls PR_Read(), which blocks until it returns data from disk.\n#1  in nsBufferedInputStream::Fill at /netwerk/base/src/nsBufferedStreams.cpp:399\n#2  in nsBufferedInputStream::ReadSegments at /netwerk/base/src/nsBufferedStreams.cpp:363\n#3  in nsBufferedInputStream::Read at /netwerk/base/src/nsBufferedStreams.cpp:335\n#4  in nsMultiplexInputStream::Read at /xpcom/io/nsMultiplexInputStream.cpp:224\n#5  in nsMultiplexInputStream::Read  at /xpcom/io/nsMultiplexInputStream.cpp:224\n#6  in nsMIMEInputStream::Read at /netwerk/base/src/nsMIMEInputStream.cpp:282\n#7  in nsMultiplexInputStream::Read at /xpcom/io/nsMultiplexInputStream.cpp:224\n#8  in nsBufferedInputStream::Fill at /netwerk/base/src/nsBufferedStreams.cpp:399\n#9  in nsBufferedInputStream::ReadSegments at /netwerk/base/src/nsBufferedStreams.cpp:363\n#10 in nsHttpTransaction::ReadSegments at /netwerk/protocol/http/nsHttpTransaction.cpp:488\n#11 in nsHttpConnection::OnSocketWritable  at /netwerk/protocol/http/nsHttpConnection.cpp:709\n#12 in nsHttpConnection::OnOutputStreamReady  at /netwerk/protocol/http/nsHttpConnection.cpp:940\n#13 in nsHttpConnection::Activate at /netwerk/protocol/http/nsHttpConnection.cpp:191\n#14 in nsHttpConnectionMgr::DispatchTransaction at /netwerk/protocol/http/nsHttpConnectionMgr.cpp:866\n#15 in nsHttpConnectionMgr::nsHalfOpenSocket::OnOutputStreamReady at /netwerk/protocol/http/nsHttpConnectionMgr.cpp:1577\n#16 in nsSocketOutputStream::OnSocketReady at /netwerk/base/src/nsSocketTransport2.cpp:514\n#17 in nsSocketTransport::OnSocketReady at /netwerk/base/src/nsSocketTransport2.cpp:1531\n#18 in nsSocketTransportService::DoPollIteration at /netwerk/base/src/nsSocketTransportService2.cpp:738\n#19 in nsSocketTransportService::Run at /netwerk/base/src/nsSocketTransportService2.cpp:631\n\nIt looks like we didn't intend this to happen: nsHttpTransaction::ReadSegments has code that checks to see if mRequestStream->ReadSegments() returns NS_BASE_STREAM_WOULD_BLOCK, and if so we do\n\n    // if read would block then we need to AsyncWait on the request stream.\n    // have callback occur on socket thread so we stay synchronized.\n    if (rv == NS_BASE_STREAM_WOULD_BLOCK) {\n        nsCOMPtr<nsIAsyncInputStream> asyncIn =\n                do_QueryInterface(mRequestStream);\n        if (asyncIn) {\n            nsCOMPtr<nsIEventTarget> target;\n            gHttpHandler->GetSocketThreadTarget(getter_AddRefs(target));\n            if (target)\n                asyncIn->AsyncWait(this, 0, 0, target);\n\nBut this is defeated by the fact that nothing in the big pile 'o streams returns NS_BASE_STREAM_WOULD_BLOCK.\n\nI can think of two solutions here:\n\n1) add a new nsNonBlockingBufferedInputStream class (or add nsIAsyncInputStream support into the existing nsBufferedInputStream class), and instead of having its ReadSegments() function call Fill() when its buffer is empty (which does a blocking Read), it should return NS_BASE_STREAM_WOULD_BLOCK and arrange to fill it's buffer in a non-blocking way, presumably by sending the I/O to a reader thread.\n\n2) We already have a class that's devoted to turning blocking streams into async ones: nsIStreamTransportService.  If we determine that the upload stream contains a blocking stream, we should probably use this class instead of reading from the stream directly.  However, this will at a mimumum require us to change the implementation of nsMultiplexInputStream::IsNonBlocking().  Right now it returns \"true\" if *any* of the streams it wraps are nonblocking.  Instead it would only return true if *all* of its substreams are nonblocking (that makes a whole lot more sense to me anyway, no?).  I haven't looked into what this change might break, however, and I also don't know how well nsIStreamTransportService plays with streams that are already nonblocking (there's a mix of blocking/nonblocking streams in a form POST): the IDL says the stream 'must implement \"blocking\" stream semantics': not clear on what that means in practice.\n\n#2 sounds better to me, but the changes for #1 sound narrower in scope.\n\nThoughts?", "tags": []}, {"bug_id": 690633, "text": "I new I had seen this somewhere... nsIStreamTransportService may be a solution here.  It creates an nsITransport from nsIInputStream.  We can then query that transport for an input stream, that is async (one side of a pipe) that is async copied on a pooled background thread.", "tags": [], "attachment_id": null, "raw_text": "I new I had seen this somewhere... nsIStreamTransportService may be a solution here.  It creates an nsITransport from nsIInputStream.  We can then query that transport for an input stream, that is async (one side of a pipe) that is async copied on a pooled background thread.", "creator": "honzab.moz@firemni.cz", "creation_time": "2011-09-30T15:17:36Z", "time": "2011-09-30T15:17:36Z", "author": "honzab.moz@firemni.cz", "is_private": false, "count": 1, "id": 5749562}, {"text": "My patch in Bug 1329089 will make this issue less severe before this is fixed.", "bug_id": 690633, "tags": [], "raw_text": "My patch in Bug 1329089 will make this issue less severe before this is fixed.", "attachment_id": null, "author": "polo.hellfire@gmail.com", "time": "2017-01-12T09:40:55Z", "creation_time": "2017-01-12T09:40:55Z", "creator": "polo.hellfire@gmail.com", "count": 2, "id": 11976893, "is_private": false}, {"is_private": false, "count": 3, "id": 12657716, "author": "bug-husbandry-bot@mozilla.bugs", "creator": "bug-husbandry-bot@mozilla.bugs", "time": "2017-09-13T18:34:13Z", "creation_time": "2017-09-13T18:34:13Z", "raw_text": "Bulk change to priority: https://bugzilla.mozilla.org/show_bug.cgi?id=1399258", "attachment_id": null, "tags": [], "text": "Bulk change to priority: https://bugzilla.mozilla.org/show_bug.cgi?id=1399258", "bug_id": 690633}, {"raw_text": "Bulk change to priority: https://bugzilla.mozilla.org/show_bug.cgi?id=1399258", "attachment_id": null, "tags": [], "bug_id": 690633, "text": "Bulk change to priority: https://bugzilla.mozilla.org/show_bug.cgi?id=1399258", "is_private": false, "count": 4, "id": 12659271, "author": "bug-husbandry-bot@mozilla.bugs", "creator": "bug-husbandry-bot@mozilla.bugs", "time": "2017-09-13T18:46:29Z", "creation_time": "2017-09-13T18:46:29Z"}]}}, "comments": {}}