{"bugs": {"702697": {"comments": [{"creation_time": "2011-11-15T19:04:56Z", "author": "hlavac@softidea.sk", "text": "User Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.2 (KHTML, like Gecko) Chrome/15.0.874.120 Safari/535.2\n\nSteps to reproduce:\n\nAbstract:\nWhile logging in to the https page (e.g.  https://secure.cacert.org/) using client certificate and RSA keys generated on the PKCS#11 token the process fails, because Firefox asks pkcs11 library to sign incorrectly encoded cryptographical data.\n\nTest case:\nIn Firefox (8.0; Nightly 11.0a1) load pkcs11 token supporting CKM_RSA_PKCS. Generate RSA key pair and client certificate on token (e.g.  https://www.cacert.org, \"Join\"). Try to login to the site using the generated client certificate (e.g.  https://www.cacert.org, \"Certificate Login\").\n\n\nActual results:\n\nResult: \nPKCS11 library returns error CKR_DATA_LEN_RANGE as a response to the C_Sign call. Firefox shows error message \"An error occurred during a connection to secure.cacert.org.\nUnable to digitally sign data required to verify your certificate.\n(Error code: ssl_error_sign_hashes_failure)\"\n\n\nExpected results:\n\nExpected result: \nOperation succeeds.\n\nImpact:\nFirefox SSL client authentification does not work with PKCS11 library that is encoded in agreement with PKCS#11 and PKCS#1 standards.\n\nDetails:\nThe application tries to sign data buffer using the mechanism CKM_RSA_PKCS. With this mechanism the input data buffer should contain structure DigestInfo? which is the encoded hash algorithm identifier + raw hash. Instead firefox supplies data consisting of concatenated raw md5 + sha1 hashes. This violates rules defined by pkcs#1 in versions 1.5-2.1.\n\nStack trace:\nPK11_Sign(SECKEYPrivateKey *key, SECItem *sig, SECItem *hash) Line 768 C\nssl3_SignHashes(SSL3Hashes * hash, SECKEYPrivateKeyStr * key, SECItemStr * buf, int isTLS) Line 888 C\nssl3_SendCertificateVerify(sslSocketStr * ss) Line 4858 C\nssl3_HandleServerHelloDone(sslSocketStr * ss) Line 5782 + 0x9 bytes C\nssl3_HandleHandshakeMessage(sslSocketStr * ss, unsigned char * b, unsigned int length) Line 8684 + 0x9 bytes C\nssl3_HandleHandshake(sslSocketStr * ss, sslBufferStr * origBuf) Line 8779 + 0x19 bytes C\nssl3_HandleRecord(sslSocketStr * ss, SSL3Ciphertext * cText, sslBufferStr * databuf) Line 9118 + 0xd bytes C\nssl3_GatherCompleteHandshake(sslSocketStr * ss, int flags) Line 209 + 0x17 bytes C\nssl_GatherRecord1stHandshake(sslSocketStr * ss) Line 1258 + 0xb bytes C\nssl_Do1stHandshake(sslSocketStr * ss) Line 153 + 0xf bytes C\nssl_SecureSend(sslSocketStr * ss, const unsigned char * buf, int len, int flags) Line 1229 + 0x9 bytes C\nssl_SecureWrite(sslSocketStr * ss, const unsigned char * buf, int len) Line 1274 + 0x13 bytes C\nssl_Write(PRFileDesc * fd, const void * buf, int len) Line 1689 + 0x17 bytes C\nnsSSLThread::Run() Line 1047 + 0x1c bytes C++\n...\n\nAnalyses:\nFor test purposes I modified the pkcs11 library in order to sign the supplied hashes H=MD5|SHA1, |H|=36 as it was DigestInfo so in effect using encoding: EM=0|1|0|PS|0|H. The operation suceeded.\n\nProposed solution:\nIf behaviour defined in \"Analyses\" is desired, I propose to do the encoding to EM=0|1|0|PS|0|MD5|SHA1 within the NSS code and supply the encoded data to the signature process using the appropriate mechanism CKM_RSA_X_509. Doing things as stated in \"Analyses\" is violation of PKCS#1 and if any PKCS#11 provider implements \"workaround\" that makes things work this way, such workaround could provide potential security threat.\n\nNote: \nSeems to me that the primary issue is that the specification of SSL itself (3.0 and 3.1) is in conflict with PKCS#1 regarding to encoding of hash data for RSA signature.", "time": "2011-11-15T19:04:56Z", "bug_id": 702697, "tags": [], "is_private": false, "creator": "hlavac@softidea.sk", "count": 0, "id": 5849968, "attachment_id": null, "raw_text": "User Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.2 (KHTML, like Gecko) Chrome/15.0.874.120 Safari/535.2\n\nSteps to reproduce:\n\nAbstract:\nWhile logging in to the https page (e.g.  https://secure.cacert.org/) using client certificate and RSA keys generated on the PKCS#11 token the process fails, because Firefox asks pkcs11 library to sign incorrectly encoded cryptographical data.\n\nTest case:\nIn Firefox (8.0; Nightly 11.0a1) load pkcs11 token supporting CKM_RSA_PKCS. Generate RSA key pair and client certificate on token (e.g.  https://www.cacert.org, \"Join\"). Try to login to the site using the generated client certificate (e.g.  https://www.cacert.org, \"Certificate Login\").\n\n\nActual results:\n\nResult: \nPKCS11 library returns error CKR_DATA_LEN_RANGE as a response to the C_Sign call. Firefox shows error message \"An error occurred during a connection to secure.cacert.org.\nUnable to digitally sign data required to verify your certificate.\n(Error code: ssl_error_sign_hashes_failure)\"\n\n\nExpected results:\n\nExpected result: \nOperation succeeds.\n\nImpact:\nFirefox SSL client authentification does not work with PKCS11 library that is encoded in agreement with PKCS#11 and PKCS#1 standards.\n\nDetails:\nThe application tries to sign data buffer using the mechanism CKM_RSA_PKCS. With this mechanism the input data buffer should contain structure DigestInfo? which is the encoded hash algorithm identifier + raw hash. Instead firefox supplies data consisting of concatenated raw md5 + sha1 hashes. This violates rules defined by pkcs#1 in versions 1.5-2.1.\n\nStack trace:\nPK11_Sign(SECKEYPrivateKey *key, SECItem *sig, SECItem *hash) Line 768 C\nssl3_SignHashes(SSL3Hashes * hash, SECKEYPrivateKeyStr * key, SECItemStr * buf, int isTLS) Line 888 C\nssl3_SendCertificateVerify(sslSocketStr * ss) Line 4858 C\nssl3_HandleServerHelloDone(sslSocketStr * ss) Line 5782 + 0x9 bytes C\nssl3_HandleHandshakeMessage(sslSocketStr * ss, unsigned char * b, unsigned int length) Line 8684 + 0x9 bytes C\nssl3_HandleHandshake(sslSocketStr * ss, sslBufferStr * origBuf) Line 8779 + 0x19 bytes C\nssl3_HandleRecord(sslSocketStr * ss, SSL3Ciphertext * cText, sslBufferStr * databuf) Line 9118 + 0xd bytes C\nssl3_GatherCompleteHandshake(sslSocketStr * ss, int flags) Line 209 + 0x17 bytes C\nssl_GatherRecord1stHandshake(sslSocketStr * ss) Line 1258 + 0xb bytes C\nssl_Do1stHandshake(sslSocketStr * ss) Line 153 + 0xf bytes C\nssl_SecureSend(sslSocketStr * ss, const unsigned char * buf, int len, int flags) Line 1229 + 0x9 bytes C\nssl_SecureWrite(sslSocketStr * ss, const unsigned char * buf, int len) Line 1274 + 0x13 bytes C\nssl_Write(PRFileDesc * fd, const void * buf, int len) Line 1689 + 0x17 bytes C\nnsSSLThread::Run() Line 1047 + 0x1c bytes C++\n...\n\nAnalyses:\nFor test purposes I modified the pkcs11 library in order to sign the supplied hashes H=MD5|SHA1, |H|=36 as it was DigestInfo so in effect using encoding: EM=0|1|0|PS|0|H. The operation suceeded.\n\nProposed solution:\nIf behaviour defined in \"Analyses\" is desired, I propose to do the encoding to EM=0|1|0|PS|0|MD5|SHA1 within the NSS code and supply the encoded data to the signature process using the appropriate mechanism CKM_RSA_X_509. Doing things as stated in \"Analyses\" is violation of PKCS#1 and if any PKCS#11 provider implements \"workaround\" that makes things work this way, such workaround could provide potential security threat.\n\nNote: \nSeems to me that the primary issue is that the specification of SSL itself (3.0 and 3.1) is in conflict with PKCS#1 regarding to encoding of hash data for RSA signature."}]}}, "comments": {}}