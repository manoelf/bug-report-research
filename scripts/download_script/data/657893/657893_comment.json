{"comments": {}, "bugs": {"657893": {"comments": [{"raw_text": "For content we allocate buffers bigger than the actually visible portion to faciliate smooth scrolling.\nFor chrome content like floating thebes elements or scroll boxes, such as the awesomepage url list or the settings page in fennec, we are very strict about what gets painted. This leads to many paint/resize/blit operations, which are expensive for openGL backends. If we really want to leverage the gpu and provide smooth scrolling we need to pre-cache out of view chrome contents to a reasonable extent.", "bug_id": 657893, "count": 0, "time": "2011-05-18T10:07:31Z", "is_private": false, "tags": [], "creation_time": "2011-05-18T10:07:31Z", "attachment_id": null, "id": 5476750, "text": "For content we allocate buffers bigger than the actually visible portion to faciliate smooth scrolling.\nFor chrome content like floating thebes elements or scroll boxes, such as the awesomepage url list or the settings page in fennec, we are very strict about what gets painted. This leads to many paint/resize/blit operations, which are expensive for openGL backends. If we really want to leverage the gpu and provide smooth scrolling we need to pre-cache out of view chrome contents to a reasonable extent.", "creator": "florian.haenel@heeen.de", "author": "florian.haenel@heeen.de"}, {"author": "florian.haenel@heeen.de", "id": 5476755, "attachment_id": null, "text": "Adding some people for discussion.", "creator": "florian.haenel@heeen.de", "creation_time": "2011-05-18T10:09:04Z", "is_private": false, "tags": [], "time": "2011-05-18T10:09:04Z", "count": 1, "raw_text": "Adding some people for discussion.", "bug_id": 657893}, {"text": "We could adapt setDisplayportForElement so that Fennec could specify how much to retain. It shouldn't be very hard--we should just remove the metadata from nsDisplayScrollLayer for the chrome process and I think everything else might just work.", "creator": "ben@stechz.com", "id": 5478544, "attachment_id": null, "author": "ben@stechz.com", "creation_time": "2011-05-18T22:35:55Z", "time": "2011-05-18T22:35:55Z", "tags": [], "is_private": false, "bug_id": 657893, "raw_text": "We could adapt setDisplayportForElement so that Fennec could specify how much to retain. It shouldn't be very hard--we should just remove the metadata from nsDisplayScrollLayer for the chrome process and I think everything else might just work.", "count": 2}, {"author": "florian.haenel@heeen.de", "text": "Created attachment 537777\noprofile callgraph - scrolling in settings", "creator": "florian.haenel@heeen.de", "attachment_id": 537777, "id": 5517270, "creation_time": "2011-06-07T13:47:46Z", "tags": [], "is_private": false, "time": "2011-06-07T13:47:46Z", "count": 3, "bug_id": 657893, "raw_text": ""}, {"text": "Comment #2 would be fine, but we could also make chrome scrollboxes automatically pre-cache.", "creator": "roc@ocallahan.org", "attachment_id": null, "id": 5521001, "author": "roc@ocallahan.org", "creation_time": "2011-06-08T22:12:16Z", "time": "2011-06-08T22:12:16Z", "tags": [], "is_private": false, "bug_id": 657893, "raw_text": "Comment #2 would be fine, but we could also make chrome scrollboxes automatically pre-cache.", "count": 4}, {"raw_text": "So, honestly I'd much rather fix painting being slow than start caching things. Memory is precious for mobile devices. From the callgraph, it's not as if uploading to GL is any sort of bottleneck here. We spend a lot of time...painting backgrounds it seems?", "bug_id": 657893, "count": 5, "time": "2011-06-15T17:11:51Z", "is_private": false, "tags": [], "creation_time": "2011-06-15T17:11:51Z", "id": 5534366, "attachment_id": null, "creator": "ben@stechz.com", "text": "So, honestly I'd much rather fix painting being slow than start caching things. Memory is precious for mobile devices. From the callgraph, it's not as if uploading to GL is any sort of bottleneck here. We spend a lot of time...painting backgrounds it seems?", "author": "ben@stechz.com"}, {"raw_text": "So I'm figuring stuff out...\nfirst: nsDisplayScrollLayer and nsDisplayScrollInfoLayer rely on the scrolllayer count property on their mScrolled frame, right? it is increased for every item generated and reduced for every item that gets optimized away.\nBut it turns out it is only decremented for the TryMerge case, not the ShouldFlattenAway case - so you can end up with a flat list of display items and the count is still > 0 - is this intended?\n\nsecondly, about the fennec use case.\nwe use the gfxScrollFrame for Preferences scrolling. It turns out that the background items and the text/foreground items are separated by the scrollframes and the images above the settings scroller (the settings tab headers if you will). I can reason about the scrollbars somehow - they are an intrinsic part of the scroller, but why the images? they don't even overlap the scroller.\nWith the separated bg and front items their respective clips don't get merged and in turn the scrolllayers don't get merged, so we end up with two thebes layers that get independently painted.", "bug_id": 657893, "count": 6, "time": "2011-07-21T15:33:40Z", "is_private": false, "tags": [], "creation_time": "2011-07-21T15:33:40Z", "id": 5604405, "attachment_id": null, "creator": "florian.haenel@heeen.de", "text": "So I'm figuring stuff out...\nfirst: nsDisplayScrollLayer and nsDisplayScrollInfoLayer rely on the scrolllayer count property on their mScrolled frame, right? it is increased for every item generated and reduced for every item that gets optimized away.\nBut it turns out it is only decremented for the TryMerge case, not the ShouldFlattenAway case - so you can end up with a flat list of display items and the count is still > 0 - is this intended?\n\nsecondly, about the fennec use case.\nwe use the gfxScrollFrame for Preferences scrolling. It turns out that the background items and the text/foreground items are separated by the scrollframes and the images above the settings scroller (the settings tab headers if you will). I can reason about the scrollbars somehow - they are an intrinsic part of the scroller, but why the images? they don't even overlap the scroller.\nWith the separated bg and front items their respective clips don't get merged and in turn the scrolllayers don't get merged, so we end up with two thebes layers that get independently painted.", "author": "florian.haenel@heeen.de"}, {"attachment_id": null, "id": 5604550, "text": "(In reply to comment #6)\n> So I'm figuring stuff out...\n> first: nsDisplayScrollLayer and nsDisplayScrollInfoLayer rely on the\n> scrolllayer count property on their mScrolled frame, right? it is increased\n> for every item generated and reduced for every item that gets optimized away.\n> But it turns out it is only decremented for the TryMerge case, not the\n> ShouldFlattenAway case - so you can end up with a flat list of display items\n> and the count is still > 0 - is this intended?\n\nYes. If we get to ShouldFlattenAway, *all* the remaining nsDisplayScrollLayers for that frame should disappear.\n\n> secondly, about the fennec use case.\n> we use the gfxScrollFrame for Preferences scrolling. It turns out that the\n> background items and the text/foreground items are separated by the\n> scrollframes and the images above the settings scroller (the settings tab\n> headers if you will). I can reason about the scrollbars somehow - they are\n> an intrinsic part of the scroller, but why the images? they don't even\n> overlap the scroller.\n> With the separated bg and front items their respective clips don't get\n> merged and in turn the scrolllayers don't get merged, so we end up with two\n> thebes layers that get independently painted.\n\nI'm not getting a clear picture of the problem with this description. Maybe you could post the relevant display list here (or actually, in a new bug)? The more succinct, the easier it will be to understand, so if you can please hide as much in the preferences as possible that gets your case across.\n\nIt certainly seems like this may be a case where there's no reason we can't generate a new layer, but I think we'll need a reduced example to tease out the proper answer.\n\nIn short, it sounds like you are on the right track, but the display list needs a little massaging.", "creator": "ben@stechz.com", "author": "ben@stechz.com", "creation_time": "2011-07-21T16:38:52Z", "time": "2011-07-21T16:38:52Z", "is_private": false, "tags": [], "raw_text": "(In reply to comment #6)\n> So I'm figuring stuff out...\n> first: nsDisplayScrollLayer and nsDisplayScrollInfoLayer rely on the\n> scrolllayer count property on their mScrolled frame, right? it is increased\n> for every item generated and reduced for every item that gets optimized away.\n> But it turns out it is only decremented for the TryMerge case, not the\n> ShouldFlattenAway case - so you can end up with a flat list of display items\n> and the count is still > 0 - is this intended?\n\nYes. If we get to ShouldFlattenAway, *all* the remaining nsDisplayScrollLayers for that frame should disappear.\n\n> secondly, about the fennec use case.\n> we use the gfxScrollFrame for Preferences scrolling. It turns out that the\n> background items and the text/foreground items are separated by the\n> scrollframes and the images above the settings scroller (the settings tab\n> headers if you will). I can reason about the scrollbars somehow - they are\n> an intrinsic part of the scroller, but why the images? they don't even\n> overlap the scroller.\n> With the separated bg and front items their respective clips don't get\n> merged and in turn the scrolllayers don't get merged, so we end up with two\n> thebes layers that get independently painted.\n\nI'm not getting a clear picture of the problem with this description. Maybe you could post the relevant display list here (or actually, in a new bug)? The more succinct, the easier it will be to understand, so if you can please hide as much in the preferences as possible that gets your case across.\n\nIt certainly seems like this may be a case where there's no reason we can't generate a new layer, but I think we'll need a reduced example to tease out the proper answer.\n\nIn short, it sounds like you are on the right track, but the display list needs a little massaging.", "bug_id": 657893, "count": 7}, {"creation_time": "2011-07-25T07:42:11Z", "text": "I was able to prevent the images from getting in between the scrolled content's border&background and text by forcing a new stacking context:\n<box id=\"panel-controls\" class=\"panel-row-header\" oncommand=\"BrowserUI.switchPane(event.target.getAttribute('linkedpanel'));\" style=\"position:relative; z-index:0;\">\nhere: http://mxr.mozilla.org/mozilla-central/source/mobile/chrome/content/browser.xul#381\n\nas for the scrollbars, I'm looking at the AppendScrollPartsTo function to see if we can force them into a different stacking context or at least put them at the bottom of the context they are in right now.\n\nAlso I'm looking at why the scrolled content is divided into two clips with backgrounds and texts at all - shouldn't they be in a single clip?", "attachment_id": null, "id": 5610415, "raw_text": "I was able to prevent the images from getting in between the scrolled content's border&background and text by forcing a new stacking context:\n<box id=\"panel-controls\" class=\"panel-row-header\" oncommand=\"BrowserUI.switchPane(event.target.getAttribute('linkedpanel'));\" style=\"position:relative; z-index:0;\">\nhere: http://mxr.mozilla.org/mozilla-central/source/mobile/chrome/content/browser.xul#381\n\nas for the scrollbars, I'm looking at the AppendScrollPartsTo function to see if we can force them into a different stacking context or at least put them at the bottom of the context they are in right now.\n\nAlso I'm looking at why the scrolled content is divided into two clips with backgrounds and texts at all - shouldn't they be in a single clip?", "tags": [], "is_private": false, "author": "florian.haenel@heeen.de", "creator": "florian.haenel@heeen.de", "count": 8, "bug_id": 657893, "time": "2011-07-25T07:42:11Z"}, {"count": 9, "bug_id": 657893, "time": "2011-07-25T07:48:07Z", "author": "florian.haenel@heeen.de", "creator": "florian.haenel@heeen.de", "raw_text": "display lists after I managed to force the images into a different stacking context, but the scrollbars still intervene.\n\nWe create two thebes layers the size of the viewport and lock/paint/unlock both of them with every scrolled pixel.", "tags": [], "is_private": false, "creation_time": "2011-07-25T07:48:07Z", "text": "display lists after I managed to force the images into a different stacking context, but the scrollbars still intervene.\n\nWe create two thebes layers the size of the viewport and lock/paint/unlock both of them with every scrolled pixel.", "id": 5610421, "attachment_id": null}, {"author": "florian.haenel@heeen.de", "creator": "florian.haenel@heeen.de", "time": "2011-07-25T07:48:51Z", "count": 10, "bug_id": 657893, "id": 5610422, "attachment_id": 548113, "text": "Created attachment 548113\nscrollbars", "creation_time": "2011-07-25T07:48:51Z", "is_private": false, "tags": [], "raw_text": ""}, {"attachment_id": null, "id": 5611205, "text": "So the changes I propose - sorry my tree is full of printfs right now - are:\n\n1.: Prevent the toolbar tabs from interfering with the scrollboxes below:\n\n- <box id=\"panel-controls\" class=\"panel-row-header\" oncommand=\"BrowserUI.switchPane(event.target.getAttribute('linkedpanel'));\">\n+ <box id=\"panel-controls\" class=\"panel-row-header\" oncommand=\"BrowserUI.switchPane(event.target.getAttribute('linkedpanel'));\" style=\"position:relative; z-index:0;\">\n\n2.: Set display ports on relevant scrollboxes:\n\nlet winCwu = window.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils);\nwinCwu.setDisplayPortForElement(0, 0, 854, 2048, document.getElementById(\"prefs-list\")._scrollbox);\n\n3.: We want a flag here, or want to enable it always if we have a display port set:\n\nPRBool createLayersForScrollbars = mIsRoot &&\n  mOuter->PresContext()->IsRootContentDocument();\ncreateLayersForScrollbars=true; //FIXME\n\n4.: I think we want to reduce the count of nsDisplayScrollLayers on frames if we merge them:\n\nPRBool\nnsDisplayScrollLayer::TryMerge(nsDisplayListBuilder* aBuilder,\n                               nsDisplayItem* aItem)\n{\n  if (aItem->GetType() != TYPE_SCROLL_LAYER) {\n    return PR_FALSE;\n  }\n\n  nsDisplayScrollLayer* other = static_cast<nsDisplayScrollLayer*>(aItem);\n  if (other->mScrolledFrame != this->mScrolledFrame) {\n    return PR_FALSE;\n  }\n\n+  FrameProperties props = mScrolledFrame->Properties();\n+  int count=GetScrollLayerCount() - 1;\n+  props.Set(nsIFrame::ScrollLayerCount(),\n+    reinterpret_cast<void*>(count));\n\n  mList.AppendToBottom(&other->mList);\n  return PR_TRUE;\n}\n\n5.: Get the scrollbars out between the text and border&background of the scrolled content:\n\nnsGfxScrollFrameInner::AppendScrollPartsTo(nsDisplayListBuilder*          aBuilder,\nconst nsRect&                  aDirtyRect,\nconst nsDisplayListSet&        aLists,\nconst nsDisplayListCollection& aDest,\nPRBool&                        aCreateLayer)\n{\n  nsresult rv = NS_OK;\n  PRBool hasResizer = HasResizer();\n  for (nsIFrame* kid = mOuter->GetFirstChild(nsnull); kid; kid = kid->GetNextSibling()) {\n    if (kid != mScrolledFrame) {\n      if (kid == mResizerBox && hasResizer) {\n        continue;\n      }\n      rv = mOuter->BuildDisplayListForChild(aBuilder, kid, aDirtyRect, aDest,\n                                            nsIFrame::DISPLAY_CHILD_FORCE_STACKING_CONTEXT);\n      NS_ENSURE_SUCCESS(rv, rv);\n      // DISPLAY_CHILD_FORCE_STACKING_CONTEXT put everything into the\n      // PositionedDescendants list.\n-      ::AppendToTop(aBuilder, aLists.BorderBackground(), \n+      ::AppendToTop(aBuilder, aLists.PositionedDescendants(),\n                    aDest.PositionedDescendants(), kid,\n                    aCreateLayer);\n    }\n  }\n  return rv;\n}\n\nall in all this gives us ZERO locking/painting/unlocking on the scroller surface for scrolling after the settings dialog has been finished loading.\n\nI still do get one paint event for the scrollbar every frame, though.\n\nThe resulting texture image is a measly 917px high for the settings page, I consider that nothing compared to content pages. And it should only live as long as the page is open anyways. PLUS due to the toolbar images and scrollbars spliting the scrolled content's display lists, they couldn't merge and we had two viewport sized RGBA buffers allocated, while now we have a single one.", "creation_time": "2011-07-25T16:21:21Z", "is_private": false, "tags": [], "raw_text": "So the changes I propose - sorry my tree is full of printfs right now - are:\n\n1.: Prevent the toolbar tabs from interfering with the scrollboxes below:\n\n- <box id=\"panel-controls\" class=\"panel-row-header\" oncommand=\"BrowserUI.switchPane(event.target.getAttribute('linkedpanel'));\">\n+ <box id=\"panel-controls\" class=\"panel-row-header\" oncommand=\"BrowserUI.switchPane(event.target.getAttribute('linkedpanel'));\" style=\"position:relative; z-index:0;\">\n\n2.: Set display ports on relevant scrollboxes:\n\nlet winCwu = window.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils);\nwinCwu.setDisplayPortForElement(0, 0, 854, 2048, document.getElementById(\"prefs-list\")._scrollbox);\n\n3.: We want a flag here, or want to enable it always if we have a display port set:\n\nPRBool createLayersForScrollbars = mIsRoot &&\n  mOuter->PresContext()->IsRootContentDocument();\ncreateLayersForScrollbars=true; //FIXME\n\n4.: I think we want to reduce the count of nsDisplayScrollLayers on frames if we merge them:\n\nPRBool\nnsDisplayScrollLayer::TryMerge(nsDisplayListBuilder* aBuilder,\n                               nsDisplayItem* aItem)\n{\n  if (aItem->GetType() != TYPE_SCROLL_LAYER) {\n    return PR_FALSE;\n  }\n\n  nsDisplayScrollLayer* other = static_cast<nsDisplayScrollLayer*>(aItem);\n  if (other->mScrolledFrame != this->mScrolledFrame) {\n    return PR_FALSE;\n  }\n\n+  FrameProperties props = mScrolledFrame->Properties();\n+  int count=GetScrollLayerCount() - 1;\n+  props.Set(nsIFrame::ScrollLayerCount(),\n+    reinterpret_cast<void*>(count));\n\n  mList.AppendToBottom(&other->mList);\n  return PR_TRUE;\n}\n\n5.: Get the scrollbars out between the text and border&background of the scrolled content:\n\nnsGfxScrollFrameInner::AppendScrollPartsTo(nsDisplayListBuilder*          aBuilder,\nconst nsRect&                  aDirtyRect,\nconst nsDisplayListSet&        aLists,\nconst nsDisplayListCollection& aDest,\nPRBool&                        aCreateLayer)\n{\n  nsresult rv = NS_OK;\n  PRBool hasResizer = HasResizer();\n  for (nsIFrame* kid = mOuter->GetFirstChild(nsnull); kid; kid = kid->GetNextSibling()) {\n    if (kid != mScrolledFrame) {\n      if (kid == mResizerBox && hasResizer) {\n        continue;\n      }\n      rv = mOuter->BuildDisplayListForChild(aBuilder, kid, aDirtyRect, aDest,\n                                            nsIFrame::DISPLAY_CHILD_FORCE_STACKING_CONTEXT);\n      NS_ENSURE_SUCCESS(rv, rv);\n      // DISPLAY_CHILD_FORCE_STACKING_CONTEXT put everything into the\n      // PositionedDescendants list.\n-      ::AppendToTop(aBuilder, aLists.BorderBackground(), \n+      ::AppendToTop(aBuilder, aLists.PositionedDescendants(),\n                    aDest.PositionedDescendants(), kid,\n                    aCreateLayer);\n    }\n  }\n  return rv;\n}\n\nall in all this gives us ZERO locking/painting/unlocking on the scroller surface for scrolling after the settings dialog has been finished loading.\n\nI still do get one paint event for the scrollbar every frame, though.\n\nThe resulting texture image is a measly 917px high for the settings page, I consider that nothing compared to content pages. And it should only live as long as the page is open anyways. PLUS due to the toolbar images and scrollbars spliting the scrolled content's display lists, they couldn't merge and we had two viewport sized RGBA buffers allocated, while now we have a single one.", "author": "florian.haenel@heeen.de", "creator": "florian.haenel@heeen.de", "time": "2011-07-25T16:21:21Z", "count": 11, "bug_id": 657893}, {"text": "Good work!\n\n1, 2 and 3 sound reasonable. 4 already exists on trunk, not sure which rev you're looking at.\n\nFor 5, I would use the Content() list instead.\n\n> I still do get one paint event for the scrollbar every frame, though.\n\nIsn't that because we have to repaint the scrollbar as the thumb moves?\n\n(In reply to comment #8)\n> Also I'm looking at why the scrolled content is divided into two clips with\n> backgrounds and texts at all - shouldn't they be in a single clip?\n\nThat's because in CSS, the backgrounds of elements outside a overflow:hidden element can be drawn between the background of the overflow:hidden element and its contents.", "creator": "roc@ocallahan.org", "attachment_id": null, "id": 5624690, "author": "roc@ocallahan.org", "creation_time": "2011-08-01T04:25:02Z", "time": "2011-08-01T04:25:02Z", "tags": [], "is_private": false, "bug_id": 657893, "raw_text": "Good work!\n\n1, 2 and 3 sound reasonable. 4 already exists on trunk, not sure which rev you're looking at.\n\nFor 5, I would use the Content() list instead.\n\n> I still do get one paint event for the scrollbar every frame, though.\n\nIsn't that because we have to repaint the scrollbar as the thumb moves?\n\n(In reply to comment #8)\n> Also I'm looking at why the scrolled content is divided into two clips with\n> backgrounds and texts at all - shouldn't they be in a single clip?\n\nThat's because in CSS, the backgrounds of elements outside a overflow:hidden element can be drawn between the background of the overflow:hidden element and its contents.", "count": 12}, {"count": 13, "bug_id": 657893, "raw_text": "Here's a visual draw-log from what I have with the forthcoming patches and the patch from bug 524925. Where we had redraws for the scrollbars for every scroll movement we now only have very few paints and the entailing locks. Also visible is the settings page drawn in a single texture that is bigger than the visible screen (852x480). Scrolling is smooth as butter.", "tags": [], "is_private": false, "time": "2011-08-11T16:27:43Z", "creation_time": "2011-08-11T16:27:43Z", "author": "florian.haenel@heeen.de", "text": "Created attachment 552393\nvisual draw log\n\nHere's a visual draw-log from what I have with the forthcoming patches and the patch from bug 524925. Where we had redraws for the scrollbars for every scroll movement we now only have very few paints and the entailing locks. Also visible is the settings page drawn in a single texture that is bigger than the visible screen (852x480). Scrolling is smooth as butter.", "creator": "florian.haenel@heeen.de", "id": 5647756, "attachment_id": 552393}, {"author": "florian.haenel@heeen.de", "creator": "florian.haenel@heeen.de", "text": "Created attachment 552406\nneeds to be separated\n\nHere's all changes in one patch so far. I still need to separate this into individual changesets.", "id": 5647805, "attachment_id": 552406, "creation_time": "2011-08-11T16:47:52Z", "tags": [], "is_private": false, "time": "2011-08-11T16:47:52Z", "count": 14, "bug_id": 657893, "raw_text": "Here's all changes in one patch so far. I still need to separate this into individual changesets."}, {"time": "2011-08-11T17:14:59Z", "bug_id": 657893, "count": 15, "creator": "ben@stechz.com", "author": "ben@stechz.com", "is_private": false, "tags": [], "raw_text": "A little drive by feedback, but good job removing so much painting! :D\n\n> PRBool\n> nsDisplayScrollLayer::ShouldFlattenAway(nsDisplayListBuilder* aBuilder)\n> {\n>-  return GetScrollLayerCount() > 1;\n>+  int count=GetScrollLayerCount();\n>+  if(count > 1) {\n>+    if(mScrolledFrame) {\n>+      FrameProperties props = mScrolledFrame->Properties();\n>+      props.Set(nsIFrame::ScrollLayerCount(),\n>+                reinterpret_cast<void*>(count-1));\n>+    }\n>+    return PR_TRUE;\n>+  }\n>+  return PR_FALSE;\n> }\n\nWhat is this change doing? If scroll layers aren't next to each other then we probably shouldn't make a scroll layer.\n\nI haven't tried this patch, but it has to NOT generate a scroll layer in cases like this:\nhttp://people.mozilla.org/~bstover/zindex.html\n\n> NS_IMETHODIMP\n> nsSliderFrame::HandleEvent(nsPresContext* aPresContext,\n\nI don't know what these are. Does Fennec use these?", "attachment_id": 552406, "id": 5647863, "text": "Comment on attachment 552406\nneeds to be separated\n\nA little drive by feedback, but good job removing so much painting! :D\n\n> PRBool\n> nsDisplayScrollLayer::ShouldFlattenAway(nsDisplayListBuilder* aBuilder)\n> {\n>-  return GetScrollLayerCount() > 1;\n>+  int count=GetScrollLayerCount();\n>+  if(count > 1) {\n>+    if(mScrolledFrame) {\n>+      FrameProperties props = mScrolledFrame->Properties();\n>+      props.Set(nsIFrame::ScrollLayerCount(),\n>+                reinterpret_cast<void*>(count-1));\n>+    }\n>+    return PR_TRUE;\n>+  }\n>+  return PR_FALSE;\n> }\n\nWhat is this change doing? If scroll layers aren't next to each other then we probably shouldn't make a scroll layer.\n\nI haven't tried this patch, but it has to NOT generate a scroll layer in cases like this:\nhttp://people.mozilla.org/~bstover/zindex.html\n\n> NS_IMETHODIMP\n> nsSliderFrame::HandleEvent(nsPresContext* aPresContext,\n\nI don't know what these are. Does Fennec use these?", "creation_time": "2011-08-11T17:14:59Z"}, {"creation_time": "2011-08-11T23:36:24Z", "author": "roc@ocallahan.org", "creator": "roc@ocallahan.org", "text": "Comment on attachment 552406\nneeds to be separated\n\nReview of attachment 552406:\n-----------------------------------------------------------------\n\nPut the gfxASurface changes in a separate patch.\n\n::: layout/base/nsDisplayList.cpp\n@@ +1933,5 @@\n> +      FrameProperties props = mScrolledFrame->Properties();\n> +      props.Set(nsIFrame::ScrollLayerCount(),\n> +                reinterpret_cast<void*>(count-1));\n> +    }\n> +    return PR_TRUE;\n\nThis shouldn't be needed.\n\n::: layout/generic/nsGfxScrollFrame.cpp\n@@ +1876,5 @@\n>        NS_ENSURE_SUCCESS(rv, rv);\n>        // DISPLAY_CHILD_FORCE_STACKING_CONTEXT put everything into the\n>        // PositionedDescendants list.\n> +      ::AppendToTop(aBuilder, aLists.PositionedDescendants(), //aLists->aDest\n> +                    aDest.PositionedDescendants(), kid,       //aDest->aSource?\n\nWhat are these comments about?\n\nI suggested using the Content() destination list, not the PositionedDescendants() list.\n\n@@ +1993,5 @@\n>    // Since making new layers is expensive, only use nsDisplayScrollLayer\n>    // if the area is scrollable.\n>    nsRect scrollRange = GetScrollRange();\n>    ScrollbarStyles styles = GetScrollbarStylesFromFrame();\n> +  mShouldBuildLayer = (\n\nWe need some kind of new check here ... I don't think we want to do this everywhere yet.\n\n::: layout/xul/base/src/nsScrollbarFrame.cpp\n@@ -75,5 @@\n> -  // We want to be a reflow root since we use reflows to move the\n> -  // slider.  Any reflow inside the scrollbar frame will be a reflow to\n> -  // move the slider and will thus not change anything outside of the\n> -  // scrollbar or change the size of the scrollbar frame.\n> -  mState |= NS_FRAME_REFLOW_ROOT;\n\nWhy are you removing this?\n\n::: layout/xul/base/src/nsSliderFrame.cpp\n@@ +738,5 @@\n> +  transform.AppendInt(newThumbRect.y/60);\n> +  transform.AppendLiteral(\"px)\");\n> +  nsAutoString prop;\n> +  prop.AppendLiteral(\"-moz-transform\");\n> +  result = cssDecl->SetProperty(prop,transform, EmptyString());\n\nUgh, this is horrible! :-)\n\nWhat we probably should do is extend nsDisplayTransform and nsIFrame::IsTransformed() to check for an \"extra transform\" frame property, and include that in the transform. With a state bit that is set when the property is available.", "attachment_id": 552406, "id": 5649016, "count": 16, "bug_id": 657893, "raw_text": "Review of attachment 552406:\n-----------------------------------------------------------------\n\nPut the gfxASurface changes in a separate patch.\n\n::: layout/base/nsDisplayList.cpp\n@@ +1933,5 @@\n> +      FrameProperties props = mScrolledFrame->Properties();\n> +      props.Set(nsIFrame::ScrollLayerCount(),\n> +                reinterpret_cast<void*>(count-1));\n> +    }\n> +    return PR_TRUE;\n\nThis shouldn't be needed.\n\n::: layout/generic/nsGfxScrollFrame.cpp\n@@ +1876,5 @@\n>        NS_ENSURE_SUCCESS(rv, rv);\n>        // DISPLAY_CHILD_FORCE_STACKING_CONTEXT put everything into the\n>        // PositionedDescendants list.\n> +      ::AppendToTop(aBuilder, aLists.PositionedDescendants(), //aLists->aDest\n> +                    aDest.PositionedDescendants(), kid,       //aDest->aSource?\n\nWhat are these comments about?\n\nI suggested using the Content() destination list, not the PositionedDescendants() list.\n\n@@ +1993,5 @@\n>    // Since making new layers is expensive, only use nsDisplayScrollLayer\n>    // if the area is scrollable.\n>    nsRect scrollRange = GetScrollRange();\n>    ScrollbarStyles styles = GetScrollbarStylesFromFrame();\n> +  mShouldBuildLayer = (\n\nWe need some kind of new check here ... I don't think we want to do this everywhere yet.\n\n::: layout/xul/base/src/nsScrollbarFrame.cpp\n@@ -75,5 @@\n> -  // We want to be a reflow root since we use reflows to move the\n> -  // slider.  Any reflow inside the scrollbar frame will be a reflow to\n> -  // move the slider and will thus not change anything outside of the\n> -  // scrollbar or change the size of the scrollbar frame.\n> -  mState |= NS_FRAME_REFLOW_ROOT;\n\nWhy are you removing this?\n\n::: layout/xul/base/src/nsSliderFrame.cpp\n@@ +738,5 @@\n> +  transform.AppendInt(newThumbRect.y/60);\n> +  transform.AppendLiteral(\"px)\");\n> +  nsAutoString prop;\n> +  prop.AppendLiteral(\"-moz-transform\");\n> +  result = cssDecl->SetProperty(prop,transform, EmptyString());\n\nUgh, this is horrible! :-)\n\nWhat we probably should do is extend nsDisplayTransform and nsIFrame::IsTransformed() to check for an \"extra transform\" frame property, and include that in the transform. With a state bit that is set when the property is available.", "tags": [], "is_private": false, "time": "2011-08-11T23:36:24Z"}, {"text": "Created attachment 553483\nwork in progress\n\nadded display port to awesomebar panels and the other scroll lists next to preferences. removed unnecessary changes, but some of roc's issues remain.\n\nThere's two issues I noticed in very long scrollboxes: When the history page lazy-loads items to the end of the list, there's a short black flicker. If you scroll way down and then way back up, you get a white area.\n\notherwise scrolling is noticably smoother.", "attachment_id": 553483, "id": 5657051, "creation_time": "2011-08-16T15:14:23Z", "tags": [], "is_private": false, "raw_text": "added display port to awesomebar panels and the other scroll lists next to preferences. removed unnecessary changes, but some of roc's issues remain.\n\nThere's two issues I noticed in very long scrollboxes: When the history page lazy-loads items to the end of the list, there's a short black flicker. If you scroll way down and then way back up, you get a white area.\n\notherwise scrolling is noticably smoother.", "creator": "florian.haenel@heeen.de", "author": "florian.haenel@heeen.de", "time": "2011-08-16T15:14:23Z", "bug_id": 657893, "count": 17}, {"count": 18, "bug_id": 657893, "time": "2011-08-18T16:09:12Z", "author": "florian.haenel@heeen.de", "creator": "florian.haenel@heeen.de", "raw_text": "about the new transform property: can we use this call from here\nhttp://mxr.mozilla.org/mozilla-central/source/layout/base/nsCSSFrameConstructor.cpp#7671\nto tell the frame to cache the transform from the display style into it's local mTransform, setting the MAY_BE_TRANSFORMED flag and then just returning mTransForm from GetTransformMatrix?", "is_private": false, "tags": [], "creation_time": "2011-08-18T16:09:12Z", "id": 5662644, "attachment_id": null, "text": "about the new transform property: can we use this call from here\nhttp://mxr.mozilla.org/mozilla-central/source/layout/base/nsCSSFrameConstructor.cpp#7671\nto tell the frame to cache the transform from the display style into it's local mTransform, setting the MAY_BE_TRANSFORMED flag and then just returning mTransForm from GetTransformMatrix?"}, {"creation_time": "2011-08-19T01:27:51Z", "attachment_id": null, "id": 5664338, "text": "No.\n\nI would use a new state bit to indicate whether the frame has an \"extra transform\". When there's an extra transform, store it as a frame property.", "raw_text": "No.\n\nI would use a new state bit to indicate whether the frame has an \"extra transform\". When there's an extra transform, store it as a frame property.", "is_private": false, "tags": [], "author": "roc@ocallahan.org", "creator": "roc@ocallahan.org", "count": 19, "bug_id": 657893, "time": "2011-08-19T01:27:51Z"}, {"tags": [], "is_private": false, "time": "2011-08-19T13:52:18Z", "count": 20, "bug_id": 657893, "raw_text": "The patch grew considerably due to the new property and I had to shuffle a few functions around that depended on only css ever transforming a frame.", "author": "florian.haenel@heeen.de", "creator": "florian.haenel@heeen.de", "text": "Created attachment 554397\nWIP - Added AdditionalTransform frame property\n\nThe patch grew considerably due to the new property and I had to shuffle a few functions around that depended on only css ever transforming a frame.", "id": 5665318, "attachment_id": 554397, "creation_time": "2011-08-19T13:52:18Z"}, {"bug_id": 657893, "raw_text": "Review of attachment 554397:\n-----------------------------------------------------------------\n\nThe rest basically looks OK although I don't think you should move that code around to become methods of nsIFrame.\n\n::: layout/generic/nsIFrame.h\n@@ +2743,5 @@\n>    nsRect           mRect;\n>    nsIContent*      mContent;\n>    nsStyleContext*  mStyleContext;\n>    nsIFrame*        mParent;\n> +  gfx3DMatrix      mAdditionalTransform;\n\nYou can't do this, this bloats the size of frames massively. Use a frame property via NS_DECLARE_FRAME_PROPERTY etc.", "count": 21, "time": "2011-08-20T11:17:31Z", "tags": [], "is_private": false, "creation_time": "2011-08-20T11:17:31Z", "creator": "roc@ocallahan.org", "text": "Comment on attachment 554397\nWIP - Added AdditionalTransform frame property\n\nReview of attachment 554397:\n-----------------------------------------------------------------\n\nThe rest basically looks OK although I don't think you should move that code around to become methods of nsIFrame.\n\n::: layout/generic/nsIFrame.h\n@@ +2743,5 @@\n>    nsRect           mRect;\n>    nsIContent*      mContent;\n>    nsStyleContext*  mStyleContext;\n>    nsIFrame*        mParent;\n> +  gfx3DMatrix      mAdditionalTransform;\n\nYou can't do this, this bloats the size of frames massively. Use a frame property via NS_DECLARE_FRAME_PROPERTY etc.", "attachment_id": 554397, "id": 5667152, "author": "roc@ocallahan.org"}, {"creation_time": "2011-08-24T12:36:21Z", "attachment_id": 555370, "id": 5674649, "text": "Created attachment 555370\nWIP - using frame property", "creator": "florian.haenel@heeen.de", "author": "florian.haenel@heeen.de", "raw_text": "", "bug_id": 657893, "count": 22, "time": "2011-08-24T12:36:21Z", "is_private": false, "tags": []}, {"count": 23, "raw_text": "Review of attachment 555370:\n-----------------------------------------------------------------\n\n::: layout/base/nsDisplayList.cpp\n@@ +2428,5 @@\n> +\n> +  gfx3DMatrix result;\n> +\n> +  if (aFrame->GetStateBits() & NS_FRAME_ADDITIONAL_TRANSFORM) {\n> +    gfx3DMatrix* trafo = static_cast<gfx3DMatrix*>(\n\ncall it \"transform\", \"trafo\" is quite unclear :-)\n\n@@ +2430,5 @@\n> +\n> +  if (aFrame->GetStateBits() & NS_FRAME_ADDITIONAL_TRANSFORM) {\n> +    gfx3DMatrix* trafo = static_cast<gfx3DMatrix*>(\n> +        Properties().Get(AdditionalTransform()));\n> +    if(trafo)\n\nAssert that trafo/transform is non-null, since it should be if the state bit is set.\n\n@@ -2442,5 @@\n>                     nsDisplayTransform::GetFrameBoundsForTransform(aFrame));\n>  \n>    /* Get the matrix, then change its basis to factor in the origin. */\n>    PRBool dummy;\n> -  gfx3DMatrix result =\n\nHow can removing this line be correct? This wouldn't even compile since 'result' is used.\n\n@@ +2747,5 @@\n>                                           const nsPoint &aOrigin,\n>                                           const nsRect* aBoundsOverride)\n>  {\n>    NS_PRECONDITION(aFrame, \"Can't take the transform based on a null frame!\");\n> +  NS_PRECONDITION(aFrame->IsTransformed(),\n\nIsTransformed is not the same as \"GetStyleDisplay()->HasTransform() || flags & NS_FRAME_ADDITIONAL_TRANSFORM\". For example, nsSVGOuterSVGFrame overrides it.\n\nYou need a new method, something like HasSpecifiedTransform().\n\n::: layout/generic/nsFrame.cpp\n@@ +4194,5 @@\n> +  } else {\n> +    mState |= NS_FRAME_ADDITIONAL_TRANSFORM;\n> +    gfx3DMatrix* trafo = new gfx3DMatrix;\n> +    *trafo = aTransform;\n> +    Properties().Set(AdditionalTransform(), trafo);\n\nYou can just pass \"new gfx3DMatrix(aTransform)\" here.\n\n::: layout/generic/nsGfxScrollFrame.cpp\n@@ +1999,1 @@\n>       (styles.mHorizontal != NS_STYLE_OVERFLOW_HIDDEN ||\n\nThis makes us build nsDisplayScrollLayers on desktop products. I don't think we want to do that, it's overhead we don't need or use on desktop Firefox at the moment. I'm not sure the best way to control this though. For chrome, it really should be enabled on a per-element basis somehow, since it's pointless if chrome isn't going to set up displayports for it.\n\n::: layout/xul/base/src/nsSliderFrame.cpp\n@@ +720,5 @@\n> +  thumbFrame->SetAdditionalTransform(\n> +      gfx3DMatrix::Translation(\n> +        NSAppUnitsToFloatPixels(newThumbRect.x, scaleFactor),\n> +        NSAppUnitsToFloatPixels(newThumbRect.y, scaleFactor),\n> +        0));\n\nYou still need to invalidate here.", "bug_id": 657893, "is_private": false, "tags": [], "time": "2011-08-25T01:00:09Z", "creation_time": "2011-08-25T01:00:09Z", "author": "roc@ocallahan.org", "id": 5676700, "attachment_id": 555370, "creator": "roc@ocallahan.org", "text": "Comment on attachment 555370\nWIP - using frame property\n\nReview of attachment 555370:\n-----------------------------------------------------------------\n\n::: layout/base/nsDisplayList.cpp\n@@ +2428,5 @@\n> +\n> +  gfx3DMatrix result;\n> +\n> +  if (aFrame->GetStateBits() & NS_FRAME_ADDITIONAL_TRANSFORM) {\n> +    gfx3DMatrix* trafo = static_cast<gfx3DMatrix*>(\n\ncall it \"transform\", \"trafo\" is quite unclear :-)\n\n@@ +2430,5 @@\n> +\n> +  if (aFrame->GetStateBits() & NS_FRAME_ADDITIONAL_TRANSFORM) {\n> +    gfx3DMatrix* trafo = static_cast<gfx3DMatrix*>(\n> +        Properties().Get(AdditionalTransform()));\n> +    if(trafo)\n\nAssert that trafo/transform is non-null, since it should be if the state bit is set.\n\n@@ -2442,5 @@\n>                     nsDisplayTransform::GetFrameBoundsForTransform(aFrame));\n>  \n>    /* Get the matrix, then change its basis to factor in the origin. */\n>    PRBool dummy;\n> -  gfx3DMatrix result =\n\nHow can removing this line be correct? This wouldn't even compile since 'result' is used.\n\n@@ +2747,5 @@\n>                                           const nsPoint &aOrigin,\n>                                           const nsRect* aBoundsOverride)\n>  {\n>    NS_PRECONDITION(aFrame, \"Can't take the transform based on a null frame!\");\n> +  NS_PRECONDITION(aFrame->IsTransformed(),\n\nIsTransformed is not the same as \"GetStyleDisplay()->HasTransform() || flags & NS_FRAME_ADDITIONAL_TRANSFORM\". For example, nsSVGOuterSVGFrame overrides it.\n\nYou need a new method, something like HasSpecifiedTransform().\n\n::: layout/generic/nsFrame.cpp\n@@ +4194,5 @@\n> +  } else {\n> +    mState |= NS_FRAME_ADDITIONAL_TRANSFORM;\n> +    gfx3DMatrix* trafo = new gfx3DMatrix;\n> +    *trafo = aTransform;\n> +    Properties().Set(AdditionalTransform(), trafo);\n\nYou can just pass \"new gfx3DMatrix(aTransform)\" here.\n\n::: layout/generic/nsGfxScrollFrame.cpp\n@@ +1999,1 @@\n>       (styles.mHorizontal != NS_STYLE_OVERFLOW_HIDDEN ||\n\nThis makes us build nsDisplayScrollLayers on desktop products. I don't think we want to do that, it's overhead we don't need or use on desktop Firefox at the moment. I'm not sure the best way to control this though. For chrome, it really should be enabled on a per-element basis somehow, since it's pointless if chrome isn't going to set up displayports for it.\n\n::: layout/xul/base/src/nsSliderFrame.cpp\n@@ +720,5 @@\n> +  thumbFrame->SetAdditionalTransform(\n> +      gfx3DMatrix::Translation(\n> +        NSAppUnitsToFloatPixels(newThumbRect.x, scaleFactor),\n> +        NSAppUnitsToFloatPixels(newThumbRect.y, scaleFactor),\n> +        0));\n\nYou still need to invalidate here."}, {"author": "florian.haenel@heeen.de", "id": 5677128, "attachment_id": null, "creator": "florian.haenel@heeen.de", "text": "> How can removing this line be correct? This wouldn't even compile since 'result' is used.\n\nI pulled the declaration of result up, check the first block you quoted :)\n\n> You still need to invalidate here.\n\nCan you explain why? Is there a case where we influence either the scrolled content or the thumb through transforming it?", "creation_time": "2011-08-25T07:05:00Z", "is_private": false, "tags": [], "time": "2011-08-25T07:05:00Z", "count": 24, "raw_text": "> How can removing this line be correct? This wouldn't even compile since 'result' is used.\n\nI pulled the declaration of result up, check the first block you quoted :)\n\n> You still need to invalidate here.\n\nCan you explain why? Is there a case where we influence either the scrolled content or the thumb through transforming it?", "bug_id": 657893}, {"count": 25, "bug_id": 657893, "time": "2011-08-26T04:32:35Z", "author": "roc@ocallahan.org", "creator": "roc@ocallahan.org", "raw_text": "Changing the layer tree doesn't itself cause repainting. You need to invalidate to ensure that the scrollbar thumb area is repainted.", "is_private": false, "tags": [], "creation_time": "2011-08-26T04:32:35Z", "id": 5679832, "attachment_id": null, "text": "Changing the layer tree doesn't itself cause repainting. You need to invalidate to ensure that the scrollbar thumb area is repainted."}, {"tags": [], "is_private": false, "raw_text": "", "text": "Created attachment 556543\nVersion using css2 transform again", "id": 5684785, "attachment_id": 556543, "creation_time": "2011-08-29T14:14:10Z", "time": "2011-08-29T14:14:10Z", "bug_id": 657893, "count": 26, "creator": "florian.haenel@heeen.de", "author": "florian.haenel@heeen.de"}, {"author": "florian.haenel@heeen.de", "attachment_id": 556566, "id": 5685040, "text": "Created attachment 556566\nimprove sidebars\n\nI played around with displayport some more and found a way to improve the sidebar panning experience and making bug 608983 obsolete with a much simpler patch.\nI notice some superfluous drawing of the url bar, still.", "creator": "florian.haenel@heeen.de", "creation_time": "2011-08-29T16:02:50Z", "is_private": false, "tags": [], "time": "2011-08-29T16:02:50Z", "count": 27, "raw_text": "I played around with displayport some more and found a way to improve the sidebar panning experience and making bug 608983 obsolete with a much simpler patch.\nI notice some superfluous drawing of the url bar, still.", "bug_id": 657893}, {"tags": [], "is_private": false, "time": "2011-08-30T03:15:37Z", "count": 28, "bug_id": 657893, "raw_text": "Review of attachment 556543:\n-----------------------------------------------------------------\n\n::: layout/generic/nsGfxScrollFrame.cpp\n@@ +1871,5 @@\n> +      // PositionedDescendants list. We also put everything into our PositionedDescendants\n> +      // list so it comes after all the scrolled content and doesn't interfere in merging the\n> +      // nsDisplayScrollItems generated by the scrolled content.\n> +      ::AppendToTop(aBuilder, aLists.PositionedDescendants(), // the destination\n> +                    aDest.PositionedDescendants(), kid,       // the source\n\nI still think the destination list should be the Content() list.\n\n@@ +1993,2 @@\n>       (styles.mHorizontal != NS_STYLE_OVERFLOW_HIDDEN ||\n>        styles.mVertical != NS_STYLE_OVERFLOW_HIDDEN) &&\n\nLike I said before, this starts creating scrollinfo layers for all scrollable areas in desktop Firefox, and that's probably not what we want. You should use a pref or something to control this.\n\n::: layout/xul/base/src/nsSliderFrame.cpp\n@@ -433,5 @@\n> -\n> -  // set the thumb's coord to be the current pos * the ratio.\n> -  nsRect thumbRect(clientRect.x, clientRect.y, thumbSize.width, thumbSize.height);\n> -  PRInt32& thumbPos = (IsHorizontal() ? thumbRect.x : thumbRect.y);\n> -  thumbPos += NSToCoordRound(pos * mRatio);\n\nAre you just removing support for the \"reverse\" attribute? Why is that OK?\n\n@@ +669,5 @@\n> +  public:\n> +    nsSliderThumbTranslator(nsIFrame* aThumbFrame, nsPoint aTargetTranslation)\n> +      : mThumbFrame(aThumbFrame)\n> +      , mTargetTranslation(aTargetTranslation) {};\n> +  NS_IMETHOD Run()\n\nYou shouldn't hold onto mThumbFrame. That frame could be destroyed before this runs. Instead, hold onto the content node with a strong pointer (nsCOMPtr<nsIContent>).\n\n@@ +745,2 @@\n>  \n> +  thumbFrame->InvalidateTransformLayer();\n\nThis should be done by nsSliderThumbTranslator.", "author": "roc@ocallahan.org", "text": "Comment on attachment 556543\nVersion using css2 transform again\n\nReview of attachment 556543:\n-----------------------------------------------------------------\n\n::: layout/generic/nsGfxScrollFrame.cpp\n@@ +1871,5 @@\n> +      // PositionedDescendants list. We also put everything into our PositionedDescendants\n> +      // list so it comes after all the scrolled content and doesn't interfere in merging the\n> +      // nsDisplayScrollItems generated by the scrolled content.\n> +      ::AppendToTop(aBuilder, aLists.PositionedDescendants(), // the destination\n> +                    aDest.PositionedDescendants(), kid,       // the source\n\nI still think the destination list should be the Content() list.\n\n@@ +1993,2 @@\n>       (styles.mHorizontal != NS_STYLE_OVERFLOW_HIDDEN ||\n>        styles.mVertical != NS_STYLE_OVERFLOW_HIDDEN) &&\n\nLike I said before, this starts creating scrollinfo layers for all scrollable areas in desktop Firefox, and that's probably not what we want. You should use a pref or something to control this.\n\n::: layout/xul/base/src/nsSliderFrame.cpp\n@@ -433,5 @@\n> -\n> -  // set the thumb's coord to be the current pos * the ratio.\n> -  nsRect thumbRect(clientRect.x, clientRect.y, thumbSize.width, thumbSize.height);\n> -  PRInt32& thumbPos = (IsHorizontal() ? thumbRect.x : thumbRect.y);\n> -  thumbPos += NSToCoordRound(pos * mRatio);\n\nAre you just removing support for the \"reverse\" attribute? Why is that OK?\n\n@@ +669,5 @@\n> +  public:\n> +    nsSliderThumbTranslator(nsIFrame* aThumbFrame, nsPoint aTargetTranslation)\n> +      : mThumbFrame(aThumbFrame)\n> +      , mTargetTranslation(aTargetTranslation) {};\n> +  NS_IMETHOD Run()\n\nYou shouldn't hold onto mThumbFrame. That frame could be destroyed before this runs. Instead, hold onto the content node with a strong pointer (nsCOMPtr<nsIContent>).\n\n@@ +745,2 @@\n>  \n> +  thumbFrame->InvalidateTransformLayer();\n\nThis should be done by nsSliderThumbTranslator.", "creator": "roc@ocallahan.org", "id": 5686849, "attachment_id": 556543, "creation_time": "2011-08-30T03:15:37Z"}, {"tags": [], "is_private": false, "time": "2011-08-30T03:16:54Z", "count": 29, "bug_id": 657893, "raw_text": "Your display ports are very large. Is it necessary to make them that large?", "author": "roc@ocallahan.org", "text": "Your display ports are very large. Is it necessary to make them that large?", "creator": "roc@ocallahan.org", "attachment_id": null, "id": 5686850, "creation_time": "2011-08-30T03:16:54Z"}, {"count": 30, "raw_text": "(In reply to Robert O'Callahan (:roc) (Mozilla Corporation) from comment #28)\n> > +      ::AppendToTop(aBuilder, aLists.PositionedDescendants(), // the destination\n> > +                    aDest.PositionedDescendants(), kid,       // the source\n> \n> I still think the destination list should be the Content() list.\n\nI double checked and it turns out with the css transform we can use the Content list.\nI had some weird case before where using anything but the positioned desendants list would interfere in layer building.\n\n> \n> @@ +1993,2 @@\n> >       (styles.mHorizontal != NS_STYLE_OVERFLOW_HIDDEN ||\n> >        styles.mVertical != NS_STYLE_OVERFLOW_HIDDEN) &&\n> \n> Like I said before, this starts creating scrollinfo layers for all\n> scrollable areas in desktop Firefox, and that's probably not what we want.\n> You should use a pref or something to control this.\n\nA global preference, as in about:config? Or a per-frame setting?\n\n> \n> ::: layout/xul/base/src/nsSliderFrame.cpp\n> @@ -433,5 @@\n> > -\n> > -  // set the thumb's coord to be the current pos * the ratio.\n> > -  nsRect thumbRect(clientRect.x, clientRect.y, thumbSize.width, thumbSize.height);\n> > -  PRInt32& thumbPos = (IsHorizontal() ? thumbRect.x : thumbRect.y);\n> > -  thumbPos += NSToCoordRound(pos * mRatio);\n> \n> Are you just removing support for the \"reverse\" attribute? Why is that OK?\n\nBecause identical code lives further down in nsSliderFrame::CurrentPositionChanged, where the positioning happens exclusively now. Here in DoLayout we only resize the thumb, which does not depend on reverse or not. We can probably slim this function down further.\n\n> \n> @@ +669,5 @@\n> > +  public:\n> > +    nsSliderThumbTranslator(nsIFrame* aThumbFrame, nsPoint aTargetTranslation)\n> > +      : mThumbFrame(aThumbFrame)\n> > +      , mTargetTranslation(aTargetTranslation) {};\n> > +  NS_IMETHOD Run()\n> \n> You shouldn't hold onto mThumbFrame. That frame could be destroyed before\n> this runs. Instead, hold onto the content node with a strong pointer\n> (nsCOMPtr<nsIContent>).\n> \n> @@ +745,2 @@\n> >  \n> > +  thumbFrame->InvalidateTransformLayer();\n> \n> This should be done by nsSliderThumbTranslator.\nCan we do this if we only hold a reference to the content, not the frame?", "bug_id": 657893, "is_private": false, "tags": [], "time": "2011-08-30T09:32:04Z", "creation_time": "2011-08-30T09:32:04Z", "author": "florian.haenel@heeen.de", "attachment_id": null, "id": 5687235, "creator": "florian.haenel@heeen.de", "text": "(In reply to Robert O'Callahan (:roc) (Mozilla Corporation) from comment #28)\n> > +      ::AppendToTop(aBuilder, aLists.PositionedDescendants(), // the destination\n> > +                    aDest.PositionedDescendants(), kid,       // the source\n> \n> I still think the destination list should be the Content() list.\n\nI double checked and it turns out with the css transform we can use the Content list.\nI had some weird case before where using anything but the positioned desendants list would interfere in layer building.\n\n> \n> @@ +1993,2 @@\n> >       (styles.mHorizontal != NS_STYLE_OVERFLOW_HIDDEN ||\n> >        styles.mVertical != NS_STYLE_OVERFLOW_HIDDEN) &&\n> \n> Like I said before, this starts creating scrollinfo layers for all\n> scrollable areas in desktop Firefox, and that's probably not what we want.\n> You should use a pref or something to control this.\n\nA global preference, as in about:config? Or a per-frame setting?\n\n> \n> ::: layout/xul/base/src/nsSliderFrame.cpp\n> @@ -433,5 @@\n> > -\n> > -  // set the thumb's coord to be the current pos * the ratio.\n> > -  nsRect thumbRect(clientRect.x, clientRect.y, thumbSize.width, thumbSize.height);\n> > -  PRInt32& thumbPos = (IsHorizontal() ? thumbRect.x : thumbRect.y);\n> > -  thumbPos += NSToCoordRound(pos * mRatio);\n> \n> Are you just removing support for the \"reverse\" attribute? Why is that OK?\n\nBecause identical code lives further down in nsSliderFrame::CurrentPositionChanged, where the positioning happens exclusively now. Here in DoLayout we only resize the thumb, which does not depend on reverse or not. We can probably slim this function down further.\n\n> \n> @@ +669,5 @@\n> > +  public:\n> > +    nsSliderThumbTranslator(nsIFrame* aThumbFrame, nsPoint aTargetTranslation)\n> > +      : mThumbFrame(aThumbFrame)\n> > +      , mTargetTranslation(aTargetTranslation) {};\n> > +  NS_IMETHOD Run()\n> \n> You shouldn't hold onto mThumbFrame. That frame could be destroyed before\n> this runs. Instead, hold onto the content node with a strong pointer\n> (nsCOMPtr<nsIContent>).\n> \n> @@ +745,2 @@\n> >  \n> > +  thumbFrame->InvalidateTransformLayer();\n> \n> This should be done by nsSliderThumbTranslator.\nCan we do this if we only hold a reference to the content, not the frame?"}, {"time": "2011-08-30T09:33:38Z", "is_private": false, "tags": [], "raw_text": "(In reply to Robert O'Callahan (:roc) (Mozilla Corporation) from comment #29)\n> Your display ports are very large. Is it necessary to make them that large?\n\nThey are the size of the maximum texture size on mobile. The actual textures that get created are only the size of what is actually there in terms of content, though. I can provide you with a log containing all the generated images.", "bug_id": 657893, "count": 31, "attachment_id": null, "id": 5687238, "creator": "florian.haenel@heeen.de", "text": "(In reply to Robert O'Callahan (:roc) (Mozilla Corporation) from comment #29)\n> Your display ports are very large. Is it necessary to make them that large?\n\nThey are the size of the maximum texture size on mobile. The actual textures that get created are only the size of what is actually there in terms of content, though. I can provide you with a log containing all the generated images.", "author": "florian.haenel@heeen.de", "creation_time": "2011-08-30T09:33:38Z"}, {"author": "roc@ocallahan.org", "creator": "roc@ocallahan.org", "count": 32, "bug_id": 657893, "time": "2011-08-30T09:38:23Z", "creation_time": "2011-08-30T09:38:23Z", "text": "(In reply to Florian H\u00e4nel [:heeen] from comment #30)\n> > @@ +1993,2 @@\n> > >       (styles.mHorizontal != NS_STYLE_OVERFLOW_HIDDEN ||\n> > >        styles.mVertical != NS_STYLE_OVERFLOW_HIDDEN) &&\n> > \n> > Like I said before, this starts creating scrollinfo layers for all\n> > scrollable areas in desktop Firefox, and that's probably not what we want.\n> > You should use a pref or something to control this.\n> \n> A global preference, as in about:config? Or a per-frame setting?\n\nThe former I guess.\n\n> > ::: layout/xul/base/src/nsSliderFrame.cpp\n> > @@ -433,5 @@\n> > > -\n> > > -  // set the thumb's coord to be the current pos * the ratio.\n> > > -  nsRect thumbRect(clientRect.x, clientRect.y, thumbSize.width, thumbSize.height);\n> > > -  PRInt32& thumbPos = (IsHorizontal() ? thumbRect.x : thumbRect.y);\n> > > -  thumbPos += NSToCoordRound(pos * mRatio);\n> > \n> > Are you just removing support for the \"reverse\" attribute? Why is that OK?\n> \n> Because identical code lives further down in\n> nsSliderFrame::CurrentPositionChanged, where the positioning happens\n> exclusively now. Here in DoLayout we only resize the thumb, which does not\n> depend on reverse or not. We can probably slim this function down further.\n\nBut we have to reposition the thumb when the slider size changes, right? What ensures that happens, with your patch?\n\n> > @@ +745,2 @@\n> > >  \n> > > +  thumbFrame->InvalidateTransformLayer();\n> > \n> > This should be done by nsSliderThumbTranslator.\n> Can we do this if we only hold a reference to the content, not the frame?\n\nYes, you can always get the frame for the content by calling GetPrimaryFrame() ... if there is one; it might be null.", "id": 5687246, "attachment_id": null, "raw_text": "(In reply to Florian H\u00e4nel [:heeen] from comment #30)\n> > @@ +1993,2 @@\n> > >       (styles.mHorizontal != NS_STYLE_OVERFLOW_HIDDEN ||\n> > >        styles.mVertical != NS_STYLE_OVERFLOW_HIDDEN) &&\n> > \n> > Like I said before, this starts creating scrollinfo layers for all\n> > scrollable areas in desktop Firefox, and that's probably not what we want.\n> > You should use a pref or something to control this.\n> \n> A global preference, as in about:config? Or a per-frame setting?\n\nThe former I guess.\n\n> > ::: layout/xul/base/src/nsSliderFrame.cpp\n> > @@ -433,5 @@\n> > > -\n> > > -  // set the thumb's coord to be the current pos * the ratio.\n> > > -  nsRect thumbRect(clientRect.x, clientRect.y, thumbSize.width, thumbSize.height);\n> > > -  PRInt32& thumbPos = (IsHorizontal() ? thumbRect.x : thumbRect.y);\n> > > -  thumbPos += NSToCoordRound(pos * mRatio);\n> > \n> > Are you just removing support for the \"reverse\" attribute? Why is that OK?\n> \n> Because identical code lives further down in\n> nsSliderFrame::CurrentPositionChanged, where the positioning happens\n> exclusively now. Here in DoLayout we only resize the thumb, which does not\n> depend on reverse or not. We can probably slim this function down further.\n\nBut we have to reposition the thumb when the slider size changes, right? What ensures that happens, with your patch?\n\n> > @@ +745,2 @@\n> > >  \n> > > +  thumbFrame->InvalidateTransformLayer();\n> > \n> > This should be done by nsSliderThumbTranslator.\n> Can we do this if we only hold a reference to the content, not the frame?\n\nYes, you can always get the frame for the content by calling GetPrimaryFrame() ... if there is one; it might be null.", "tags": [], "is_private": false}, {"tags": [], "is_private": false, "time": "2011-08-30T16:53:18Z", "count": 33, "bug_id": 657893, "raw_text": "", "author": "florian.haenel@heeen.de", "text": "Created attachment 556888\nlatest revision", "creator": "florian.haenel@heeen.de", "id": 5688035, "attachment_id": 556888, "creation_time": "2011-08-30T16:53:18Z"}, {"author": "florian.haenel@heeen.de", "creator": "florian.haenel@heeen.de", "time": "2011-08-31T09:36:41Z", "count": 34, "bug_id": 657893, "attachment_id": null, "id": 5690109, "text": "hmmm the thumb is positioned at the wrong position after we append items to one of the dynamically growing listboxes (e.g. history). With a translation of 0,0 when we scroll back to the top, it is still somewhere at 1/3 of the screen...", "creation_time": "2011-08-31T09:36:41Z", "is_private": false, "tags": [], "raw_text": "hmmm the thumb is positioned at the wrong position after we append items to one of the dynamically growing listboxes (e.g. history). With a translation of 0,0 when we scroll back to the top, it is still somewhere at 1/3 of the screen..."}, {"creation_time": "2011-08-31T23:36:08Z", "text": "So I think AppendScrollPartsTo() should not change to put the items in Content() or PositionedDescendants(). Instead, we should make the particular list a parameter to AppendScrollPartsTo(). In the !mScrollbarsCanOverlapContent case, we can continue appending to aLists.BorderBackground(). In the mScrollbarsCanOverlapContent, we can append to PositionedDescendants().", "creator": "roc@ocallahan.org", "id": 5692411, "attachment_id": null, "author": "roc@ocallahan.org", "bug_id": 657893, "raw_text": "So I think AppendScrollPartsTo() should not change to put the items in Content() or PositionedDescendants(). Instead, we should make the particular list a parameter to AppendScrollPartsTo(). In the !mScrollbarsCanOverlapContent case, we can continue appending to aLists.BorderBackground(). In the mScrollbarsCanOverlapContent, we can append to PositionedDescendants().", "count": 35, "time": "2011-08-31T23:36:08Z", "tags": [], "is_private": false}, {"time": "2011-09-01T14:54:29Z", "bug_id": 657893, "count": 36, "creator": "florian.haenel@heeen.de", "author": "florian.haenel@heeen.de", "tags": [], "is_private": false, "raw_text": "", "text": "Created attachment 557500\nlatest revision", "attachment_id": 557500, "id": 5693587, "creation_time": "2011-09-01T14:54:29Z"}, {"attachment_id": null, "id": 5693598, "creator": "florian.haenel@heeen.de", "text": "I tested the displayport for the sidebars some more and got some weird results. Sometimes stuff typed into the url bar would just not show and my draw log would show it trying to paint a white layer the size of the screen - but nothing shows there - really weird.", "author": "florian.haenel@heeen.de", "creation_time": "2011-09-01T14:58:11Z", "time": "2011-09-01T14:58:11Z", "is_private": false, "tags": [], "raw_text": "I tested the displayport for the sidebars some more and got some weird results. Sometimes stuff typed into the url bar would just not show and my draw log would show it trying to paint a white layer the size of the screen - but nothing shows there - really weird.", "bug_id": 657893, "count": 37}, {"count": 38, "bug_id": 657893, "raw_text": "Review of attachment 557500:\n-----------------------------------------------------------------\n\nLooks good.\n\n::: layout/generic/nsGfxScrollFrame.cpp\n@@ +1468,5 @@\n>    presContext->LookAndFeel()->\n>      GetMetric(nsILookAndFeel::eMetric_ScrollbarsCanOverlapContent, canOverlap);\n>    mScrollbarsCanOverlapContent = canOverlap;\n>    mScrollingActive = IsAlwaysActive();\n> +  sXULScrollLayersEnabled=Preferences::GetBool(\"layers.acceleration.xul-scrolling\", PR_FALSE);\n\nNot a layers pref really ... layout.scrolling.layers_always?", "tags": [], "is_private": false, "time": "2011-09-01T21:42:34Z", "creation_time": "2011-09-01T21:42:34Z", "author": "roc@ocallahan.org", "text": "Comment on attachment 557500\nlatest revision\n\nReview of attachment 557500:\n-----------------------------------------------------------------\n\nLooks good.\n\n::: layout/generic/nsGfxScrollFrame.cpp\n@@ +1468,5 @@\n>    presContext->LookAndFeel()->\n>      GetMetric(nsILookAndFeel::eMetric_ScrollbarsCanOverlapContent, canOverlap);\n>    mScrollbarsCanOverlapContent = canOverlap;\n>    mScrollingActive = IsAlwaysActive();\n> +  sXULScrollLayersEnabled=Preferences::GetBool(\"layers.acceleration.xul-scrolling\", PR_FALSE);\n\nNot a layers pref really ... layout.scrolling.layers_always?", "creator": "roc@ocallahan.org", "attachment_id": 557500, "id": 5694819}, {"is_private": false, "tags": [], "time": "2011-09-05T08:44:31Z", "count": 39, "raw_text": "", "bug_id": 657893, "author": "florian.haenel@heeen.de", "id": 5700252, "attachment_id": 558247, "text": "Created attachment 558247\nlatest revision", "creator": "florian.haenel@heeen.de", "creation_time": "2011-09-05T08:44:31Z"}, {"id": 5700329, "attachment_id": 558247, "creator": "roc@ocallahan.org", "text": "Comment on attachment 558247\nlatest revision\n\nReview of attachment 558247:\n-----------------------------------------------------------------\n\n::: layout/generic/nsGfxScrollFrame.cpp\n@@ +1468,5 @@\n>    presContext->LookAndFeel()->\n>      GetMetric(nsILookAndFeel::eMetric_ScrollbarsCanOverlapContent, canOverlap);\n>    mScrollbarsCanOverlapContent = canOverlap;\n>    mScrollingActive = IsAlwaysActive();\n> +  sXULScrollLayersEnabled=Preferences::GetBool(\"layout.scrolling.layers-always\", PR_FALSE);\n\nUse GetCachedBoolPref, I think\n\n@@ +1989,5 @@\n>    // if the area is scrollable.\n>    nsRect scrollRange = GetScrollRange();\n>    ScrollbarStyles styles = GetScrollbarStylesFromFrame();\n>    mShouldBuildLayer =\n> +     ((sXULScrollLayersEnabled || XRE_GetProcessType() == GeckoProcessType_Content) &&\n\nWe don't need the process type check here anymore, right?\n\n::: layout/xul/base/src/nsSliderFrame.cpp\n@@ +373,5 @@\n> +      mThumbContent = aThumbFrame->GetContent();\n> +    };\n> +  NS_IMETHOD Run()\n> +  {\n> +    printf(\"translating thumb! %i,%i\\n\", mTargetTranslation.x, mTargetTranslation.y);\n\nThis needs to be removed\n\n@@ +488,5 @@\n> +    PRInt32 scaleFactor = PresContext()->AppUnitsPerDevPixel();\n> +    nsContentUtils::AddScriptRunner(new nsSliderThumbTranslator(\n> +          thumbFrame,\n> +          nsPoint(NSAppUnitsToFloatPixels(thumbRect.x, scaleFactor),\n> +                  NSAppUnitsToFloatPixels(thumbRect.y, scaleFactor))));\n\nWe can't land this until bug 524925 is landed, otherwise we'll be triggering lots of reflows.\n\nHave you checked that this works properly on other platforms and themes?\n\nI wonder whether this works properly with themes that change the status of scrollbar buttons depending on where the thumb is.\n\nThis might need to be special-cased for Fennec scrollbars only.\n\n::: mobile/chrome/content/bindings.xml\n@@ +215,5 @@\n> +        <![CDATA[\n> +        // need to handle autocomplete popup differently from batch box\n> +        // also lazy loaded so can't set from browser-ui.js init() like prefs\n> +          let winCwu = window.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils);\n> +          winCwu.setDisplayPortForElement(0, 0, 2048, 2048, this._items);\n\nPlease separate out these displayport changes. Someone else should review them.", "author": "roc@ocallahan.org", "creation_time": "2011-09-05T10:29:06Z", "time": "2011-09-05T10:29:06Z", "is_private": false, "tags": [], "raw_text": "Review of attachment 558247:\n-----------------------------------------------------------------\n\n::: layout/generic/nsGfxScrollFrame.cpp\n@@ +1468,5 @@\n>    presContext->LookAndFeel()->\n>      GetMetric(nsILookAndFeel::eMetric_ScrollbarsCanOverlapContent, canOverlap);\n>    mScrollbarsCanOverlapContent = canOverlap;\n>    mScrollingActive = IsAlwaysActive();\n> +  sXULScrollLayersEnabled=Preferences::GetBool(\"layout.scrolling.layers-always\", PR_FALSE);\n\nUse GetCachedBoolPref, I think\n\n@@ +1989,5 @@\n>    // if the area is scrollable.\n>    nsRect scrollRange = GetScrollRange();\n>    ScrollbarStyles styles = GetScrollbarStylesFromFrame();\n>    mShouldBuildLayer =\n> +     ((sXULScrollLayersEnabled || XRE_GetProcessType() == GeckoProcessType_Content) &&\n\nWe don't need the process type check here anymore, right?\n\n::: layout/xul/base/src/nsSliderFrame.cpp\n@@ +373,5 @@\n> +      mThumbContent = aThumbFrame->GetContent();\n> +    };\n> +  NS_IMETHOD Run()\n> +  {\n> +    printf(\"translating thumb! %i,%i\\n\", mTargetTranslation.x, mTargetTranslation.y);\n\nThis needs to be removed\n\n@@ +488,5 @@\n> +    PRInt32 scaleFactor = PresContext()->AppUnitsPerDevPixel();\n> +    nsContentUtils::AddScriptRunner(new nsSliderThumbTranslator(\n> +          thumbFrame,\n> +          nsPoint(NSAppUnitsToFloatPixels(thumbRect.x, scaleFactor),\n> +                  NSAppUnitsToFloatPixels(thumbRect.y, scaleFactor))));\n\nWe can't land this until bug 524925 is landed, otherwise we'll be triggering lots of reflows.\n\nHave you checked that this works properly on other platforms and themes?\n\nI wonder whether this works properly with themes that change the status of scrollbar buttons depending on where the thumb is.\n\nThis might need to be special-cased for Fennec scrollbars only.\n\n::: mobile/chrome/content/bindings.xml\n@@ +215,5 @@\n> +        <![CDATA[\n> +        // need to handle autocomplete popup differently from batch box\n> +        // also lazy loaded so can't set from browser-ui.js init() like prefs\n> +          let winCwu = window.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils);\n> +          winCwu.setDisplayPortForElement(0, 0, 2048, 2048, this._items);\n\nPlease separate out these displayport changes. Someone else should review them.", "bug_id": 657893, "count": 40}, {"creation_time": "2011-09-06T09:16:46Z", "text": "Created attachment 558425\nnow fennec only", "id": 5701573, "attachment_id": 558425, "raw_text": "", "tags": [], "is_private": false, "author": "florian.haenel@heeen.de", "creator": "florian.haenel@heeen.de", "count": 41, "bug_id": 657893, "time": "2011-09-06T09:16:46Z"}, {"author": "florian.haenel@heeen.de", "text": "Created attachment 558427\nthe xul/fennec-side displayport stuff\n\nnot sure who to pick, I think stechz has helped me understanding displayport stuff better iirc.", "creator": "florian.haenel@heeen.de", "id": 5701575, "attachment_id": 558427, "creation_time": "2011-09-06T09:18:22Z", "tags": [], "is_private": false, "time": "2011-09-06T09:18:22Z", "count": 42, "bug_id": 657893, "raw_text": "not sure who to pick, I think stechz has helped me understanding displayport stuff better iirc."}, {"count": 43, "bug_id": 657893, "raw_text": "Can you reply to comment #40?", "tags": [], "is_private": false, "time": "2011-09-06T11:53:22Z", "creation_time": "2011-09-06T11:53:22Z", "author": "roc@ocallahan.org", "creator": "roc@ocallahan.org", "text": "Can you reply to comment #40?", "attachment_id": null, "id": 5701731}, {"creation_time": "2011-09-06T16:31:53Z", "author": "florian.haenel@heeen.de", "id": 5702271, "attachment_id": null, "creator": "florian.haenel@heeen.de", "text": "(In reply to Robert O'Callahan (:roc) (Mozilla Corporation) from comment #40)\n> Comment on attachment 558247\n> latest revision\n> \n> Review of attachment 558247:\n> -----------------------------------------------------------------\n> \n> ::: layout/generic/nsGfxScrollFrame.cpp\n> @@ +1468,5 @@\n> >    presContext->LookAndFeel()->\n> >      GetMetric(nsILookAndFeel::eMetric_ScrollbarsCanOverlapContent, canOverlap);\n> >    mScrollbarsCanOverlapContent = canOverlap;\n> >    mScrollingActive = IsAlwaysActive();\n> > +  sXULScrollLayersEnabled=Preferences::GetBool(\"layout.scrolling.layers-always\", PR_FALSE);\n> \n> Use GetCachedBoolPref, I think\n\nthe only references to this I find for some PresContext settings, are you sure this is the one you mean?\n\n> \n> @@ +1989,5 @@\n> >    // if the area is scrollable.\n> >    nsRect scrollRange = GetScrollRange();\n> >    ScrollbarStyles styles = GetScrollbarStylesFromFrame();\n> >    mShouldBuildLayer =\n> > +     ((sXULScrollLayersEnabled || XRE_GetProcessType() == GeckoProcessType_Content) &&\n> \n> We don't need the process type check here anymore, right?\n\nwe used to do this for remote unconditionally before my change, are you sure you want to make this conditional on the pref setting now for remoat and xul?\n\n\n> \n> @@ +488,5 @@\n> > +    PRInt32 scaleFactor = PresContext()->AppUnitsPerDevPixel();\n> > +    nsContentUtils::AddScriptRunner(new nsSliderThumbTranslator(\n> > +          thumbFrame,\n> > +          nsPoint(NSAppUnitsToFloatPixels(thumbRect.x, scaleFactor),\n> > +                  NSAppUnitsToFloatPixels(thumbRect.y, scaleFactor))));\n> \n> We can't land this until bug 524925 is landed, otherwise we'll be triggering\n> lots of reflows.\n> \n> Have you checked that this works properly on other platforms and themes?\n> \n> I wonder whether this works properly with themes that change the status of\n> scrollbar buttons depending on where the thumb is.\n> \n> This might need to be special-cased for Fennec scrollbars only.\n\nSorry, I don't have enough platforms at hand to thoroughly test this everywhere. I opted to ifdef it for GFX_OPTIMIZE_MOBILE instead and asked :cwiiis to test on android.\n\n\n> \n> ::: mobile/chrome/content/bindings.xml\n> @@ +215,5 @@\n> > +        <![CDATA[\n> > +        // need to handle autocomplete popup differently from batch box\n> > +        // also lazy loaded so can't set from browser-ui.js init() like prefs\n> > +          let winCwu = window.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils);\n> > +          winCwu.setDisplayPortForElement(0, 0, 2048, 2048, this._items);\n> \n> Please separate out these displayport changes. Someone else should review\n> them.\n\nas stechz probably won't be up for review I'll have to find someone else. I think bjacob tutored stechz on displayport stuff?", "count": 44, "raw_text": "(In reply to Robert O'Callahan (:roc) (Mozilla Corporation) from comment #40)\n> Comment on attachment 558247\n> latest revision\n> \n> Review of attachment 558247:\n> -----------------------------------------------------------------\n> \n> ::: layout/generic/nsGfxScrollFrame.cpp\n> @@ +1468,5 @@\n> >    presContext->LookAndFeel()->\n> >      GetMetric(nsILookAndFeel::eMetric_ScrollbarsCanOverlapContent, canOverlap);\n> >    mScrollbarsCanOverlapContent = canOverlap;\n> >    mScrollingActive = IsAlwaysActive();\n> > +  sXULScrollLayersEnabled=Preferences::GetBool(\"layout.scrolling.layers-always\", PR_FALSE);\n> \n> Use GetCachedBoolPref, I think\n\nthe only references to this I find for some PresContext settings, are you sure this is the one you mean?\n\n> \n> @@ +1989,5 @@\n> >    // if the area is scrollable.\n> >    nsRect scrollRange = GetScrollRange();\n> >    ScrollbarStyles styles = GetScrollbarStylesFromFrame();\n> >    mShouldBuildLayer =\n> > +     ((sXULScrollLayersEnabled || XRE_GetProcessType() == GeckoProcessType_Content) &&\n> \n> We don't need the process type check here anymore, right?\n\nwe used to do this for remote unconditionally before my change, are you sure you want to make this conditional on the pref setting now for remoat and xul?\n\n\n> \n> @@ +488,5 @@\n> > +    PRInt32 scaleFactor = PresContext()->AppUnitsPerDevPixel();\n> > +    nsContentUtils::AddScriptRunner(new nsSliderThumbTranslator(\n> > +          thumbFrame,\n> > +          nsPoint(NSAppUnitsToFloatPixels(thumbRect.x, scaleFactor),\n> > +                  NSAppUnitsToFloatPixels(thumbRect.y, scaleFactor))));\n> \n> We can't land this until bug 524925 is landed, otherwise we'll be triggering\n> lots of reflows.\n> \n> Have you checked that this works properly on other platforms and themes?\n> \n> I wonder whether this works properly with themes that change the status of\n> scrollbar buttons depending on where the thumb is.\n> \n> This might need to be special-cased for Fennec scrollbars only.\n\nSorry, I don't have enough platforms at hand to thoroughly test this everywhere. I opted to ifdef it for GFX_OPTIMIZE_MOBILE instead and asked :cwiiis to test on android.\n\n\n> \n> ::: mobile/chrome/content/bindings.xml\n> @@ +215,5 @@\n> > +        <![CDATA[\n> > +        // need to handle autocomplete popup differently from batch box\n> > +        // also lazy loaded so can't set from browser-ui.js init() like prefs\n> > +          let winCwu = window.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils);\n> > +          winCwu.setDisplayPortForElement(0, 0, 2048, 2048, this._items);\n> \n> Please separate out these displayport changes. Someone else should review\n> them.\n\nas stechz probably won't be up for review I'll have to find someone else. I think bjacob tutored stechz on displayport stuff?", "bug_id": 657893, "is_private": false, "tags": [], "time": "2011-09-06T16:31:53Z"}, {"attachment_id": null, "id": 5703769, "creator": "roc@ocallahan.org", "text": "(In reply to Florian H\u00e4nel [:heeen] from comment #44)\n> the only references to this I find for some PresContext settings, are you\n> sure this is the one you mean?\n\nSorry, I meant Preferences::AddBoolVarCache.\n\n> > @@ +1989,5 @@\n> > >    // if the area is scrollable.\n> > >    nsRect scrollRange = GetScrollRange();\n> > >    ScrollbarStyles styles = GetScrollbarStylesFromFrame();\n> > >    mShouldBuildLayer =\n> > > +     ((sXULScrollLayersEnabled || XRE_GetProcessType() == GeckoProcessType_Content) &&\n> > \n> > We don't need the process type check here anymore, right?\n> \n> we used to do this for remote unconditionally before my change, are you sure\n> you want to make this conditional on the pref setting now for remoat and xul?\n\nOK, you're right.\n\n> Sorry, I don't have enough platforms at hand to thoroughly test this\n> everywhere. I opted to ifdef it for GFX_OPTIMIZE_MOBILE instead and asked\n> :cwiiis to test on android.\n\nOK.\n\n> > ::: mobile/chrome/content/bindings.xml\n> > @@ +215,5 @@\n> > > +        <![CDATA[\n> > > +        // need to handle autocomplete popup differently from batch box\n> > > +        // also lazy loaded so can't set from browser-ui.js init() like prefs\n> > > +          let winCwu = window.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils);\n> > > +          winCwu.setDisplayPortForElement(0, 0, 2048, 2048, this._items);\n> > \n> > Please separate out these displayport changes. Someone else should review\n> > them.\n> \n> as stechz probably won't be up for review I'll have to find someone else. I\n> think bjacob tutored stechz on displayport stuff?\n\nDon't think so. Stechz or cjones.", "author": "roc@ocallahan.org", "creation_time": "2011-09-07T01:58:04Z", "time": "2011-09-07T01:58:04Z", "is_private": false, "tags": [], "raw_text": "(In reply to Florian H\u00e4nel [:heeen] from comment #44)\n> the only references to this I find for some PresContext settings, are you\n> sure this is the one you mean?\n\nSorry, I meant Preferences::AddBoolVarCache.\n\n> > @@ +1989,5 @@\n> > >    // if the area is scrollable.\n> > >    nsRect scrollRange = GetScrollRange();\n> > >    ScrollbarStyles styles = GetScrollbarStylesFromFrame();\n> > >    mShouldBuildLayer =\n> > > +     ((sXULScrollLayersEnabled || XRE_GetProcessType() == GeckoProcessType_Content) &&\n> > \n> > We don't need the process type check here anymore, right?\n> \n> we used to do this for remote unconditionally before my change, are you sure\n> you want to make this conditional on the pref setting now for remoat and xul?\n\nOK, you're right.\n\n> Sorry, I don't have enough platforms at hand to thoroughly test this\n> everywhere. I opted to ifdef it for GFX_OPTIMIZE_MOBILE instead and asked\n> :cwiiis to test on android.\n\nOK.\n\n> > ::: mobile/chrome/content/bindings.xml\n> > @@ +215,5 @@\n> > > +        <![CDATA[\n> > > +        // need to handle autocomplete popup differently from batch box\n> > > +        // also lazy loaded so can't set from browser-ui.js init() like prefs\n> > > +          let winCwu = window.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils);\n> > > +          winCwu.setDisplayPortForElement(0, 0, 2048, 2048, this._items);\n> > \n> > Please separate out these displayport changes. Someone else should review\n> > them.\n> \n> as stechz probably won't be up for review I'll have to find someone else. I\n> think bjacob tutored stechz on displayport stuff?\n\nDon't think so. Stechz or cjones.", "bug_id": 657893, "count": 45}, {"count": 46, "raw_text": "I not a good reviewer of fennec frontend code.", "bug_id": 657893, "is_private": false, "tags": [], "time": "2011-09-08T03:28:27Z", "creation_time": "2011-09-08T03:28:27Z", "author": "cjones.bugs@gmail.com", "attachment_id": 558427, "id": 5706742, "text": "Comment on attachment 558427\nthe xul/fennec-side displayport stuff\n\nI not a good reviewer of fennec frontend code.", "creator": "cjones.bugs@gmail.com"}, {"author": "florian.haenel@heeen.de", "creator": "florian.haenel@heeen.de", "time": "2011-09-09T12:53:24Z", "count": 47, "bug_id": 657893, "id": 5710362, "attachment_id": null, "text": "It is my understanding that :stechz has left mozilla and is not up for review.", "creation_time": "2011-09-09T12:53:24Z", "is_private": false, "tags": [], "raw_text": "It is my understanding that :stechz has left mozilla and is not up for review."}, {"id": 5710383, "attachment_id": null, "text": "https://tbpl.mozilla.org/?tree=Try&usebuildbot=1&rev=bf5060a15ef3", "creator": "florian.haenel@heeen.de", "author": "florian.haenel@heeen.de", "creation_time": "2011-09-09T13:05:32Z", "time": "2011-09-09T13:05:32Z", "is_private": false, "tags": [], "raw_text": "https://tbpl.mozilla.org/?tree=Try&usebuildbot=1&rev=bf5060a15ef3", "bug_id": 657893, "count": 48}, {"creation_time": "2011-09-11T14:45:32Z", "author": "ben@stechz.com", "text": "I am happy to still do reviews, though I am still not convinced about this approach! Looking at the scrolling FPS for local things on my phone, I am rather certain something else is wrong. Uploading time might be important when we are almost at 60FPS (see https://bugzilla.mozilla.org/show_bug.cgi?id=670930#c11--we should be able to upload tons of pixels for a handful of milliseconds), but I think I am seeing something more like 5FPS. I'd say this is really just putting a band-aid over another problem we really need to fix.\n\nI'm happy to re-examine once we figure out the terribad problem, but until then I'm not willing to r+ this.", "creator": "ben@stechz.com", "id": 5713237, "attachment_id": null, "count": 49, "bug_id": 657893, "raw_text": "I am happy to still do reviews, though I am still not convinced about this approach! Looking at the scrolling FPS for local things on my phone, I am rather certain something else is wrong. Uploading time might be important when we are almost at 60FPS (see https://bugzilla.mozilla.org/show_bug.cgi?id=670930#c11--we should be able to upload tons of pixels for a handful of milliseconds), but I think I am seeing something more like 5FPS. I'd say this is really just putting a band-aid over another problem we really need to fix.\n\nI'm happy to re-examine once we figure out the terribad problem, but until then I'm not willing to r+ this.", "tags": [], "is_private": false, "time": "2011-09-11T14:45:32Z"}, {"time": "2011-09-11T16:57:59Z", "bug_id": 657893, "count": 50, "creator": "romaxa@gmail.com", "author": "romaxa@gmail.com", "is_private": false, "tags": [], "raw_text": "without these patches I'm seeing 5-6 FPS max in preferences view, and with these patches 20FPS.\nUpload costs are different from device to device, also texture create/destroy is very different, depends on drivers implementation.\nWithout cached scrollable view we have both problems which makes scrolling just horrible...\nThis is not band-aid, because we definitely should do textures churning and uploading as less as possible, and I don't see other way then having it pre-cached (btw we do the same for content viewport)", "id": 5713316, "attachment_id": null, "text": "without these patches I'm seeing 5-6 FPS max in preferences view, and with these patches 20FPS.\nUpload costs are different from device to device, also texture create/destroy is very different, depends on drivers implementation.\nWithout cached scrollable view we have both problems which makes scrolling just horrible...\nThis is not band-aid, because we definitely should do textures churning and uploading as less as possible, and I don't see other way then having it pre-cached (btw we do the same for content viewport)", "creation_time": "2011-09-11T16:57:59Z"}, {"tags": [], "is_private": false, "time": "2011-09-11T17:34:25Z", "count": 51, "bug_id": 657893, "raw_text": "Here profile report for chrome pref scrolling, with these patches...\nI see we still do lot of calculations in layout, but that also happening for software rendering...", "author": "romaxa@gmail.com", "creator": "romaxa@gmail.com", "text": "Created attachment 559779\nRest of problems\n\nHere profile report for chrome pref scrolling, with these patches...\nI see we still do lot of calculations in layout, but that also happening for software rendering...", "attachment_id": 559779, "id": 5713330, "creation_time": "2011-09-11T17:34:25Z"}, {"creator": "mbrubeck@limpet.net", "author": "mbrubeck@limpet.net", "time": "2011-09-16T14:07:51Z", "bug_id": 657893, "count": 52, "text": "Comment on attachment 558427\nthe xul/fennec-side displayport stuff\n\nThe code looks good to me.\n\nShould we also do this for the tab list, which is scrollable in tablet mode?\n\nWhat is the impact of this change on RAM/memory footprint?", "attachment_id": 558427, "id": 5720087, "creation_time": "2011-09-16T14:07:51Z", "tags": [], "is_private": false, "raw_text": "The code looks good to me.\n\nShould we also do this for the tab list, which is scrollable in tablet mode?\n\nWhat is the impact of this change on RAM/memory footprint?"}, {"creation_time": "2011-09-19T11:40:38Z", "creator": "florian.haenel@heeen.de", "text": "(In reply to Matt Brubeck (:mbrubeck) from comment #52)\n> What is the impact of this change on RAM/memory footprint?\n\nI just tested TextureImage creation and destruction and images are destroyed as soon as the related content isn't visible anymore, eg.: You open the preferences panel and in my case a Texture of 854x1068 pixels is created where normally there would be a 854x400px texture. As soon as I return to the main view, the texture is destroyed. So any increase in vram is only temporary as long as it is required.", "id": 5722737, "attachment_id": null, "author": "florian.haenel@heeen.de", "bug_id": 657893, "raw_text": "(In reply to Matt Brubeck (:mbrubeck) from comment #52)\n> What is the impact of this change on RAM/memory footprint?\n\nI just tested TextureImage creation and destruction and images are destroyed as soon as the related content isn't visible anymore, eg.: You open the preferences panel and in my case a Texture of 854x1068 pixels is created where normally there would be a 854x400px texture. As soon as I return to the main view, the texture is destroyed. So any increase in vram is only temporary as long as it is required.", "count": 53, "time": "2011-09-19T11:40:38Z", "tags": [], "is_private": false}, {"count": 54, "bug_id": 657893, "time": "2011-09-19T13:33:03Z", "author": "florian.haenel@heeen.de", "creator": "florian.haenel@heeen.de", "raw_text": "(In reply to Benjamin Stover (:stechz) from comment #49)\n> I am happy to still do reviews, though I am still not convinced about this\n> approach! Looking at the scrolling FPS for local things on my phone, I am\n> rather certain something else is wrong. Uploading time might be important\n> when we are almost at 60FPS (see\n> https://bugzilla.mozilla.org/show_bug.cgi?id=670930#c11--we should be able\n> to upload tons of pixels for a handful of milliseconds), but I think I am\n> seeing something more like 5FPS. I'd say this is really just putting a\n> band-aid over another problem we really need to fix.\n> \n> I'm happy to re-examine once we figure out the terribad problem, but until\n> then I'm not willing to r+ this.\n\nThis patch saves not only uploading, but also re-flowing due to a moving scrollbar and painting due to scrolled content as well as the scrollbar needing to be painted onto the content. I can't rule out that there still lurks a slow painting bug somewhere but I think caching scrollable areas is something we would end up doing anyways. If it is good for dynamic remote content it should be good for our handful of usecases.\nThe pixelformat conversion mentioned in the comment you linked does not really apply on maemo where the locked texture dictates the pixel format the painting surface is created with.", "tags": [], "is_private": false, "creation_time": "2011-09-19T13:33:03Z", "text": "(In reply to Benjamin Stover (:stechz) from comment #49)\n> I am happy to still do reviews, though I am still not convinced about this\n> approach! Looking at the scrolling FPS for local things on my phone, I am\n> rather certain something else is wrong. Uploading time might be important\n> when we are almost at 60FPS (see\n> https://bugzilla.mozilla.org/show_bug.cgi?id=670930#c11--we should be able\n> to upload tons of pixels for a handful of milliseconds), but I think I am\n> seeing something more like 5FPS. I'd say this is really just putting a\n> band-aid over another problem we really need to fix.\n> \n> I'm happy to re-examine once we figure out the terribad problem, but until\n> then I'm not willing to r+ this.\n\nThis patch saves not only uploading, but also re-flowing due to a moving scrollbar and painting due to scrolled content as well as the scrollbar needing to be painted onto the content. I can't rule out that there still lurks a slow painting bug somewhere but I think caching scrollable areas is something we would end up doing anyways. If it is good for dynamic remote content it should be good for our handful of usecases.\nThe pixelformat conversion mentioned in the comment you linked does not really apply on maemo where the locked texture dictates the pixel format the painting surface is created with.", "attachment_id": null, "id": 5722850}, {"creation_time": "2011-09-19T13:56:42Z", "author": "ben@stechz.com", "attachment_id": null, "id": 5722888, "creator": "ben@stechz.com", "text": "> This patch saves not only uploading, but also re-flowing due to a moving\n> scrollbar and painting due to scrolled content as well as the scrollbar\n> needing to be painted onto the content. I can't rule out that there still\n> lurks a slow painting bug somewhere but I think caching scrollable areas is\n> something we would end up doing anyways. If it is good for dynamic remote\n> content it should be good for our handful of usecases.\n> The pixelformat conversion mentioned in the comment you linked does not\n> really apply on maemo where the locked texture dictates the pixel format the\n> painting surface is created with.\n\nThe good news is that we are fixing the reflowing issues in a separate bug, yes? Do you know if that bug helps with the FPS here?\n\nIt's not the pixel format I was linking to. It was the speed. I'm curious what texture uploading speed is like on maemo and if uploading is our bottleneck. I seem to recall it was background painting that was the bottleneck in the last profile you did.\n\nAnyways, maybe I'm too worried about the extra memory thrashing and certainly this will help a lot in the common use cases you've patched. I wonder what the plan is for the bookmarks and about:config though?", "count": 55, "raw_text": "> This patch saves not only uploading, but also re-flowing due to a moving\n> scrollbar and painting due to scrolled content as well as the scrollbar\n> needing to be painted onto the content. I can't rule out that there still\n> lurks a slow painting bug somewhere but I think caching scrollable areas is\n> something we would end up doing anyways. If it is good for dynamic remote\n> content it should be good for our handful of usecases.\n> The pixelformat conversion mentioned in the comment you linked does not\n> really apply on maemo where the locked texture dictates the pixel format the\n> painting surface is created with.\n\nThe good news is that we are fixing the reflowing issues in a separate bug, yes? Do you know if that bug helps with the FPS here?\n\nIt's not the pixel format I was linking to. It was the speed. I'm curious what texture uploading speed is like on maemo and if uploading is our bottleneck. I seem to recall it was background painting that was the bottleneck in the last profile you did.\n\nAnyways, maybe I'm too worried about the extra memory thrashing and certainly this will help a lot in the common use cases you've patched. I wonder what the plan is for the bookmarks and about:config though?", "bug_id": 657893, "is_private": false, "tags": [], "time": "2011-09-19T13:56:42Z"}, {"raw_text": "(In reply to Benjamin Stover (:stechz) from comment #55)\n> The good news is that we are fixing the reflowing issues in a separate bug,\n> yes? Do you know if that bug helps with the FPS here?\nI'm not sure, this bug depends on bug 524925, where we fix some translation issues. Without this patch we do SetRect which will always reflow at least the scrollbar as well as invalidate anything under it.\n\n> \n> It's not the pixel format I was linking to. It was the speed. I'm curious\n> what texture uploading speed is like on maemo and if uploading is our\n> bottleneck. I seem to recall it was background painting that was the\n> bottleneck in the last profile you did.\nI don't think it is the locking/unlocking we do on maemo in particular. We should be fast enough there. I guess it is the sum of things we do in scrolling plus that it is all happening synchronously, blocking user input.\n\nHere's some timing output from inside DrawThebesLayer in FrameLayerBuilder, as well as TiledTextureImage.\n\ndestBufferRect:0,0 854x480    \ndrawBounds: 846,75 6x397      \n->DrawThebesLayer             \n<-DrawThebesLayer 641 usec    \ndestroying texture: 854x405   \ndestBufferRect:0,189 854x405  \ndrawBounds: 0,189 854x405     \ncreated Texture: 854x405      \n->DrawThebesLayer             \n<-DrawThebesLayer 33508 usec  \ndestBufferRect:846,146 6x141  \ndrawBounds: 846,146 6x141     \ncreated Texture: 6x141        \ndestroying texture: 6x141     \n->DrawThebesLayer             \n<-DrawThebesLayer 1221 usec   \ndestBufferRect:0,199 854x396  \ndrawBounds: 0,199 854x265     \ncreated Texture: 854x395      \ndestroying texture: 854x396   \n->DrawThebesLayer             \n<-DrawThebesLayer 3632 usec   \ndestBufferRect:0,0 854x480    \ndrawBounds: 846,89 6x383      \n->DrawThebesLayer             \n<-DrawThebesLayer 1191 usec   \ndestroying texture: 854x405   \ndestBufferRect:0,218 854x405  \ndrawBounds: 0,218 854x405     \ncreated Texture: 854x405      \n->DrawThebesLayer             \n<-DrawThebesLayer 41626 usec  \ndestBufferRect:846,157 6x141  \ndrawBounds: 846,157 6x141     \ncreated Texture: 6x141        \ndestroying texture: 6x141     \n->DrawThebesLayer             \n<-DrawThebesLayer 1282 usec   \ndestBufferRect:0,218 854x395  \ndrawBounds: 8,218 844x386     \ncreated Texture: 854x386      \ndestroying texture: 854x395   \n->DrawThebesLayer             \n<-DrawThebesLayer 3662 usec   \ndestBufferRect:0,0 854x480    \ndrawBounds: 0,75 854x405      \n->DrawThebesLayer             \n<-DrawThebesLayer 732 usec    \ndestroying texture: 854x405   \ndestBufferRect:0,127 854x405  \ndrawBounds: 0,127 854x405     \ncreated Texture: 854x405      \n->DrawThebesLayer             \n<-DrawThebesLayer 34729 usec  \ndestBufferRect:846,123 6x141  \ndrawBounds: 846,123 6x141     \ncreated Texture: 6x141        \ndestroying texture: 6x141     \n->DrawThebesLayer             \n<-DrawThebesLayer 1251 usec   \ndestBufferRect:0,142 854x390  \ndrawBounds: 0,142 854x272     \ncreated Texture: 854x390      \ndestroying texture: 854x386   \n->DrawThebesLayer             \n<-DrawThebesLayer 4699 usec   \ndestBufferRect:0,0 854x480    \ndrawBounds: 846,96 6x376      \n->DrawThebesLayer             \n<-DrawThebesLayer 702 usec    \ndestroying texture: 854x405   \ndestBufferRect:0,211 854x405  \ndrawBounds: 0,211 854x405     \ncreated Texture: 854x405      \n->DrawThebesLayer             \n<-DrawThebesLayer 42388 usec  \ndestBufferRect:846,154 6x141  \ndrawBounds: 846,154 6x141     \ncreated Texture: 6x141        \ndestroying texture: 6x141     \n->DrawThebesLayer             \n<-DrawThebesLayer 1251 usec   \ndestBufferRect:0,211 854x393  \ndrawBounds: 8,211 846x393     \ncreated Texture: 854x393      \ndestroying texture: 854x390   \n->DrawThebesLayer             \n<-DrawThebesLayer 3570 usec   \ndestBufferRect:0,0 854x480    \ndrawBounds: 846,75 6x397      \n->DrawThebesLayer             \n<-DrawThebesLayer 671 usec    \ndestroying texture: 854x405   \ndestBufferRect:0,86 854x405   \ndrawBounds: 0,86 854x405      \ncreated Texture: 854x405      \n->DrawThebesLayer             \n<-DrawThebesLayer 35309 usec  \ndestBufferRect:846,107 6x141  \ndrawBounds: 846,107 6x141     \ncreated Texture: 6x141        \ndestroying texture: 6x141     \n->DrawThebesLayer             \n<-DrawThebesLayer 1251 usec   \ndestBufferRect:0,86 854x393   \ndrawBounds: 0,86 854x328      \ncreated Texture: 854x378      \ndestroying texture: 854x393   \n->DrawThebesLayer             \n<-DrawThebesLayer 3906 usec   \ndestBufferRect:0,0 854x480    \ndrawBounds: 846,94 6x378      \n->DrawThebesLayer             \n<-DrawThebesLayer 702 usec    \n\nlooks like we are churning on texture images quite a bit\n\n\n> \n> Anyways, maybe I'm too worried about the extra memory thrashing and\n> certainly this will help a lot in the common use cases you've patched. I\n> wonder what the plan is for the bookmarks and about:config though?\n\nI guess for all cases with content potentially bigger than 2048px there should be a policy to move it by a sensible amount so we don't run into churning again.", "tags": [], "is_private": false, "creation_time": "2011-09-19T15:46:30Z", "text": "(In reply to Benjamin Stover (:stechz) from comment #55)\n> The good news is that we are fixing the reflowing issues in a separate bug,\n> yes? Do you know if that bug helps with the FPS here?\nI'm not sure, this bug depends on bug 524925, where we fix some translation issues. Without this patch we do SetRect which will always reflow at least the scrollbar as well as invalidate anything under it.\n\n> \n> It's not the pixel format I was linking to. It was the speed. I'm curious\n> what texture uploading speed is like on maemo and if uploading is our\n> bottleneck. I seem to recall it was background painting that was the\n> bottleneck in the last profile you did.\nI don't think it is the locking/unlocking we do on maemo in particular. We should be fast enough there. I guess it is the sum of things we do in scrolling plus that it is all happening synchronously, blocking user input.\n\nHere's some timing output from inside DrawThebesLayer in FrameLayerBuilder, as well as TiledTextureImage.\n\ndestBufferRect:0,0 854x480    \ndrawBounds: 846,75 6x397      \n->DrawThebesLayer             \n<-DrawThebesLayer 641 usec    \ndestroying texture: 854x405   \ndestBufferRect:0,189 854x405  \ndrawBounds: 0,189 854x405     \ncreated Texture: 854x405      \n->DrawThebesLayer             \n<-DrawThebesLayer 33508 usec  \ndestBufferRect:846,146 6x141  \ndrawBounds: 846,146 6x141     \ncreated Texture: 6x141        \ndestroying texture: 6x141     \n->DrawThebesLayer             \n<-DrawThebesLayer 1221 usec   \ndestBufferRect:0,199 854x396  \ndrawBounds: 0,199 854x265     \ncreated Texture: 854x395      \ndestroying texture: 854x396   \n->DrawThebesLayer             \n<-DrawThebesLayer 3632 usec   \ndestBufferRect:0,0 854x480    \ndrawBounds: 846,89 6x383      \n->DrawThebesLayer             \n<-DrawThebesLayer 1191 usec   \ndestroying texture: 854x405   \ndestBufferRect:0,218 854x405  \ndrawBounds: 0,218 854x405     \ncreated Texture: 854x405      \n->DrawThebesLayer             \n<-DrawThebesLayer 41626 usec  \ndestBufferRect:846,157 6x141  \ndrawBounds: 846,157 6x141     \ncreated Texture: 6x141        \ndestroying texture: 6x141     \n->DrawThebesLayer             \n<-DrawThebesLayer 1282 usec   \ndestBufferRect:0,218 854x395  \ndrawBounds: 8,218 844x386     \ncreated Texture: 854x386      \ndestroying texture: 854x395   \n->DrawThebesLayer             \n<-DrawThebesLayer 3662 usec   \ndestBufferRect:0,0 854x480    \ndrawBounds: 0,75 854x405      \n->DrawThebesLayer             \n<-DrawThebesLayer 732 usec    \ndestroying texture: 854x405   \ndestBufferRect:0,127 854x405  \ndrawBounds: 0,127 854x405     \ncreated Texture: 854x405      \n->DrawThebesLayer             \n<-DrawThebesLayer 34729 usec  \ndestBufferRect:846,123 6x141  \ndrawBounds: 846,123 6x141     \ncreated Texture: 6x141        \ndestroying texture: 6x141     \n->DrawThebesLayer             \n<-DrawThebesLayer 1251 usec   \ndestBufferRect:0,142 854x390  \ndrawBounds: 0,142 854x272     \ncreated Texture: 854x390      \ndestroying texture: 854x386   \n->DrawThebesLayer             \n<-DrawThebesLayer 4699 usec   \ndestBufferRect:0,0 854x480    \ndrawBounds: 846,96 6x376      \n->DrawThebesLayer             \n<-DrawThebesLayer 702 usec    \ndestroying texture: 854x405   \ndestBufferRect:0,211 854x405  \ndrawBounds: 0,211 854x405     \ncreated Texture: 854x405      \n->DrawThebesLayer             \n<-DrawThebesLayer 42388 usec  \ndestBufferRect:846,154 6x141  \ndrawBounds: 846,154 6x141     \ncreated Texture: 6x141        \ndestroying texture: 6x141     \n->DrawThebesLayer             \n<-DrawThebesLayer 1251 usec   \ndestBufferRect:0,211 854x393  \ndrawBounds: 8,211 846x393     \ncreated Texture: 854x393      \ndestroying texture: 854x390   \n->DrawThebesLayer             \n<-DrawThebesLayer 3570 usec   \ndestBufferRect:0,0 854x480    \ndrawBounds: 846,75 6x397      \n->DrawThebesLayer             \n<-DrawThebesLayer 671 usec    \ndestroying texture: 854x405   \ndestBufferRect:0,86 854x405   \ndrawBounds: 0,86 854x405      \ncreated Texture: 854x405      \n->DrawThebesLayer             \n<-DrawThebesLayer 35309 usec  \ndestBufferRect:846,107 6x141  \ndrawBounds: 846,107 6x141     \ncreated Texture: 6x141        \ndestroying texture: 6x141     \n->DrawThebesLayer             \n<-DrawThebesLayer 1251 usec   \ndestBufferRect:0,86 854x393   \ndrawBounds: 0,86 854x328      \ncreated Texture: 854x378      \ndestroying texture: 854x393   \n->DrawThebesLayer             \n<-DrawThebesLayer 3906 usec   \ndestBufferRect:0,0 854x480    \ndrawBounds: 846,94 6x378      \n->DrawThebesLayer             \n<-DrawThebesLayer 702 usec    \n\nlooks like we are churning on texture images quite a bit\n\n\n> \n> Anyways, maybe I'm too worried about the extra memory thrashing and\n> certainly this will help a lot in the common use cases you've patched. I\n> wonder what the plan is for the bookmarks and about:config though?\n\nI guess for all cases with content potentially bigger than 2048px there should be a policy to move it by a sensible amount so we don't run into churning again.", "attachment_id": null, "id": 5723118, "count": 56, "bug_id": 657893, "time": "2011-09-19T15:46:30Z", "author": "florian.haenel@heeen.de", "creator": "florian.haenel@heeen.de"}, {"time": "2011-09-20T13:55:36Z", "bug_id": 657893, "count": 57, "creator": "florian.haenel@heeen.de", "author": "florian.haenel@heeen.de", "tags": [], "is_private": false, "raw_text": "I looked at the reasons why we were so slow in scrolling again in the first place. For each scroll movement there are 4 texture images involved.\n1. The background receives an invalidation from the scrollbar although in the case of fennec nothing is happening there. lock, paint(?), unlock\n2. The scrollbar thumb has its own texture image. Although it doesn't change, only move, it is being repainted because we do a crude SetRect and relayout for it. lock, paint, unlock.\n3 & 4. The borderbackground and the text elements of the scrolled content each get their own image. This is because they each have a separate clip and between the clips the scroll thumb prevents these from merging.\nDue to the buffers being exactly the visible size we also seem to run into this condition here quite often, which means more buffer destructions and re-creations: http://mxr.mozilla.org/mozilla-central/source/gfx/layers/opengl/ThebesLayerOGL.cpp#522\nAnyways, this nets us another 2x (buffer lock, paint, unlock)", "text": "Created attachment 561178\nwhat happens when scrolling without the propsed patch\n\nI looked at the reasons why we were so slow in scrolling again in the first place. For each scroll movement there are 4 texture images involved.\n1. The background receives an invalidation from the scrollbar although in the case of fennec nothing is happening there. lock, paint(?), unlock\n2. The scrollbar thumb has its own texture image. Although it doesn't change, only move, it is being repainted because we do a crude SetRect and relayout for it. lock, paint, unlock.\n3 & 4. The borderbackground and the text elements of the scrolled content each get their own image. This is because they each have a separate clip and between the clips the scroll thumb prevents these from merging.\nDue to the buffers being exactly the visible size we also seem to run into this condition here quite often, which means more buffer destructions and re-creations: http://mxr.mozilla.org/mozilla-central/source/gfx/layers/opengl/ThebesLayerOGL.cpp#522\nAnyways, this nets us another 2x (buffer lock, paint, unlock)", "attachment_id": 561178, "id": 5725423, "creation_time": "2011-09-20T13:55:36Z"}, {"creator": "roc@ocallahan.org", "author": "roc@ocallahan.org", "time": "2011-09-20T19:45:44Z", "bug_id": 657893, "count": 58, "text": "So if we take your patches to fix the z-ordering of the thumb, and make it use CSS transforms, most of those problems would go away, right? We'd still have one update to the scrolled content image left.\n\nLet's break those patches out and land them.", "id": 5726447, "attachment_id": null, "creation_time": "2011-09-20T19:45:44Z", "tags": [], "is_private": false, "raw_text": "So if we take your patches to fix the z-ordering of the thumb, and make it use CSS transforms, most of those problems would go away, right? We'd still have one update to the scrolled content image left.\n\nLet's break those patches out and land them."}, {"creation_time": "2011-09-21T15:33:58Z", "id": 5728260, "attachment_id": 561484, "text": "Created attachment 561484\nfix: header buttons into separate stacking context", "creator": "florian.haenel@heeen.de", "author": "florian.haenel@heeen.de", "raw_text": "", "bug_id": 657893, "count": 59, "time": "2011-09-21T15:33:58Z", "is_private": false, "tags": []}, {"is_private": false, "tags": [], "time": "2011-09-21T15:35:43Z", "count": 60, "raw_text": "", "bug_id": 657893, "author": "florian.haenel@heeen.de", "attachment_id": 561485, "id": 5728272, "creator": "florian.haenel@heeen.de", "text": "Created attachment 561485\nmake scrollbar thumbs use css transforms on mobile", "creation_time": "2011-09-21T15:35:43Z"}, {"author": "florian.haenel@heeen.de", "creator": "florian.haenel@heeen.de", "count": 61, "bug_id": 657893, "time": "2011-09-21T15:38:32Z", "creation_time": "2011-09-21T15:38:32Z", "id": 5728302, "attachment_id": 561486, "text": "Created attachment 561486\nenable displayport buffering for some common scrollboxes on fennec\n\nwhat this patch was originally about", "raw_text": "what this patch was originally about", "is_private": false, "tags": []}, {"time": "2011-09-21T17:27:11Z", "bug_id": 657893, "count": 62, "creator": "mbrubeck@limpet.net", "author": "mbrubeck@limpet.net", "tags": [], "is_private": false, "raw_text": ">+    winCwu.setDisplayPortForElement(0, 0, 2048, 2048, document.getElementById(\"prefs-list\")._scrollbox);\n>+    winCwu.setDisplayPortForElement(0, 0, 2048, 2048, document.getElementById(\"addons-list\")._scrollbox);\n>+    winCwu.setDisplayPortForElement(0, 0, 2048, 2048, document.getElementById(\"downloads-list\")._scrollbox);\n>+    winCwu.setDisplayPortForElement(0, 0, 2048, 2048, document.getElementById(\"console-box\")._scrollbox);\n\nI think we should also add document.getElementById(\"tabs\")._scrollbox to this list (especially important in the new tablet layout).", "text": "Comment on attachment 561486\nenable displayport buffering for some common scrollboxes on fennec\n\n>+    winCwu.setDisplayPortForElement(0, 0, 2048, 2048, document.getElementById(\"prefs-list\")._scrollbox);\n>+    winCwu.setDisplayPortForElement(0, 0, 2048, 2048, document.getElementById(\"addons-list\")._scrollbox);\n>+    winCwu.setDisplayPortForElement(0, 0, 2048, 2048, document.getElementById(\"downloads-list\")._scrollbox);\n>+    winCwu.setDisplayPortForElement(0, 0, 2048, 2048, document.getElementById(\"console-box\")._scrollbox);\n\nI think we should also add document.getElementById(\"tabs\")._scrollbox to this list (especially important in the new tablet layout).", "attachment_id": 561486, "id": 5728610, "creation_time": "2011-09-21T17:27:11Z"}, {"count": 63, "raw_text": "Review of attachment 561485:\n-----------------------------------------------------------------\n\nr+ with those fixed.\n\n::: layout/xul/base/src/nsSliderFrame.cpp\n@@ +388,5 @@\n> +    transform.AppendLiteral(\"px)\");\n> +    result = css2->SetMozTransform(transform);\n> +\n> +    nsIFrame* frame = mThumbContent->GetPrimaryFrame();\n> +    if(frame) {\n\nif (frame) {\n\n@@ +390,5 @@\n> +\n> +    nsIFrame* frame = mThumbContent->GetPrimaryFrame();\n> +    if(frame) {\n> +      frame->InvalidateTransformLayer();\n> +    }\n\nActually, this InvalidateTransformLayer call chould be unnecessary. The style change should take care of it.\n\n@@ +482,5 @@\n> +  LayoutChildAt(aState, thumbBox, nsRect(0,0, thumbSize.width, thumbSize.height));\n> +  SyncLayout(aState);\n> +  // Redraw only if thumb changed size.\n> +  if (oldThumbRect.Size() != thumbRect.Size())\n> +    Redraw(aState);\n\n{}\n\n@@ +485,5 @@\n> +  if (oldThumbRect.Size() != thumbRect.Size())\n> +    Redraw(aState);\n> +\n> +  nsIFrame* thumbFrame = mFrames.FirstChild();\n> +  if(thumbFrame) {\n\nif (thumbFrame) {", "bug_id": 657893, "is_private": false, "tags": [], "time": "2011-09-22T03:46:57Z", "creation_time": "2011-09-22T03:46:57Z", "author": "roc@ocallahan.org", "id": 5730016, "attachment_id": 561485, "text": "Comment on attachment 561485\nmake scrollbar thumbs use css transforms on mobile\n\nReview of attachment 561485:\n-----------------------------------------------------------------\n\nr+ with those fixed.\n\n::: layout/xul/base/src/nsSliderFrame.cpp\n@@ +388,5 @@\n> +    transform.AppendLiteral(\"px)\");\n> +    result = css2->SetMozTransform(transform);\n> +\n> +    nsIFrame* frame = mThumbContent->GetPrimaryFrame();\n> +    if(frame) {\n\nif (frame) {\n\n@@ +390,5 @@\n> +\n> +    nsIFrame* frame = mThumbContent->GetPrimaryFrame();\n> +    if(frame) {\n> +      frame->InvalidateTransformLayer();\n> +    }\n\nActually, this InvalidateTransformLayer call chould be unnecessary. The style change should take care of it.\n\n@@ +482,5 @@\n> +  LayoutChildAt(aState, thumbBox, nsRect(0,0, thumbSize.width, thumbSize.height));\n> +  SyncLayout(aState);\n> +  // Redraw only if thumb changed size.\n> +  if (oldThumbRect.Size() != thumbRect.Size())\n> +    Redraw(aState);\n\n{}\n\n@@ +485,5 @@\n> +  if (oldThumbRect.Size() != thumbRect.Size())\n> +    Redraw(aState);\n> +\n> +  nsIFrame* thumbFrame = mFrames.FirstChild();\n> +  if(thumbFrame) {\n\nif (thumbFrame) {", "creator": "roc@ocallahan.org"}, {"time": "2011-09-22T08:26:30Z", "tags": [], "is_private": false, "bug_id": 657893, "raw_text": "(In reply to Matt Brubeck (:mbrubeck) from comment #62)\n> Comment on attachment 561486\n> enable displayport buffering for some common scrollboxes on fennec\n> \n> >+    winCwu.setDisplayPortForElement(0, 0, 2048, 2048, document.getElementById(\"prefs-list\")._scrollbox);\n> >+    winCwu.setDisplayPortForElement(0, 0, 2048, 2048, document.getElementById(\"addons-list\")._scrollbox);\n> >+    winCwu.setDisplayPortForElement(0, 0, 2048, 2048, document.getElementById(\"downloads-list\")._scrollbox);\n> >+    winCwu.setDisplayPortForElement(0, 0, 2048, 2048, document.getElementById(\"console-box\")._scrollbox);\n> \n> I think we should also add document.getElementById(\"tabs\")._scrollbox to\n> this list (especially important in the new tablet layout).\n\nI found that gecko doesn'T like display port an every element, so we have to try and see what works. For instance I have been trying to track down why setting a displayport on #controls-scrollbox breaks the autocomplete popup (bug 684881).", "count": 64, "text": "(In reply to Matt Brubeck (:mbrubeck) from comment #62)\n> Comment on attachment 561486\n> enable displayport buffering for some common scrollboxes on fennec\n> \n> >+    winCwu.setDisplayPortForElement(0, 0, 2048, 2048, document.getElementById(\"prefs-list\")._scrollbox);\n> >+    winCwu.setDisplayPortForElement(0, 0, 2048, 2048, document.getElementById(\"addons-list\")._scrollbox);\n> >+    winCwu.setDisplayPortForElement(0, 0, 2048, 2048, document.getElementById(\"downloads-list\")._scrollbox);\n> >+    winCwu.setDisplayPortForElement(0, 0, 2048, 2048, document.getElementById(\"console-box\")._scrollbox);\n> \n> I think we should also add document.getElementById(\"tabs\")._scrollbox to\n> this list (especially important in the new tablet layout).\n\nI found that gecko doesn'T like display port an every element, so we have to try and see what works. For instance I have been trying to track down why setting a displayport on #controls-scrollbox breaks the autocomplete popup (bug 684881).", "creator": "florian.haenel@heeen.de", "attachment_id": null, "id": 5730258, "author": "florian.haenel@heeen.de", "creation_time": "2011-09-22T08:26:30Z"}, {"creation_time": "2011-09-26T20:50:47Z", "id": 5737999, "attachment_id": 561486, "creator": "mark.finkle@gmail.com", "text": "Comment on attachment 561486\nenable displayport buffering for some common scrollboxes on fennec\n\nI don't like this one bit. It's too fragile and too obtrusive. If this is supposed to be added to <scrollbox>s then add it to the XBL and provide a way to set the buffering size.\n\nThis patch just looks like a big hack.\n\nHow much memory are we going to start chewing up because of this?", "author": "mark.finkle@gmail.com", "raw_text": "I don't like this one bit. It's too fragile and too obtrusive. If this is supposed to be added to <scrollbox>s then add it to the XBL and provide a way to set the buffering size.\n\nThis patch just looks like a big hack.\n\nHow much memory are we going to start chewing up because of this?", "bug_id": 657893, "count": 65, "time": "2011-09-26T20:50:47Z", "is_private": false, "tags": []}, {"count": 66, "bug_id": 657893, "raw_text": "I don't mind this change, but the CSS does not convey the end result. Very fragile. I wouldn't doubt this change would be \"cleaned up\" in a future refactoring without ever knowing the purpose.\n\nIs this really the best answer we have?", "tags": [], "is_private": false, "time": "2011-09-26T20:53:43Z", "creation_time": "2011-09-26T20:53:43Z", "author": "mark.finkle@gmail.com", "creator": "mark.finkle@gmail.com", "text": "Comment on attachment 561484\nfix: header buttons into separate stacking context\n\nI don't mind this change, but the CSS does not convey the end result. Very fragile. I wouldn't doubt this change would be \"cleaned up\" in a future refactoring without ever knowing the purpose.\n\nIs this really the best answer we have?", "id": 5738008, "attachment_id": 561484}, {"is_private": false, "tags": [], "raw_text": "Let me pull back a bit and say that this looks like a promising way to speed up scrolling, but I don't think it's quite ready yet. The implementation aspects of the patches could be taken a bit further along and made a little cleaner for front-end consumers like Fennec.", "id": 5738031, "attachment_id": null, "text": "Let me pull back a bit and say that this looks like a promising way to speed up scrolling, but I don't think it's quite ready yet. The implementation aspects of the patches could be taken a bit further along and made a little cleaner for front-end consumers like Fennec.", "creation_time": "2011-09-26T21:00:21Z", "time": "2011-09-26T21:00:21Z", "count": 67, "bug_id": 657893, "author": "mark.finkle@gmail.com", "creator": "mark.finkle@gmail.com"}, {"creator": "romaxa@gmail.com", "text": "> How much memory are we going to start chewing up because of this?\nalready answered above see comment 53..", "id": 5738066, "attachment_id": null, "author": "romaxa@gmail.com", "creation_time": "2011-09-26T21:10:31Z", "time": "2011-09-26T21:10:31Z", "tags": [], "is_private": false, "bug_id": 657893, "raw_text": "> How much memory are we going to start chewing up because of this?\nalready answered above see comment 53..", "count": 68}, {"bug_id": 657893, "count": 69, "time": "2011-09-26T21:17:16Z", "creator": "romaxa@gmail.com", "author": "romaxa@gmail.com", "raw_text": "> fragile. I wouldn't doubt this change would be \"cleaned up\" in a future\n> refactoring without ever knowing the purpose.\nAny other suggestion how to fix this problem, I think UI should care from time to time about engine implementation bottle necks and find ways to build UI in such way that backend implementation will work in most optimal and fast way... \nRecall me some previous bug about getBoundingRects usage in UI.", "tags": [], "is_private": false, "creation_time": "2011-09-26T21:17:16Z", "text": "> fragile. I wouldn't doubt this change would be \"cleaned up\" in a future\n> refactoring without ever knowing the purpose.\nAny other suggestion how to fix this problem, I think UI should care from time to time about engine implementation bottle necks and find ways to build UI in such way that backend implementation will work in most optimal and fast way... \nRecall me some previous bug about getBoundingRects usage in UI.", "attachment_id": null, "id": 5738100}, {"author": "mark.finkle@gmail.com", "id": 5738107, "attachment_id": null, "creator": "mark.finkle@gmail.com", "text": "(In reply to Oleg Romashin (:romaxa) from comment #68)\n> > How much memory are we going to start chewing up because of this?\n> already answered above see comment 53..\n\nThe preferences panel uses at least 3 scrollboxes (could be 4 if error console is on), Would memory be used for all 3 or only the visible one?", "creation_time": "2011-09-26T21:20:12Z", "is_private": false, "tags": [], "time": "2011-09-26T21:20:12Z", "count": 70, "raw_text": "(In reply to Oleg Romashin (:romaxa) from comment #68)\n> > How much memory are we going to start chewing up because of this?\n> already answered above see comment 53..\n\nThe preferences panel uses at least 3 scrollboxes (could be 4 if error console is on), Would memory be used for all 3 or only the visible one?", "bug_id": 657893}, {"bug_id": 657893, "raw_text": "(In reply to Oleg Romashin (:romaxa) from comment #69)\n> > fragile. I wouldn't doubt this change would be \"cleaned up\" in a future\n> > refactoring without ever knowing the purpose.\n> Any other suggestion how to fix this problem, I think UI should care from\n> time to time about engine implementation bottle necks and find ways to build\n> UI in such way that backend implementation will work in most optimal and\n> fast way... \n> Recall me some previous bug about getBoundingRects usage in UI.\n\nFrankly, I get worried whenever the front-end needs to actively handle performance bottlenecks. Your getBoundingClientRect example is a perfect use case: Do you know how many times JS code has added gBCR since you filed that bug? We would need some static code analyzer to make sure we don't introduce a \"badly\" performing function call in some routine patch in the future. It's fragile.", "count": 71, "time": "2011-09-26T21:22:59Z", "tags": [], "is_private": false, "creation_time": "2011-09-26T21:22:59Z", "text": "(In reply to Oleg Romashin (:romaxa) from comment #69)\n> > fragile. I wouldn't doubt this change would be \"cleaned up\" in a future\n> > refactoring without ever knowing the purpose.\n> Any other suggestion how to fix this problem, I think UI should care from\n> time to time about engine implementation bottle necks and find ways to build\n> UI in such way that backend implementation will work in most optimal and\n> fast way... \n> Recall me some previous bug about getBoundingRects usage in UI.\n\nFrankly, I get worried whenever the front-end needs to actively handle performance bottlenecks. Your getBoundingClientRect example is a perfect use case: Do you know how many times JS code has added gBCR since you filed that bug? We would need some static code analyzer to make sure we don't introduce a \"badly\" performing function call in some routine patch in the future. It's fragile.", "creator": "mark.finkle@gmail.com", "id": 5738119, "attachment_id": null, "author": "mark.finkle@gmail.com"}, {"author": "roc@ocallahan.org", "attachment_id": null, "id": 5738304, "creator": "roc@ocallahan.org", "text": "Maybe we can put z-index:0 around the content <browser> to ensure that the scrollbars are captured in its stacking context.", "creation_time": "2011-09-26T22:10:40Z", "is_private": false, "tags": [], "time": "2011-09-26T22:10:40Z", "count": 72, "raw_text": "Maybe we can put z-index:0 around the content <browser> to ensure that the scrollbars are captured in its stacking context.", "bug_id": 657893}, {"time": "2011-09-26T22:19:27Z", "is_private": false, "tags": [], "raw_text": "(In reply to Mark Finkle (:mfinkle) from comment #70)\n> The preferences panel uses at least 3 scrollboxes (could be 4 if error\n> console is on), Would memory be used for all 3 or only the visible one?\n\nonly actually visible elements get layers, also in stacks.", "bug_id": 657893, "count": 73, "attachment_id": null, "id": 5738324, "text": "(In reply to Mark Finkle (:mfinkle) from comment #70)\n> The preferences panel uses at least 3 scrollboxes (could be 4 if error\n> console is on), Would memory be used for all 3 or only the visible one?\n\nonly actually visible elements get layers, also in stacks.", "creator": "florian.haenel@heeen.de", "author": "florian.haenel@heeen.de", "creation_time": "2011-09-26T22:19:27Z"}]}}}