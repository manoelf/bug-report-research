{"comments": {}, "bugs": {"652818": {"comments": [{"attachment_id": null, "time": "2011-04-26T15:47:11Z", "is_private": false, "author": "jorendorff@mozilla.com", "bug_id": 652818, "tags": [], "creator": "jorendorff@mozilla.com", "count": 0, "raw_text": "Christian Holler was part of a team that used science to estimate the exploitability of various components of Mozilla.\n  http://www.st.cs.uni-saarland.de/softevo/vulnerabilities.php\n\nIn brief the researchers used the dependency graph of the source tree (what calls what) and historical data about which files have contained security bugs (MFSAs -> bug numbers -> hg log) as input to mathematical wizardry. It turned out to be fairly accurate. This was in 2007.\n\nI asked him to re-run the analysis. The results are here:\n  http://users.own-hero.net/~decoder/mozilla-svm.html\nIt fingers content/base/src/nsContentUtils.cpp, and the score it assigns is disturbingly high.\n\nIt is debatable whether this estimate means anything; due to the kind of math used, it's very hard to know what's behind this, just what pattern the math is seeing in the data, etc. I am pretty skeptical myself. We could discuss these imponderables ad nauseum in this bug. I'd rather try something and see what happens. I am no expert in this code but my plan is to stare at it for 8 hours next Wednesday (4 May) (assuming nobody takes it first).\n\n(This bug is closed for now. I don't know how security-sensitive the data at that URL is.)", "id": 5431901, "text": "Christian Holler was part of a team that used science to estimate the exploitability of various components of Mozilla.\n  http://www.st.cs.uni-saarland.de/softevo/vulnerabilities.php\n\nIn brief the researchers used the dependency graph of the source tree (what calls what) and historical data about which files have contained security bugs (MFSAs -> bug numbers -> hg log) as input to mathematical wizardry. It turned out to be fairly accurate. This was in 2007.\n\nI asked him to re-run the analysis. The results are here:\n  http://users.own-hero.net/~decoder/mozilla-svm.html\nIt fingers content/base/src/nsContentUtils.cpp, and the score it assigns is disturbingly high.\n\nIt is debatable whether this estimate means anything; due to the kind of math used, it's very hard to know what's behind this, just what pattern the math is seeing in the data, etc. I am pretty skeptical myself. We could discuss these imponderables ad nauseum in this bug. I'd rather try something and see what happens. I am no expert in this code but my plan is to stare at it for 8 hours next Wednesday (4 May) (assuming nobody takes it first).\n\n(This bug is closed for now. I don't know how security-sensitive the data at that URL is.)", "creation_time": "2011-04-26T15:47:11Z"}, {"attachment_id": null, "time": "2011-04-29T15:33:18Z", "is_private": false, "author": "choller@mozilla.com", "bug_id": 652818, "count": 1, "tags": [], "creator": "choller@mozilla.com", "text": "I compared the prediction with the most recent MFSAs (MFSA 2011-12 to 2011-18, released in April) and got two hits (same bug id):\n\n#7 layout/base/nsLayoutUtils MSFA2011-12 619021\n#9 layout/generic/nsFrame MSFA2011-12 619021\n\nWhen I get some time I plan to investigate in how far a clustering algorithm could help to improve the reasoning of the predictions (i.e. hint on why this is component is considered problematic).", "creation_time": "2011-04-29T15:33:18Z", "raw_text": "I compared the prediction with the most recent MFSAs (MFSA 2011-12 to 2011-18, released in April) and got two hits (same bug id):\n\n#7 layout/base/nsLayoutUtils MSFA2011-12 619021\n#9 layout/generic/nsFrame MSFA2011-12 619021\n\nWhen I get some time I plan to investigate in how far a clustering algorithm could help to improve the reasoning of the predictions (i.e. hint on why this is component is considered problematic).", "id": 5439654}, {"time": "2011-05-13T21:06:53Z", "is_private": false, "attachment_id": null, "creator": "jorendorff@mozilla.com", "count": 2, "tags": [], "bug_id": 652818, "creation_time": "2011-05-13T21:06:53Z", "text": "I forgot about this. Rescheduling for *next* Wednesday, 18 May.", "id": 5469157, "raw_text": "I forgot about this. Rescheduling for *next* Wednesday, 18 May.", "author": "jorendorff@mozilla.com"}, {"attachment_id": null, "time": "2011-05-18T14:50:01Z", "is_private": false, "author": "jorendorff@mozilla.com", "bug_id": 652818, "creator": "jorendorff@mozilla.com", "tags": [], "count": 3, "text": "Christian ran a more fine-grained version of the same analysis (2 weeks ago) and was able to offer this:\n\n    Lines 1 to 999:       0.04126131\n    Lines 1000 to 1999:   8.341698\n    Lines 2000 to 2999:   1.187755\n    Lines 3000 to 3999:   0.5436279\n    Lines 4000 to 4999:   1.920721\n    Lines 5000 to 5999:   4.188863\n    Lines 6000 to 6522:   0.1392063 \n\nSo I will start by reading lines 1000-1999 or thereabouts.\n\nNarrowing it too far, I gather, would eventually make the results meaningless.", "creation_time": "2011-05-18T14:50:01Z", "raw_text": "Christian ran a more fine-grained version of the same analysis (2 weeks ago) and was able to offer this:\n\n    Lines 1 to 999:       0.04126131\n    Lines 1000 to 1999:   8.341698\n    Lines 2000 to 2999:   1.187755\n    Lines 3000 to 3999:   0.5436279\n    Lines 4000 to 4999:   1.920721\n    Lines 5000 to 5999:   4.188863\n    Lines 6000 to 6522:   0.1392063 \n\nSo I will start by reading lines 1000-1999 or thereabouts.\n\nNarrowing it too far, I gather, would eventually make the results meaningless.", "id": 5477096}, {"author": "jorendorff@mozilla.com", "id": 5478418, "raw_text": "nsContentUtils::Shutdown is probably the source of most of the \"smell\" Christian's math is detecting in lines 1000-1999 of this file. It calls into everything. There's no way I can realistically audit that -- at least, not today.", "creation_time": "2011-05-18T21:54:11Z", "text": "nsContentUtils::Shutdown is probably the source of most of the \"smell\" Christian's math is detecting in lines 1000-1999 of this file. It calls into everything. There's no way I can realistically audit that -- at least, not today.", "tags": [], "creator": "jorendorff@mozilla.com", "count": 4, "bug_id": 652818, "attachment_id": null, "is_private": false, "time": "2011-05-18T21:54:11Z"}, {"author": "jorendorff@mozilla.com", "attachment_id": null, "raw_text": "OK, done with my first 8 hours. I read lines 1000-1999 and found one\nbug, bug 658037. Here are some general observations:\n\nThere are several XXXbz comments that could be revisited, including\nnone-too-reassuring stuff like\n\n>    // XXX We don't need to use index if name is there\n>    // XXXbz We don't?  Why not?  I don't follow\n\nThroughout this code return values don't get checked. This is probably\nsafe in most cases because of special knowledge this code has of\nimplementation details of the callee... or even the caller... but that\nkind of tight coupling is inherently brittle, and even if you did buy\nit, you wouldn't just throw the return value away. You'd assert.\n\nAll this seems kind of crazy, when a bug could so easily lead to\nundefined behavior, and it would be so easy to just check the stupid\nreturns.\n\nMaybe I'm like Joel Spolskly in\nhttp://www.joelonsoftware.com/articles/Wrong.html\nand I just don't know what \"clean\" is supposed to look like in this\ncode. I beg to be reassured on that point, if so, because to me checking\nreturn values is C++ 101.", "id": 5478767, "text": "OK, done with my first 8 hours. I read lines 1000-1999 and found one\nbug, bug 658037. Here are some general observations:\n\nThere are several XXXbz comments that could be revisited, including\nnone-too-reassuring stuff like\n\n>    // XXX We don't need to use index if name is there\n>    // XXXbz We don't?  Why not?  I don't follow\n\nThroughout this code return values don't get checked. This is probably\nsafe in most cases because of special knowledge this code has of\nimplementation details of the callee... or even the caller... but that\nkind of tight coupling is inherently brittle, and even if you did buy\nit, you wouldn't just throw the return value away. You'd assert.\n\nAll this seems kind of crazy, when a bug could so easily lead to\nundefined behavior, and it would be so easy to just check the stupid\nreturns.\n\nMaybe I'm like Joel Spolskly in\nhttp://www.joelonsoftware.com/articles/Wrong.html\nand I just don't know what \"clean\" is supposed to look like in this\ncode. I beg to be reassured on that point, if so, because to me checking\nreturn values is C++ 101.", "creation_time": "2011-05-19T00:06:31Z", "is_private": false, "bug_id": 652818, "tags": [], "count": 5, "creator": "jorendorff@mozilla.com", "time": "2011-05-19T00:06:31Z"}, {"author": "jorendorff@mozilla.com", "creation_time": "2011-05-19T00:09:07Z", "text": "I would like bz or mrbkap to look closely at this code in\nnsContentUtils::ReparentContentWrappersInScope:\n\n>  // Try really hard to find a context to work on.\n>  nsIScriptContext *context = aOldScope->GetContext();\n>  if (context) {\n>    cx = static_cast<JSContext *>(context->GetNativeContext());\n>  }\n>\n>  if (!cx) {\n>    context = aNewScope->GetContext();\n>    if (context) {\n>      cx = static_cast<JSContext *>(context->GetNativeContext());\n>    }\n>\n>    if (!cx) {\n>      sThreadJSContextStack->Peek(&cx);\n>\n>      if (!cx) {\n>        sThreadJSContextStack->GetSafeJSContext(&cx);\n\nThere's similar code in a few other places. A few thoughts:\n\n- This is about as sketchy as it gets. Why not just add:\n\n         if (!cx) {\n           sIKnowAGuy->HeKnowAGuy()->GetYouSafeJSContextRealCheap(&cx);\n\n- nsHTMLDocument::OpenCommon can only be successfully called from\n  script, right?  If so, since that's our only caller,\n  sThreadJSContextStack->Peek here must succeed. So the GetSafeJSContext\n  part at least should be dead code; I say dike it out.\n\n- For that matter, why are we trying aOldScope and aNewScope first?\n\n- If OpenCommon really can only be called from script, via XPConnect,\n  then we should use explicit_jscontext and delete all of this.", "id": 5478772, "raw_text": "I would like bz or mrbkap to look closely at this code in\nnsContentUtils::ReparentContentWrappersInScope:\n\n>  // Try really hard to find a context to work on.\n>  nsIScriptContext *context = aOldScope->GetContext();\n>  if (context) {\n>    cx = static_cast<JSContext *>(context->GetNativeContext());\n>  }\n>\n>  if (!cx) {\n>    context = aNewScope->GetContext();\n>    if (context) {\n>      cx = static_cast<JSContext *>(context->GetNativeContext());\n>    }\n>\n>    if (!cx) {\n>      sThreadJSContextStack->Peek(&cx);\n>\n>      if (!cx) {\n>        sThreadJSContextStack->GetSafeJSContext(&cx);\n\nThere's similar code in a few other places. A few thoughts:\n\n- This is about as sketchy as it gets. Why not just add:\n\n         if (!cx) {\n           sIKnowAGuy->HeKnowAGuy()->GetYouSafeJSContextRealCheap(&cx);\n\n- nsHTMLDocument::OpenCommon can only be successfully called from\n  script, right?  If so, since that's our only caller,\n  sThreadJSContextStack->Peek here must succeed. So the GetSafeJSContext\n  part at least should be dead code; I say dike it out.\n\n- For that matter, why are we trying aOldScope and aNewScope first?\n\n- If OpenCommon really can only be called from script, via XPConnect,\n  then we should use explicit_jscontext and delete all of this.", "tags": [], "count": 6, "creator": "jorendorff@mozilla.com", "bug_id": 652818, "attachment_id": null, "is_private": false, "time": "2011-05-19T00:09:07Z"}, {"time": "2011-05-19T00:11:13Z", "count": 7, "tags": [], "creator": "jorendorff@mozilla.com", "bug_id": 652818, "id": 5478775, "raw_text": "The rest are nits.\n\nIn nsContentUtils::ParseIntMarginValue:\n>  marginStr.CompressWhitespace(PR_TRUE, PR_TRUE);\n\nNo bug, but this method looks like it accepts a pretty wide range of\nstupid bogus input. (Callers are XUL-only, looks like, so not exposed to\nthe web.)\n\n> void\n> nsContentUtils::GetOfflineAppManifest(nsIDocument *aDocument, nsIURI **aURI)\n\nNo bug, just very strange style choices. This is fallible but void. On\nfailure it just returns, leaving aURI (hopefully?) untouched. Also:\n\n>  nsAutoString manifestSpec;\n>  docElement->GetAttr(kNameSpaceID_None, nsGkAtoms::manifest, manifestSpec);\n>\n>  // Manifest URIs can't have fragment identifiers.\n>  if (manifestSpec.IsEmpty() ||\n\nDo COM objects always leave the out parameter alone on failure?  I\nthought they generally did but that callers weren't supposed to\nassume.\n\n>  nsContentUtils::NewURIWithDocumentCharset(aURI, manifestSpec,\n>                                            aDocument,\n>                                            aDocument->GetDocBaseURI());\n>}\n\nSame thing here. All it would take to make me happy is change this to\nreturn an nsresult and do normal error checking.\n\nComment on nsContentUtils::CheckSameOrigin:\n> * Checks whether two nodes come from the same origin. aTrustedNode is\n> * considered 'safe' in that a user can operate on it and that it isn't\n> * a js-object that implements nsIDOMNode.\n> * Never call this function with the first node provided by script, it\n> * must always be known to be a 'real' node!\n\nWorking in js/src has convinced me that information like this doesn't belong\nin a comment. XPConnect should provide a way to check this and we should\nassert. Same thing in several other places.\n\n>  // XXXbz should we actually have a Subsumes() check here instead?  Or perhaps\n>  // a separate method for that, with callers using one or the other?\n>  if (NS_FAILED(trustedPrincipal->Equals(unTrustedPrincipal, &equal)) ||\n\nNo bug. If anything we're too strict here. The comment could stand to be\nreplaced with one explaining why this is fine, though.\n\nIn nsContentUtils::CanCallerAccess:\n>  isSystem = NS_FAILED(rv) || isSystem;\n>  const char* capability =\n>    NS_FAILED(rv) || isSystem ? \"UniversalXPConnect\" : \"UniversalBrowserRead\";\n\nThe `isSystem = ` line is redundant, since we then do the\n`NS_FAILED(rv) ||` bit again anyway.\n\nIn nsContentUtils::GetDocumentFromCaller:\n>  JSAutoEnterCompartment ac;\n>  if (!ac.enter(cx, obj)) {\n>    return nsnull;\n>  }\n\nI wonder why GetDocumentFromCaller needs one of these but\nGetDocumentFromContext doesn't.\n\nIn IsCharInSet:\n>  PRUnichar ch;\n>  while ((ch = *aSet)) {\n>    if (aChar == PRUnichar(ch)) {\n\nThe cast is redundant; if we want a cast here at all it belongs on the\nprevious line, where the 8-bit *aSet is being assigned to 16-bit ch.", "creation_time": "2011-05-19T00:11:13Z", "is_private": false, "text": "The rest are nits.\n\nIn nsContentUtils::ParseIntMarginValue:\n>  marginStr.CompressWhitespace(PR_TRUE, PR_TRUE);\n\nNo bug, but this method looks like it accepts a pretty wide range of\nstupid bogus input. (Callers are XUL-only, looks like, so not exposed to\nthe web.)\n\n> void\n> nsContentUtils::GetOfflineAppManifest(nsIDocument *aDocument, nsIURI **aURI)\n\nNo bug, just very strange style choices. This is fallible but void. On\nfailure it just returns, leaving aURI (hopefully?) untouched. Also:\n\n>  nsAutoString manifestSpec;\n>  docElement->GetAttr(kNameSpaceID_None, nsGkAtoms::manifest, manifestSpec);\n>\n>  // Manifest URIs can't have fragment identifiers.\n>  if (manifestSpec.IsEmpty() ||\n\nDo COM objects always leave the out parameter alone on failure?  I\nthought they generally did but that callers weren't supposed to\nassume.\n\n>  nsContentUtils::NewURIWithDocumentCharset(aURI, manifestSpec,\n>                                            aDocument,\n>                                            aDocument->GetDocBaseURI());\n>}\n\nSame thing here. All it would take to make me happy is change this to\nreturn an nsresult and do normal error checking.\n\nComment on nsContentUtils::CheckSameOrigin:\n> * Checks whether two nodes come from the same origin. aTrustedNode is\n> * considered 'safe' in that a user can operate on it and that it isn't\n> * a js-object that implements nsIDOMNode.\n> * Never call this function with the first node provided by script, it\n> * must always be known to be a 'real' node!\n\nWorking in js/src has convinced me that information like this doesn't belong\nin a comment. XPConnect should provide a way to check this and we should\nassert. Same thing in several other places.\n\n>  // XXXbz should we actually have a Subsumes() check here instead?  Or perhaps\n>  // a separate method for that, with callers using one or the other?\n>  if (NS_FAILED(trustedPrincipal->Equals(unTrustedPrincipal, &equal)) ||\n\nNo bug. If anything we're too strict here. The comment could stand to be\nreplaced with one explaining why this is fine, though.\n\nIn nsContentUtils::CanCallerAccess:\n>  isSystem = NS_FAILED(rv) || isSystem;\n>  const char* capability =\n>    NS_FAILED(rv) || isSystem ? \"UniversalXPConnect\" : \"UniversalBrowserRead\";\n\nThe `isSystem = ` line is redundant, since we then do the\n`NS_FAILED(rv) ||` bit again anyway.\n\nIn nsContentUtils::GetDocumentFromCaller:\n>  JSAutoEnterCompartment ac;\n>  if (!ac.enter(cx, obj)) {\n>    return nsnull;\n>  }\n\nI wonder why GetDocumentFromCaller needs one of these but\nGetDocumentFromContext doesn't.\n\nIn IsCharInSet:\n>  PRUnichar ch;\n>  while ((ch = *aSet)) {\n>    if (aChar == PRUnichar(ch)) {\n\nThe cast is redundant; if we want a cast here at all it belongs on the\nprevious line, where the 8-bit *aSet is being assigned to 16-bit ch.", "attachment_id": null, "author": "jorendorff@mozilla.com"}, {"author": "bzbarsky@mit.edu", "bug_id": 652818, "creator": "bzbarsky@mit.edu", "count": 8, "tags": [], "text": "> including none-too-reassuring stuff like\n\nYeah, that form control state restoration code is sorta broken by design....  Shouldn't be a security issue, though.\n\n> nsContentUtils::ReparentContentWrappersInScope:\n\npeterv's your man.\n\n> nsHTMLDocument::OpenCommon can only be successfully called from script, right?\n\nHmm... more or less, yes.  This didn't use to be the case back in the day.\n\n> then we should use explicit_jscontext and delete all of this.\n\nSold. Want to file?\n\n> Do COM objects always leave the out parameter alone on failure?\n\nNo.  However GetAttr happens to not be fallible.\n\nI think the point is that if manifest processing fails, we want to just do nothing, so things are ok-ish...  Or something.  I agree being more explicit here would be nice.\n\n> XPConnect should provide a way to check this\n\nXPConnect should provide a way to _enforce_ this (i.e. passing random crud as nsIDOMNode should throw).  There are bugs on this.\n\n> I wonder why GetDocumentFromCaller needs one of these but\n> GetDocumentFromContext doesn't.\n\nI _think_ the latter doesn't use any nontrivial JSAPI, unlike GetDocumentFromCaller... but in general when to enter compartments seems like a deep mystery.  :(", "creation_time": "2011-05-19T02:00:51Z", "raw_text": "> including none-too-reassuring stuff like\n\nYeah, that form control state restoration code is sorta broken by design....  Shouldn't be a security issue, though.\n\n> nsContentUtils::ReparentContentWrappersInScope:\n\npeterv's your man.\n\n> nsHTMLDocument::OpenCommon can only be successfully called from script, right?\n\nHmm... more or less, yes.  This didn't use to be the case back in the day.\n\n> then we should use explicit_jscontext and delete all of this.\n\nSold. Want to file?\n\n> Do COM objects always leave the out parameter alone on failure?\n\nNo.  However GetAttr happens to not be fallible.\n\nI think the point is that if manifest processing fails, we want to just do nothing, so things are ok-ish...  Or something.  I agree being more explicit here would be nice.\n\n> XPConnect should provide a way to check this\n\nXPConnect should provide a way to _enforce_ this (i.e. passing random crud as nsIDOMNode should throw).  There are bugs on this.\n\n> I wonder why GetDocumentFromCaller needs one of these but\n> GetDocumentFromContext doesn't.\n\nI _think_ the latter doesn't use any nontrivial JSAPI, unlike GetDocumentFromCaller... but in general when to enter compartments seems like a deep mystery.  :(", "id": 5478982, "attachment_id": null, "time": "2011-05-19T02:00:51Z", "is_private": false}, {"attachment_id": null, "time": "2011-05-19T09:15:30Z", "is_private": false, "author": "peterv@propagandism.org", "tags": [], "creator": "peterv@propagandism.org", "count": 9, "bug_id": 652818, "creation_time": "2011-05-19T09:15:30Z", "text": "(In reply to comment #8)\n> > nsContentUtils::ReparentContentWrappersInScope:\n> \n> peterv's your man.\n\nNot really, but I'll bite. That code was added in bug 321299, so about 5 years ago. There might have been more callers and we didn't have anything like explicit_jscontext, so I'm not really sure what the problem is. The code was written to make sure that we always rewrap, even if getting the context of the document failed. Not rewrapping would have been a security hole. If there's one caller now and we can switch it to explicit_jscontext then by all means let's just file a bug and patch.\n\n(In reply to comment #6)\n> - This is about as sketchy as it gets.\n\nI don't think adding a safety net is sketchy. Rewrapping has always been brittle and a source of security bugs. Rather than leave another potential hole based on conditions that we think shouldn't happen (but aren't sure) we added fallback code. Over the years we've done various changes to make it all more robust, if we now have more tools to do that then let's just fix it.\n\n> - For that matter, why are we trying aOldScope and aNewScope first?\n\nI didn't write this, but my guess is performance. Using the context stack used to be slow. That might also have changed in the meantime.", "id": 5479522, "raw_text": "(In reply to comment #8)\n> > nsContentUtils::ReparentContentWrappersInScope:\n> \n> peterv's your man.\n\nNot really, but I'll bite. That code was added in bug 321299, so about 5 years ago. There might have been more callers and we didn't have anything like explicit_jscontext, so I'm not really sure what the problem is. The code was written to make sure that we always rewrap, even if getting the context of the document failed. Not rewrapping would have been a security hole. If there's one caller now and we can switch it to explicit_jscontext then by all means let's just file a bug and patch.\n\n(In reply to comment #6)\n> - This is about as sketchy as it gets.\n\nI don't think adding a safety net is sketchy. Rewrapping has always been brittle and a source of security bugs. Rather than leave another potential hole based on conditions that we think shouldn't happen (but aren't sure) we added fallback code. Over the years we've done various changes to make it all more robust, if we now have more tools to do that then let's just fix it.\n\n> - For that matter, why are we trying aOldScope and aNewScope first?\n\nI didn't write this, but my guess is performance. Using the context stack used to be slow. That might also have changed in the meantime."}, {"attachment_id": null, "is_private": false, "time": "2011-05-19T09:44:16Z", "author": "jorendorff@mozilla.com", "creation_time": "2011-05-19T09:44:16Z", "text": "(In reply to comment #9)\n> > - This is about as sketchy as it gets.\n> \n> I don't think adding a safety net is sketchy. Rewrapping has always been\n> brittle and a source of security bugs.\n\nWhat bothers me is just that different cx's can have different subject principals and different scope chains (and can be in different compartments), so there's ordinarily just the one correct cx to use for a given task.\n\n> > - For that matter, why are we trying aOldScope and aNewScope first?\n>\n> I didn't write this, but my guess is performance.\n\nOh, ok. explicit_jscontext is quick. Filed bug 658213.", "id": 5479563, "raw_text": "(In reply to comment #9)\n> > - This is about as sketchy as it gets.\n> \n> I don't think adding a safety net is sketchy. Rewrapping has always been\n> brittle and a source of security bugs.\n\nWhat bothers me is just that different cx's can have different subject principals and different scope chains (and can be in different compartments), so there's ordinarily just the one correct cx to use for a given task.\n\n> > - For that matter, why are we trying aOldScope and aNewScope first?\n>\n> I didn't write this, but my guess is performance.\n\nOh, ok. explicit_jscontext is quick. Filed bug 658213.", "count": 10, "creator": "jorendorff@mozilla.com", "tags": [], "bug_id": 652818}, {"creation_time": "2012-03-02T04:53:44Z", "text": "If this audit is complete can we open this up?", "id": 6108488, "raw_text": "If this audit is complete can we open this up?", "count": 11, "creator": "jaas@kflag.net", "tags": [], "bug_id": 652818, "author": "jaas@kflag.net", "is_private": false, "time": "2012-03-02T04:53:44Z", "attachment_id": null}, {"author": "jorendorff@mozilla.com", "attachment_id": null, "text": "Yep. Let's open it up.", "is_private": false, "creation_time": "2012-03-05T19:14:27Z", "raw_text": "Yep. Let's open it up.", "id": 6115021, "bug_id": 652818, "creator": "jorendorff@mozilla.com", "count": 12, "time": "2012-03-05T19:14:27Z", "tags": []}, {"attachment_id": null, "is_private": false, "time": "2018-06-29T04:58:29Z", "author": "bug-husbandry-bot@mozilla.bugs", "id": 13436592, "raw_text": "https://bugzilla.mozilla.org/show_bug.cgi?id=1472046\n\nMove all DOM bugs that haven\u2019t been updated in more than 3 years and has no one currently assigned to P5.\n\nIf you have questions, please contact :mdaly.", "creation_time": "2018-06-29T04:58:29Z", "text": "https://bugzilla.mozilla.org/show_bug.cgi?id=1472046\n\nMove all DOM bugs that haven\u2019t been updated in more than 3 years and has no one currently assigned to P5.\n\nIf you have questions, please contact :mdaly.", "tags": [], "count": 13, "creator": "bug-husbandry-bot@mozilla.bugs", "bug_id": 652818}]}}}