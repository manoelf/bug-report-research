{"comments": {}, "bugs": {"636907": {"comments": [{"text": "SpiderMonkey should provide a debug object with functions providing a safe JavaScript interface to the JSDBGAPI facilities and the debugging hooks. This would be an alternative to JSD, a basis for the future debugging protocol server, and make it easy to test debugging facilities in SM's current JS-based test suite. It will begin life rough and rudimentary, so that we can release early and often as we improve it.\n\nThe debug object should be part of SpiderMonkey itself, not a separate directory like JSD. Embeddings would call something like JS_DefineDebugFunctions to add the debugging functions to their global if desired.\n\nTo avoid dependencies that may might be annoying to embedders, it should be in straight C++, not based on an IDL interface, to permit an idiomatic JS API (using objects the way Object.getOwnPropertyDescriptor does, for example).\n\nThe API should be safe, in that a buggy debugger should not be able to crash SpiderMonkey.\n\nIt should use compartments to enforce the boundary between the debugger and debuggee. It should protect the debugger from the debuggee's getters, setters, and so on; it should prevent the debuggee from referring to the debugger's objects at all; it should prevent the debugger from inserting breakpoints in its own code; and so on.\n\nIt should be nestable: it should support debugging debuggers. Placing debugger and debuggee in separate compartments makes it clear to whom each trap should be reported.\n\nHaving JSDBGAPI functionality available at the JS level will make it easier to test debugging functionality, since it will be testable via ordinary js/src/tests-style tests.\n\nThe initial cut will be as direct as practical a reflection of the existing JSDBGAPI functions and debug hooks, so that we can release early and often. The API will be unstable until we've done more hacking and have a better idea what we want.\n\nDocumentation wiki page here: https://wiki.mozilla.org/Debug_Object", "creator": "jimb@mozilla.com", "id": 5305605, "attachment_id": null, "author": "jimb@mozilla.com", "creation_time": "2011-02-26T01:18:30Z", "time": "2011-02-26T01:18:30Z", "tags": [], "is_private": false, "bug_id": 636907, "raw_text": "SpiderMonkey should provide a debug object with functions providing a safe JavaScript interface to the JSDBGAPI facilities and the debugging hooks. This would be an alternative to JSD, a basis for the future debugging protocol server, and make it easy to test debugging facilities in SM's current JS-based test suite. It will begin life rough and rudimentary, so that we can release early and often as we improve it.\n\nThe debug object should be part of SpiderMonkey itself, not a separate directory like JSD. Embeddings would call something like JS_DefineDebugFunctions to add the debugging functions to their global if desired.\n\nTo avoid dependencies that may might be annoying to embedders, it should be in straight C++, not based on an IDL interface, to permit an idiomatic JS API (using objects the way Object.getOwnPropertyDescriptor does, for example).\n\nThe API should be safe, in that a buggy debugger should not be able to crash SpiderMonkey.\n\nIt should use compartments to enforce the boundary between the debugger and debuggee. It should protect the debugger from the debuggee's getters, setters, and so on; it should prevent the debuggee from referring to the debugger's objects at all; it should prevent the debugger from inserting breakpoints in its own code; and so on.\n\nIt should be nestable: it should support debugging debuggers. Placing debugger and debuggee in separate compartments makes it clear to whom each trap should be reported.\n\nHaving JSDBGAPI functionality available at the JS level will make it easier to test debugging functionality, since it will be testable via ordinary js/src/tests-style tests.\n\nThe initial cut will be as direct as practical a reflection of the existing JSDBGAPI functions and debug hooks, so that we can release early and often. The API will be unstable until we've done more hacking and have a better idea what we want.\n\nDocumentation wiki page here: https://wiki.mozilla.org/Debug_Object", "count": 0}, {"raw_text": "Now in wiki docs: overall Debug object, debug hook descriptions.\n\nThis is all pretty simple, but having the Debug object available in the shell is going to be a big win; already the 'error' hook gets us a way to test error message generation and the decompiler, which people have wanted for a long time.\n\nBeing able to test this stuff from the shell will also be exciting. Debugging is coming in from the cold!", "tags": [], "is_private": false, "creation_time": "2011-03-01T03:57:06Z", "text": "Now in wiki docs: overall Debug object, debug hook descriptions.\n\nThis is all pretty simple, but having the Debug object available in the shell is going to be a big win; already the 'error' hook gets us a way to test error message generation and the decompiler, which people have wanted for a long time.\n\nBeing able to test this stuff from the shell will also be exciting. Debugging is coming in from the cold!", "attachment_id": null, "id": 5310657, "count": 1, "bug_id": 636907, "time": "2011-03-01T03:57:06Z", "author": "jimb@mozilla.com", "creator": "jimb@mozilla.com"}, {"attachment_id": null, "id": 5310874, "creator": "jimb@mozilla.com", "text": "JJB, you mentioned a while back that you wanted the stack passed to every debug hook. The wiki sketch linked to in comment 0 doesn't pass a frame to the script creation and destruction hooks; I understand that you use the stack at that point in Firebug to reconstruct detailed origin information for scripts that are otherwise hard to attribute (appendChild and the like). If some idea like the one suggested in bug 637572 gets implemented, do you still need the stack at newScript and destroyScript?", "author": "jimb@mozilla.com", "creation_time": "2011-03-01T06:19:07Z", "time": "2011-03-01T06:19:07Z", "is_private": false, "tags": [], "raw_text": "JJB, you mentioned a while back that you wanted the stack passed to every debug hook. The wiki sketch linked to in comment 0 doesn't pass a frame to the script creation and destruction hooks; I understand that you use the stack at that point in Firebug to reconstruct detailed origin information for scripts that are otherwise hard to attribute (appendChild and the like). If some idea like the one suggested in bug 637572 gets implemented, do you still need the stack at newScript and destroyScript?", "bug_id": 636907, "count": 2}, {"is_private": false, "tags": [], "time": "2011-03-01T13:30:09Z", "count": 3, "raw_text": "Observation: This sounds an awful lot like jsdb, except without JSD, using compartments instead of runtimes, and present in web content.\n\nDoes this mean that remote debuggers are off the table? If not, how will the remote communicate with the debugger while the debuggee is running?", "bug_id": 636907, "author": "wes@page.ca", "attachment_id": null, "id": 5311349, "creator": "wes@page.ca", "text": "Observation: This sounds an awful lot like jsdb, except without JSD, using compartments instead of runtimes, and present in web content.\n\nDoes this mean that remote debuggers are off the table? If not, how will the remote communicate with the debugger while the debuggee is running?", "creation_time": "2011-03-01T13:30:09Z"}, {"creation_time": "2011-03-02T03:06:15Z", "text": "(In reply to comment #3)\n> Observation: This sounds an awful lot like jsdb, except without JSD, using\n> compartments instead of runtimes, and present in web content.\n\nThanks for reading this over!\n\njsdb includes user interaction stuff; this is just JS-level access to the underlying debug hooks. Yes, it's an alternative to jsd, but single-threaded; lacking the XPConnect dependency; and using compartments to check critical invariants, so we can sanely do things like debugging the debugger. It's meant to be enough to implement the debugging protocol server --- and write tests for the debugging support.\n\n> Does this mean that remote debuggers are off the table? If not, how will the\n> remote communicate with the debugger while the debuggee is running?\n\nNot at all! Remote debugging is where we're headed. This is the bottom layer, on which a server can be written. I want something I can commit soon, play with, and revise, so as a starting point this is just a direct reflection of what's available via JSDBGAPI.\n\nTo keep the communication live while JS runs, I can imagine two kinds of architectures:\n\n- Polling, where the running JS code's operation callback checks the communications channel (socket; pipe; inter-thread thingy) for requests from the client (the debugger UI); or\n\n- Multi-threaded, where a separate thread watches the channel and interrupts the JS thread (using the operation callback stuff, or whatever the latest and greatest asynchronous interference API is).\n\nIn either case, we get to interrupt the debuggee and run debugger JS code, and the Debug object can do its job.\n\nWhat's needed in the Debug object documentation for either of these scenarios is a way to get the debugger JS code the current stack frame of the interrupted code. Ideally it would receive it in a natural way, perhaps via a new hook? I think I need to understand the operation callback API better to do a good job with that.", "id": 5314002, "attachment_id": null, "raw_text": "(In reply to comment #3)\n> Observation: This sounds an awful lot like jsdb, except without JSD, using\n> compartments instead of runtimes, and present in web content.\n\nThanks for reading this over!\n\njsdb includes user interaction stuff; this is just JS-level access to the underlying debug hooks. Yes, it's an alternative to jsd, but single-threaded; lacking the XPConnect dependency; and using compartments to check critical invariants, so we can sanely do things like debugging the debugger. It's meant to be enough to implement the debugging protocol server --- and write tests for the debugging support.\n\n> Does this mean that remote debuggers are off the table? If not, how will the\n> remote communicate with the debugger while the debuggee is running?\n\nNot at all! Remote debugging is where we're headed. This is the bottom layer, on which a server can be written. I want something I can commit soon, play with, and revise, so as a starting point this is just a direct reflection of what's available via JSDBGAPI.\n\nTo keep the communication live while JS runs, I can imagine two kinds of architectures:\n\n- Polling, where the running JS code's operation callback checks the communications channel (socket; pipe; inter-thread thingy) for requests from the client (the debugger UI); or\n\n- Multi-threaded, where a separate thread watches the channel and interrupts the JS thread (using the operation callback stuff, or whatever the latest and greatest asynchronous interference API is).\n\nIn either case, we get to interrupt the debuggee and run debugger JS code, and the Debug object can do its job.\n\nWhat's needed in the Debug object documentation for either of these scenarios is a way to get the debugger JS code the current stack frame of the interrupted code. Ideally it would receive it in a natural way, perhaps via a new hook? I think I need to understand the operation callback API better to do a good job with that.", "tags": [], "is_private": false, "author": "jimb@mozilla.com", "creator": "jimb@mozilla.com", "count": 4, "bug_id": 636907, "time": "2011-03-02T03:06:15Z"}, {"creation_time": "2011-03-02T03:40:22Z", "attachment_id": null, "id": 5314079, "text": "This is exactly the right direction. Threading, remoting, etc. follow, using web technologies (not C++ libraries and OS-specific system calls!).\n\n/be", "creator": "brendan@mozilla.org", "author": "brendan@mozilla.org", "raw_text": "This is exactly the right direction. Threading, remoting, etc. follow, using web technologies (not C++ libraries and OS-specific system calls!).\n\n/be", "bug_id": 636907, "count": 5, "time": "2011-03-02T03:40:22Z", "is_private": false, "tags": []}, {"raw_text": "(In reply to comment #2)\n> JJB, you mentioned a while back that you wanted the stack passed to every debug\n> hook. \n\nThis request is based on the trouble we have with the jsd hooks that do not have stack arguments, onScriptCreated and onError. \n\n> The wiki sketch linked to in comment 0 doesn't pass a frame to the script\n> creation and destruction hooks; \n\nWhy not?\n\n>I understand that you use the stack at that\n> point in Firebug to reconstruct detailed origin information for scripts that\n> are otherwise hard to attribute (appendChild and the like). If some idea like\n> the one suggested in bug 637572 gets implemented, do you still need the stack\n> at newScript and destroyScript?\n\n Stacks are just fundamental to debugging. When you call us, I guess you think about it as a call within a coherent environment and sequence of operations. But our experience is the opposite: we just get a call, \"boom!\" there it is.  We have to infer the environment and operations. The stack is what we need to make sense of the call.", "is_private": false, "tags": [], "creation_time": "2011-03-02T05:17:43Z", "attachment_id": null, "id": 5314266, "text": "(In reply to comment #2)\n> JJB, you mentioned a while back that you wanted the stack passed to every debug\n> hook. \n\nThis request is based on the trouble we have with the jsd hooks that do not have stack arguments, onScriptCreated and onError. \n\n> The wiki sketch linked to in comment 0 doesn't pass a frame to the script\n> creation and destruction hooks; \n\nWhy not?\n\n>I understand that you use the stack at that\n> point in Firebug to reconstruct detailed origin information for scripts that\n> are otherwise hard to attribute (appendChild and the like). If some idea like\n> the one suggested in bug 637572 gets implemented, do you still need the stack\n> at newScript and destroyScript?\n\n Stacks are just fundamental to debugging. When you call us, I guess you think about it as a call within a coherent environment and sequence of operations. But our experience is the opposite: we just get a call, \"boom!\" there it is.  We have to infer the environment and operations. The stack is what we need to make sense of the call.", "bug_id": 636907, "count": 6, "time": "2011-03-02T05:17:43Z", "creator": "johnjbarton@johnjbarton.com", "author": "johnjbarton@johnjbarton.com"}, {"is_private": false, "tags": [], "time": "2011-03-02T05:30:51Z", "count": 7, "raw_text": "(In reply to comment #4)\n...\n> > Does this mean that remote debuggers are off the table? If not, how will the\n> > remote communicate with the debugger while the debuggee is running?\n> \n> Not at all! Remote debugging is where we're headed. This is the bottom layer,\n> on which a server can be written. I want something I can commit soon, play\n> with, and revise, so as a starting point this is just a direct reflection of\n> what's available via JSDBGAPI.\n\nFirebug 1.8 will support at least prototype-quality remote JS debug, and probably production, depending on FF4.0+ schedules. So we're ready to start trying your api as soon as you land it. (1.8a1 ~two weeks).\n\n> \n> To keep the communication live while JS runs, I can imagine two kinds of\n> architectures:\n> \n> - Polling, where the running JS code's operation callback checks the\n> communications channel (socket; pipe; inter-thread thingy) for requests from\n> the client (the debugger UI); or\n> \n> - Multi-threaded, where a separate thread watches the channel and interrupts\n> the JS thread (using the operation callback stuff, or whatever the latest and\n> greatest asynchronous interference API is).\n\nI guess 'event-driven' is half-way in between, with the channel-thread setting a flag that the running JS polls. Anyway, we have socket-based server now, but we also have experience with comet-like servers (holding on to an AJAX request until ready to reply).", "bug_id": 636907, "author": "johnjbarton@johnjbarton.com", "attachment_id": null, "id": 5314289, "text": "(In reply to comment #4)\n...\n> > Does this mean that remote debuggers are off the table? If not, how will the\n> > remote communicate with the debugger while the debuggee is running?\n> \n> Not at all! Remote debugging is where we're headed. This is the bottom layer,\n> on which a server can be written. I want something I can commit soon, play\n> with, and revise, so as a starting point this is just a direct reflection of\n> what's available via JSDBGAPI.\n\nFirebug 1.8 will support at least prototype-quality remote JS debug, and probably production, depending on FF4.0+ schedules. So we're ready to start trying your api as soon as you land it. (1.8a1 ~two weeks).\n\n> \n> To keep the communication live while JS runs, I can imagine two kinds of\n> architectures:\n> \n> - Polling, where the running JS code's operation callback checks the\n> communications channel (socket; pipe; inter-thread thingy) for requests from\n> the client (the debugger UI); or\n> \n> - Multi-threaded, where a separate thread watches the channel and interrupts\n> the JS thread (using the operation callback stuff, or whatever the latest and\n> greatest asynchronous interference API is).\n\nI guess 'event-driven' is half-way in between, with the channel-thread setting a flag that the running JS polls. Anyway, we have socket-based server now, but we also have experience with comet-like servers (holding on to an AJAX request until ready to reply).", "creator": "johnjbarton@johnjbarton.com", "creation_time": "2011-03-02T05:30:51Z"}, {"text": "(In reply to comment #6)\n> (In reply to comment #2)\n> > JJB, you mentioned a while back that you wanted the stack passed to every debug\n> > hook. \n> \n> This request is based on the trouble we have with the jsd hooks that do not\n> have stack arguments, onScriptCreated and onError. \n\nonError (the 'error' hook in the draft API) should clearly receive a stack frame. It's more the script creation and destruction stuff that I'm concerned about.\n\n> > The wiki sketch linked to in comment 0 doesn't pass a frame to the script\n> > creation and destruction hooks; \n> \n> Why not?\n\nPrimarily because the JSDBGAPI's JSDebugHooks members don't, but that's almost a non sequitur. A better argument is that JSScript creation isn't intrinsically related to any particular JS action; if some C++ code calls JS_CompileScript, that may not have anything to do with the top JS stack frame in the context. But see below.\n\n> When you call us, I guess you think\n> about it as a call within a coherent environment and sequence of operations.\n> But our experience is the opposite: we just get a call, \"boom!\" there it is. \n\nThis made me laugh really hard! Poor Firebug! Not sarcastic.\n\n> We have to infer the environment and operations. The stack is what we need to\n> make sense of the call.\n\nFair enough, but for the reason I gave above, whatever information you're inferring from the call stack, I think we should just be handing you directly via script location information; let's continue discussing this in bug 637572.", "id": 5314505, "attachment_id": null, "creation_time": "2011-03-02T08:00:08Z", "tags": [], "is_private": false, "raw_text": "(In reply to comment #6)\n> (In reply to comment #2)\n> > JJB, you mentioned a while back that you wanted the stack passed to every debug\n> > hook. \n> \n> This request is based on the trouble we have with the jsd hooks that do not\n> have stack arguments, onScriptCreated and onError. \n\nonError (the 'error' hook in the draft API) should clearly receive a stack frame. It's more the script creation and destruction stuff that I'm concerned about.\n\n> > The wiki sketch linked to in comment 0 doesn't pass a frame to the script\n> > creation and destruction hooks; \n> \n> Why not?\n\nPrimarily because the JSDBGAPI's JSDebugHooks members don't, but that's almost a non sequitur. A better argument is that JSScript creation isn't intrinsically related to any particular JS action; if some C++ code calls JS_CompileScript, that may not have anything to do with the top JS stack frame in the context. But see below.\n\n> When you call us, I guess you think\n> about it as a call within a coherent environment and sequence of operations.\n> But our experience is the opposite: we just get a call, \"boom!\" there it is. \n\nThis made me laugh really hard! Poor Firebug! Not sarcastic.\n\n> We have to infer the environment and operations. The stack is what we need to\n> make sense of the call.\n\nFair enough, but for the reason I gave above, whatever information you're inferring from the call stack, I think we should just be handing you directly via script location information; let's continue discussing this in bug 637572.", "author": "jimb@mozilla.com", "creator": "jimb@mozilla.com", "time": "2011-03-02T08:00:08Z", "count": 8, "bug_id": 636907}, {"raw_text": "(In reply to comment #7)\n> I guess 'event-driven' is half-way in between, with the channel-thread setting\n> a flag that the running JS polls.\n\nSo the debuggee JS is checking this flag? Depending on the debuggee's cooperation seems sub-optimal; are there cases where this is the best choice available?", "is_private": false, "tags": [], "creation_time": "2011-03-02T09:45:53Z", "id": 5314657, "attachment_id": null, "text": "(In reply to comment #7)\n> I guess 'event-driven' is half-way in between, with the channel-thread setting\n> a flag that the running JS polls.\n\nSo the debuggee JS is checking this flag? Depending on the debuggee's cooperation seems sub-optimal; are there cases where this is the best choice available?", "bug_id": 636907, "count": 9, "time": "2011-03-02T09:45:53Z", "creator": "jimb@mozilla.com", "author": "jimb@mozilla.com"}, {"count": 10, "raw_text": "(In reply to comment #3)\n> Observation: This sounds an awful lot like jsdb, except ... present in web\n> content.\n\nI wanted to address this: I don't think this should be present in web content. It should be added to globals only on request, like CTypes (one calls JS_InitCTypesClass if one wants the ctypes stuff available, as I understand it). The chrome global would have it; the shell global would have it; web globals would not.\n\nThis does raise an important point: debugging a compartment shouldn't magically permit any access that wouldn't otherwise be permitted by the debugger's and debuggee's compartments' relationship.", "bug_id": 636907, "is_private": false, "tags": [], "time": "2011-03-02T10:02:49Z", "creation_time": "2011-03-02T10:02:49Z", "author": "jimb@mozilla.com", "id": 5314690, "attachment_id": null, "text": "(In reply to comment #3)\n> Observation: This sounds an awful lot like jsdb, except ... present in web\n> content.\n\nI wanted to address this: I don't think this should be present in web content. It should be added to globals only on request, like CTypes (one calls JS_InitCTypesClass if one wants the ctypes stuff available, as I understand it). The chrome global would have it; the shell global would have it; web globals would not.\n\nThis does raise an important point: debugging a compartment shouldn't magically permit any access that wouldn't otherwise be permitted by the debugger's and debuggee's compartments' relationship.", "creator": "jimb@mozilla.com"}, {"author": "wes@page.ca", "attachment_id": null, "id": 5315012, "creator": "wes@page.ca", "text": "When I mentioned jsdb above, I was specifically talking about js/jsd/jsdb/jsdrefl.cpp, not the UI written in JavaScript.\n\nFWIW - since it never made it out of CVS, here's a link to my fork if you want to scan it (includes unreviewed patches from timeless) -- http://code.google.com/p/gpsee/source/browse/extras/gsrdb/jsd/jsdb/jsdrefl.cpp\n\nIncidentally, by comparing to jsdb, I never meant to imply that this a bad idea or anything -- just pointing out that there may be opportunities for conceptual re-use.\n\nJSD and jsdb also do not rely on XPConnect -- the only reliance is the way JSD is exposed to browser extensions, the jsdIDebuggerService.idl stuff.  JSD was written, IIUC, to be a high-level abstraction of the JSDBGAPI and then reflected into XPConnect, JavaScript, and Java.\n\nI hadn't considered the operation callback in either scenario you described. That's clever.\n\nWill it be tricky for debugger authors to handle the case where the operation callback interrupts the interpreter mid-statement?  (How does GDB handle getting an async signal mid-statement?)\n\nAs for API -- access to the debugger keyword hook, throw hook, etc, looks friendly. I'll assume \"frame\" carries with it filename and line number information. Does it carry the script object initially passed to the newScript hook?  How does the debugger request relevant source code from the throw/debugger/etc hooks?", "creation_time": "2011-03-02T14:05:27Z", "is_private": false, "tags": [], "time": "2011-03-02T14:05:27Z", "count": 11, "raw_text": "When I mentioned jsdb above, I was specifically talking about js/jsd/jsdb/jsdrefl.cpp, not the UI written in JavaScript.\n\nFWIW - since it never made it out of CVS, here's a link to my fork if you want to scan it (includes unreviewed patches from timeless) -- http://code.google.com/p/gpsee/source/browse/extras/gsrdb/jsd/jsdb/jsdrefl.cpp\n\nIncidentally, by comparing to jsdb, I never meant to imply that this a bad idea or anything -- just pointing out that there may be opportunities for conceptual re-use.\n\nJSD and jsdb also do not rely on XPConnect -- the only reliance is the way JSD is exposed to browser extensions, the jsdIDebuggerService.idl stuff.  JSD was written, IIUC, to be a high-level abstraction of the JSDBGAPI and then reflected into XPConnect, JavaScript, and Java.\n\nI hadn't considered the operation callback in either scenario you described. That's clever.\n\nWill it be tricky for debugger authors to handle the case where the operation callback interrupts the interpreter mid-statement?  (How does GDB handle getting an async signal mid-statement?)\n\nAs for API -- access to the debugger keyword hook, throw hook, etc, looks friendly. I'll assume \"frame\" carries with it filename and line number information. Does it carry the script object initially passed to the newScript hook?  How does the debugger request relevant source code from the throw/debugger/etc hooks?", "bug_id": 636907}, {"creation_time": "2011-03-02T16:17:05Z", "id": 5315313, "attachment_id": null, "text": "(In reply to comment #9)\n> (In reply to comment #7)\n> > I guess 'event-driven' is half-way in between, with the channel-thread setting\n> > a flag that the running JS polls.\n> \n> So the debuggee JS is checking this flag? Depending on the debuggee's\n> cooperation seems sub-optimal; are there cases where this is the best choice\n> available?\n\nSorry I was not clear. In my world, both the debuggee and debugger are JS. The debugger starts socket event handlers and operates on the JS engine to control the debuggee. If a socket packet arrives, the engine passes control to the debugger on the next trip through the event loop which then operates on the JS engine to change the fate of the debuggee. We can use existing event logic for all of this (in fact we do). \n\nAs nice improvement would be a way for the debugger to assert priority when the channel event arrives. This would allow a long running JS event in the debuggee to be paused. Normal JS event process would not allow this.  While the incremental work to support this feature does not seem difficult, but maintaining high performance with threads that share data is difficult. A unidirectional flag written by the channel handler and polled by the engine is all I am suggesting. In fact I was only really trying to paint this as small problem instead of a \"Multi-threading architecture problem\" ;-).", "creator": "johnjbarton@johnjbarton.com", "author": "johnjbarton@johnjbarton.com", "raw_text": "(In reply to comment #9)\n> (In reply to comment #7)\n> > I guess 'event-driven' is half-way in between, with the channel-thread setting\n> > a flag that the running JS polls.\n> \n> So the debuggee JS is checking this flag? Depending on the debuggee's\n> cooperation seems sub-optimal; are there cases where this is the best choice\n> available?\n\nSorry I was not clear. In my world, both the debuggee and debugger are JS. The debugger starts socket event handlers and operates on the JS engine to control the debuggee. If a socket packet arrives, the engine passes control to the debugger on the next trip through the event loop which then operates on the JS engine to change the fate of the debuggee. We can use existing event logic for all of this (in fact we do). \n\nAs nice improvement would be a way for the debugger to assert priority when the channel event arrives. This would allow a long running JS event in the debuggee to be paused. Normal JS event process would not allow this.  While the incremental work to support this feature does not seem difficult, but maintaining high performance with threads that share data is difficult. A unidirectional flag written by the channel handler and polled by the engine is all I am suggesting. In fact I was only really trying to paint this as small problem instead of a \"Multi-threading architecture problem\" ;-).", "bug_id": 636907, "count": 12, "time": "2011-03-02T16:17:05Z", "is_private": false, "tags": []}, {"raw_text": "You know, it might be possible to achieve that behaviour by having the debuggee context yield from the operation callback.", "tags": [], "is_private": false, "creation_time": "2011-03-02T18:20:38Z", "text": "You know, it might be possible to achieve that behaviour by having the debuggee context yield from the operation callback.", "attachment_id": null, "id": 5315710, "count": 13, "bug_id": 636907, "time": "2011-03-02T18:20:38Z", "author": "wes@page.ca", "creator": "wes@page.ca"}, {"creator": "jimb@mozilla.com", "text": "(In reply to comment #12)\n> Sorry I was not clear. In my world, both the debuggee and debugger are JS. The\n> debugger starts socket event handlers and operates on the JS engine to control\n> the debuggee. If a socket packet arrives, the engine passes control to the\n> debugger on the next trip through the event loop which then operates on the JS\n> engine to change the fate of the debuggee. We can use existing event logic for\n> all of this (in fact we do). \n> \n> As nice improvement would be a way for the debugger to assert priority when the\n> channel event arrives. This would allow a long running JS event in the debuggee\n> to be paused. Normal JS event process would not allow this.\n\nI understood that Firebug mostly worked via the event loop; I did not know that Firebug had no way (other than the operation callback) to interrupt long-running JS code. Now that I think about it, it's obvious --- nothing is listening while JS is running.\n\nBut that limitation is definitely something we want to ditch; it may be semi-acceptable for the browser, but it's certainly not okay for other embeddings. The ability to put the channel-watching code in another thread and then use the operation callback is another win for the debuggee-in-separate-thread approach.\n\n> A\n> unidirectional flag written by the channel handler and polled by the engine is\n> all I am suggesting.\n\nThat's exactly what the operation callback is. JS_TriggerOperationCallback simply sets a bit in JSThreadData::interruptFlags.\n\n\n> In fact I was only really trying to paint this as small\n> problem instead of a \"Multi-threading architecture problem\" ;-).\n\nWell, I hope that didn't make things seem more grandiose than they are. But that one little bit of cross-thread communication is critical. See also bug 638038.", "id": 5315789, "attachment_id": null, "author": "jimb@mozilla.com", "creation_time": "2011-03-02T18:38:54Z", "time": "2011-03-02T18:38:54Z", "tags": [], "is_private": false, "bug_id": 636907, "raw_text": "(In reply to comment #12)\n> Sorry I was not clear. In my world, both the debuggee and debugger are JS. The\n> debugger starts socket event handlers and operates on the JS engine to control\n> the debuggee. If a socket packet arrives, the engine passes control to the\n> debugger on the next trip through the event loop which then operates on the JS\n> engine to change the fate of the debuggee. We can use existing event logic for\n> all of this (in fact we do). \n> \n> As nice improvement would be a way for the debugger to assert priority when the\n> channel event arrives. This would allow a long running JS event in the debuggee\n> to be paused. Normal JS event process would not allow this.\n\nI understood that Firebug mostly worked via the event loop; I did not know that Firebug had no way (other than the operation callback) to interrupt long-running JS code. Now that I think about it, it's obvious --- nothing is listening while JS is running.\n\nBut that limitation is definitely something we want to ditch; it may be semi-acceptable for the browser, but it's certainly not okay for other embeddings. The ability to put the channel-watching code in another thread and then use the operation callback is another win for the debuggee-in-separate-thread approach.\n\n> A\n> unidirectional flag written by the channel handler and polled by the engine is\n> all I am suggesting.\n\nThat's exactly what the operation callback is. JS_TriggerOperationCallback simply sets a bit in JSThreadData::interruptFlags.\n\n\n> In fact I was only really trying to paint this as small\n> problem instead of a \"Multi-threading architecture problem\" ;-).\n\nWell, I hope that didn't make things seem more grandiose than they are. But that one little bit of cross-thread communication is critical. See also bug 638038.", "count": 14}, {"creation_time": "2011-03-02T18:48:59Z", "text": "(In reply to comment #11)\n> JSD and jsdb also do not rely on XPConnect -- the only reliance is the way JSD\n> is exposed to browser extensions, the jsdIDebuggerService.idl stuff.  JSD was\n> written, IIUC, to be a high-level abstraction of the JSDBGAPI and then\n> reflected into XPConnect, JavaScript, and Java.\n\nThe difference I was getting at was that JS will be able to get to debugging functionality without XPConnect --- at the moment, it has to go through js/jsd/idl/jsdIDebuggerService.idl, right?\n\n> Will it be tricky for debugger authors to handle the case where the operation\n> callback interrupts the interpreter mid-statement?  (How does GDB handle\n> getting an async signal mid-statement?)\n\nWell, any bytecode can throw an exception, so those states arise now, don't they?\n\n> As for API -- access to the debugger keyword hook, throw hook, etc, looks\n> friendly. I'll assume \"frame\" carries with it filename and line number\n> information.\n\nYes.\n\n> Does it carry the script object initially passed to the newScript\n> hook?\n\nYes.\n\n> How does the debugger request relevant source code from the\n> throw/debugger/etc hooks?\n\nThe hook gets the stack frame; the stack frame provides the script (and possibly the function) it's running; the script provides its origin information --- and, if bug 637572 goes that way, the source code itself will be included in that information (a la V8). Either way, we'll want pretty-printed source accessible.", "creator": "jimb@mozilla.com", "id": 5315833, "attachment_id": null, "author": "jimb@mozilla.com", "bug_id": 636907, "raw_text": "(In reply to comment #11)\n> JSD and jsdb also do not rely on XPConnect -- the only reliance is the way JSD\n> is exposed to browser extensions, the jsdIDebuggerService.idl stuff.  JSD was\n> written, IIUC, to be a high-level abstraction of the JSDBGAPI and then\n> reflected into XPConnect, JavaScript, and Java.\n\nThe difference I was getting at was that JS will be able to get to debugging functionality without XPConnect --- at the moment, it has to go through js/jsd/idl/jsdIDebuggerService.idl, right?\n\n> Will it be tricky for debugger authors to handle the case where the operation\n> callback interrupts the interpreter mid-statement?  (How does GDB handle\n> getting an async signal mid-statement?)\n\nWell, any bytecode can throw an exception, so those states arise now, don't they?\n\n> As for API -- access to the debugger keyword hook, throw hook, etc, looks\n> friendly. I'll assume \"frame\" carries with it filename and line number\n> information.\n\nYes.\n\n> Does it carry the script object initially passed to the newScript\n> hook?\n\nYes.\n\n> How does the debugger request relevant source code from the\n> throw/debugger/etc hooks?\n\nThe hook gets the stack frame; the stack frame provides the script (and possibly the function) it's running; the script provides its origin information --- and, if bug 637572 goes that way, the source code itself will be included in that information (a la V8). Either way, we'll want pretty-printed source accessible.", "count": 15, "time": "2011-03-02T18:48:59Z", "tags": [], "is_private": false}, {"creator": "johnjbarton@johnjbarton.com", "author": "johnjbarton@johnjbarton.com", "time": "2011-03-02T19:55:13Z", "bug_id": 636907, "count": 16, "text": "From https://wiki.mozilla.org/Debug_Object\n>newScript(script, [function])\n>    New code, represented by the Debug.Script instance script, has been loaded\n>into the debuggee's compartment. If the new code is part of a function,\n> function is a Debug.Object reference to the function object. \n\nHow can |new code| not be part of a function?\n\n>enterFrame(frame, call)\n>    The stack frame frame is about to begin executing code. (Naturally, frame \n>is currently the youngest debuggee frame.) If call is true, it is a function \n>call; if call is false, it is global or eval code\n\nIn the false case, I guess you mean the function is what we call the \"outer\" or \"file\" function. That is the function created from the outermost scope in the compilation unit:\n  var x = 1+1; // a statement in the outer most scope of a compilation unit\n  function y() {\n    return x+x;  // statement in the scope of y()\n  };  \n\n> If this hook function returns a function F, SpiderMonkey will call F when  \n> execution of frame completes, passing one argument indicating how it \n> completed. If the argument is of the form { return: value }, then the code \n> completed normally, yielding value. If the argument is of the form { throw: \n> value }, then the code threw value as an exception. In either case, value is \n>a debuggee value. \n\nAs we make deeper call stacks, the debugger enterFrame() function return functions are effectively interleaved with the debuggee frames.\nSo the debugger will probably want to close over the frame given in F, in order to keep track of which \"F\" is running.  That could be harmless and natural... or not.", "id": 5316119, "attachment_id": null, "creation_time": "2011-03-02T19:55:13Z", "tags": [], "is_private": false, "raw_text": "From https://wiki.mozilla.org/Debug_Object\n>newScript(script, [function])\n>    New code, represented by the Debug.Script instance script, has been loaded\n>into the debuggee's compartment. If the new code is part of a function,\n> function is a Debug.Object reference to the function object. \n\nHow can |new code| not be part of a function?\n\n>enterFrame(frame, call)\n>    The stack frame frame is about to begin executing code. (Naturally, frame \n>is currently the youngest debuggee frame.) If call is true, it is a function \n>call; if call is false, it is global or eval code\n\nIn the false case, I guess you mean the function is what we call the \"outer\" or \"file\" function. That is the function created from the outermost scope in the compilation unit:\n  var x = 1+1; // a statement in the outer most scope of a compilation unit\n  function y() {\n    return x+x;  // statement in the scope of y()\n  };  \n\n> If this hook function returns a function F, SpiderMonkey will call F when  \n> execution of frame completes, passing one argument indicating how it \n> completed. If the argument is of the form { return: value }, then the code \n> completed normally, yielding value. If the argument is of the form { throw: \n> value }, then the code threw value as an exception. In either case, value is \n>a debuggee value. \n\nAs we make deeper call stacks, the debugger enterFrame() function return functions are effectively interleaved with the debuggee frames.\nSo the debugger will probably want to close over the frame given in F, in order to keep track of which \"F\" is running.  That could be harmless and natural... or not."}, {"time": "2011-03-04T01:57:09Z", "count": 17, "bug_id": 636907, "author": "jimb@mozilla.com", "creator": "jimb@mozilla.com", "tags": [], "is_private": false, "raw_text": "(In reply to comment #16)\n\nThanks very much for reading this over!\n\n> From https://wiki.mozilla.org/Debug_Object\n> >newScript(script, [function])\n> >    New code, represented by the Debug.Script instance script, has been loaded\n> >into the debuggee's compartment. If the new code is part of a function,\n> > function is a Debug.Object reference to the function object. \n> \n> How can |new code| not be part of a function?\n\nCode passed to indirect eval is evaluated in the global scope. Code for DOM event handlers and top-level <script> code isn't part of any function.\n\n> >enterFrame(frame, call)\n> >    The stack frame frame is about to begin executing code. (Naturally, frame \n> >is currently the youngest debuggee frame.) If call is true, it is a function \n> >call; if call is false, it is global or eval code\n> \n> In the false case, I guess you mean the function is what we call the \"outer\" or\n> \"file\" function. That is the function created from the outermost scope in the\n> compilation unit:\n>   var x = 1+1; // a statement in the outer most scope of a compilation unit\n>   function y() {\n>     return x+x;  // statement in the scope of y()\n>   };  \n\nI'm trying to use ES5 terminology; the standard defines global, eval, and function code in section 10.1.\n\n> > If this hook function returns a function F, SpiderMonkey will call F when  \n> > execution of frame completes, passing one argument indicating how it \n> > completed. If the argument is of the form { return: value }, then the code \n> > completed normally, yielding value. If the argument is of the form { throw: \n> > value }, then the code threw value as an exception. In either case, value is \n> >a debuggee value. \n> \n> As we make deeper call stacks, the debugger enterFrame() function return\n> functions are effectively interleaved with the debuggee frames.\n\nIn a sense --- although the functions the hook returns get called, not returned to. But if you're a Scheme fan, that may not seem like a critical distinction. :)\n\n> So the debugger will probably want to close over the frame given in F, in order\n> to keep track of which \"F\" is running.  That could be harmless and natural...\n> or not.\n\nYes, exactly! There's no need for an explicit mechanism to carry data from entry function to exit function, because the latter just captures whatever data it needs naturally. Since the debugger's Debug.Frame objects are weak references to the debuggee's frames (that is, when the debuggee returns from the frame, it goes away regardless of whether there is a Debug.Frame object referring to it; operations on dead Debug.Frame objects just raise errors), it should be fine for it to get closed over.\n\nDoes this seem like it will introduce problems? I thought it was really neat.", "text": "(In reply to comment #16)\n\nThanks very much for reading this over!\n\n> From https://wiki.mozilla.org/Debug_Object\n> >newScript(script, [function])\n> >    New code, represented by the Debug.Script instance script, has been loaded\n> >into the debuggee's compartment. If the new code is part of a function,\n> > function is a Debug.Object reference to the function object. \n> \n> How can |new code| not be part of a function?\n\nCode passed to indirect eval is evaluated in the global scope. Code for DOM event handlers and top-level <script> code isn't part of any function.\n\n> >enterFrame(frame, call)\n> >    The stack frame frame is about to begin executing code. (Naturally, frame \n> >is currently the youngest debuggee frame.) If call is true, it is a function \n> >call; if call is false, it is global or eval code\n> \n> In the false case, I guess you mean the function is what we call the \"outer\" or\n> \"file\" function. That is the function created from the outermost scope in the\n> compilation unit:\n>   var x = 1+1; // a statement in the outer most scope of a compilation unit\n>   function y() {\n>     return x+x;  // statement in the scope of y()\n>   };  \n\nI'm trying to use ES5 terminology; the standard defines global, eval, and function code in section 10.1.\n\n> > If this hook function returns a function F, SpiderMonkey will call F when  \n> > execution of frame completes, passing one argument indicating how it \n> > completed. If the argument is of the form { return: value }, then the code \n> > completed normally, yielding value. If the argument is of the form { throw: \n> > value }, then the code threw value as an exception. In either case, value is \n> >a debuggee value. \n> \n> As we make deeper call stacks, the debugger enterFrame() function return\n> functions are effectively interleaved with the debuggee frames.\n\nIn a sense --- although the functions the hook returns get called, not returned to. But if you're a Scheme fan, that may not seem like a critical distinction. :)\n\n> So the debugger will probably want to close over the frame given in F, in order\n> to keep track of which \"F\" is running.  That could be harmless and natural...\n> or not.\n\nYes, exactly! There's no need for an explicit mechanism to carry data from entry function to exit function, because the latter just captures whatever data it needs naturally. Since the debugger's Debug.Frame objects are weak references to the debuggee's frames (that is, when the debuggee returns from the frame, it goes away regardless of whether there is a Debug.Frame object referring to it; operations on dead Debug.Frame objects just raise errors), it should be fine for it to get closed over.\n\nDoes this seem like it will introduce problems? I thought it was really neat.", "id": 5320629, "attachment_id": null, "creation_time": "2011-03-04T01:57:09Z"}, {"creator": "johnjbarton@johnjbarton.com", "author": "johnjbarton@johnjbarton.com", "time": "2011-03-04T04:50:23Z", "bug_id": 636907, "count": 18, "id": 5320937, "attachment_id": null, "text": "(In reply to comment #17)\n> (In reply to comment #16)\n> Code for DOM\n> event handlers and top-level <script> code isn't part of any function.\n...\n> I'm trying to use ES5 terminology; the standard defines global, eval, and\n> function code in section 10.1.\n\nThat's great, as far as it goes. (Global unfortunately confusing, devs will think that functions that are properties of the global scope are \"global\"). But in terms of API we want to know if a function-that-isn't-a-function is a browser-generated event handler or a top-level script code.", "creation_time": "2011-03-04T04:50:23Z", "is_private": false, "tags": [], "raw_text": "(In reply to comment #17)\n> (In reply to comment #16)\n> Code for DOM\n> event handlers and top-level <script> code isn't part of any function.\n...\n> I'm trying to use ES5 terminology; the standard defines global, eval, and\n> function code in section 10.1.\n\nThat's great, as far as it goes. (Global unfortunately confusing, devs will think that functions that are properties of the global scope are \"global\"). But in terms of API we want to know if a function-that-isn't-a-function is a browser-generated event handler or a top-level script code."}, {"is_private": false, "tags": [], "time": "2011-03-04T04:53:32Z", "count": 19, "raw_text": "(In reply to comment #17)\n> Does this seem like it will introduce problems? \n\nWe work with jsd now, it's not going to be worse than that ...\n\n> I thought it was really neat.\n\n...so go for it.", "bug_id": 636907, "author": "johnjbarton@johnjbarton.com", "attachment_id": null, "id": 5320938, "text": "(In reply to comment #17)\n> Does this seem like it will introduce problems? \n\nWe work with jsd now, it's not going to be worse than that ...\n\n> I thought it was really neat.\n\n...so go for it.", "creator": "johnjbarton@johnjbarton.com", "creation_time": "2011-03-04T04:53:32Z"}, {"tags": [], "is_private": false, "time": "2011-03-04T04:54:10Z", "count": 20, "bug_id": 636907, "raw_text": "(In reply to comment #17)\n> Code passed to indirect eval is evaluated in the global scope. Code for DOM\n> event handlers and top-level <script> code isn't part of any function.\n\nI believe that DOM event handlers are compiled and run as though the attribute's value were the body of an anonymous function taking one parameter named \"event\".\n\nThe string form of setTimeout will be a case like indirect eval, I think.  javascript: URLs as well.", "author": "shaver@mozilla.org", "text": "(In reply to comment #17)\n> Code passed to indirect eval is evaluated in the global scope. Code for DOM\n> event handlers and top-level <script> code isn't part of any function.\n\nI believe that DOM event handlers are compiled and run as though the attribute's value were the body of an anonymous function taking one parameter named \"event\".\n\nThe string form of setTimeout will be a case like indirect eval, I think.  javascript: URLs as well.", "creator": "shaver@mozilla.org", "attachment_id": null, "id": 5320939, "creation_time": "2011-03-04T04:54:10Z"}, {"is_private": false, "tags": [], "raw_text": "Yes, event handlers are just functions.\n\n  <input onclick=\"foo(event)\" ...>\n\ncompiles to something like\n\n  function onclick(event) { foo(event) }\n\nin the scope of the receiver, named by its 'onclick' property.\n\n/be", "id": 5321002, "attachment_id": null, "text": "Yes, event handlers are just functions.\n\n  <input onclick=\"foo(event)\" ...>\n\ncompiles to something like\n\n  function onclick(event) { foo(event) }\n\nin the scope of the receiver, named by its 'onclick' property.\n\n/be", "creation_time": "2011-03-04T06:09:35Z", "time": "2011-03-04T06:09:35Z", "count": 21, "bug_id": 636907, "author": "brendan@mozilla.org", "creator": "brendan@mozilla.org"}, {"time": "2011-03-04T06:21:54Z", "tags": [], "is_private": false, "bug_id": 636907, "raw_text": "(In reply to comment #18)\n> But\n> in terms of API we want to know if a function-that-isn't-a-function is a\n> browser-generated event handler or a top-level script code.\n\n(In reply to comment #20)\n> The string form of setTimeout will be a case like indirect eval, I think. \n> javascript: URLs as well.\n\n(In reply to comment #21)\n> Yes, event handlers are just functions.\n\nI think all of these cases should be distinguished by getting the frame's script and looking at its origin information (bug 637572).", "count": 22, "text": "(In reply to comment #18)\n> But\n> in terms of API we want to know if a function-that-isn't-a-function is a\n> browser-generated event handler or a top-level script code.\n\n(In reply to comment #20)\n> The string form of setTimeout will be a case like indirect eval, I think. \n> javascript: URLs as well.\n\n(In reply to comment #21)\n> Yes, event handlers are just functions.\n\nI think all of these cases should be distinguished by getting the frame's script and looking at its origin information (bug 637572).", "creator": "jimb@mozilla.com", "id": 5321016, "attachment_id": null, "author": "jimb@mozilla.com", "creation_time": "2011-03-04T06:21:54Z"}, {"time": "2011-03-04T08:14:27Z", "bug_id": 636907, "count": 23, "creator": "jimb@mozilla.com", "author": "jimb@mozilla.com", "tags": [], "is_private": false, "raw_text": "Debug.Frame docs now up on the wiki:\nhttps://wiki.mozilla.org/Debug_Object#Debug.Frame", "text": "Debug.Frame docs now up on the wiki:\nhttps://wiki.mozilla.org/Debug_Object#Debug.Frame", "id": 5321107, "attachment_id": null, "creation_time": "2011-03-04T08:14:27Z"}, {"id": 5324472, "attachment_id": null, "creator": "jimb@mozilla.com", "text": "Debug.Object docs now up on wiki:\nhttps://wiki.mozilla.org/Debug_Object#Debug.Object", "author": "jimb@mozilla.com", "creation_time": "2011-03-05T23:40:39Z", "time": "2011-03-05T23:40:39Z", "is_private": false, "tags": [], "raw_text": "Debug.Object docs now up on wiki:\nhttps://wiki.mozilla.org/Debug_Object#Debug.Object", "bug_id": 636907, "count": 24}, {"author": "jimb@mozilla.com", "creator": "jimb@mozilla.com", "count": 25, "bug_id": 636907, "time": "2011-03-07T19:47:06Z", "creation_time": "2011-03-07T19:47:06Z", "text": "Debug.Script docs now up on wiki:\nhttps://wiki.mozilla.org/Debug_Object#Debug.Script\n\nSo all the major pieces are documented now.\n\nThere are things missing that jsd has:\n- line/bytecode mappings for pretty-printed source\n- watchpoints\n- better cleanup when debugger is turned off\nand I have a list of other issues I want to address. But it's probably time to start coding, and give people something to play with.", "attachment_id": null, "id": 5327882, "raw_text": "Debug.Script docs now up on wiki:\nhttps://wiki.mozilla.org/Debug_Object#Debug.Script\n\nSo all the major pieces are documented now.\n\nThere are things missing that jsd has:\n- line/bytecode mappings for pretty-printed source\n- watchpoints\n- better cleanup when debugger is turned off\nand I have a list of other issues I want to address. But it's probably time to start coding, and give people something to play with.", "tags": [], "is_private": false}, {"count": 26, "bug_id": 636907, "raw_text": "- Added watchpoint API.\n- Debug instances now have an 'enabled' property; setting it to false takes out the instance's debug hooks, breakpoints, and watchpoints.", "tags": [], "is_private": false, "time": "2011-03-08T06:02:47Z", "creation_time": "2011-03-08T06:02:47Z", "author": "jimb@mozilla.com", "text": "- Added watchpoint API.\n- Debug instances now have an 'enabled' property; setting it to false takes out the instance's debug hooks, breakpoints, and watchpoints.", "creator": "jimb@mozilla.com", "attachment_id": null, "id": 5329464}, {"creation_time": "2011-03-14T17:22:49Z", "text": "The Debug.Script api\nhttps://wiki.mozilla.org/Debug_Object#Debug.Script\nuses lines to identify source, but this is not adequate for real systems. Developers often have expressions in statements on a single line that need to be stepped through, especially expressions passed as arguments to functions. Also, lots of code is compressed so the entire script is on one line. Decompile is part of the answer for the compressed case, but that's really for the UI to decide.", "attachment_id": null, "id": 5343510, "raw_text": "The Debug.Script api\nhttps://wiki.mozilla.org/Debug_Object#Debug.Script\nuses lines to identify source, but this is not adequate for real systems. Developers often have expressions in statements on a single line that need to be stepped through, especially expressions passed as arguments to functions. Also, lots of code is compressed so the entire script is on one line. Decompile is part of the answer for the compressed case, but that's really for the UI to decide.", "tags": [], "is_private": false, "author": "johnjbarton@johnjbarton.com", "creator": "johnjbarton@johnjbarton.com", "count": 27, "bug_id": 636907, "time": "2011-03-14T17:22:49Z"}, {"count": 28, "raw_text": "(In reply to comment #27)\n> The Debug.Script api\n> https://wiki.mozilla.org/Debug_Object#Debug.Script\n> uses lines to identify source, but this is not adequate for real systems.\n> Developers often have expressions in statements on a single line that need to\n> be stepped through, especially expressions passed as arguments to functions.\n> Also, lots of code is compressed so the entire script is on one line. Decompile\n> is part of the answer for the compressed case, but that's really for the UI to\n> decide.\n\nYes. As a first cut, we're going to present the functionality JSDBGAPI currently has; the design on the wiki is simply fronting the JSScript we have now. Once that's usable, we'll evolve it. We certainly want column numbers (bug 568142), and the ability to use a pretty-printed source-to-bytecode map (no bug yet).", "bug_id": 636907, "is_private": false, "tags": [], "time": "2011-03-14T22:16:17Z", "creation_time": "2011-03-14T22:16:17Z", "author": "jimb@mozilla.com", "attachment_id": null, "id": 5344485, "text": "(In reply to comment #27)\n> The Debug.Script api\n> https://wiki.mozilla.org/Debug_Object#Debug.Script\n> uses lines to identify source, but this is not adequate for real systems.\n> Developers often have expressions in statements on a single line that need to\n> be stepped through, especially expressions passed as arguments to functions.\n> Also, lots of code is compressed so the entire script is on one line. Decompile\n> is part of the answer for the compressed case, but that's really for the UI to\n> decide.\n\nYes. As a first cut, we're going to present the functionality JSDBGAPI currently has; the design on the wiki is simply fronting the JSScript we have now. Once that's usable, we'll evolve it. We certainly want column numbers (bug 568142), and the ability to use a pretty-printed source-to-bytecode map (no bug yet).", "creator": "jimb@mozilla.com"}, {"author": "jimb@mozilla.com", "creator": "jimb@mozilla.com", "text": "One thing which I've said before but which I should probably emphasize:\n\nWe want to make early versions of this interface available to hackers ASAP, but we want to *evolve* it. So names will change, arguments will change, semantic details will change, types will change, and so on. Because we're doing such a primitive initial cut, we'll value improvements to clarity, detail, and completeness over compatibility when evaluating changes for the initial period.\n\nPerhaps the spec should make the Debug.foo.prototype properties writable, to allow monkey-patching...", "id": 5351124, "attachment_id": null, "creation_time": "2011-03-17T17:39:21Z", "tags": [], "is_private": false, "time": "2011-03-17T17:39:21Z", "count": 29, "bug_id": 636907, "raw_text": "One thing which I've said before but which I should probably emphasize:\n\nWe want to make early versions of this interface available to hackers ASAP, but we want to *evolve* it. So names will change, arguments will change, semantic details will change, types will change, and so on. Because we're doing such a primitive initial cut, we'll value improvements to clarity, detail, and completeness over compatibility when evaluating changes for the initial period.\n\nPerhaps the spec should make the Debug.foo.prototype properties writable, to allow monkey-patching..."}, {"creation_time": "2011-03-17T18:55:02Z", "attachment_id": null, "id": 5351422, "creator": "wes@page.ca", "text": "monkeyPatching += Math.Infinity;", "author": "wes@page.ca", "raw_text": "monkeyPatching += Math.Infinity;", "bug_id": 636907, "count": 30, "time": "2011-03-17T18:55:02Z", "is_private": false, "tags": []}, {"count": 31, "raw_text": "Okay, spec is now monkey-patch friendly; I looked it over and didn't notice any areas where this was going to cause problems.\n\nAlso added frame arguments to a few places that were missing them.", "bug_id": 636907, "is_private": false, "tags": [], "time": "2011-03-19T08:51:36Z", "creation_time": "2011-03-19T08:51:36Z", "author": "jimb@mozilla.com", "attachment_id": null, "id": 5355136, "creator": "jimb@mozilla.com", "text": "Okay, spec is now monkey-patch friendly; I looked it over and didn't notice any areas where this was going to cause problems.\n\nAlso added frame arguments to a few places that were missing them."}, {"author": "johnjbarton@johnjbarton.com", "creator": "johnjbarton@johnjbarton.com", "count": 32, "bug_id": 636907, "time": "2011-03-21T04:16:47Z", "creation_time": "2011-03-21T04:16:47Z", "text": "(In reply to comment #29)\n> One thing which I've said before but which I should probably emphasize:\n> \n> We want to make early versions of this interface available to hackers ASAP, but\n> we want to *evolve* it. So names will change, arguments will change, semantic\n> details will change, types will change, and so on. Because we're doing such a\n> primitive initial cut, we'll value improvements to clarity, detail, and\n> completeness over compatibility when evaluating changes for the initial period.\n\nThis much is not a problem on the Firebug side. But what form might the early versions arrive in? All of our infrastructure relies on Firefox.", "attachment_id": null, "id": 5356643, "raw_text": "(In reply to comment #29)\n> One thing which I've said before but which I should probably emphasize:\n> \n> We want to make early versions of this interface available to hackers ASAP, but\n> we want to *evolve* it. So names will change, arguments will change, semantic\n> details will change, types will change, and so on. Because we're doing such a\n> primitive initial cut, we'll value improvements to clarity, detail, and\n> completeness over compatibility when evaluating changes for the initial period.\n\nThis much is not a problem on the Firebug side. But what form might the early versions arrive in? All of our infrastructure relies on Firefox.", "tags": [], "is_private": false}, {"tags": [], "is_private": false, "raw_text": "(In reply to comment #32)\n> This much is not a problem on the Firebug side. But what form might the early\n> versions arrive in? All of our infrastructure relies on Firefox.\n\nI'm not sure I understand the question, so this may not be helpful:\n\nAt the JSAPI level, there'll be a JS_DefineDebugFunctions(cx, obj) function that adds a definition for Debug to the global object obj. The JavaScript shell will call it unconditionally. In Firefox, I'm not sure how we want to start shipping it; I don't think it should just be turned on, because then we may start getting clients and get locked in. Perhaps it could be enabled by a \"enableDebugObjectWhoseInterfaceIUnderstandIsInFluxAndIAgreeIt'sMyProblemToKeepUp\" preference. :) I don't know; I'd love suggestions.", "text": "(In reply to comment #32)\n> This much is not a problem on the Firebug side. But what form might the early\n> versions arrive in? All of our infrastructure relies on Firefox.\n\nI'm not sure I understand the question, so this may not be helpful:\n\nAt the JSAPI level, there'll be a JS_DefineDebugFunctions(cx, obj) function that adds a definition for Debug to the global object obj. The JavaScript shell will call it unconditionally. In Firefox, I'm not sure how we want to start shipping it; I don't think it should just be turned on, because then we may start getting clients and get locked in. Perhaps it could be enabled by a \"enableDebugObjectWhoseInterfaceIUnderstandIsInFluxAndIAgreeIt'sMyProblemToKeepUp\" preference. :) I don't know; I'd love suggestions.", "id": 5356709, "attachment_id": null, "creation_time": "2011-03-21T06:00:54Z", "time": "2011-03-21T06:00:54Z", "bug_id": 636907, "count": 33, "creator": "jimb@mozilla.com", "author": "jimb@mozilla.com"}, {"raw_text": "In my opinion you should just ship it in Firefox. No one will build a lot of code on Debug with out reading docs or asking questions about the API, at which point the flux will be obvious.", "is_private": false, "tags": [], "creation_time": "2011-03-21T14:54:42Z", "id": 5357116, "attachment_id": null, "text": "In my opinion you should just ship it in Firefox. No one will build a lot of code on Debug with out reading docs or asking questions about the API, at which point the flux will be obvious.", "bug_id": 636907, "count": 34, "time": "2011-03-21T14:54:42Z", "creator": "johnjbarton@johnjbarton.com", "author": "johnjbarton@johnjbarton.com"}, {"author": "wes@page.ca", "id": 5357597, "attachment_id": null, "text": "I agree. There is no reason to make JSDBGAPI any stabler than JSAPI IMO.", "creator": "wes@page.ca", "creation_time": "2011-03-21T17:41:41Z", "is_private": false, "tags": [], "time": "2011-03-21T17:41:41Z", "count": 35, "raw_text": "I agree. There is no reason to make JSDBGAPI any stabler than JSAPI IMO.", "bug_id": 636907}, {"time": "2011-03-21T18:58:01Z", "bug_id": 636907, "count": 36, "creator": "jimb@mozilla.com", "author": "jimb@mozilla.com", "tags": [], "is_private": false, "raw_text": "I'd sure love to get the feedback from users.", "text": "I'd sure love to get the feedback from users.", "id": 5357853, "attachment_id": null, "creation_time": "2011-03-21T18:58:01Z"}, {"creation_time": "2011-03-23T20:15:55Z", "id": 5363571, "attachment_id": null, "text": "Some spec work:\n- Pulled out descriptions of completion and resumption values into their own sections.\n- Added 'evalWithBindings' to Debug.Frame.prototype.\n- Added 'call' and 'apply' methods to Debug.Object.prototype.\n\n(The latter two were added in response to a question about how to do the analogous thing in Archer GDB. It turns out to be very clumsy to evaluate a source code expression using gdb.Value instances one has in Python. You can get values from the debuggee, but there's no way at all to get the values into the debuggee. Now we've avoided making the analagous mistake in the Debug interface.)", "raw_text": "Some spec work:\n- Pulled out descriptions of completion and resumption values into their own sections.\n- Added 'evalWithBindings' to Debug.Frame.prototype.\n- Added 'call' and 'apply' methods to Debug.Object.prototype.\n\n(The latter two were added in response to a question about how to do the analogous thing in Archer GDB. It turns out to be very clumsy to evaluate a source code expression using gdb.Value instances one has in Python. You can get values from the debuggee, but there's no way at all to get the values into the debuggee. Now we've avoided making the analagous mistake in the Debug interface.)", "is_private": false, "tags": [], "creator": "jimb@mozilla.com", "author": "jimb@mozilla.com", "bug_id": 636907, "count": 37, "time": "2011-03-23T20:15:55Z"}, {"time": "2011-03-30T17:25:36Z", "tags": [], "is_private": false, "bug_id": 636907, "raw_text": "More spec work, based on suggestions from Jason Orendorff:\n- Separated scope chain objects out from other objects: Debug.Environment vs. Debug.Object.\n- \"undefined\" is now the resumption value that requests continuing execution normally.\n- More minor monkey-patching friendliness.", "count": 38, "creator": "jimb@mozilla.com", "text": "More spec work, based on suggestions from Jason Orendorff:\n- Separated scope chain objects out from other objects: Debug.Environment vs. Debug.Object.\n- \"undefined\" is now the resumption value that requests continuing execution normally.\n- More minor monkey-patching friendliness.", "attachment_id": null, "id": 5380742, "author": "jimb@mozilla.com", "creation_time": "2011-03-30T17:25:36Z"}]}}}