{"bugs": {"662826": {"comments": [{"creation_time": "2011-06-08T16:43:50Z", "is_private": false, "creator": "jimb@mozilla.com", "tags": [], "attachment_id": null, "id": 5519971, "bug_id": 662826, "text": "This doesn't work, and we shouldn't bother supporting it:\n\njs> var f;\njs> var x = 42;\njs> function g(t) { f = function () { return x; }; evalInFrame(0, t); }\njs> g('')\njs> f()\n42\njs> g('var x = \"local\";')\njs> f()\n42\njs> \n\n(Treat the call to evalInFrame as a stand-in for having the debugger stop after the assignment to f and evaluate the new declaration of x in g's frame using JS_EvaluateUCInStackFrame.)\n\nJS_EvaluateUCInStackFrame promises that the latter will return \"local\". Rather than failing silently, JS_EvaluateUCInStackFrame should raise an error when it cannot do its job correctly.\n\nImplementing the ideal behavior in all cases requires retaining enough information to undo all the def/use analysis the bytecode compiler does, possibly re-instating scope objects that don't exist any more on closures' scope chains, and so on. This is impractical.\n\nTests like js/src/jit-test/tests/jaeger/bug563000/eif-call-newvar.js and js/src/jit-test/tests/jaeger/bug563000/eif-getter-newvar.js actually expect this to always work. I don't believe they cover the problem space very well; they should be removed.\n\nWhere JS_EvaluateUCInStackFrame can do its job --- where a new binding in the given frame would go on the global, say, or where it is a call object that could be extended by calls to eval (or function statements) and across which we must implement the general case variable look up already --- then it should do so. But it shouldn't try to extend call objects that were not known to the bytecode compiler to be extensible.", "count": 0, "author": "jimb@mozilla.com", "raw_text": "This doesn't work, and we shouldn't bother supporting it:\n\njs> var f;\njs> var x = 42;\njs> function g(t) { f = function () { return x; }; evalInFrame(0, t); }\njs> g('')\njs> f()\n42\njs> g('var x = \"local\";')\njs> f()\n42\njs> \n\n(Treat the call to evalInFrame as a stand-in for having the debugger stop after the assignment to f and evaluate the new declaration of x in g's frame using JS_EvaluateUCInStackFrame.)\n\nJS_EvaluateUCInStackFrame promises that the latter will return \"local\". Rather than failing silently, JS_EvaluateUCInStackFrame should raise an error when it cannot do its job correctly.\n\nImplementing the ideal behavior in all cases requires retaining enough information to undo all the def/use analysis the bytecode compiler does, possibly re-instating scope objects that don't exist any more on closures' scope chains, and so on. This is impractical.\n\nTests like js/src/jit-test/tests/jaeger/bug563000/eif-call-newvar.js and js/src/jit-test/tests/jaeger/bug563000/eif-getter-newvar.js actually expect this to always work. I don't believe they cover the problem space very well; they should be removed.\n\nWhere JS_EvaluateUCInStackFrame can do its job --- where a new binding in the given frame would go on the global, say, or where it is a call object that could be extended by calls to eval (or function statements) and across which we must implement the general case variable look up already --- then it should do so. But it shouldn't try to extend call objects that were not known to the bytecode compiler to be extensible.", "time": "2011-06-08T16:43:50Z"}, {"is_private": false, "creation_time": "2011-06-08T16:45:25Z", "id": 5519977, "bug_id": 662826, "count": 1, "text": "*** Bug 662822 has been marked as a duplicate of this bug. ***", "author": "bhackett1024@gmail.com", "creator": "bhackett1024@gmail.com", "tags": [], "raw_text": "", "attachment_id": null, "time": "2011-06-08T16:45:25Z"}]}}, "comments": {}}