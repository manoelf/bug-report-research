{"comments": {}, "bugs": {"699571": {"comments": [{"bug_id": 699571, "tags": [], "is_private": false, "count": 0, "id": 5824769, "text": "Emscripten's translation of memset and memcpy are trivial loops that we should be able to relatively easily recognize and optimize, for a huge performance boost on all Emscripten translated code.", "creator": "terrence.d.cole@gmail.com", "author": "terrence.d.cole@gmail.com", "time": "2011-11-03T21:09:30Z", "attachment_id": null, "creation_time": "2011-11-03T21:09:30Z", "raw_text": "Emscripten's translation of memset and memcpy are trivial loops that we should be able to relatively easily recognize and optimize, for a huge performance boost on all Emscripten translated code."}, {"author": "azakai@mozilla.com", "creator": "azakai@mozilla.com", "attachment_id": null, "time": "2011-11-15T01:54:32Z", "text": "As Terrence pointed out to me, it's also possible to do memcpy using typed array's .set() method (setting a view on the same underlying buffer), basically\n\n  memcpy(dst, src, len)\n\nbecomes\n\n  MEM.set(MEM.subarray(src, src+len), dst)\n\nThis seems slower than a normal loop, though, I guess it hasn't been optimized? Perhaps it would be easier to optimize than a loop, however (make it use memcpy() internally when possible, something like that)?", "creation_time": "2011-11-15T01:54:32Z", "raw_text": "As Terrence pointed out to me, it's also possible to do memcpy using typed array's .set() method (setting a view on the same underlying buffer), basically\n\n  memcpy(dst, src, len)\n\nbecomes\n\n  MEM.set(MEM.subarray(src, src+len), dst)\n\nThis seems slower than a normal loop, though, I guess it hasn't been optimized? Perhaps it would be easier to optimize than a loop, however (make it use memcpy() internally when possible, something like that)?", "bug_id": 699571, "id": 5848418, "tags": [], "is_private": false, "count": 1}, {"bug_id": 699571, "id": 5859204, "count": 2, "is_private": false, "tags": [], "time": "2011-11-18T21:41:18Z", "attachment_id": null, "author": "terrence.d.cole@gmail.com", "text": "I did some micro-benchmark profiling.  For large numbers of tiny memcpy's, the majority of the overhead is in creating the subarray objects.  I think what is going on here is that in order to go into C++ to do the memcpy, we incur a relatively large amount of overhead.  First, C++ calls from the methodjit aren't cheap (we do two here) and second, we have to hit the allocator for our temporary subarray object, which is also not terribly fast.\n\nThe test I ran confirms this:\n\n/* Common preamble */\nvar SIZE = 128 * 1024 * 1024;\nvar COPY_SIZE = ___;\nvar buf = new ArrayBuffer(SIZE);\nvar view = new Uint8Array(buf);\nvar view2 = new Uint8Array(buf);\n/* Test 1 */\nfor (var i = 1; i < SIZE / COPY_SIZE; i++) {\n    var q = view.subarray(i*COPY_SIZE, i+COPY_SIZE);\n    view2.set(q, i * COPY_SIZE - COPY_SIZE);\n}\n/* Test 2 */\nfor (var i = 1; i < SIZE / COPY_SIZE; i++) {\n    for (var j = 0; j < COPY_SIZE; j++) {\n        view2[i * COPY_SIZE - COPY_SIZE + j] = view[i * COPY_SIZE + j];\n    }\n}\n/* *** */\n\nFor COPY_SIZE = 4:\nTypeArray.set: 0m5.262s\nsimple loop:   0m1.741s\n\nFor COPY_SIZE = 1024 * 1024:\nTypeArray.set: 0m0.013s\nsimple loop:   0m1.721s\n\nIn the long run, the right solution here is to teach the jits about typearrays.  In the meantime, Alon, would it be possible to try adding a branch such that we only TypeArray.set when len is large and do the simple loop for small len?  It will take a bit of profiling to find the right tradeoff for the average C program, but this should give immediate wins until we can get a better solution into SM.", "creator": "terrence.d.cole@gmail.com", "raw_text": "I did some micro-benchmark profiling.  For large numbers of tiny memcpy's, the majority of the overhead is in creating the subarray objects.  I think what is going on here is that in order to go into C++ to do the memcpy, we incur a relatively large amount of overhead.  First, C++ calls from the methodjit aren't cheap (we do two here) and second, we have to hit the allocator for our temporary subarray object, which is also not terribly fast.\n\nThe test I ran confirms this:\n\n/* Common preamble */\nvar SIZE = 128 * 1024 * 1024;\nvar COPY_SIZE = ___;\nvar buf = new ArrayBuffer(SIZE);\nvar view = new Uint8Array(buf);\nvar view2 = new Uint8Array(buf);\n/* Test 1 */\nfor (var i = 1; i < SIZE / COPY_SIZE; i++) {\n    var q = view.subarray(i*COPY_SIZE, i+COPY_SIZE);\n    view2.set(q, i * COPY_SIZE - COPY_SIZE);\n}\n/* Test 2 */\nfor (var i = 1; i < SIZE / COPY_SIZE; i++) {\n    for (var j = 0; j < COPY_SIZE; j++) {\n        view2[i * COPY_SIZE - COPY_SIZE + j] = view[i * COPY_SIZE + j];\n    }\n}\n/* *** */\n\nFor COPY_SIZE = 4:\nTypeArray.set: 0m5.262s\nsimple loop:   0m1.741s\n\nFor COPY_SIZE = 1024 * 1024:\nTypeArray.set: 0m0.013s\nsimple loop:   0m1.721s\n\nIn the long run, the right solution here is to teach the jits about typearrays.  In the meantime, Alon, would it be possible to try adding a branch such that we only TypeArray.set when len is large and do the simple loop for small len?  It will take a bit of profiling to find the right tradeoff for the average C program, but this should give immediate wins until we can get a better solution into SM.", "creation_time": "2011-11-18T21:41:18Z"}, {"creator": "azakai@mozilla.com", "author": "azakai@mozilla.com", "text": "Thanks, I tested that, and turns out in the Emscripten benchmark suite it is never beneficial to use TypedArray.set over a simple loop. The biggest memcopies there are less than 100 bytes, I guess that isn't enough to make it worthwhile. This is now an option though, it can be tweaked to whatever works better later on.", "time": "2011-11-22T01:20:18Z", "attachment_id": null, "raw_text": "Thanks, I tested that, and turns out in the Emscripten benchmark suite it is never beneficial to use TypedArray.set over a simple loop. The biggest memcopies there are less than 100 bytes, I guess that isn't enough to make it worthwhile. This is now an option though, it can be tweaked to whatever works better later on.", "creation_time": "2011-11-22T01:20:18Z", "bug_id": 699571, "tags": [], "count": 3, "is_private": false, "id": 5864300}]}}}