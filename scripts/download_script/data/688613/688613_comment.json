{"comments": {}, "bugs": {"688613": {"comments": [{"text": "", "bug_id": 688613, "tags": [], "raw_text": "", "attachment_id": null, "author": "gal@uci.edu", "creation_time": "2011-09-22T21:19:39Z", "time": "2011-09-22T21:19:39Z", "creator": "gal@uci.edu", "id": 5732069, "count": 0, "is_private": false}, {"attachment_id": 561884, "raw_text": "", "bug_id": 688613, "text": "Created attachment 561884\npatch", "tags": [], "is_private": false, "id": 5732071, "count": 1, "creator": "gal@uci.edu", "creation_time": "2011-09-22T21:20:01Z", "time": "2011-09-22T21:20:01Z", "author": "gal@uci.edu"}, {"time": "2011-09-22T21:25:03Z", "creation_time": "2011-09-22T21:25:03Z", "creator": "gal@uci.edu", "bug_id": 688613, "text": "- disable NN filtering and go back to bilinear filtering which gives better results and seems to perform reasonably well (looking for more test cases and devices, but I don't see a performance difference on my Galaxy S 2)\n- use 24-bit surfaces by default, recent devices have 24-bit frame buffers and using 16-bit surfaces isn't any faster best case, and can hit horrible slow paths worst case", "tags": [], "author": "gal@uci.edu", "count": 2, "id": 5732080, "attachment_id": null, "is_private": false, "raw_text": "- disable NN filtering and go back to bilinear filtering which gives better results and seems to perform reasonably well (looking for more test cases and devices, but I don't see a performance difference on my Galaxy S 2)\n- use 24-bit surfaces by default, recent devices have 24-bit frame buffers and using 16-bit surfaces isn't any faster best case, and can hit horrible slow paths worst case"}, {"attachment_id": 561884, "raw_text": "cjones, who is a good reviewer for this?", "tags": [], "bug_id": 688613, "text": "Comment on attachment 561884\npatch\n\ncjones, who is a good reviewer for this?", "count": 3, "id": 5732082, "is_private": false, "time": "2011-09-22T21:25:28Z", "creation_time": "2011-09-22T21:25:28Z", "creator": "gal@uci.edu", "author": "gal@uci.edu"}, {"time": "2011-09-22T22:35:42Z", "creation_time": "2011-09-22T22:35:42Z", "creator": "cjones.bugs@gmail.com", "author": "cjones.bugs@gmail.com", "id": 5732340, "count": 4, "is_private": false, "bug_id": 688613, "text": "I would recommend breaking these into separate patches and requesting\nreview from the author noted in the blame.  If the author can give a\ntestcase where the patch makes a measurable difference, we should\nconsider that against possible quality tradeoff.  If there's no\ntestcase, let's just land it until data says otherwise (and we can add\nregression tests!).\n\n>diff --git a/gfx/layers/Layers.cpp b/gfx/layers/Layers.cpp\n>      useIntermediateSurface = PR_TRUE;   \n>-    } else if (\n>-#ifdef MOZ_GFX_OPTIMIZE_MOBILE\n>-        !contTransform.PreservesAxisAlignedRectangles()) {\n>-#else\n>-        contTransform.HasNonIntegerTranslation()) {\n>-#endif\n>+    } else if (contTransform.HasNonIntegerTranslation()) {\n\nI think this was working around a problem with the way we implemented\nzoom for fennec in the layer tree, which we've fixed.  Pretty sure it\ncan go.\n\n>diff --git a/gfx/layers/ThebesLayerBuffer.cpp b/gfx/layers/ThebesLayerBuffer.cpp\n>@@ -83,21 +83,16 @@ ThebesLayerBuffer::DrawBufferQuadrant(gf\n> \n>-#ifdef MOZ_GFX_OPTIMIZE_MOBILE\n>-  gfxPattern::GraphicsFilter filter = gfxPattern::FILTER_NEAREST;\n>-  pattern->SetFilter(filter);\n>-#endif\n>-\n\nThis is on the critical repaint path in the UI when we're using CPU\ncompositing.  Since this landed, bilinear scaling has been optimized\nin pixman so it might be fast enough (on chips with NEON).  Need data.\n\n>diff --git a/gfx/layers/basic/BasicLayers.cpp b/gfx/layers/basic/BasicLayers.cpp\n>@@ -708,23 +708,21 @@ BasicThebesLayer::PaintThebes(gfxContext\n>-#ifndef MOZ_GFX_OPTIMIZE_MOBILE\n>     gfxMatrix transform;\n>     if (!GetEffectiveTransform().CanDraw2D(&transform) ||\n>         transform.HasNonIntegerTranslation()) {\n>       flags |= ThebesLayerBuffer::PAINT_WILL_RESAMPLE;\n>     }\n>-#endif\n\nI think this is just trying to skip the transform check to avoid dealing with\nfloats, because we always set PAINT_WILL_RESAMPLE on shadowed layers.  We\nshould check HasShadowManager() instead of ifdef hackery.\n\n>diff --git a/gfx/layers/ipc/ShadowLayers.cpp b/gfx/layers/ipc/ShadowLayers.cpp\n> static gfxASurface::gfxImageFormat\n> OptimalFormatFor(gfxASurface::gfxContentType aContent)\n> {\n>   switch (aContent) {\n>   case gfxASurface::CONTENT_COLOR:\n>-#ifdef MOZ_GFX_OPTIMIZE_MOBILE\n>-    return gfxASurface::ImageFormatRGB16_565;\n>-#else\n>     return gfxASurface::ImageFormatRGB24;\n>-#endif\n\nEvidence suggests going to r8g8b8 is likely to be a win on modern HW,\nespecially with GL compositing.  We might need to tune this for older\nHW.  Until we have a good way to check memory bandwidth dynamically\n(i.e. autotune) and a solid perf-measurement infra, I'm fine with\ngoing to 24 bit.\n\n>diff --git a/gfx/layers/opengl/ThebesLayerOGL.cpp b/gfx/layers/opengl/ThebesLayerOGL.cpp\n>@@ -438,25 +438,21 @@ BasicBufferOGL::BeginPaint(ContentType a\n>     if (mode == Layer::SURFACE_COMPONENT_ALPHA) {\n>-#ifdef MOZ_GFX_OPTIMIZE_MOBILE\n>-      mode = Layer::SURFACE_SINGLE_CHANNEL_ALPHA;\n>-#else\n\nI don't understand what this is doing.\n\n>@@ -745,26 +741,24 @@ ThebesLayerOGL::RenderLayer(int aPreviou\n>   PRUint32 flags = 0;\n>-#ifndef MOZ_GFX_OPTIMIZE_MOBILE\n>   gfxMatrix transform2d;\n>   if (GetEffectiveTransform().Is2D(&transform2d)) {\n>     if (transform2d.HasNonIntegerTranslation()) {\n>       flags |= ThebesLayerBufferOGL::PAINT_WILL_RESAMPLE;\n>     }\n>   } else {\n>     flags |= ThebesLayerBufferOGL::PAINT_WILL_RESAMPLE;\n>   }\n>-#endif\n\nSame hack as in BasicThebesLayer::PaintThebes.\n\n>diff --git a/layout/base/nsLayoutUtils.cpp b/layout/base/nsLayoutUtils.cpp\n>   PRBool ignoreScale = PR_FALSE;\n>-#ifdef MOZ_GFX_OPTIMIZE_MOBILE\n>-  ignoreScale = PR_TRUE;\n>-#endif\n\nI don't understand that one well enough to comment.\n\n>diff --git a/layout/base/nsPresShell.cpp b/layout/base/nsPresShell.cpp\n>@@ -4405,21 +4405,17 @@ PresShell::RenderDocument(const nsRect& \n>   aThebesContext->NewPath();\n>-#ifdef MOZ_GFX_OPTIMIZE_MOBILE\n>-  aThebesContext->Rectangle(r, PR_TRUE);\n>-#else\n>   aThebesContext->Rectangle(r);\n>-#endif\n> \n\nThis used to be on the critical repaint path with the tilecanvas\nfrontend, but we don't really care about this anymore.  I think this\nwould have caused seaming anyway in that frontend.\n\n>diff --git a/layout/generic/nsObjectFrame.cpp b/layout/generic/nsObjectFrame.cpp\n>@@ -1628,22 +1628,16 @@ nsObjectFrame::BuildLayer(nsDisplayListB\n>-#ifdef MOZ_GFX_OPTIMIZE_MOBILE\n>-    if (!aManager->IsCompositingCheap()) {\n>-      // Pixman just horrible with bilinear filter scaling\n>-      filter = gfxPattern::FILTER_NEAREST;\n>-    }\n>-#endif\n\nPretty sure the NEON optimizations landed after this was pushed.  Need\ndata.  We don't really care about this on android either way atm,\nthough with dougt's/blassey's stuff we might soon.", "tags": [], "attachment_id": null, "raw_text": "I would recommend breaking these into separate patches and requesting\nreview from the author noted in the blame.  If the author can give a\ntestcase where the patch makes a measurable difference, we should\nconsider that against possible quality tradeoff.  If there's no\ntestcase, let's just land it until data says otherwise (and we can add\nregression tests!).\n\n>diff --git a/gfx/layers/Layers.cpp b/gfx/layers/Layers.cpp\n>      useIntermediateSurface = PR_TRUE;   \n>-    } else if (\n>-#ifdef MOZ_GFX_OPTIMIZE_MOBILE\n>-        !contTransform.PreservesAxisAlignedRectangles()) {\n>-#else\n>-        contTransform.HasNonIntegerTranslation()) {\n>-#endif\n>+    } else if (contTransform.HasNonIntegerTranslation()) {\n\nI think this was working around a problem with the way we implemented\nzoom for fennec in the layer tree, which we've fixed.  Pretty sure it\ncan go.\n\n>diff --git a/gfx/layers/ThebesLayerBuffer.cpp b/gfx/layers/ThebesLayerBuffer.cpp\n>@@ -83,21 +83,16 @@ ThebesLayerBuffer::DrawBufferQuadrant(gf\n> \n>-#ifdef MOZ_GFX_OPTIMIZE_MOBILE\n>-  gfxPattern::GraphicsFilter filter = gfxPattern::FILTER_NEAREST;\n>-  pattern->SetFilter(filter);\n>-#endif\n>-\n\nThis is on the critical repaint path in the UI when we're using CPU\ncompositing.  Since this landed, bilinear scaling has been optimized\nin pixman so it might be fast enough (on chips with NEON).  Need data.\n\n>diff --git a/gfx/layers/basic/BasicLayers.cpp b/gfx/layers/basic/BasicLayers.cpp\n>@@ -708,23 +708,21 @@ BasicThebesLayer::PaintThebes(gfxContext\n>-#ifndef MOZ_GFX_OPTIMIZE_MOBILE\n>     gfxMatrix transform;\n>     if (!GetEffectiveTransform().CanDraw2D(&transform) ||\n>         transform.HasNonIntegerTranslation()) {\n>       flags |= ThebesLayerBuffer::PAINT_WILL_RESAMPLE;\n>     }\n>-#endif\n\nI think this is just trying to skip the transform check to avoid dealing with\nfloats, because we always set PAINT_WILL_RESAMPLE on shadowed layers.  We\nshould check HasShadowManager() instead of ifdef hackery.\n\n>diff --git a/gfx/layers/ipc/ShadowLayers.cpp b/gfx/layers/ipc/ShadowLayers.cpp\n> static gfxASurface::gfxImageFormat\n> OptimalFormatFor(gfxASurface::gfxContentType aContent)\n> {\n>   switch (aContent) {\n>   case gfxASurface::CONTENT_COLOR:\n>-#ifdef MOZ_GFX_OPTIMIZE_MOBILE\n>-    return gfxASurface::ImageFormatRGB16_565;\n>-#else\n>     return gfxASurface::ImageFormatRGB24;\n>-#endif\n\nEvidence suggests going to r8g8b8 is likely to be a win on modern HW,\nespecially with GL compositing.  We might need to tune this for older\nHW.  Until we have a good way to check memory bandwidth dynamically\n(i.e. autotune) and a solid perf-measurement infra, I'm fine with\ngoing to 24 bit.\n\n>diff --git a/gfx/layers/opengl/ThebesLayerOGL.cpp b/gfx/layers/opengl/ThebesLayerOGL.cpp\n>@@ -438,25 +438,21 @@ BasicBufferOGL::BeginPaint(ContentType a\n>     if (mode == Layer::SURFACE_COMPONENT_ALPHA) {\n>-#ifdef MOZ_GFX_OPTIMIZE_MOBILE\n>-      mode = Layer::SURFACE_SINGLE_CHANNEL_ALPHA;\n>-#else\n\nI don't understand what this is doing.\n\n>@@ -745,26 +741,24 @@ ThebesLayerOGL::RenderLayer(int aPreviou\n>   PRUint32 flags = 0;\n>-#ifndef MOZ_GFX_OPTIMIZE_MOBILE\n>   gfxMatrix transform2d;\n>   if (GetEffectiveTransform().Is2D(&transform2d)) {\n>     if (transform2d.HasNonIntegerTranslation()) {\n>       flags |= ThebesLayerBufferOGL::PAINT_WILL_RESAMPLE;\n>     }\n>   } else {\n>     flags |= ThebesLayerBufferOGL::PAINT_WILL_RESAMPLE;\n>   }\n>-#endif\n\nSame hack as in BasicThebesLayer::PaintThebes.\n\n>diff --git a/layout/base/nsLayoutUtils.cpp b/layout/base/nsLayoutUtils.cpp\n>   PRBool ignoreScale = PR_FALSE;\n>-#ifdef MOZ_GFX_OPTIMIZE_MOBILE\n>-  ignoreScale = PR_TRUE;\n>-#endif\n\nI don't understand that one well enough to comment.\n\n>diff --git a/layout/base/nsPresShell.cpp b/layout/base/nsPresShell.cpp\n>@@ -4405,21 +4405,17 @@ PresShell::RenderDocument(const nsRect& \n>   aThebesContext->NewPath();\n>-#ifdef MOZ_GFX_OPTIMIZE_MOBILE\n>-  aThebesContext->Rectangle(r, PR_TRUE);\n>-#else\n>   aThebesContext->Rectangle(r);\n>-#endif\n> \n\nThis used to be on the critical repaint path with the tilecanvas\nfrontend, but we don't really care about this anymore.  I think this\nwould have caused seaming anyway in that frontend.\n\n>diff --git a/layout/generic/nsObjectFrame.cpp b/layout/generic/nsObjectFrame.cpp\n>@@ -1628,22 +1628,16 @@ nsObjectFrame::BuildLayer(nsDisplayListB\n>-#ifdef MOZ_GFX_OPTIMIZE_MOBILE\n>-    if (!aManager->IsCompositingCheap()) {\n>-      // Pixman just horrible with bilinear filter scaling\n>-      filter = gfxPattern::FILTER_NEAREST;\n>-    }\n>-#endif\n\nPretty sure the NEON optimizations landed after this was pushed.  Need\ndata.  We don't really care about this on android either way atm,\nthough with dougt's/blassey's stuff we might soon."}, {"attachment_id": null, "raw_text": "(In reply to Chris Jones [:cjones] [:warhammer] from comment #4)\n> I would recommend breaking these into separate patches and requesting\n> review from the author noted in the blame.  If the author can give a\n> testcase where the patch makes a measurable difference, we should\n> consider that against possible quality tradeoff.  If there's no\n> testcase, let's just land it until data says otherwise (and we can add\n> regression tests!).\n\nI agree with this", "bug_id": 688613, "text": "(In reply to Chris Jones [:cjones] [:warhammer] from comment #4)\n> I would recommend breaking these into separate patches and requesting\n> review from the author noted in the blame.  If the author can give a\n> testcase where the patch makes a measurable difference, we should\n> consider that against possible quality tradeoff.  If there's no\n> testcase, let's just land it until data says otherwise (and we can add\n> regression tests!).\n\nI agree with this", "tags": [], "id": 5733886, "count": 5, "is_private": false, "creation_time": "2011-09-23T17:06:02Z", "time": "2011-09-23T17:06:02Z", "creator": "lassey@chromium.org", "author": "lassey@chromium.org"}, {"is_private": false, "id": 5733918, "count": 6, "author": "gal@uci.edu", "creator": "gal@uci.edu", "creation_time": "2011-09-23T17:13:06Z", "time": "2011-09-23T17:13:06Z", "raw_text": "Sounds easy enough, will do", "attachment_id": null, "tags": [], "bug_id": 688613, "text": "Sounds easy enough, will do"}, {"creator": "cjones.bugs@gmail.com", "creation_time": "2011-09-24T00:29:16Z", "time": "2011-09-24T00:29:16Z", "author": "cjones.bugs@gmail.com", "is_private": false, "count": 7, "id": 5734884, "bug_id": 688613, "text": "(In reply to Chris Jones [:cjones] [:warhammer] from comment #4)\n> >diff --git a/gfx/layers/basic/BasicLayers.cpp b/gfx/layers/basic/BasicLayers.cpp\n> >@@ -708,23 +708,21 @@ BasicThebesLayer::PaintThebes(gfxContext\n> >-#ifndef MOZ_GFX_OPTIMIZE_MOBILE\n> >     gfxMatrix transform;\n> >     if (!GetEffectiveTransform().CanDraw2D(&transform) ||\n> >         transform.HasNonIntegerTranslation()) {\n> >       flags |= ThebesLayerBuffer::PAINT_WILL_RESAMPLE;\n> >     }\n> >-#endif\n> \n\nLooking back over bug 634759 reminded me what's going on here.  We have an optimization in which we can \"rotate\" a buffer when repainting part of it after scrolling, instead of moving all the pixels.  Then when drawing, we \"unrotate\" the buffer by blitting the rotated parts to where they're supposed to be.  This can cause issues when the buffer is painted with a scale transform because we'll resample across the rotation boundaries, causing artifacts.\n\nThe decision in bug 634759 was to live with these artifacts since they'll be temporary (the next content repaint after the zoom will eliminate them).  It's very easy to find tests where this makes a difference.  I'm not a big fan of the ifdef but it's not a big deal either.\n\nWe should definitely add a comment here.", "tags": [], "attachment_id": null, "raw_text": "(In reply to Chris Jones [:cjones] [:warhammer] from comment #4)\n> >diff --git a/gfx/layers/basic/BasicLayers.cpp b/gfx/layers/basic/BasicLayers.cpp\n> >@@ -708,23 +708,21 @@ BasicThebesLayer::PaintThebes(gfxContext\n> >-#ifndef MOZ_GFX_OPTIMIZE_MOBILE\n> >     gfxMatrix transform;\n> >     if (!GetEffectiveTransform().CanDraw2D(&transform) ||\n> >         transform.HasNonIntegerTranslation()) {\n> >       flags |= ThebesLayerBuffer::PAINT_WILL_RESAMPLE;\n> >     }\n> >-#endif\n> \n\nLooking back over bug 634759 reminded me what's going on here.  We have an optimization in which we can \"rotate\" a buffer when repainting part of it after scrolling, instead of moving all the pixels.  Then when drawing, we \"unrotate\" the buffer by blitting the rotated parts to where they're supposed to be.  This can cause issues when the buffer is painted with a scale transform because we'll resample across the rotation boundaries, causing artifacts.\n\nThe decision in bug 634759 was to live with these artifacts since they'll be temporary (the next content repaint after the zoom will eliminate them).  It's very easy to find tests where this makes a difference.  I'm not a big fan of the ifdef but it's not a big deal either.\n\nWe should definitely add a comment here."}]}}}