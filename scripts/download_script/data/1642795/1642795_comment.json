{"comments": {}, "bugs": {"1642795": {"comments": [{"raw_text": "People who have used OpenPGP in the past and who migrate to the new OpenPGP code, will probably have verified some keys of other people. The usual mechanism to remember the verification is to use your own secret key to sign/certify that public key.\n\nCurrently, we won't accept those keys automatically, they are treated as \"undecided\".\n\nThis bug suggests to enhance our implementation in the following way:\n\nIf we need to know the acceptance status of a public key, and the key is still in the \"undecided\" state, then perform an analysis of the certifications.\n\nFor each certification, check if it was made by any of the (still valid) secret keys that the local user has locally available. If yes, and the signature is valid, then treat the public key as \"verified\".\n\nBecause this is an expensive operation, we may cache the user's acceptance decision (in our sqlite table that's used to remember the user's acceptance decision).\n\nOnce this is discovered, we probably shouldn't allow the user to mark the key as \"undecided\" or \"unverified\" any longer. We might still allow the user to make the key as \"rejected\" (and figure out what action we should perform on the old key signature).\n\nIt seems this is a very important functionality for anyone migrating.", "time": "2020-06-02T22:02:44Z", "author": "kaie@kuix.de", "is_private": false, "count": 0, "bug_id": 1642795, "tags": [], "creation_time": "2020-06-02T22:02:44Z", "attachment_id": null, "creator": "kaie@kuix.de", "id": 14859268, "text": "People who have used OpenPGP in the past and who migrate to the new OpenPGP code, will probably have verified some keys of other people. The usual mechanism to remember the verification is to use your own secret key to sign/certify that public key.\n\nCurrently, we won't accept those keys automatically, they are treated as \"undecided\".\n\nThis bug suggests to enhance our implementation in the following way:\n\nIf we need to know the acceptance status of a public key, and the key is still in the \"undecided\" state, then perform an analysis of the certifications.\n\nFor each certification, check if it was made by any of the (still valid) secret keys that the local user has locally available. If yes, and the signature is valid, then treat the public key as \"verified\".\n\nBecause this is an expensive operation, we may cache the user's acceptance decision (in our sqlite table that's used to remember the user's acceptance decision).\n\nOnce this is discovered, we probably shouldn't allow the user to mark the key as \"undecided\" or \"unverified\" any longer. We might still allow the user to make the key as \"rejected\" (and figure out what action we should perform on the old key signature).\n\nIt seems this is a very important functionality for anyone migrating."}, {"is_private": false, "count": 1, "bug_id": 1642795, "tags": [], "author": "kaie@kuix.de", "time": "2020-06-03T11:53:22Z", "raw_text": "It's necessary to mention a complication and we need to decide how to handle it.\n\nYou don't sign someone public key's. Rather, you sign someone's user ID that's associated to a public key.\nA public key can have multiple user IDs attached, with different email addresses.\n\nExample: Bob's key has two email addresses, bob@corp.example.com and bob@fun.example.org\nWhen Alice signed Bob's key, she might have signed the corp address, but did not sign the fun address.\n\nThere are several reasons why Alice might have signed only one key.\n* Bob might have asked for the corp address to be signed, but didn't ask for the fun address\n* Alice might have decided she doesn't know if the fun address really belongs to Bob\n* At the time Alice signed the key, the key might not yet have contained the fun address, Bob might have added that user ID later\n\nIn this example, which email addresses should Thunderbird treat as accepted?\nIf we decide to accept the corp address, only, then we might need a more complex user interface for the key acceptance.\n\nToday, the key details and acceptance dialog uses a simplified approach.\nWhen viewing a key, we show all email addresses in a list, and ask to decide.\nIf the user accepts the key, then we remember that for all email addresses that are currently shown.\n\nIf the key gets updated (a more recent version of the key is imported), user IDs might have been removed or added.\nIf a key was removed, our code already handles that - we no longer treat removed keys as accepted.\nIf a new key was added, then we don't accept that key yet.\n\nHowever, our user interface will not show that yet.\n\nRather, today's UI will show the overall acceptance status for the key's fingerprint, and will not show the status for the individual email addresses.\nToday, if the user confirms the new dialog (e.g. keeping an existing \"yes\" choice), we will update the set of accepted email addresses to include any new addresses.\n\nLet's look at the scenarios in detail:\n\n(1)\nWe have the simple scenario, which will cover many users:\n- the foreign public key has only one user ID\n- the single foreign user ID is signed by the local user\n\nWe can automatically accept the signed user ID and disable choices for \"undecided\" and \"unverified\".\n\n(2)\nThe foreign public key has multiple IDs / email addresses, but all of them have been signed by the local user.\n\nWe can treat this identically to scenario (1).\n\n(3)\nThe foreign public key has multiple IDs / email addresses, but only a subset has been signed by the local user.\n\nCan we find a reasonable strategy to handle this in a simplified way?", "text": "It's necessary to mention a complication and we need to decide how to handle it.\n\nYou don't sign someone public key's. Rather, you sign someone's user ID that's associated to a public key.\nA public key can have multiple user IDs attached, with different email addresses.\n\nExample: Bob's key has two email addresses, bob@corp.example.com and bob@fun.example.org\nWhen Alice signed Bob's key, she might have signed the corp address, but did not sign the fun address.\n\nThere are several reasons why Alice might have signed only one key.\n* Bob might have asked for the corp address to be signed, but didn't ask for the fun address\n* Alice might have decided she doesn't know if the fun address really belongs to Bob\n* At the time Alice signed the key, the key might not yet have contained the fun address, Bob might have added that user ID later\n\nIn this example, which email addresses should Thunderbird treat as accepted?\nIf we decide to accept the corp address, only, then we might need a more complex user interface for the key acceptance.\n\nToday, the key details and acceptance dialog uses a simplified approach.\nWhen viewing a key, we show all email addresses in a list, and ask to decide.\nIf the user accepts the key, then we remember that for all email addresses that are currently shown.\n\nIf the key gets updated (a more recent version of the key is imported), user IDs might have been removed or added.\nIf a key was removed, our code already handles that - we no longer treat removed keys as accepted.\nIf a new key was added, then we don't accept that key yet.\n\nHowever, our user interface will not show that yet.\n\nRather, today's UI will show the overall acceptance status for the key's fingerprint, and will not show the status for the individual email addresses.\nToday, if the user confirms the new dialog (e.g. keeping an existing \"yes\" choice), we will update the set of accepted email addresses to include any new addresses.\n\nLet's look at the scenarios in detail:\n\n(1)\nWe have the simple scenario, which will cover many users:\n- the foreign public key has only one user ID\n- the single foreign user ID is signed by the local user\n\nWe can automatically accept the signed user ID and disable choices for \"undecided\" and \"unverified\".\n\n(2)\nThe foreign public key has multiple IDs / email addresses, but all of them have been signed by the local user.\n\nWe can treat this identically to scenario (1).\n\n(3)\nThe foreign public key has multiple IDs / email addresses, but only a subset has been signed by the local user.\n\nCan we find a reasonable strategy to handle this in a simplified way?", "id": 14860279, "attachment_id": null, "creator": "kaie@kuix.de", "creation_time": "2020-06-03T11:53:22Z"}, {"raw_text": "(In reply to Kai Engert (:KaiE:) from comment #1)\n> (3)\n> The foreign public key has multiple IDs / email addresses, but only a subset has been signed by the local user.\n> Can we find a reasonable strategy to handle this in a simplified way?\n\nI suggest the following (initial) strategy:\n\nWe accept all signed/certified email addresses as accepted/verified.\nAll other emails listed in this key are treated as \"undecided\".\n\nIn the key details dialog, we append something to each user ID string shown, like [certified by yourself].\nIn the lower area, in the \"your acceptance\" tab, we don't show the usual radio buttons.\nInstead, we show a special text:\n\"You have certified some of the user IDs contained in this key, as indicated above. The certificated email addresses will be treated as accepted and verified. The remaining email addresses will be treated as not accepted.\"\n\nThe idea is, state that we currently have a limitation. Potentially, we could have a more advanced UI for this in the future. I'm hoping this scenario is rare.", "time": "2020-06-03T16:39:22Z", "author": "kaie@kuix.de", "count": 2, "is_private": false, "tags": [], "bug_id": 1642795, "creation_time": "2020-06-03T16:39:22Z", "creator": "kaie@kuix.de", "attachment_id": null, "id": 14860907, "text": "(In reply to Kai Engert (:KaiE:) from comment #1)\n> (3)\n> The foreign public key has multiple IDs / email addresses, but only a subset has been signed by the local user.\n> Can we find a reasonable strategy to handle this in a simplified way?\n\nI suggest the following (initial) strategy:\n\nWe accept all signed/certified email addresses as accepted/verified.\nAll other emails listed in this key are treated as \"undecided\".\n\nIn the key details dialog, we append something to each user ID string shown, like [certified by yourself].\nIn the lower area, in the \"your acceptance\" tab, we don't show the usual radio buttons.\nInstead, we show a special text:\n\"You have certified some of the user IDs contained in this key, as indicated above. The certificated email addresses will be treated as accepted and verified. The remaining email addresses will be treated as not accepted.\"\n\nThe idea is, state that we currently have a limitation. Potentially, we could have a more advanced UI for this in the future. I'm hoping this scenario is rare."}, {"text": "I think we'll need to migrate GnuPG's ownertrust setting for secret keys, at least partially.\n\nI was thinking about how to implement this bug.\n\nShould we really trust all signatures that were made by any secret key the user has in possession?\nIt seems we shouldn't, because it could allow an attack vector.\n\nLet's assume Eve wants to trick Alice. Eve wants to read the encrypted emails that Alice sends to Bob.\nTo achieve that, Eve sends a fake key to Alice, which contains Bob's email.\n\nUsually Alice wouldn't accept that fake key (not automatically).\n\nHowever, Eve could create a new secret key, with an arbitrary user ID, let's say in the name of Charlie.\nEve uses the fake Charlie key to sign the fake Bob key.\n\nNow Eve sends the two fake keys to Alice:\n* the fake public key for Bob, signed by the Charlie key\n* the fake secret key for Charlie\n\nEve might be willing to import both keys, and might not notice that she is importing a secret key (in Charlie's name).\n\nIf we automatically trusted all signatures made by any owned secret keys, then the presence of the fake Charlie key would have the result of automatically trusting the fake Bob key as accepted.\n\nIt shouldn't be possible to trick Alice simply by getting her to import a secret key.\n\nHow should we prevent that?\n\nI tried this attack with GnuPG. Apparently, when GnuPG created a secret key locally, it is set to ultimate ownertrust.\nHowever, if a secret key is imported that was created elsewhere, the key isn't marked as ultimately, it's marked with an unknown trust level.\n\nEven if I export an ultimately trusted secret key, and then restore it into a fresh keyring, the secret key is no longer ultimately trusted.\n\nSo, GnuPG doesn't fall for this potential attack scenario. Rather, GnuPG (apparently) requires that a secret key is marked as \"trusted to sign other keys\".\n\nI think we must do something similar in TB, and allow the user to configure which of the user's own secret keys are trusted to sign and thereby automatically accept the public keys of other people.\n\nIf my thoughts make sense, and we agree this trust attribute for secret keys is required, then a migration from GnuPG should also import those existing trust attributes.", "id": 14872381, "creation_time": "2020-06-09T17:11:09Z", "attachment_id": null, "creator": "kaie@kuix.de", "author": "kaie@kuix.de", "count": 3, "is_private": false, "bug_id": 1642795, "tags": [], "raw_text": "I think we'll need to migrate GnuPG's ownertrust setting for secret keys, at least partially.\n\nI was thinking about how to implement this bug.\n\nShould we really trust all signatures that were made by any secret key the user has in possession?\nIt seems we shouldn't, because it could allow an attack vector.\n\nLet's assume Eve wants to trick Alice. Eve wants to read the encrypted emails that Alice sends to Bob.\nTo achieve that, Eve sends a fake key to Alice, which contains Bob's email.\n\nUsually Alice wouldn't accept that fake key (not automatically).\n\nHowever, Eve could create a new secret key, with an arbitrary user ID, let's say in the name of Charlie.\nEve uses the fake Charlie key to sign the fake Bob key.\n\nNow Eve sends the two fake keys to Alice:\n* the fake public key for Bob, signed by the Charlie key\n* the fake secret key for Charlie\n\nEve might be willing to import both keys, and might not notice that she is importing a secret key (in Charlie's name).\n\nIf we automatically trusted all signatures made by any owned secret keys, then the presence of the fake Charlie key would have the result of automatically trusting the fake Bob key as accepted.\n\nIt shouldn't be possible to trick Alice simply by getting her to import a secret key.\n\nHow should we prevent that?\n\nI tried this attack with GnuPG. Apparently, when GnuPG created a secret key locally, it is set to ultimate ownertrust.\nHowever, if a secret key is imported that was created elsewhere, the key isn't marked as ultimately, it's marked with an unknown trust level.\n\nEven if I export an ultimately trusted secret key, and then restore it into a fresh keyring, the secret key is no longer ultimately trusted.\n\nSo, GnuPG doesn't fall for this potential attack scenario. Rather, GnuPG (apparently) requires that a secret key is marked as \"trusted to sign other keys\".\n\nI think we must do something similar in TB, and allow the user to configure which of the user's own secret keys are trusted to sign and thereby automatically accept the public keys of other people.\n\nIf my thoughts make sense, and we agree this trust attribute for secret keys is required, then a migration from GnuPG should also import those existing trust attributes.", "time": "2020-06-09T17:11:09Z"}, {"is_private": false, "count": 4, "bug_id": 1642795, "tags": [], "author": "kaie@kuix.de", "time": "2020-06-09T17:12:01Z", "raw_text": "Patrick, does comment 3 make sense? Any additional thoughts, or details that I'm missing?", "id": 14872385, "text": "Patrick, does comment 3 make sense? Any additional thoughts, or details that I'm missing?", "attachment_id": null, "creator": "kaie@kuix.de", "creation_time": "2020-06-09T17:12:01Z"}, {"creation_time": "2020-06-09T17:45:13Z", "creator": "kaie@kuix.de", "attachment_id": null, "id": 14872462, "text": "The current (new) TB implementation will automatically accept a key, if the secret key is available. So, Eve can trick Alice to accept Charlie's key, simply by sending a fake secret key to Alice, and convincing Alice to import it. In that case, we don't ask Alice to confirm or verify that it's really Charlie's key. That a security issue, we need to change how this works. (That's independent of this enhancement bug for processing key signatures.)", "raw_text": "The current (new) TB implementation will automatically accept a key, if the secret key is available. So, Eve can trick Alice to accept Charlie's key, simply by sending a fake secret key to Alice, and convincing Alice to import it. In that case, we don't ask Alice to confirm or verify that it's really Charlie's key. That a security issue, we need to change how this works. (That's independent of this enhancement bug for processing key signatures.)", "time": "2020-06-09T17:45:13Z", "author": "kaie@kuix.de", "tags": [], "bug_id": 1642795, "is_private": false, "count": 5}, {"raw_text": "Yes, comment 3 does make sense.", "time": "2020-06-09T18:29:02Z", "author": "patrick@enigmail.net", "count": 6, "is_private": false, "tags": [], "bug_id": 1642795, "creation_time": "2020-06-09T18:29:02Z", "creator": "patrick@enigmail.net", "attachment_id": null, "id": 14872546, "text": "Yes, comment 3 does make sense."}, {"count": 7, "is_private": false, "tags": [], "bug_id": 1642795, "author": "kaie@kuix.de", "time": "2020-06-17T21:02:27Z", "raw_text": "Our intention is to make this easier to understand than in other software. For example in GnuPG, a key is accepted as a personal key, if the user marks its ownertrust as ultimate.\nIt took me a lot of brainstorming to come up with a solution that I like.\n\nI suggest that following text for the \"Your Acceptance\" tab, if both secret and public key are available.\n\n==================\nFor this key, you have both the public and the secret part. This usually means that it is your personal key. A personal key is treated specially, and can be used to influence which keys of other people you automatically accept.\n\nDo you accept this key as your personal key?\nIf a key was given to you by someone else, then don't accept it as a personal key.\n\n* No, don't accept it as my personal key.\n* Yes, this is my personal key. I have created it myself, and the displayed key ownership refers to myself. If this personal key is used to certify another key, then automatically accept that other key as verified.\n\n==================", "id": 14887853, "text": "Our intention is to make this easier to understand than in other software. For example in GnuPG, a key is accepted as a personal key, if the user marks its ownertrust as ultimate.\nIt took me a lot of brainstorming to come up with a solution that I like.\n\nI suggest that following text for the \"Your Acceptance\" tab, if both secret and public key are available.\n\n==================\nFor this key, you have both the public and the secret part. This usually means that it is your personal key. A personal key is treated specially, and can be used to influence which keys of other people you automatically accept.\n\nDo you accept this key as your personal key?\nIf a key was given to you by someone else, then don't accept it as a personal key.\n\n* No, don't accept it as my personal key.\n* Yes, this is my personal key. I have created it myself, and the displayed key ownership refers to myself. If this personal key is used to certify another key, then automatically accept that other key as verified.\n\n==================", "attachment_id": null, "creator": "kaie@kuix.de", "creation_time": "2020-06-17T21:02:27Z"}, {"author": "kaie@kuix.de", "tags": [], "bug_id": 1642795, "is_private": false, "count": 8, "raw_text": "Further explanation of intentions:\n\nIf Thunderbird is used to create the user's personal key, we automatically mark the key as \"yes this is my personal key\".\n\nIf the user imports a personal/secret key, then the import procedure should ask the user for a confirmation that it is really a key the user has created on their own, and is restoring it from a backup - or - if the key has been given to the user by someone else (possibly in an attempt to trick them).\n\nSo, when importing a secret key using the new wizard from bug 1627736, I think we should offer the above explanation and choice, and default to \"don't accept\".", "time": "2020-06-17T21:09:58Z", "id": 14887870, "text": "Further explanation of intentions:\n\nIf Thunderbird is used to create the user's personal key, we automatically mark the key as \"yes this is my personal key\".\n\nIf the user imports a personal/secret key, then the import procedure should ask the user for a confirmation that it is really a key the user has created on their own, and is restoring it from a backup - or - if the key has been given to the user by someone else (possibly in an attempt to trick them).\n\nSo, when importing a secret key using the new wizard from bug 1627736, I think we should offer the above explanation and choice, and default to \"don't accept\".", "creation_time": "2020-06-17T21:09:58Z", "creator": "kaie@kuix.de", "attachment_id": null}, {"tags": [], "bug_id": 1642795, "is_private": false, "count": 9, "author": "mkmelin+mozilla@iki.fi", "time": "2020-06-18T05:51:47Z", "raw_text": "Under which circumstances would you ever be \"given both the public and secret key of someone else\"?", "id": 14888484, "text": "Under which circumstances would you ever be \"given both the public and secret key of someone else\"?", "attachment_id": null, "creator": "mkmelin+mozilla@iki.fi", "creation_time": "2020-06-18T05:51:47Z"}, {"tags": [], "bug_id": 1642795, "is_private": false, "count": 10, "author": "kaie@kuix.de", "time": "2020-06-18T08:13:18Z", "raw_text": "(In reply to Magnus Melin [:mkmelin] from comment #9)\n> Under which circumstances would you ever be \"given both the public and secret key of someone else\"?\n\nWith the current experimental implementation, Thunderbird fully accepts a secret key, without asking the user to accept/verify it.\n\nKnowing this, an attacker could send victim Alice a fake key in the victim Bob's name. Instead of a public key, they could send a secret key. They could convince Alice to import it using the key manager.\n\nIf Thunderbird behavior stays this way, then this could be an approach to trick users into accepting fake keys, circumventing the \"acceptance\" safeguards in the user interface.", "id": 14888658, "text": "(In reply to Magnus Melin [:mkmelin] from comment #9)\n> Under which circumstances would you ever be \"given both the public and secret key of someone else\"?\n\nWith the current experimental implementation, Thunderbird fully accepts a secret key, without asking the user to accept/verify it.\n\nKnowing this, an attacker could send victim Alice a fake key in the victim Bob's name. Instead of a public key, they could send a secret key. They could convince Alice to import it using the key manager.\n\nIf Thunderbird behavior stays this way, then this could be an approach to trick users into accepting fake keys, circumventing the \"acceptance\" safeguards in the user interface.", "creator": "kaie@kuix.de", "attachment_id": null, "creation_time": "2020-06-18T08:13:18Z"}, {"creator": "patrick@enigmail.net", "attachment_id": null, "creation_time": "2020-06-18T16:10:56Z", "text": "(In reply to Magnus Melin [:mkmelin] from comment #9)\n> Under which circumstances would you ever be \"given both the public and secret key of someone else\"?\n\nFor example if you use a mailing list with a (relatively small) list of known users. If you want to encrypt mails, and not use something like Schleuder, then the simplest thing is to create a specific key to use for encrypting to that list, and you share the secret key among all subscribers.", "id": 14889408, "time": "2020-06-18T16:10:56Z", "raw_text": "(In reply to Magnus Melin [:mkmelin] from comment #9)\n> Under which circumstances would you ever be \"given both the public and secret key of someone else\"?\n\nFor example if you use a mailing list with a (relatively small) list of known users. If you want to encrypt mails, and not use something like Schleuder, then the simplest thing is to create a specific key to use for encrypting to that list, and you share the secret key among all subscribers.", "bug_id": 1642795, "tags": [], "is_private": false, "count": 11, "author": "patrick@enigmail.net"}, {"creation_time": "2020-06-22T16:44:59Z", "creator": "kaie@kuix.de", "attachment_id": null, "text": "After more brainstorming, I think we should do the following:\n\n* Have separate settings for (a) \"I accept this as a personal key\" and (b) \"I want to automatically accept other keys that are certified by this key\".\n* GnuPG seems to combine the settings for both (a) and (b) into a single choice, being \"ownertrust = ultimate\". This is problematic in the scenario that Patrick mentioned in comment 11. If people do that, they probably want to be able to send email to that address, so they'd need (a) = true. However, if Alice and Eve share the secret key, then Eve could use the key to sign a fake key in Bob's name, thereby tricking Alice to automatically accept it. For that purpose, I think it makes sense to have setting (b) separate.\n* At this time, we'd set (b) for all imported keys that have ownertrust = ultimate set.\n* Although we need to allow (b) for personal keys, there's no reason why we'd have to restrict it to personal keys. We could consider to allow any key of anyone else to be acceptable for (b). I'd suggest that we limit the ability to set (b) = true to keys that have acceptance level \"verified\".\n* Doing the above would satisfy the request to support certification keys.\n\nIn order to implement the above, I suggest to introduce an additional tab in the key details/properties dialog.\n\nThe new tab could be called \"Certification Acceptance\".\n(I wouldn't call it ownertrust, because we don't fully follow the model that GnuPG uses for ownertrust.)\n\nIf a key (pair) is accepted as a personal key, or if the shown (public) key is in acceptance level \"verified\", we'd offer the following choices:\n* Don't automatically accept other keys that are certified by this key.\n* If this key is used to certify another key, then that other key is automatically accepted as verified.\n\nIf the is neither accepted as a personal key and isn't verified, then the tab would display an information message saying:\n\"This functionality is available for personal keys and verified public keys, only.\"\nThe choices would still be shown, but disabled, and the \"don't\" choice is selected.\n\nThis approach allow us to migrate all ownertrust flags from GnuPG at the time of Enigmail migration.\nWe could store all flags as they are set in GnuPG.\n\nWe might limit the initial implementation (shortage of time) to personal keys, and consider the other details for later, including decisions about indirect trust.", "id": 14894507, "raw_text": "After more brainstorming, I think we should do the following:\n\n* Have separate settings for (a) \"I accept this as a personal key\" and (b) \"I want to automatically accept other keys that are certified by this key\".\n* GnuPG seems to combine the settings for both (a) and (b) into a single choice, being \"ownertrust = ultimate\". This is problematic in the scenario that Patrick mentioned in comment 11. If people do that, they probably want to be able to send email to that address, so they'd need (a) = true. However, if Alice and Eve share the secret key, then Eve could use the key to sign a fake key in Bob's name, thereby tricking Alice to automatically accept it. For that purpose, I think it makes sense to have setting (b) separate.\n* At this time, we'd set (b) for all imported keys that have ownertrust = ultimate set.\n* Although we need to allow (b) for personal keys, there's no reason why we'd have to restrict it to personal keys. We could consider to allow any key of anyone else to be acceptable for (b). I'd suggest that we limit the ability to set (b) = true to keys that have acceptance level \"verified\".\n* Doing the above would satisfy the request to support certification keys.\n\nIn order to implement the above, I suggest to introduce an additional tab in the key details/properties dialog.\n\nThe new tab could be called \"Certification Acceptance\".\n(I wouldn't call it ownertrust, because we don't fully follow the model that GnuPG uses for ownertrust.)\n\nIf a key (pair) is accepted as a personal key, or if the shown (public) key is in acceptance level \"verified\", we'd offer the following choices:\n* Don't automatically accept other keys that are certified by this key.\n* If this key is used to certify another key, then that other key is automatically accepted as verified.\n\nIf the is neither accepted as a personal key and isn't verified, then the tab would display an information message saying:\n\"This functionality is available for personal keys and verified public keys, only.\"\nThe choices would still be shown, but disabled, and the \"don't\" choice is selected.\n\nThis approach allow us to migrate all ownertrust flags from GnuPG at the time of Enigmail migration.\nWe could store all flags as they are set in GnuPG.\n\nWe might limit the initial implementation (shortage of time) to personal keys, and consider the other details for later, including decisions about indirect trust.", "time": "2020-06-22T16:44:59Z", "author": "kaie@kuix.de", "is_private": false, "count": 12, "bug_id": 1642795, "tags": []}, {"attachment_id": null, "creator": "kaie@kuix.de", "time": "2020-06-22T16:45:27Z", "raw_text": "Patrick, what's your opinion about comment 12 ?", "creation_time": "2020-06-22T16:45:27Z", "count": 13, "is_private": false, "tags": [], "bug_id": 1642795, "author": "kaie@kuix.de", "text": "Patrick, what's your opinion about comment 12 ?", "id": 14894509}, {"is_private": false, "count": 14, "bug_id": 1642795, "tags": [], "text": "(In reply to Kai Engert (:KaiE:) from comment #12)\n\nI agree that this is the most flexible choice. But maybe we should name it a little differently (from the user's perspective):\n(a) this is a private key I own myself and that I have fully under my control\n(b) this is a private key that is shared among several people and/or that I don't trust entirely", "id": 14894921, "author": "patrick@enigmail.net", "creator": "patrick@enigmail.net", "attachment_id": null, "time": "2020-06-22T19:31:46Z", "raw_text": "(In reply to Kai Engert (:KaiE:) from comment #12)\n\nI agree that this is the most flexible choice. But maybe we should name it a little differently (from the user's perspective):\n(a) this is a private key I own myself and that I have fully under my control\n(b) this is a private key that is shared among several people and/or that I don't trust entirely", "creation_time": "2020-06-22T19:31:46Z"}, {"creator": "kaie@kuix.de", "attachment_id": null, "creation_time": "2020-06-23T12:49:44Z", "text": "Patrick, thanks for your general agreement. The wordage in comment 14 might not be ideal, we probably shouldn't tell people about the possibility of sharing keys. They might incorrectly conclude that as a reasonable thing to do - while we probably shouldn't encourage sharing of secret keys.", "id": 14896358, "time": "2020-06-23T12:49:44Z", "raw_text": "Patrick, thanks for your general agreement. The wordage in comment 14 might not be ideal, we probably shouldn't tell people about the possibility of sharing keys. They might incorrectly conclude that as a reasonable thing to do - while we probably shouldn't encourage sharing of secret keys.", "is_private": false, "count": 15, "bug_id": 1642795, "tags": [], "author": "kaie@kuix.de"}, {"raw_text": "I have a bigger patch ready, that implements suggested UI, the required backend storage, and the interdependencies between controls.\nIt's still missing the complete automatic checking if a key should be automatically accepted, and the relevant status.\nBut it might be good to get started with this work.\nIdeally, I'd like to have this landed before the 78 release - to enable Patrick to migrate existing GnuPG ownertrust flags into our new storage.", "time": "2020-06-23T12:51:50Z", "author": "kaie@kuix.de", "is_private": false, "count": 16, "bug_id": 1642795, "tags": [], "creation_time": "2020-06-23T12:51:50Z", "attachment_id": null, "creator": "kaie@kuix.de", "text": "I have a bigger patch ready, that implements suggested UI, the required backend storage, and the interdependencies between controls.\nIt's still missing the complete automatic checking if a key should be automatically accepted, and the relevant status.\nBut it might be good to get started with this work.\nIdeally, I'd like to have this landed before the 78 release - to enable Patrick to migrate existing GnuPG ownertrust flags into our new storage.", "id": 14896360}, {"time": "2020-06-23T12:53:27Z", "raw_text": "For comparison, this is the current/old display of the \"your acceptance\" tab, whenever we find we have a secret available.\nAs explained above, we want to change that.", "count": 17, "is_private": false, "tags": [], "bug_id": 1642795, "author": "kaie@kuix.de", "attachment_id": 9158518, "creator": "kaie@kuix.de", "creation_time": "2020-06-23T12:53:27Z", "text": "Created attachment 9158518\ncurrent/old acceptance tab for secret keys\n\nFor comparison, this is the current/old display of the \"your acceptance\" tab, whenever we find we have a secret available.\nAs explained above, we want to change that.", "id": 14896363}, {"author": "kaie@kuix.de", "bug_id": 1642795, "tags": [], "is_private": false, "count": 18, "raw_text": "New display for acceptance tab, if personal key is available.\n\nUser is able to mark a key as \"not my key\" or \"yes this is my key with my identity and I created it myself\" - to distinguish from keys, that the user might have imported, but has been given by someone else.\n\nThe idea is to automatically set this flag to \"yes\" whenever we generate a key inside Thunderbird.\n\nWhen importing a secret key, the user should be asked to make that choice.", "time": "2020-06-23T12:55:28Z", "id": 14896370, "text": "Created attachment 9158520\nNew display for acceptance tab, if personal key is available\n\nNew display for acceptance tab, if personal key is available.\n\nUser is able to mark a key as \"not my key\" or \"yes this is my key with my identity and I created it myself\" - to distinguish from keys, that the user might have imported, but has been given by someone else.\n\nThe idea is to automatically set this flag to \"yes\" whenever we generate a key inside Thunderbird.\n\nWhen importing a secret key, the user should be asked to make that choice.", "creation_time": "2020-06-23T12:55:28Z", "creator": "kaie@kuix.de", "attachment_id": 9158520}, {"creation_time": "2020-06-23T12:57:08Z", "creator": "kaie@kuix.de", "attachment_id": 9158521, "id": 14896373, "text": "Created attachment 9158521\nIndirect acceptance for personal keys\n\nThis patch introduces a new tab, currently named \"Indirect Accptance\".\n\nIf you look at a key pair (have secret key) and the user has confirmed it's a personal key, then we get this display - which offers the user the choice to automatically accept certified keys.", "raw_text": "This patch introduces a new tab, currently named \"Indirect Accptance\".\n\nIf you look at a key pair (have secret key) and the user has confirmed it's a personal key, then we get this display - which offers the user the choice to automatically accept certified keys.", "time": "2020-06-23T12:57:08Z", "author": "kaie@kuix.de", "count": 19, "is_private": false, "bug_id": 1642795, "tags": []}, {"attachment_id": 9158522, "creator": "kaie@kuix.de", "creation_time": "2020-06-23T12:58:32Z", "id": 14896375, "text": "Created attachment 9158522\nIndirect acceptance for secret keys that are NOT personal keys\n\nIn contrast to the previous image - if you're looking at a secret key, but the user has rejected the \"is a personal key\" flag, this is what you get in the \"indirect acceptance\" tab. - You are not allowed to mark it as \"accept certifications\".", "time": "2020-06-23T12:58:32Z", "raw_text": "In contrast to the previous image - if you're looking at a secret key, but the user has rejected the \"is a personal key\" flag, this is what you get in the \"indirect acceptance\" tab. - You are not allowed to mark it as \"accept certifications\".", "tags": [], "bug_id": 1642795, "count": 20, "is_private": false, "author": "kaie@kuix.de"}, {"attachment_id": 9158523, "creator": "kaie@kuix.de", "creation_time": "2020-06-23T12:59:50Z", "text": "Created attachment 9158523\nindirect acceptance for public keys that aren't verified\n\nThis is shown for a public key (someone else's key) that you haven't verified. You aren't allowed to mark it to automatically other keys.", "id": 14896376, "time": "2020-06-23T12:59:50Z", "raw_text": "This is shown for a public key (someone else's key) that you haven't verified. You aren't allowed to mark it to automatically other keys.", "tags": [], "bug_id": 1642795, "count": 21, "is_private": false, "author": "kaie@kuix.de"}, {"creation_time": "2020-06-23T13:01:44Z", "attachment_id": 9158526, "creator": "kaie@kuix.de", "text": "Created attachment 9158526\nindirect acceptance for verified public keys\n\nIn contrast to the previous image, if you have verified another person's public key, you are able to mark it as \"automatically accept other keys that were certified by this one\".", "id": 14896379, "raw_text": "In contrast to the previous image, if you have verified another person's public key, you are able to mark it as \"automatically accept other keys that were certified by this one\".", "time": "2020-06-23T13:01:44Z", "author": "kaie@kuix.de", "is_private": false, "count": 22, "bug_id": 1642795, "tags": []}, {"creation_time": "2020-06-23T13:02:20Z", "attachment_id": 9158527, "creator": "kaie@kuix.de", "id": 14896381, "text": "Created attachment 9158527\nna5.png\n\nFinally, this is for a public key that isn't valid any more, obviously you cannot use it to trust anyone else.", "raw_text": "Finally, this is for a public key that isn't valid any more, obviously you cannot use it to trust anyone else.", "time": "2020-06-23T13:02:20Z", "author": "kaie@kuix.de", "is_private": false, "count": 23, "tags": [], "bug_id": 1642795}, {"creation_time": "2020-06-23T13:05:53Z", "attachment_id": 9158530, "creator": "kaie@kuix.de", "id": 14896393, "text": "Created attachment 9158530\nBug 1642795 - Ability to mark key pairs as \"accepted personal keys\" or not. r=PatrickBrunschwig", "raw_text": "", "time": "2020-06-23T13:05:53Z", "author": "kaie@kuix.de", "count": 24, "is_private": false, "tags": [], "bug_id": 1642795}, {"attachment_id": null, "creator": "kaie@kuix.de", "creation_time": "2020-06-23T13:14:40Z", "id": 14896407, "text": "When migrating ownertrust from GnuPG, the suggestion is to:\n- migrate \"ultimate\" into calls to RNP.acceptAsPersonalKey(fingerprint); and RNP.updateTrustedVerifier(fingerprint, \"full\");\n- migrate \"full\" by calling RNP.updateTrustedVerifier(fingerprint, \"full\");\n\nDon't make a call if ownertrust has any other value, because they wouldn't have any effect with our implementation.\n\nI'm slightly undecided if migrating the other ownertrust flags make sense - because if it's a one time import, then those flags sit in our storage for a year without being used. If the user uses GnuPG in parallel, they might make changes to those flags in GnuPG, and our storage gets out of sync.\n\nSo, if we'll ever want to offer users to make use of more indirect trust, then maybe we should work out a synchronization of flags from GnuPG at a future time.", "time": "2020-06-23T13:14:40Z", "raw_text": "When migrating ownertrust from GnuPG, the suggestion is to:\n- migrate \"ultimate\" into calls to RNP.acceptAsPersonalKey(fingerprint); and RNP.updateTrustedVerifier(fingerprint, \"full\");\n- migrate \"full\" by calling RNP.updateTrustedVerifier(fingerprint, \"full\");\n\nDon't make a call if ownertrust has any other value, because they wouldn't have any effect with our implementation.\n\nI'm slightly undecided if migrating the other ownertrust flags make sense - because if it's a one time import, then those flags sit in our storage for a year without being used. If the user uses GnuPG in parallel, they might make changes to those flags in GnuPG, and our storage gets out of sync.\n\nSo, if we'll ever want to offer users to make use of more indirect trust, then maybe we should work out a synchronization of flags from GnuPG at a future time.", "bug_id": 1642795, "tags": [], "is_private": false, "count": 25, "author": "kaie@kuix.de"}, {"attachment_id": null, "creator": "kaie@kuix.de", "creation_time": "2020-06-25T09:25:58Z", "text": "We cannot implement this at this time, because RNP doesn't yet support checking the validity of signatures on a key.\n\nI'll mark this bug as a feature enhancement, and will file a separate bug for marking secret keys as personal keys (or not).", "id": 14901069, "time": "2020-06-25T09:25:58Z", "raw_text": "We cannot implement this at this time, because RNP doesn't yet support checking the validity of signatures on a key.\n\nI'll mark this bug as a feature enhancement, and will file a separate bug for marking secret keys as personal keys (or not).", "count": 26, "is_private": false, "tags": [], "bug_id": 1642795, "author": "kaie@kuix.de"}, {"time": "2020-06-25T10:30:42Z", "raw_text": "(In reply to Kai Engert (:KaiE:) from comment #26)\n> I'll mark this bug as a feature enhancement, and will file a separate bug for marking secret keys as personal keys (or not).\n\nNo. Let's change this bug into only handling \"mark as personal\" key, because 70% of the attached patch are about that.\n\nI'll update the revision, to only be about that.", "count": 27, "is_private": false, "bug_id": 1642795, "tags": [], "author": "kaie@kuix.de", "creator": "kaie@kuix.de", "attachment_id": null, "creation_time": "2020-06-25T10:30:42Z", "text": "(In reply to Kai Engert (:KaiE:) from comment #26)\n> I'll mark this bug as a feature enhancement, and will file a separate bug for marking secret keys as personal keys (or not).\n\nNo. Let's change this bug into only handling \"mark as personal\" key, because 70% of the attached patch are about that.\n\nI'll update the revision, to only be about that.", "id": 14901191}, {"creation_time": "2020-06-25T21:53:24Z", "attachment_id": null, "creator": "pulsebot@bots.tld", "id": 14902724, "text": "Pushed by kaie@kuix.de:\nhttps://hg.mozilla.org/comm-central/rev/5fed4272e44c\nAbility to mark key pairs as \"accepted personal keys\" or not. r=PatrickBrunschwig", "raw_text": "Pushed by kaie@kuix.de:\nhttps://hg.mozilla.org/comm-central/rev/5fed4272e44c\nAbility to mark key pairs as \"accepted personal keys\" or not. r=PatrickBrunschwig", "time": "2020-06-25T21:53:24Z", "author": "pulsebot@bots.tld", "bug_id": 1642795, "tags": [], "count": 28, "is_private": false}, {"author": "kaie@kuix.de", "bug_id": 1642795, "tags": [], "count": 29, "is_private": false, "raw_text": "This is an important change to OpenPGP, that makes additional flags available, that need to be set by the Enigmail migration tool.", "time": "2020-06-26T09:48:49Z", "text": "Comment on attachment 9158530\nBug 1642795 - Ability to mark key pairs as \"accepted personal keys\" or not. r=PatrickBrunschwig\n\nThis is an important change to OpenPGP, that makes additional flags available, that need to be set by the Enigmail migration tool.", "id": 14903473, "creation_time": "2020-06-26T09:48:49Z", "attachment_id": 9158530, "creator": "kaie@kuix.de"}, {"id": 14903486, "text": "Comment on attachment 9158530\nBug 1642795 - Ability to mark key pairs as \"accepted personal keys\" or not. r=PatrickBrunschwig\n\nApproved for beta", "author": "vseerror@lehigh.edu", "is_private": false, "count": 30, "bug_id": 1642795, "tags": [], "raw_text": "Approved for beta", "creation_time": "2020-06-26T10:00:18Z", "attachment_id": 9158530, "creator": "vseerror@lehigh.edu", "time": "2020-06-26T10:00:18Z"}, {"creation_time": "2020-06-26T16:13:00Z", "creator": "kaie@kuix.de", "attachment_id": null, "text": "https://hg.mozilla.org/releases/comm-beta/rev/b116b868d07f7114e9f559d41ce7172934bb3472", "id": 14904126, "raw_text": "https://hg.mozilla.org/releases/comm-beta/rev/b116b868d07f7114e9f559d41ce7172934bb3472", "time": "2020-06-26T16:13:00Z", "author": "kaie@kuix.de", "bug_id": 1642795, "tags": [], "count": 31, "is_private": false}]}}}