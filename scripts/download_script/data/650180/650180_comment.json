{"bugs": {"650180": {"comments": [{"creation_time": "2011-04-15T00:43:04Z", "author": "dvander@alliedmods.net", "attachment_id": null, "id": 5411013, "creator": "dvander@alliedmods.net", "text": "The existing JM2 architecture suffices as a baseline compiler, but further optimization and specialization work is difficult, extremely hacky, or impossible.\n\nThere are two problems: the lack of an IR and the design of the compiler itself. The first pass computes stack depths, and the second pass splats out a little template of assembly per-opcode. Operations aren't broken down into small enough units to perform typical optimizations, making cross-basic-block regalloc & LICM rather ad-hoc or limited.\n\nThe plan is to design a new set of IRs to assist in making new optimizations possible. We should also be able to break down existing ops into smaller units, for example, we should be able to CSE redundant shape guards or slots-array loads. On top of the IRs we will have a new code generator that re-uses the Nitro assembler. Some planned features:\n * Advanced linear scan regalloc across basic blocks\n * LICM\n * CSE\n * Interval analyses\n * Advanced specialization, via profiling and type inference\n * Better handling of boxing formats, especially on x64\n * More robust recompilation, elimination of compartment-wide debug mode\n\nA more hopeful, but perhaps not realistic goal is to make this new compiler capable of being both an optimizing, type-specializing compiler, and a generic baseline compiler to replace JM. I think we'll know pretty early on whether this is feasible (i.e. whether it can be done without ruining the design or compile times), and if not, we can also focus on simplifying JM.", "count": 0, "raw_text": "The existing JM2 architecture suffices as a baseline compiler, but further optimization and specialization work is difficult, extremely hacky, or impossible.\n\nThere are two problems: the lack of an IR and the design of the compiler itself. The first pass computes stack depths, and the second pass splats out a little template of assembly per-opcode. Operations aren't broken down into small enough units to perform typical optimizations, making cross-basic-block regalloc & LICM rather ad-hoc or limited.\n\nThe plan is to design a new set of IRs to assist in making new optimizations possible. We should also be able to break down existing ops into smaller units, for example, we should be able to CSE redundant shape guards or slots-array loads. On top of the IRs we will have a new code generator that re-uses the Nitro assembler. Some planned features:\n * Advanced linear scan regalloc across basic blocks\n * LICM\n * CSE\n * Interval analyses\n * Advanced specialization, via profiling and type inference\n * Better handling of boxing formats, especially on x64\n * More robust recompilation, elimination of compartment-wide debug mode\n\nA more hopeful, but perhaps not realistic goal is to make this new compiler capable of being both an optimizing, type-specializing compiler, and a generic baseline compiler to replace JM. I think we'll know pretty early on whether this is feasible (i.e. whether it can be done without ruining the design or compile times), and if not, we can also focus on simplifying JM.", "bug_id": 650180, "is_private": false, "tags": [], "time": "2011-04-15T00:43:04Z"}, {"bug_id": 650180, "count": 1, "time": "2011-04-20T02:58:04Z", "creator": "n.nethercote@gmail.com", "author": "n.nethercote@gmail.com", "raw_text": "> A more hopeful, but perhaps not realistic goal is to make this new compiler\n> capable of being both an optimizing, type-specializing compiler, and a generic\n> baseline compiler to replace JM. I think we'll know pretty early on whether\n> this is feasible (i.e. whether it can be done without ruining the design or\n> compile times), and if not, we can also focus on simplifying JM.\n\nLet's assume the latter.  What does the execution pipeline look like?\n\n- Interpret a bit\n- JaegerMonkey-compile (with type inference) slightly hot code\n- IonMonkey-compile (with type inference and IRs) hotter code\n- Trace-compile really hot code?\n\nIt sounds like TraceMonkey's days are numbered, which isn't necessarily a bad thing.  With type inference in place everywhere the only compelling advantage it provides is inlining of small functions.", "is_private": false, "tags": [], "creation_time": "2011-04-20T02:58:04Z", "id": 5420435, "attachment_id": null, "text": "> A more hopeful, but perhaps not realistic goal is to make this new compiler\n> capable of being both an optimizing, type-specializing compiler, and a generic\n> baseline compiler to replace JM. I think we'll know pretty early on whether\n> this is feasible (i.e. whether it can be done without ruining the design or\n> compile times), and if not, we can also focus on simplifying JM.\n\nLet's assume the latter.  What does the execution pipeline look like?\n\n- Interpret a bit\n- JaegerMonkey-compile (with type inference) slightly hot code\n- IonMonkey-compile (with type inference and IRs) hotter code\n- Trace-compile really hot code?\n\nIt sounds like TraceMonkey's days are numbered, which isn't necessarily a bad thing.  With type inference in place everywhere the only compelling advantage it provides is inlining of small functions."}, {"time": "2011-04-20T05:28:51Z", "is_private": false, "tags": [], "raw_text": "The type inference branch currently inlines functions, Ion will too. To be honest I'm not sure what the pipeline will look like yet, and the pipeline may change as we figure out how to tune it.\n\nBut, one of the up-front design decisions I'd like to make is that Ion code will never call into the tracer. It's an insanely complex path... and reducing the JIT transition matrix is probably best for everyone's sanity. *Especially* Bill's :)\n\nMy hope is that Ion won't just be fixing problems in JM, but also TM. TM suffers from an inability to despecialize both types and control flow, as it can't separate compilation from execution. Its IR is also fairly inflexible after it's been emitted. \n\nThese are things we will fix in Ion. And for when we don't have type inference, we'll have the ability to collect type information via profiling. One backend, able to feed from multiple sources of information, should get us both JM3 and TM2. Maybe not right away, but it sounds like a good long-term goal.", "bug_id": 650180, "count": 2, "attachment_id": null, "id": 5420566, "text": "The type inference branch currently inlines functions, Ion will too. To be honest I'm not sure what the pipeline will look like yet, and the pipeline may change as we figure out how to tune it.\n\nBut, one of the up-front design decisions I'd like to make is that Ion code will never call into the tracer. It's an insanely complex path... and reducing the JIT transition matrix is probably best for everyone's sanity. *Especially* Bill's :)\n\nMy hope is that Ion won't just be fixing problems in JM, but also TM. TM suffers from an inability to despecialize both types and control flow, as it can't separate compilation from execution. Its IR is also fairly inflexible after it's been emitted. \n\nThese are things we will fix in Ion. And for when we don't have type inference, we'll have the ability to collect type information via profiling. One backend, able to feed from multiple sources of information, should get us both JM3 and TM2. Maybe not right away, but it sounds like a good long-term goal.", "creator": "dvander@alliedmods.net", "author": "dvander@alliedmods.net", "creation_time": "2011-04-20T05:28:51Z"}, {"author": "n.nethercote@gmail.com", "text": "(In reply to comment #2)\n> \n> But, one of the up-front design decisions I'd like to make is that Ion code\n> will never call into the tracer. It's an insanely complex path...\n\nGetting rid of the tracer would make that easier.  Otherwise the base compiler would have to decide whether to use IonMonkey or TM to do optimizing recompilation, which seems weird.\n\nMy gut feeling is that two levels of compilation (base + optimizing) should be enough, though bhackett suggested elsewhere that some kind of trace compilation might be good for white-hot loops.  Even if that were the case, it still sounds like a death knell for TM and particularly nanojit;  having two assemblers is weird, the momentum is clearly not with TM/nanojit, and nanojit has enough design limitations that redesigning a new trace jit from scratch based on what we've learnt about tracing sounds more sensible.", "creator": "n.nethercote@gmail.com", "id": 5436318, "attachment_id": null, "creation_time": "2011-04-28T01:33:05Z", "tags": [], "is_private": false, "time": "2011-04-28T01:33:05Z", "count": 3, "bug_id": 650180, "raw_text": "(In reply to comment #2)\n> \n> But, one of the up-front design decisions I'd like to make is that Ion code\n> will never call into the tracer. It's an insanely complex path...\n\nGetting rid of the tracer would make that easier.  Otherwise the base compiler would have to decide whether to use IonMonkey or TM to do optimizing recompilation, which seems weird.\n\nMy gut feeling is that two levels of compilation (base + optimizing) should be enough, though bhackett suggested elsewhere that some kind of trace compilation might be good for white-hot loops.  Even if that were the case, it still sounds like a death knell for TM and particularly nanojit;  having two assemblers is weird, the momentum is clearly not with TM/nanojit, and nanojit has enough design limitations that redesigning a new trace jit from scratch based on what we've learnt about tracing sounds more sensible."}, {"author": "brendan@mozilla.org", "id": 5436696, "attachment_id": null, "text": "We don't take perf regressions, so TM won't die without faster replacement on many benchmarks (not just the Stupids(tm)).\n\nI suspect bhackett is right and we'll want tracing, semi-static type inference, and baseline/profiled JITting. But it sounds like dvander et al. have a good plan to support all three.\n\n/be", "creator": "brendan@mozilla.org", "creation_time": "2011-04-28T08:20:15Z", "is_private": false, "tags": [], "time": "2011-04-28T08:20:15Z", "count": 4, "raw_text": "We don't take perf regressions, so TM won't die without faster replacement on many benchmarks (not just the Stupids(tm)).\n\nI suspect bhackett is right and we'll want tracing, semi-static type inference, and baseline/profiled JITting. But it sounds like dvander et al. have a good plan to support all three.\n\n/be", "bug_id": 650180}, {"author": "bhackett1024@gmail.com", "creator": "bhackett1024@gmail.com", "count": 5, "bug_id": 650180, "time": "2011-04-28T14:18:54Z", "creation_time": "2011-04-28T14:18:54Z", "text": "(In reply to comment #4)\n> We don't take perf regressions, so TM won't die without faster replacement on\n> many benchmarks (not just the Stupids(tm)).\n> \n> I suspect bhackett is right and we'll want tracing, semi-static type inference,\n> and baseline/profiled JITting. But it sounds like dvander et al. have a good\n> plan to support all three.\n> \n> /be\n\nWe should list the benchmarks whose performance we care about and put them on AWFY.  Not just suites, but also microbenchmarks testing individual features important for the web (typed arrays, native getters/setters, ...) and shell tests synthesized from JS bound web pages (bug 643666).  (Also, in a new page, like the test breakdown page, to avoid clutter.)  I filed this a couple weeks ago as bug 649487.\n\nJM+TI won't replace TM, but IonMonkey could, and I think should, replace both TM and JM.  IMO, such replacements can't happen without a concrete way to do a broad evaluation of a JS engine's performance, and I agree the main benchmark suites don't cut it by themselves.", "id": 5437036, "attachment_id": null, "raw_text": "(In reply to comment #4)\n> We don't take perf regressions, so TM won't die without faster replacement on\n> many benchmarks (not just the Stupids(tm)).\n> \n> I suspect bhackett is right and we'll want tracing, semi-static type inference,\n> and baseline/profiled JITting. But it sounds like dvander et al. have a good\n> plan to support all three.\n> \n> /be\n\nWe should list the benchmarks whose performance we care about and put them on AWFY.  Not just suites, but also microbenchmarks testing individual features important for the web (typed arrays, native getters/setters, ...) and shell tests synthesized from JS bound web pages (bug 643666).  (Also, in a new page, like the test breakdown page, to avoid clutter.)  I filed this a couple weeks ago as bug 649487.\n\nJM+TI won't replace TM, but IonMonkey could, and I think should, replace both TM and JM.  IMO, such replacements can't happen without a concrete way to do a broad evaluation of a JS engine's performance, and I agree the main benchmark suites don't cut it by themselves.", "tags": [], "is_private": false}, {"count": 6, "raw_text": "Right now, K9O wants bugs that are absolutely required and can be finished quickly. IM will take a bit longer and is more in the \"wanted\" category, so not blocking K9O for now.", "bug_id": 650180, "is_private": false, "tags": [], "time": "2012-05-01T18:59:59Z", "creation_time": "2012-05-01T18:59:59Z", "author": "dmandelin@mozilla.com", "attachment_id": null, "id": 6269943, "text": "Right now, K9O wants bugs that are absolutely required and can be finished quickly. IM will take a bit longer and is more in the \"wanted\" category, so not blocking K9O for now.", "creator": "dmandelin@mozilla.com"}, {"is_private": false, "tags": [], "time": "2014-05-29T15:11:02Z", "count": 7, "raw_text": "To avoid a Dupe I tried to find the \"Compiler Optimization\" / \"Be 'nice' While Compiling\" Bug, but this Meta was the most recent (and it is fairly old).\n\nThis Page http://glsl.heroku.com/e#12543.1 simply hangs the Browser for several minutes (I have a slow Computer) and then the compiled Code runs really fast.\n\nAll the other Examples on Page http://glsl.heroku.com/ that I tried load and compile almost instantly.\n\nIt would be great if the Compiler were faster on the first example. It is a \"Bug\" that when compiling the Browser hangs and we can not switch Tabs. \n\nThe compiler needs to be 'nice' and not hog the CPU. While we wait we should be able to do other things. This Bug is titled \"Build a new optimizing Compiler\", this is something that should be considered in its design. \n\nWhen running an Example on http://threejs.org/ (specifically http://www.playmapscube.com/ ) the compiled output crashed. A List of these example pages would make a good Test / Benchamrk Farm.", "bug_id": 650180, "author": "rob1weld@gmail.com", "id": 8858209, "attachment_id": null, "creator": "rob1weld@gmail.com", "text": "To avoid a Dupe I tried to find the \"Compiler Optimization\" / \"Be 'nice' While Compiling\" Bug, but this Meta was the most recent (and it is fairly old).\n\nThis Page http://glsl.heroku.com/e#12543.1 simply hangs the Browser for several minutes (I have a slow Computer) and then the compiled Code runs really fast.\n\nAll the other Examples on Page http://glsl.heroku.com/ that I tried load and compile almost instantly.\n\nIt would be great if the Compiler were faster on the first example. It is a \"Bug\" that when compiling the Browser hangs and we can not switch Tabs. \n\nThe compiler needs to be 'nice' and not hog the CPU. While we wait we should be able to do other things. This Bug is titled \"Build a new optimizing Compiler\", this is something that should be considered in its design. \n\nWhen running an Example on http://threejs.org/ (specifically http://www.playmapscube.com/ ) the compiled output crashed. A List of these example pages would make a good Test / Benchamrk Farm.", "creation_time": "2014-05-29T15:11:02Z"}, {"count": 8, "bug_id": 650180, "raw_text": "(In reply to Rob from comment #7)\n> ...\n> All the other Examples on Page http://glsl.heroku.com/ that I tried load and\n> compile almost instantly.\n> ...\n\nA great example of how slow we compile is here: https://www.shadertoy.com/browse .\n\n1. Copy that URL.\n2. Paste it into a new Tab's URL Bar.\n3. Let the first example load and then start Google Chrome.\n4. Paste the URL into Google Chrome's URL Bar.\n\nNotice that even though Firefox got a head start, and is using most of the CPU, that Chrome whips through that Page much faster. We are unacceptably slow.", "tags": [], "is_private": false, "time": "2014-05-29T16:50:28Z", "creation_time": "2014-05-29T16:50:28Z", "author": "rob1weld@gmail.com", "text": "(In reply to Rob from comment #7)\n> ...\n> All the other Examples on Page http://glsl.heroku.com/ that I tried load and\n> compile almost instantly.\n> ...\n\nA great example of how slow we compile is here: https://www.shadertoy.com/browse .\n\n1. Copy that URL.\n2. Paste it into a new Tab's URL Bar.\n3. Let the first example load and then start Google Chrome.\n4. Paste the URL into Google Chrome's URL Bar.\n\nNotice that even though Firefox got a head start, and is using most of the CPU, that Chrome whips through that Page much faster. We are unacceptably slow.", "creator": "rob1weld@gmail.com", "id": 8858804, "attachment_id": null}, {"count": 9, "bug_id": 650180, "raw_text": "IonMonkey, the compiler described in this bug, landed a year or two ago.  Please file new bugs in the Javascript: JIT component in bugzilla for any issues you may have.", "tags": [], "is_private": false, "time": "2014-05-29T16:52:04Z", "creation_time": "2014-05-29T16:52:04Z", "author": "continuation@gmail.com", "creator": "continuation@gmail.com", "text": "IonMonkey, the compiler described in this bug, landed a year or two ago.  Please file new bugs in the Javascript: JIT component in bugzilla for any issues you may have.", "attachment_id": null, "id": 8858818}]}}, "comments": {}}