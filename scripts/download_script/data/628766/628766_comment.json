{"bugs": {"628766": {"comments": [{"creation_time": "2011-01-25T20:36:32Z", "tags": [], "id": 5226301, "count": 0, "is_private": false, "text": "Currently the property cache lives in JSThread as a separated fixed-size table. We should consider moving the cache into the JSScript. That would simplify the cache lifetime management especially with the property tree moving into the compartment. \n\nA particular implementation can either use one cache entry per caching bytecode or can have a caching table with a size depending on the number of caching bytecodes in the script. The former is attractive as it would eliminate the need to check for the pc for the price of bloating each caching bytecode by the entry index. The latter is easier to implement as very little would need to be chnaged in the cache implementation.", "author": "igor@mir2.org", "attachment_id": null, "creator": "igor@mir2.org", "time": "2011-01-25T20:36:32Z", "raw_text": "Currently the property cache lives in JSThread as a separated fixed-size table. We should consider moving the cache into the JSScript. That would simplify the cache lifetime management especially with the property tree moving into the compartment. \n\nA particular implementation can either use one cache entry per caching bytecode or can have a caching table with a size depending on the number of caching bytecodes in the script. The former is attractive as it would eliminate the need to check for the pc for the price of bloating each caching bytecode by the entry index. The latter is easier to implement as very little would need to be chnaged in the cache implementation.", "bug_id": 628766}, {"text": "I really like the way WebKit does it (\"the former\"), where basically they start with JSOP_NAME plus some empty space, and then mutate that to JSOP_NAME_FUNCTIONPTR, JSOP_NAME_SLOT, JSOP_NAME_SHAPE, and so on, parameterized by the shape to guard on, slot number, etc.\n\nIt seems like a very fast, simple scheme (no hashtables), very close to what an IC or the tracer does.", "is_private": false, "bug_id": 628766, "id": 5226398, "raw_text": "I really like the way WebKit does it (\"the former\"), where basically they start with JSOP_NAME plus some empty space, and then mutate that to JSOP_NAME_FUNCTIONPTR, JSOP_NAME_SLOT, JSOP_NAME_SHAPE, and so on, parameterized by the shape to guard on, slot number, etc.\n\nIt seems like a very fast, simple scheme (no hashtables), very close to what an IC or the tracer does.", "count": 1, "creation_time": "2011-01-25T20:59:01Z", "tags": [], "time": "2011-01-25T20:59:01Z", "creator": "dmandelin@mozilla.com", "author": "dmandelin@mozilla.com", "attachment_id": null}, {"tags": [], "creation_time": "2011-01-25T22:57:42Z", "is_private": false, "text": "Yeah, with mutable thread- (compartment-, even) local scripts, we can do the same. But IIRC they have a way of not being only monomorphic, yet also not allocating space for 8 or 10 targets for every site. Right?\n\n/be", "id": 5226894, "count": 2, "time": "2011-01-25T22:57:42Z", "author": "brendan@mozilla.org", "creator": "brendan@mozilla.org", "attachment_id": null, "bug_id": 628766, "raw_text": "Yeah, with mutable thread- (compartment-, even) local scripts, we can do the same. But IIRC they have a way of not being only monomorphic, yet also not allocating space for 8 or 10 targets for every site. Right?\n\n/be"}, {"text": "(In reply to comment #2)\n> Yeah, with mutable thread- (compartment-, even) local scripts, we can do the\n> same. But IIRC they have a way of not being only monomorphic, yet also not\n> allocating space for 8 or 10 targets for every site. Right?\n> \n> /be\n\nI think so. I would guess they just allocate an array of targets and store that pointer in the immediate operands area.", "is_private": false, "bug_id": 628766, "raw_text": "(In reply to comment #2)\n> Yeah, with mutable thread- (compartment-, even) local scripts, we can do the\n> same. But IIRC they have a way of not being only monomorphic, yet also not\n> allocating space for 8 or 10 targets for every site. Right?\n> \n> /be\n\nI think so. I would guess they just allocate an array of targets and store that pointer in the immediate operands area.", "count": 3, "id": 5227196, "time": "2011-01-26T00:32:01Z", "author": "dmandelin@mozilla.com", "attachment_id": null, "creator": "dmandelin@mozilla.com", "creation_time": "2011-01-26T00:32:01Z", "tags": []}, {"time": "2011-01-26T00:47:45Z", "attachment_id": null, "creator": "brendan@mozilla.org", "author": "brendan@mozilla.org", "bug_id": 628766, "raw_text": "Yes, last I read through JSC that's exactly what they did.\n\n/be", "tags": [], "creation_time": "2011-01-26T00:47:45Z", "is_private": false, "text": "Yes, last I read through JSC that's exactly what they did.\n\n/be", "count": 4, "id": 5227252}]}}, "comments": {}}