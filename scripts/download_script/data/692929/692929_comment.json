{"comments": {}, "bugs": {"692929": {"comments": [{"author": "sjhworkman@gmail.com", "creation_time": "2011-10-07T20:59:58Z", "time": "2011-10-07T20:59:58Z", "creator": "sjhworkman@gmail.com", "count": 0, "id": 5767885, "is_private": false, "bug_id": 692929, "text": "User Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.7; rv:10.0a1) Gecko/20111007 Firefox/10.0a1\nBuild ID: 20111007031227\n\nSteps to reproduce:\n\nChecking proxy service APIs for bug 390304.\n\n\nActual results:\n\nNot clear if proxy service is available on both child and parent Necko processes.\nHttpChannelChild::GetProxyInfo(nsIProxyInfo **aProxyInfo) implemented to call DROP_DEAD.\n\n\nExpected results:\n\nPending investigation of proxy service initialisation on different platforms, proxy service needs to be available to both child and parent processes, on all platforms.", "tags": [], "raw_text": "User Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.7; rv:10.0a1) Gecko/20111007 Firefox/10.0a1\nBuild ID: 20111007031227\n\nSteps to reproduce:\n\nChecking proxy service APIs for bug 390304.\n\n\nActual results:\n\nNot clear if proxy service is available on both child and parent Necko processes.\nHttpChannelChild::GetProxyInfo(nsIProxyInfo **aProxyInfo) implemented to call DROP_DEAD.\n\n\nExpected results:\n\nPending investigation of proxy service initialisation on different platforms, proxy service needs to be available to both child and parent processes, on all platforms.", "attachment_id": null}, {"attachment_id": null, "raw_text": "Chat Transcript with Jason Duell and Steve Workman:\n\n\n[6:24pm] sworkman: ping\n[6:24pm] jduell: pong\n[6:24pm] sworkman: hey question on e10s\n[6:25pm] sworkman: is nsProtocolProxyService on all procs?\n[6:25pm] sworkman: how do I determine this myself?\n[6:25pm] sworkman: or is it like the DNS Service - only available on parent?\n[6:25pm] jduell: Hmm, i dunno!  Let me poke around...\n[6:25pm] sworkman: k, np\n[6:26pm] sworkman: where would I poke around if I were to find out for myself?\n[6:26pm] sworkman: i.e. where is e10s!! \n[6:26pm] jduell: Well, you could do something like ask for an instance of it when you're on the child--like in HttpChannelChild\n[6:26pm] jduell: but that still might not tell you what you want to know\n[6:26pm] jduell: it might exist there formally but never get used (my suspicion) and not work if you try\n[6:27pm] sworkman: k (HttpChannelChild now makes sense to me - child is e10s related - penny drops, connection made)\n[6:28pm] jduell: Yeah, the terminology was hard to pick--IPDL uses \"channels\" for communication btw parent and child, which made it all confusing when layered on top of necko channels\n[6:28pm] sworkman:  yup\n[6:28pm] sworkman: I had just seen HttpChannelChild and HttpChannel and HttpChannelBase or something like that\n[6:29pm] sworkman: in my very early code explorations\n[6:29pm] sworkman: so, now the suffix child has meaning in that contect\n[6:29pm] sworkman: *context\n[6:29pm] sworkman: yay\n[6:29pm] jduell: Ah, right--so both the channels (child and parent) share a lot of code, which is in HttpBaseChannel\n[6:29pm] sworkman: right\n[6:30pm] jduell: And then there's a nsBaseChannel that was supposed to be the base channel for *all* channels (FTP, Gopher, File, etc) but HTTP never used it\n[6:30pm] jduell: And at this point shouldn't.\n[6:30pm] sworkman: back to proxy service \u2026 am I right in assuming you added the DNS service to parent and not child\n[6:30pm] sworkman: \"added\" meaning configured or setup or whatever\n[6:30pm] sworkman: you're Mr E10s, right?\n[6:31pm] jduell: I'm sort of mr e10s\n[6:31pm] jduell: (I came up with \"e10s\" as the abbreviation for \"electrolysis\": little known folklore)\n[6:31pm] jduell: I'm not sure what you're asking about DNS\n[6:32pm] jduell: We already have it in necko, and we dupe the whole necko stack for the child\n[6:32pm] jduell: i.e. we started by having the child have it's own necko stack--it's own socket transport thread, it's own DNS, everything\n[6:32pm] sworkman: ok \u2026..\n[6:32pm] jduell: And what we've done is gradually shut off parts of it and use IPDL to have the parent do the work\n[6:32pm] sworkman: I'm looking at nsHTMLDNSPrefetch::Prefetch(nsAString &hostname, PRUint16 flags)\n[6:33pm] jduell: This is why I suspect you'll find a \"proxy service\" int he child, but it may or may not do what you want\n[6:33pm] sworkman: which forwards DNS requests to the parent\n[6:33pm] sworkman: ok \u2026 right \u2026 how do I find out if it's been turned off or not?\n[6:33pm] jduell: re: DNS--right--we take all the places where the child wants something from the net, and shovel it off to the parent to do the real work\n[6:33pm] jduell: What do you want from the proxy service, by the way?\n[6:33pm] sworkman: \"is this uri proxies?\"\n[6:33pm] sworkman: *proxied\n[6:34pm] sworkman: or rather\n[6:34pm] sworkman: \"get me proxy info - if it's null, no proxy\"\n[6:35pm] jduell: OK, I think I may have answers for you\n[6:35pm] jduell:\n[6:35pm] sworkman: yay\n[6:36pm] jduell: So, we have a mConnectionInfo variable in HttpBaseChannel\n[6:36pm] jduell: That seems to store the proxy info\n[6:36pm] jduell: AFIACT\n[6:36pm] sworkman: right\n[6:36pm] jduell: when you call nsHttpChannel::GetProxyInfo, that's what you get.\n[6:36pm] sworkman: right\n[6:37pm] jduell: So, at the moment, both child/parent channels have one of those.  And it's being set in HttpBaseChannel::Init\n[6:37pm] sworkman: ah\n[6:37pm] jduell: which is called with a nsProxyInfo arg.\n[6:38pm] jduell: Which is passed in from nsHttpHandler::NewProxiedChannel\n[6:39pm] jduell: which is getting the proxy arg from  nsIOService::NewChannelFromURIWithProxyFlags\n[6:39pm] jduell: which is talking to the proxy protocol service to get the info\n[6:39pm] jduell: mProxyService = do_GetService(NS_PROTOCOLPROXYSERVICE_CONTRACTID);\n[6:39pm] sworkman: k\n[6:40pm] jduell: So, the next question is: where does the proxy service get its info, and is the info in the child the same as in the parent?\n[6:40pm] jduell: I don't know the proxy service well.  Does it get it's info from a file?  In that case we're probably fine just having it duped in the child\n[6:41pm] jduell: But if we're getting info from one of those \"get my proxy info from this URL at startup\" things, there's a good chance that the parent will have the real info\n[6:41pm] jduell: and the child's will be wrong\n[6:41pm] jduell: Which will mean our e10s impl is broken for proxies\n[6:42pm] sworkman: k\n[6:42pm] sworkman: hmm \u2026 I guess I'll play around with it in runtime\n[6:42pm] sworkman: and poke more through the code\n[6:42pm] sworkman: thx!\n[6:42pm] jduell: So you need to poke around and find out how the proxy info gets set, and determine if we need to do something where do_GetService(NS_PROTOCOLPROXYSERVICE_CONTRACTID);\n[6:42pm] sworkman: right\n[6:43pm] jduell: returns a \"fake\"/Child version of the service, which gets the real info from the paret.\n[6:43pm] jduell: Alas, you want to make sure it doesn't ever do a blocking round trip IPDL call, so the obvious solution (send all requests to parent) will not be a happy one (the clients expect the\n[6:43pm] jduell: answer to be sync and instant)\n[6:43pm] sworkman: k \u2026 that (\"fake/child version\") sounds like a good approach\n[6:44pm] jduell: I'd guess you'd be better off having the parent proxy info send a full copy of it's info to the child\n[6:44pm] sworkman: k\n[6:44pm] jduell: So the child version is always 'updated'\n[6:44pm] sworkman: k\n[6:44pm] jduell: Also, I notice that HttpChannelChild::GetProxyInfo is not implemented\n[6:44pm] sworkman: and you said before one time, that e10s is not enabled on the desktop, but is on Adnroid?\n[6:44pm] jduell: It's one of the last spots where we have DROP_DEAD in the code.\n[6:45pm] jduell: So you want to implement that.  The cleanest fix is probably to just move the nsHttpChannel::GetProxyInfo into the HttpBaseChannel class\n[6:45pm] jduell: but that assumes that you can just hand out the mConnectionInfo and things will just \"work\"\n[6:46pm] jduell: which might well be possible (and the easiest fix) if you've got the fake/Child version of the proxy info service working.\n[6:46pm] jduell: In other words, you'll need to figure out where to put Child/Parent objects (and communication), and then the rest of the system looks unchanged.\n[6:46pm] jduell: So far that's always been the easiest way.\n[6:47pm] jduell: And yes, e10s is only in effect for now in mobile firefox (fennec).\n[6:47pm] sworkman: ok cool\n[6:47pm] jduell: If you build --enable-application=mobile on your desktop, you get a simulator that you can debug with\n[6:47pm] sworkman: I think for this bug all I need is to determine how to get the proxy\n[6:47pm] jduell: So you don't need to actually do it on Android\n[6:47pm] jduell: how to get proxy on the child?\n[6:48pm] sworkman: some of what you're saying is more about enabling proxy over e10s\n[6:48pm] sworkman: right, on child or parent : both\n[6:48pm] jduell: Not sure I understand the difference.\n[6:49pm] sworkman: look at nsHTMLDNSPrefetch::Prefetch(Link ...\n[6:49pm] sworkman: there is a call to IsNeckoChild()\n[6:49pm] sworkman: and how the DNS prefetch is requested is different depending on the return val of IsNeckoChild()\n[6:49pm] sworkman: ...\n[6:50pm] sworkman: so, when I'm checking for proxy info, I want to make sure I either:\n[6:50pm] sworkman: 1) have something similar if proxy service is on parent\n[6:50pm] sworkman: 2) don't worry about it because proxy service is everywhere\n[6:50pm] sworkman: or 3) implement something with a simple API like you suggested\n[6:51pm] sworkman: (same API for parent or child; underlying implementation of proxy service takes care of it)\n[6:51pm] sworkman: make sense?\n[6:51pm] jduell: If #2 (proxy is everywhere and has same info on child/parent) then you're done\n[6:51pm] sworkman: right\n[6:52pm] jduell: but I doubt it'll be true in all cases\n[6:52pm] sworkman:\n[6:52pm] sworkman: all platforms?\n[6:52pm] jduell: Prob true if info is read from file, not true if we get it off the net'\n[6:52pm] jduell: Also prob true if we get the info from the OS (IIRC we do that on some systems)\n[6:52pm] sworkman: right - runtime testing and code-poking needed\n[6:52pm] jduell: So really the case to look for is the --damn I forget the buzzwork\n[6:52pm] jduell: buzzword\n[6:53pm] jduell: When you get your proxy info at startup via a URL.\n[6:53pm] sworkman: ?\n[6:53pm] jduell: That's the one I'm worried about.\n[6:53pm] sworkman: ok\n[6:53pm] jduell: If we need to update the child to have the parent' proxy info after that happens, I think the easiest fix is just to add a IPDL msg\n[6:54pm] jduell: that updates the child with the new proxy info (hopefully it's easily serializable)\n[6:54pm] sworkman: right\n[6:54pm] jduell: And then everything can look the exact same otherwise.\n[6:54pm] sworkman: right\n[6:54pm] jduell: We still need to move nsHttpCHannel::GetProxyInfo into HttpBaseChannel.\n[6:54pm] jduell: too\n[6:55pm] jduell: But if that's all the work, that's pretty good.\n[6:55pm] jduell: Hopefully there's no need for really tight synchronization with the proxy info update\n[6:55pm] jduell: I.e. it's fine when the parent gets the proxy info for it to send an async msg to the child and it updates the info, and that's it\n[6:56pm] jduell: as opposed to \"at startup stop the child from issuing any necko channels until we know the proxy info is updated\"\n[6:56pm] jduell: Actually, that might be neeeded \n[6:57pm] jduell: Since when we start the browser now (non-e10s) I assume we have to block channels until we get the correct proxy info (and that's sometimes a fetch of a URI)\n[6:57pm] jduell: make sense?\n[6:57pm] sworkman: \u2026. yes \u2026. processing, but yes ..\n[6:58pm] sworkman: I think I need another bug for this one\n[6:58pm] sworkman: it seems like it needs dedicated, undistracted attention\n[6:58pm] jduell: I suppose there might be a similar need for synchronizing if/when a user changes their proxy info during browsing.  But that's probably a lot easier to be slack about.\n[6:58pm] sworkman: if only just to understand the code on different platforms and confirm correct and desired behavior\n[6:59pm] jduell: They won't really expect things to work until they close the dialog and click a link, which is lots of time for IPDL to update\n[6:59pm] sworkman: q: is ipdl expensive for a simple boolean query?\n[6:59pm] jduell: Feel free to open a new bug: \"Ensure proxy info is same on parent/child\" and cut-and-paste this IRC chat into it.\n[6:59pm] sworkman: I think I will\n[7:00pm] jduell: re: IPDL.  Depends how you do it.\n[7:00pm] sworkman: right - I'm thinking that after I asked the question\n[7:00pm] jduell: If you send an IPDL msg with a bool value, it's certainly tens of 1000s of times more expensive than just updating a bool somewhere (info needs to go down a named pipe to another process,\n[7:00pm] sworkman: I guess if the parent is querying a bool on it's side and able to return immediately, then it's quick\n[7:01pm] jduell: which receives it on the IPDL thread then sends an event to the main thread)\n[7:01pm] sworkman: but if the parent is querying a lot of data, data that might be mutexed/serialised \u2026 then we have potential time delay \u2026 and nasty blocking calls\n[7:01pm] jduell: If you want to *block* while you wait for an answer from the parent, yeah, that's totally expensive, and basically out of the question\n[7:01pm] jduell: Sorry!\n[7:01pm] jduell: Unless there's some really compelling reason why it's hard to engineer it otherwise.\n[7:02pm] sworkman: hehe - no sorry needed - I'll figure it out\n[7:02pm] sworkman: ok - Nick is asking for lunch\n[7:02pm] jduell: That's why I think the \"keep child proxy svc updated with info from parent\" is better than \"ask parent each time for info and block\"\n[7:02pm] sworkman: thx for convo - good info\n[7:02pm] jduell: OK, I think you've got enough info to be dangerous--enjoy!", "tags": [], "bug_id": 692929, "text": "Chat Transcript with Jason Duell and Steve Workman:\n\n\n[6:24pm] sworkman: ping\n[6:24pm] jduell: pong\n[6:24pm] sworkman: hey question on e10s\n[6:25pm] sworkman: is nsProtocolProxyService on all procs?\n[6:25pm] sworkman: how do I determine this myself?\n[6:25pm] sworkman: or is it like the DNS Service - only available on parent?\n[6:25pm] jduell: Hmm, i dunno!  Let me poke around...\n[6:25pm] sworkman: k, np\n[6:26pm] sworkman: where would I poke around if I were to find out for myself?\n[6:26pm] sworkman: i.e. where is e10s!! \n[6:26pm] jduell: Well, you could do something like ask for an instance of it when you're on the child--like in HttpChannelChild\n[6:26pm] jduell: but that still might not tell you what you want to know\n[6:26pm] jduell: it might exist there formally but never get used (my suspicion) and not work if you try\n[6:27pm] sworkman: k (HttpChannelChild now makes sense to me - child is e10s related - penny drops, connection made)\n[6:28pm] jduell: Yeah, the terminology was hard to pick--IPDL uses \"channels\" for communication btw parent and child, which made it all confusing when layered on top of necko channels\n[6:28pm] sworkman:  yup\n[6:28pm] sworkman: I had just seen HttpChannelChild and HttpChannel and HttpChannelBase or something like that\n[6:29pm] sworkman: in my very early code explorations\n[6:29pm] sworkman: so, now the suffix child has meaning in that contect\n[6:29pm] sworkman: *context\n[6:29pm] sworkman: yay\n[6:29pm] jduell: Ah, right--so both the channels (child and parent) share a lot of code, which is in HttpBaseChannel\n[6:29pm] sworkman: right\n[6:30pm] jduell: And then there's a nsBaseChannel that was supposed to be the base channel for *all* channels (FTP, Gopher, File, etc) but HTTP never used it\n[6:30pm] jduell: And at this point shouldn't.\n[6:30pm] sworkman: back to proxy service \u2026 am I right in assuming you added the DNS service to parent and not child\n[6:30pm] sworkman: \"added\" meaning configured or setup or whatever\n[6:30pm] sworkman: you're Mr E10s, right?\n[6:31pm] jduell: I'm sort of mr e10s\n[6:31pm] jduell: (I came up with \"e10s\" as the abbreviation for \"electrolysis\": little known folklore)\n[6:31pm] jduell: I'm not sure what you're asking about DNS\n[6:32pm] jduell: We already have it in necko, and we dupe the whole necko stack for the child\n[6:32pm] jduell: i.e. we started by having the child have it's own necko stack--it's own socket transport thread, it's own DNS, everything\n[6:32pm] sworkman: ok \u2026..\n[6:32pm] jduell: And what we've done is gradually shut off parts of it and use IPDL to have the parent do the work\n[6:32pm] sworkman: I'm looking at nsHTMLDNSPrefetch::Prefetch(nsAString &hostname, PRUint16 flags)\n[6:33pm] jduell: This is why I suspect you'll find a \"proxy service\" int he child, but it may or may not do what you want\n[6:33pm] sworkman: which forwards DNS requests to the parent\n[6:33pm] sworkman: ok \u2026 right \u2026 how do I find out if it's been turned off or not?\n[6:33pm] jduell: re: DNS--right--we take all the places where the child wants something from the net, and shovel it off to the parent to do the real work\n[6:33pm] jduell: What do you want from the proxy service, by the way?\n[6:33pm] sworkman: \"is this uri proxies?\"\n[6:33pm] sworkman: *proxied\n[6:34pm] sworkman: or rather\n[6:34pm] sworkman: \"get me proxy info - if it's null, no proxy\"\n[6:35pm] jduell: OK, I think I may have answers for you\n[6:35pm] jduell:\n[6:35pm] sworkman: yay\n[6:36pm] jduell: So, we have a mConnectionInfo variable in HttpBaseChannel\n[6:36pm] jduell: That seems to store the proxy info\n[6:36pm] jduell: AFIACT\n[6:36pm] sworkman: right\n[6:36pm] jduell: when you call nsHttpChannel::GetProxyInfo, that's what you get.\n[6:36pm] sworkman: right\n[6:37pm] jduell: So, at the moment, both child/parent channels have one of those.  And it's being set in HttpBaseChannel::Init\n[6:37pm] sworkman: ah\n[6:37pm] jduell: which is called with a nsProxyInfo arg.\n[6:38pm] jduell: Which is passed in from nsHttpHandler::NewProxiedChannel\n[6:39pm] jduell: which is getting the proxy arg from  nsIOService::NewChannelFromURIWithProxyFlags\n[6:39pm] jduell: which is talking to the proxy protocol service to get the info\n[6:39pm] jduell: mProxyService = do_GetService(NS_PROTOCOLPROXYSERVICE_CONTRACTID);\n[6:39pm] sworkman: k\n[6:40pm] jduell: So, the next question is: where does the proxy service get its info, and is the info in the child the same as in the parent?\n[6:40pm] jduell: I don't know the proxy service well.  Does it get it's info from a file?  In that case we're probably fine just having it duped in the child\n[6:41pm] jduell: But if we're getting info from one of those \"get my proxy info from this URL at startup\" things, there's a good chance that the parent will have the real info\n[6:41pm] jduell: and the child's will be wrong\n[6:41pm] jduell: Which will mean our e10s impl is broken for proxies\n[6:42pm] sworkman: k\n[6:42pm] sworkman: hmm \u2026 I guess I'll play around with it in runtime\n[6:42pm] sworkman: and poke more through the code\n[6:42pm] sworkman: thx!\n[6:42pm] jduell: So you need to poke around and find out how the proxy info gets set, and determine if we need to do something where do_GetService(NS_PROTOCOLPROXYSERVICE_CONTRACTID);\n[6:42pm] sworkman: right\n[6:43pm] jduell: returns a \"fake\"/Child version of the service, which gets the real info from the paret.\n[6:43pm] jduell: Alas, you want to make sure it doesn't ever do a blocking round trip IPDL call, so the obvious solution (send all requests to parent) will not be a happy one (the clients expect the\n[6:43pm] jduell: answer to be sync and instant)\n[6:43pm] sworkman: k \u2026 that (\"fake/child version\") sounds like a good approach\n[6:44pm] jduell: I'd guess you'd be better off having the parent proxy info send a full copy of it's info to the child\n[6:44pm] sworkman: k\n[6:44pm] jduell: So the child version is always 'updated'\n[6:44pm] sworkman: k\n[6:44pm] jduell: Also, I notice that HttpChannelChild::GetProxyInfo is not implemented\n[6:44pm] sworkman: and you said before one time, that e10s is not enabled on the desktop, but is on Adnroid?\n[6:44pm] jduell: It's one of the last spots where we have DROP_DEAD in the code.\n[6:45pm] jduell: So you want to implement that.  The cleanest fix is probably to just move the nsHttpChannel::GetProxyInfo into the HttpBaseChannel class\n[6:45pm] jduell: but that assumes that you can just hand out the mConnectionInfo and things will just \"work\"\n[6:46pm] jduell: which might well be possible (and the easiest fix) if you've got the fake/Child version of the proxy info service working.\n[6:46pm] jduell: In other words, you'll need to figure out where to put Child/Parent objects (and communication), and then the rest of the system looks unchanged.\n[6:46pm] jduell: So far that's always been the easiest way.\n[6:47pm] jduell: And yes, e10s is only in effect for now in mobile firefox (fennec).\n[6:47pm] sworkman: ok cool\n[6:47pm] jduell: If you build --enable-application=mobile on your desktop, you get a simulator that you can debug with\n[6:47pm] sworkman: I think for this bug all I need is to determine how to get the proxy\n[6:47pm] jduell: So you don't need to actually do it on Android\n[6:47pm] jduell: how to get proxy on the child?\n[6:48pm] sworkman: some of what you're saying is more about enabling proxy over e10s\n[6:48pm] sworkman: right, on child or parent : both\n[6:48pm] jduell: Not sure I understand the difference.\n[6:49pm] sworkman: look at nsHTMLDNSPrefetch::Prefetch(Link ...\n[6:49pm] sworkman: there is a call to IsNeckoChild()\n[6:49pm] sworkman: and how the DNS prefetch is requested is different depending on the return val of IsNeckoChild()\n[6:49pm] sworkman: ...\n[6:50pm] sworkman: so, when I'm checking for proxy info, I want to make sure I either:\n[6:50pm] sworkman: 1) have something similar if proxy service is on parent\n[6:50pm] sworkman: 2) don't worry about it because proxy service is everywhere\n[6:50pm] sworkman: or 3) implement something with a simple API like you suggested\n[6:51pm] sworkman: (same API for parent or child; underlying implementation of proxy service takes care of it)\n[6:51pm] sworkman: make sense?\n[6:51pm] jduell: If #2 (proxy is everywhere and has same info on child/parent) then you're done\n[6:51pm] sworkman: right\n[6:52pm] jduell: but I doubt it'll be true in all cases\n[6:52pm] sworkman:\n[6:52pm] sworkman: all platforms?\n[6:52pm] jduell: Prob true if info is read from file, not true if we get it off the net'\n[6:52pm] jduell: Also prob true if we get the info from the OS (IIRC we do that on some systems)\n[6:52pm] sworkman: right - runtime testing and code-poking needed\n[6:52pm] jduell: So really the case to look for is the --damn I forget the buzzwork\n[6:52pm] jduell: buzzword\n[6:53pm] jduell: When you get your proxy info at startup via a URL.\n[6:53pm] sworkman: ?\n[6:53pm] jduell: That's the one I'm worried about.\n[6:53pm] sworkman: ok\n[6:53pm] jduell: If we need to update the child to have the parent' proxy info after that happens, I think the easiest fix is just to add a IPDL msg\n[6:54pm] jduell: that updates the child with the new proxy info (hopefully it's easily serializable)\n[6:54pm] sworkman: right\n[6:54pm] jduell: And then everything can look the exact same otherwise.\n[6:54pm] sworkman: right\n[6:54pm] jduell: We still need to move nsHttpCHannel::GetProxyInfo into HttpBaseChannel.\n[6:54pm] jduell: too\n[6:55pm] jduell: But if that's all the work, that's pretty good.\n[6:55pm] jduell: Hopefully there's no need for really tight synchronization with the proxy info update\n[6:55pm] jduell: I.e. it's fine when the parent gets the proxy info for it to send an async msg to the child and it updates the info, and that's it\n[6:56pm] jduell: as opposed to \"at startup stop the child from issuing any necko channels until we know the proxy info is updated\"\n[6:56pm] jduell: Actually, that might be neeeded \n[6:57pm] jduell: Since when we start the browser now (non-e10s) I assume we have to block channels until we get the correct proxy info (and that's sometimes a fetch of a URI)\n[6:57pm] jduell: make sense?\n[6:57pm] sworkman: \u2026. yes \u2026. processing, but yes ..\n[6:58pm] sworkman: I think I need another bug for this one\n[6:58pm] sworkman: it seems like it needs dedicated, undistracted attention\n[6:58pm] jduell: I suppose there might be a similar need for synchronizing if/when a user changes their proxy info during browsing.  But that's probably a lot easier to be slack about.\n[6:58pm] sworkman: if only just to understand the code on different platforms and confirm correct and desired behavior\n[6:59pm] jduell: They won't really expect things to work until they close the dialog and click a link, which is lots of time for IPDL to update\n[6:59pm] sworkman: q: is ipdl expensive for a simple boolean query?\n[6:59pm] jduell: Feel free to open a new bug: \"Ensure proxy info is same on parent/child\" and cut-and-paste this IRC chat into it.\n[6:59pm] sworkman: I think I will\n[7:00pm] jduell: re: IPDL.  Depends how you do it.\n[7:00pm] sworkman: right - I'm thinking that after I asked the question\n[7:00pm] jduell: If you send an IPDL msg with a bool value, it's certainly tens of 1000s of times more expensive than just updating a bool somewhere (info needs to go down a named pipe to another process,\n[7:00pm] sworkman: I guess if the parent is querying a bool on it's side and able to return immediately, then it's quick\n[7:01pm] jduell: which receives it on the IPDL thread then sends an event to the main thread)\n[7:01pm] sworkman: but if the parent is querying a lot of data, data that might be mutexed/serialised \u2026 then we have potential time delay \u2026 and nasty blocking calls\n[7:01pm] jduell: If you want to *block* while you wait for an answer from the parent, yeah, that's totally expensive, and basically out of the question\n[7:01pm] jduell: Sorry!\n[7:01pm] jduell: Unless there's some really compelling reason why it's hard to engineer it otherwise.\n[7:02pm] sworkman: hehe - no sorry needed - I'll figure it out\n[7:02pm] sworkman: ok - Nick is asking for lunch\n[7:02pm] jduell: That's why I think the \"keep child proxy svc updated with info from parent\" is better than \"ask parent each time for info and block\"\n[7:02pm] sworkman: thx for convo - good info\n[7:02pm] jduell: OK, I think you've got enough info to be dangerous--enjoy!", "id": 5767894, "count": 1, "is_private": false, "creation_time": "2011-10-07T21:01:40Z", "time": "2011-10-07T21:01:40Z", "creator": "sjhworkman@gmail.com", "author": "sjhworkman@gmail.com"}, {"is_private": false, "id": 12658322, "count": 2, "creator": "bug-husbandry-bot@mozilla.bugs", "time": "2017-09-13T18:37:39Z", "creation_time": "2017-09-13T18:37:39Z", "author": "bug-husbandry-bot@mozilla.bugs", "attachment_id": null, "raw_text": "Bulk change to priority: https://bugzilla.mozilla.org/show_bug.cgi?id=1399258", "tags": [], "text": "Bulk change to priority: https://bugzilla.mozilla.org/show_bug.cgi?id=1399258", "bug_id": 692929}, {"creation_time": "2017-09-13T18:49:44Z", "time": "2017-09-13T18:49:44Z", "creator": "bug-husbandry-bot@mozilla.bugs", "author": "bug-husbandry-bot@mozilla.bugs", "count": 3, "id": 12659878, "is_private": false, "tags": [], "bug_id": 692929, "text": "Bulk change to priority: https://bugzilla.mozilla.org/show_bug.cgi?id=1399258", "attachment_id": null, "raw_text": "Bulk change to priority: https://bugzilla.mozilla.org/show_bug.cgi?id=1399258"}]}}}