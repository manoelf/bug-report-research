{"bugs": {"675685": {"comments": [{"creation_time": "2011-08-01T18:02:45Z", "time": "2011-08-01T18:02:45Z", "creator": "jruderman@gmail.com", "author": "jruderman@gmail.com", "count": 0, "id": 5625743, "is_private": false, "bug_id": 675685, "text": "TextUpdater::DoUpdate seems to be using a Levenshtein distance algorithm that is O(m*n) in both space and time.\n\nAccording to http://en.wikipedia.org/wiki/Levenshtein_distance there are more efficient general algorithms, and also specialized algorithms in cases where \"4 or more\" is an acceptable answer.\n\nI don't know how often this code runs and what the typical input sizes are.", "tags": [], "attachment_id": null, "raw_text": "TextUpdater::DoUpdate seems to be using a Levenshtein distance algorithm that is O(m*n) in both space and time.\n\nAccording to http://en.wikipedia.org/wiki/Levenshtein_distance there are more efficient general algorithms, and also specialized algorithms in cases where \"4 or more\" is an acceptable answer.\n\nI don't know how often this code runs and what the typical input sizes are."}, {"attachment_id": null, "raw_text": "I have following ideas right now:\n1) I can optimise memory usage to O(min(m,n))\n2) to my imagination \"4 or more\" can be generalized into \"N or more\" for any N (using diagonal approach as in wikipedia). If that's a sufficient answer I can code it in O(min(m,n) * (1+N)) (it's a shot, I am guessing I can right now).\n\nIs there a good boundary for N known?\nShould I write any of these or look further?", "bug_id": 675685, "text": "I have following ideas right now:\n1) I can optimise memory usage to O(min(m,n))\n2) to my imagination \"4 or more\" can be generalized into \"N or more\" for any N (using diagonal approach as in wikipedia). If that's a sufficient answer I can code it in O(min(m,n) * (1+N)) (it's a shot, I am guessing I can right now).\n\nIs there a good boundary for N known?\nShould I write any of these or look further?", "tags": [], "count": 1, "id": 6043471, "is_private": false, "time": "2012-02-08T12:38:01Z", "creation_time": "2012-02-08T12:38:01Z", "creator": "andrzej.j.skalski@gmail.com", "author": "andrzej.j.skalski@gmail.com"}, {"tags": [], "bug_id": 675685, "text": "(In reply to Andrzej Skalski from comment #1)\n> I have following ideas right now:\n> 1) I can optimise memory usage to O(min(m,n))\n\nthat's interesting, but I think speed is more important than memory size here assuming we don't create such a big array it won't fit.  That's because either it will be small and short lived and so the exact size doesn't really matter, or it'll be big in which jemalloc should just mmap us a region  which we'll let it unmap fiarly quickly and since its mmaped fragmentation etc shouldn't be an issue.\n\n> 2) to my imagination \"4 or more\" can be generalized into \"N or more\" for any\n> N (using diagonal approach as in wikipedia). If that's a sufficient answer I\n> can code it in O(min(m,n) * (1+N)) (it's a shot, I am guessing I can right\n> now).\n\nis that a space or time bound?  I haven't looked at wikipeida in a while for this and am pretty tired.\n\n> Is there a good boundary for N known?\n\nnot really, theoretically it could be arbitrarily large I think, so perhaps we should keep the max length constant like we do now but make it bigger.\n\n> Should I write any of these or look further?\n\nI'm not really sure off hand, but my suggestion would be to optimize for speed over size.", "raw_text": "(In reply to Andrzej Skalski from comment #1)\n> I have following ideas right now:\n> 1) I can optimise memory usage to O(min(m,n))\n\nthat's interesting, but I think speed is more important than memory size here assuming we don't create such a big array it won't fit.  That's because either it will be small and short lived and so the exact size doesn't really matter, or it'll be big in which jemalloc should just mmap us a region  which we'll let it unmap fiarly quickly and since its mmaped fragmentation etc shouldn't be an issue.\n\n> 2) to my imagination \"4 or more\" can be generalized into \"N or more\" for any\n> N (using diagonal approach as in wikipedia). If that's a sufficient answer I\n> can code it in O(min(m,n) * (1+N)) (it's a shot, I am guessing I can right\n> now).\n\nis that a space or time bound?  I haven't looked at wikipeida in a while for this and am pretty tired.\n\n> Is there a good boundary for N known?\n\nnot really, theoretically it could be arbitrarily large I think, so perhaps we should keep the max length constant like we do now but make it bigger.\n\n> Should I write any of these or look further?\n\nI'm not really sure off hand, but my suggestion would be to optimize for speed over size.", "attachment_id": null, "author": "tbsaunde+mozbugs@tbsaunde.org", "creator": "tbsaunde+mozbugs@tbsaunde.org", "creation_time": "2012-02-08T14:50:30Z", "time": "2012-02-08T14:50:30Z", "is_private": false, "id": 6043718, "count": 2}, {"id": 6043963, "count": 3, "is_private": false, "author": "andrzej.j.skalski@gmail.com", "time": "2012-02-08T16:08:50Z", "creation_time": "2012-02-08T16:08:50Z", "creator": "andrzej.j.skalski@gmail.com", "raw_text": "> is that a space or time bound?\n\nI meant computation time. The memory size should remain linear as well (as I imagine it right now).\n\nI think I propose 2 solutions, one that mimic the present function saving memory, and other that takes additional argument (limit for N) that can be used for a speedup.\n\nI can also write a third function, that returns an approximate result, but in return it will be very fast.\n\nI am generally very flexible with algorithms, if you see some paper on revolutionary solution I am not aware of just let me know :)", "attachment_id": null, "tags": [], "text": "> is that a space or time bound?\n\nI meant computation time. The memory size should remain linear as well (as I imagine it right now).\n\nI think I propose 2 solutions, one that mimic the present function saving memory, and other that takes additional argument (limit for N) that can be used for a speedup.\n\nI can also write a third function, that returns an approximate result, but in return it will be very fast.\n\nI am generally very flexible with algorithms, if you see some paper on revolutionary solution I am not aware of just let me know :)", "bug_id": 675685}, {"count": 4, "id": 6046636, "is_private": false, "time": "2012-02-09T10:18:10Z", "creation_time": "2012-02-09T10:18:10Z", "creator": "surkov.alexander@gmail.com", "author": "surkov.alexander@gmail.com", "attachment_id": null, "raw_text": "(In reply to Andrzej Skalski from comment #3)\n> > is that a space or time bound?\n> \n> I meant computation time. The memory size should remain linear as well (as I\n> imagine it right now).\n> \n> I think I propose 2 solutions, one that mimic the present function saving\n> memory, and other that takes additional argument (limit for N) that can be\n> used for a speedup.\n\nI don't think we can have a limit for N if N is a distance\n\n> I can also write a third function, that returns an approximate result, but\n> in return it will be very fast.\n\nwhat does approximate result mean exactly?", "text": "(In reply to Andrzej Skalski from comment #3)\n> > is that a space or time bound?\n> \n> I meant computation time. The memory size should remain linear as well (as I\n> imagine it right now).\n> \n> I think I propose 2 solutions, one that mimic the present function saving\n> memory, and other that takes additional argument (limit for N) that can be\n> used for a speedup.\n\nI don't think we can have a limit for N if N is a distance\n\n> I can also write a third function, that returns an approximate result, but\n> in return it will be very fast.\n\nwhat does approximate result mean exactly?", "bug_id": 675685, "tags": []}, {"attachment_id": null, "raw_text": "\n> I don't think we can have a limit for N if N is a distance\n\nThen I guess all we're left with is classic approach with some minor optimizations (constant time factor). I am still waiting for e-mail answer from someone who PHDs in such stuff.\n\n> what does approximate result mean exactly?\n\nI was thinking about http://people.csail.mit.edu/konak/papers/approximating_edit_distance.html, but now that I browse it, I don't think it's practically implementable. I would take weeks to do it right, and still I don't know what would be numerical errors.\n\nI can google further or take #1 option.", "tags": [], "bug_id": 675685, "text": "\n> I don't think we can have a limit for N if N is a distance\n\nThen I guess all we're left with is classic approach with some minor optimizations (constant time factor). I am still waiting for e-mail answer from someone who PHDs in such stuff.\n\n> what does approximate result mean exactly?\n\nI was thinking about http://people.csail.mit.edu/konak/papers/approximating_edit_distance.html, but now that I browse it, I don't think it's practically implementable. I would take weeks to do it right, and still I don't know what would be numerical errors.\n\nI can google further or take #1 option.", "count": 5, "id": 6046838, "is_private": false, "time": "2012-02-09T13:02:44Z", "creation_time": "2012-02-09T13:02:44Z", "creator": "andrzej.j.skalski@gmail.com", "author": "andrzej.j.skalski@gmail.com"}, {"count": 6, "id": 6055418, "is_private": false, "creation_time": "2012-02-13T09:16:45Z", "time": "2012-02-13T09:16:45Z", "creator": "andrzej.j.skalski@gmail.com", "author": "andrzej.j.skalski@gmail.com", "attachment_id": null, "raw_text": "I contacted to doctors specialized in text algorithms, one of the authors of linked MIT paper among them, and they both told me that approximation algorithms are purely theoretical. Also, there is a O(m*n / log(n)) exact algorithm, but I was told it's non-practical as well.\n\nWhat can be done is:\n- Reduce memory usage to linear O(min(m,n))\n- Reduce computational time to O(min(n,m) * d) where d is distance\n- Change entire computation to O(n + d^2), which is very fast for similar strings (LED < sqrt(n) ).\n- Finish a computation earlier if we use LED for decision making only (for example if(LED > max_D) we can compute LED only to known limit)\n\nSome more theoretical stuff:\n- I heard about algorithm that works in O((n+m)*(min(n,m) - d)) which would be fast for very different strings (waiting for a document to check if that's not a typo)\n- I proposed merging the two above to get one working for both cases, but I guess that's something another PhD can be made of. I am waiting right now to get Professors's feedback whether that's doable.\n\nMy suggestion:\nDo first two reductions, and the fourth one if possible.", "text": "I contacted to doctors specialized in text algorithms, one of the authors of linked MIT paper among them, and they both told me that approximation algorithms are purely theoretical. Also, there is a O(m*n / log(n)) exact algorithm, but I was told it's non-practical as well.\n\nWhat can be done is:\n- Reduce memory usage to linear O(min(m,n))\n- Reduce computational time to O(min(n,m) * d) where d is distance\n- Change entire computation to O(n + d^2), which is very fast for similar strings (LED < sqrt(n) ).\n- Finish a computation earlier if we use LED for decision making only (for example if(LED > max_D) we can compute LED only to known limit)\n\nSome more theoretical stuff:\n- I heard about algorithm that works in O((n+m)*(min(n,m) - d)) which would be fast for very different strings (waiting for a document to check if that's not a typo)\n- I proposed merging the two above to get one working for both cases, but I guess that's something another PhD can be made of. I am waiting right now to get Professors's feedback whether that's doable.\n\nMy suggestion:\nDo first two reductions, and the fourth one if possible.", "bug_id": 675685, "tags": []}, {"is_private": false, "count": 7, "id": 6055448, "author": "tbsaunde+mozbugs@tbsaunde.org", "creator": "tbsaunde+mozbugs@tbsaunde.org", "time": "2012-02-13T09:39:48Z", "creation_time": "2012-02-13T09:39:48Z", "raw_text": "(In reply to Andrzej Skalski from comment #6)\n> I contacted to doctors specialized in text algorithms, one of the authors of\n> linked MIT paper among them, and they both told me that approximation\n> algorithms are purely theoretical. Also, there is a O(m*n / log(n)) exact\n> algorithm, but I was told it's non-practical as well.\n\nok\n\n> What can be done is:\n> - Reduce memory usage to linear O(min(m,n))\n> - Reduce computational time to O(min(n,m) * d) where d is distance\n\nthat'd be great\n\n> - Change entire computation to O(n + d^2), which is very fast for similar\n> strings (LED < sqrt(n) ).\n\nits probably very often true that the edit distance is small,  one big case of this is typeing or deleting characters.\n\n> - Finish a computation earlier if we use LED for decision making only (for\n> example if(LED > max_D) we can compute LED only to known limit)\n\nWell, whatever algorithm we use I think we'll need to keep the bailout we currently have for big  computations to just fire delete and insert events for the whole strings.  So this might be useful.\n\n> My suggestion:\n> Do first two reductions, and the fourth one if possible.\n\nthat sounds fine.  optimizing this is  good, but probably not the most important thing to work on optimizing right now.", "attachment_id": null, "tags": [], "bug_id": 675685, "text": "(In reply to Andrzej Skalski from comment #6)\n> I contacted to doctors specialized in text algorithms, one of the authors of\n> linked MIT paper among them, and they both told me that approximation\n> algorithms are purely theoretical. Also, there is a O(m*n / log(n)) exact\n> algorithm, but I was told it's non-practical as well.\n\nok\n\n> What can be done is:\n> - Reduce memory usage to linear O(min(m,n))\n> - Reduce computational time to O(min(n,m) * d) where d is distance\n\nthat'd be great\n\n> - Change entire computation to O(n + d^2), which is very fast for similar\n> strings (LED < sqrt(n) ).\n\nits probably very often true that the edit distance is small,  one big case of this is typeing or deleting characters.\n\n> - Finish a computation earlier if we use LED for decision making only (for\n> example if(LED > max_D) we can compute LED only to known limit)\n\nWell, whatever algorithm we use I think we'll need to keep the bailout we currently have for big  computations to just fire delete and insert events for the whole strings.  So this might be useful.\n\n> My suggestion:\n> Do first two reductions, and the fourth one if possible.\n\nthat sounds fine.  optimizing this is  good, but probably not the most important thing to work on optimizing right now."}, {"bug_id": 675685, "text": "(In reply to Trevor Saunders (:tbsaunde) from comment #7)\n\n> > - Change entire computation to O(n + d^2), which is very fast for similar\n> > strings (LED < sqrt(n) ).\n> \n> its probably very often true that the edit distance is small,  one big case\n> of this is typeing or deleting characters.\n\nit can be big for text replacement. we don't run Levenshtein algorithm for those and as you said it makes sense to keep it since 99% percents I think it's running for equal strings, single insertion or deletion.\n\n> > My suggestion:\n> > Do first two reductions, and the fourth one if possible.\n> \n> that sounds fine.  optimizing this is  good, but probably not the most\n> important thing to work on optimizing right now.\n\nagree", "tags": [], "raw_text": "(In reply to Trevor Saunders (:tbsaunde) from comment #7)\n\n> > - Change entire computation to O(n + d^2), which is very fast for similar\n> > strings (LED < sqrt(n) ).\n> \n> its probably very often true that the edit distance is small,  one big case\n> of this is typeing or deleting characters.\n\nit can be big for text replacement. we don't run Levenshtein algorithm for those and as you said it makes sense to keep it since 99% percents I think it's running for equal strings, single insertion or deletion.\n\n> > My suggestion:\n> > Do first two reductions, and the fourth one if possible.\n> \n> that sounds fine.  optimizing this is  good, but probably not the most\n> important thing to work on optimizing right now.\n\nagree", "attachment_id": null, "author": "surkov.alexander@gmail.com", "time": "2012-02-14T01:20:43Z", "creation_time": "2012-02-14T01:20:43Z", "creator": "surkov.alexander@gmail.com", "id": 6058380, "count": 8, "is_private": false}, {"author": "andrzej.j.skalski@gmail.com", "creation_time": "2012-02-14T10:15:51Z", "time": "2012-02-14T10:15:51Z", "creator": "andrzej.j.skalski@gmail.com", "id": 6059160, "count": 9, "is_private": false, "text": "\n> > its probably very often true that the edit distance is small,  one big case\n> > of this is typeing or deleting characters.\n> \n> it can be big for text replacement. we don't run Levenshtein algorithm for\n> those and as you said it makes sense to keep it since 99% percents I think\n> it's running for equal strings, single insertion or deletion.\n> \n\nWell, at http://en.wikipedia.org/wiki/Levenshtein_distance#Upper_and_lower_bounds it's written, that:\n\n|m - n| <= d <= max(m,n), so the only situation in which this algorithm is actually slower is if you replace a short string with a very long one, totally different, and d = len(new_text). In most situation, the d square actually fits within O(m*n) rectangle. It's pretty much like with qsort - the worst case scenario is n^2, but do we really care?\nI say \"implement both, check which one performs better\".\n\n> > > My suggestion:\n> > > Do first two reductions, and the fourth one if possible.\n> > \n> > that sounds fine.  optimizing this is  good, but probably not the most\n> > important thing to work on optimizing right now.\n> \n> agree", "bug_id": 675685, "tags": [], "raw_text": "\n> > its probably very often true that the edit distance is small,  one big case\n> > of this is typeing or deleting characters.\n> \n> it can be big for text replacement. we don't run Levenshtein algorithm for\n> those and as you said it makes sense to keep it since 99% percents I think\n> it's running for equal strings, single insertion or deletion.\n> \n\nWell, at http://en.wikipedia.org/wiki/Levenshtein_distance#Upper_and_lower_bounds it's written, that:\n\n|m - n| <= d <= max(m,n), so the only situation in which this algorithm is actually slower is if you replace a short string with a very long one, totally different, and d = len(new_text). In most situation, the d square actually fits within O(m*n) rectangle. It's pretty much like with qsort - the worst case scenario is n^2, but do we really care?\nI say \"implement both, check which one performs better\".\n\n> > > My suggestion:\n> > > Do first two reductions, and the fourth one if possible.\n> > \n> > that sounds fine.  optimizing this is  good, but probably not the most\n> > important thing to work on optimizing right now.\n> \n> agree", "attachment_id": null}, {"is_private": false, "id": 6067901, "count": 10, "creator": "andrzej.j.skalski@gmail.com", "time": "2012-02-16T18:11:06Z", "creation_time": "2012-02-16T18:11:06Z", "author": "andrzej.j.skalski@gmail.com", "attachment_id": 597878, "raw_text": "It's just a prove of concept. To reach it's full performance, \"slide\" function needs to be replaced with TRIE tree. File contains implementation of naive version as well, for testing purposes.\n\nLook for sources in the header to understand code, comments would be useless at this level of abstraction.", "tags": [], "text": "Created attachment 597878\nproof-of-concept of proposed algorithm, non-optimised, just corectness\n\nIt's just a prove of concept. To reach it's full performance, \"slide\" function needs to be replaced with TRIE tree. File contains implementation of naive version as well, for testing purposes.\n\nLook for sources in the header to understand code, comments would be useless at this level of abstraction.", "bug_id": 675685}, {"is_private": false, "count": 11, "id": 6068092, "creator": "andrzej.j.skalski@gmail.com", "creation_time": "2012-02-16T18:54:48Z", "time": "2012-02-16T18:54:48Z", "author": "andrzej.j.skalski@gmail.com", "attachment_id": null, "raw_text": "I have proof-of-concept, the memory consumption can be cut to linear right now (from vector lhd I actually need only previous row which never gets wider than O(min(m,n)) ). I still need to write a suffix tree to get full performance.\n\nAnd here is my question:\n1) is there a special character I could use as \"outside the alphabet\" symbol? It's typical concept in text algorithms, but I am not sure what are capabilities of nsAString?\n2) is there any size limit on nsAString? Right now I rely on \"infinity\" value, and would like to keep it this way.", "bug_id": 675685, "text": "I have proof-of-concept, the memory consumption can be cut to linear right now (from vector lhd I actually need only previous row which never gets wider than O(min(m,n)) ). I still need to write a suffix tree to get full performance.\n\nAnd here is my question:\n1) is there a special character I could use as \"outside the alphabet\" symbol? It's typical concept in text algorithms, but I am not sure what are capabilities of nsAString?\n2) is there any size limit on nsAString? Right now I rely on \"infinity\" value, and would like to keep it this way.", "tags": []}, {"time": "2012-02-16T19:30:49Z", "creation_time": "2012-02-16T19:30:49Z", "creator": "tbsaunde+mozbugs@tbsaunde.org", "author": "tbsaunde+mozbugs@tbsaunde.org", "id": 6068227, "count": 12, "is_private": false, "tags": [], "text": "> And here is my question:\n> 1) is there a special character I could use as \"outside the alphabet\"\n> symbol? It's typical concept in text algorithms, but I am not sure what are\n> capabilities of nsAString?\n\nI'm not aware of one, but  they're usually just buffers of utf16 code points.  You're probably safe horking one of the ascii control code things.\n\n> 2) is there any size limit on nsAString? Right now I rely on \"infinity\"\n> value, and would like to keep it this way.\n\nwell, its stores the length internally as a 32 bit int so certainly no longer than that, and I'm a little scared what happens if we have a string longer than 2^31 or so", "bug_id": 675685, "attachment_id": null, "raw_text": "> And here is my question:\n> 1) is there a special character I could use as \"outside the alphabet\"\n> symbol? It's typical concept in text algorithms, but I am not sure what are\n> capabilities of nsAString?\n\nI'm not aware of one, but  they're usually just buffers of utf16 code points.  You're probably safe horking one of the ascii control code things.\n\n> 2) is there any size limit on nsAString? Right now I rely on \"infinity\"\n> value, and would like to keep it this way.\n\nwell, its stores the length internally as a 32 bit int so certainly no longer than that, and I'm a little scared what happens if we have a string longer than 2^31 or so"}, {"attachment_id": null, "raw_text": "update:\n\nI wrote the algorithm from:\nhttp://cs.haifa.ac.il/LANDAU/gadi/LMS.ps , pages (1-8)\nand now it works in time O(md) (as in unix diff), this is implementation in proof-of-concept\n\nthe way to upgrade it to O(n + d^d) is to replace slide() method in code (which is naive Longest Common Extension problem solution) with something that runs in a constant time. I did experiments with original Ukkonen algorithm, as proposed in paper, and after several hours of fighting, I googled this:\n\nhttp://www.mat.unb.br/~ayala/lvsaANDrmq.pdf\n\nThis reduces LCE problem to Range Minimum Query, which is further solved in O(1) time with Cartesian Trees. After hours of experiments, I abandon suffix tree approach, and redesign the code to work with this idea.", "bug_id": 675685, "text": "update:\n\nI wrote the algorithm from:\nhttp://cs.haifa.ac.il/LANDAU/gadi/LMS.ps , pages (1-8)\nand now it works in time O(md) (as in unix diff), this is implementation in proof-of-concept\n\nthe way to upgrade it to O(n + d^d) is to replace slide() method in code (which is naive Longest Common Extension problem solution) with something that runs in a constant time. I did experiments with original Ukkonen algorithm, as proposed in paper, and after several hours of fighting, I googled this:\n\nhttp://www.mat.unb.br/~ayala/lvsaANDrmq.pdf\n\nThis reduces LCE problem to Range Minimum Query, which is further solved in O(1) time with Cartesian Trees. After hours of experiments, I abandon suffix tree approach, and redesign the code to work with this idea.", "tags": [], "count": 13, "id": 6078093, "is_private": false, "creation_time": "2012-02-21T11:12:27Z", "time": "2012-02-21T11:12:27Z", "creator": "andrzej.j.skalski@gmail.com", "author": "andrzej.j.skalski@gmail.com"}, {"time": "2012-02-23T16:58:02Z", "creation_time": "2012-02-23T16:58:02Z", "creator": "andrzej.j.skalski@gmail.com", "tags": [], "text": "Ok, I gave up with suffix trees and suffix arrays for this week, and I would like to port a current approach ( O(d*min(m,n)) pesimistic O(n + d^2) expected time) as a patch. I optimized memory usage to O(max(m,n)) with only 2 allocations. I think the best way is to add a new class that calculates this LED (for code clarity and further extensions). Where should I put this class?", "bug_id": 675685, "author": "andrzej.j.skalski@gmail.com", "id": 6086802, "count": 14, "attachment_id": null, "is_private": false, "raw_text": "Ok, I gave up with suffix trees and suffix arrays for this week, and I would like to port a current approach ( O(d*min(m,n)) pesimistic O(n + d^2) expected time) as a patch. I optimized memory usage to O(max(m,n)) with only 2 allocations. I think the best way is to add a new class that calculates this LED (for code clarity and further extensions). Where should I put this class?"}, {"raw_text": "", "attachment_id": 600043, "tags": [], "bug_id": 675685, "text": "Created attachment 600043\nsame proof-of-concept, but with memory optimisation. still correct :)", "is_private": false, "id": 6086820, "count": 15, "author": "andrzej.j.skalski@gmail.com", "creator": "andrzej.j.skalski@gmail.com", "creation_time": "2012-02-23T17:01:39Z", "time": "2012-02-23T17:01:39Z"}, {"author": "surkov.alexander@gmail.com", "creator": "surkov.alexander@gmail.com", "time": "2012-02-24T05:06:56Z", "creation_time": "2012-02-24T05:06:56Z", "is_private": false, "id": 6089207, "count": 16, "bug_id": 675685, "text": "(In reply to Andrzej Skalski from comment #14)\n> Ok, I gave up with suffix trees and suffix arrays for this week, and I would\n> like to port a current approach ( O(d*min(m,n)) pesimistic O(n + d^2)\n> expected time) as a patch. I optimized memory usage to O(max(m,n)) with only\n> 2 allocations. I think the best way is to add a new class that calculates\n> this LED (for code clarity and further extensions). Where should I put this\n> class?\n\nunder TextUpdater where the diff is calculated now. Do you like to keep new and old logic the same time?", "tags": [], "raw_text": "(In reply to Andrzej Skalski from comment #14)\n> Ok, I gave up with suffix trees and suffix arrays for this week, and I would\n> like to port a current approach ( O(d*min(m,n)) pesimistic O(n + d^2)\n> expected time) as a patch. I optimized memory usage to O(max(m,n)) with only\n> 2 allocations. I think the best way is to add a new class that calculates\n> this LED (for code clarity and further extensions). Where should I put this\n> class?\n\nunder TextUpdater where the diff is calculated now. Do you like to keep new and old logic the same time?", "attachment_id": null}, {"raw_text": "", "attachment_id": 601346, "text": "Created attachment 601346\ncorrected proof-of-concept (avoid unnecessary computation)", "bug_id": 675685, "tags": [], "id": 6100002, "count": 17, "is_private": false, "author": "andrzej.j.skalski@gmail.com", "creation_time": "2012-02-28T19:28:45Z", "time": "2012-02-28T19:28:45Z", "creator": "andrzej.j.skalski@gmail.com"}, {"creator": "andrzej.j.skalski@gmail.com", "creation_time": "2012-03-05T18:05:59Z", "time": "2012-03-05T18:05:59Z", "author": "andrzej.j.skalski@gmail.com", "is_private": false, "id": 6114738, "count": 18, "bug_id": 675685, "text": "Created attachment 602953\nfixed uninitialized memory bug (condition h >= resdiag) and some additions", "tags": [], "attachment_id": 602953, "raw_text": ""}, {"time": "2012-03-09T19:40:09Z", "creation_time": "2012-03-09T19:40:09Z", "creator": "andrzej.j.skalski@gmail.com", "author": "andrzej.j.skalski@gmail.com", "count": 19, "id": 6128302, "is_private": false, "tags": [], "text": "Created attachment 604480\nsame algorithm, now I successfully extract all data needed to get events generated", "bug_id": 675685, "attachment_id": 604480, "raw_text": ""}, {"raw_text": "While trying to extract events from the calculated matrix, I found out that I will most probably need all immediate informations as calculated in a first attachment (though probably better stored). The example that shows precisely why is:\n\nstring 1: dupa\nstring 2: bisdupxa or bisduxpa\n\nno matter what string second is, the diagonal_substitution and horizontal_translation looks the same, and the commands to turn string1 into string2 will differ. The reason is complex - basically a long diagonal slide might not necessarily indicate a string alignment, but may be a result of an alignment on some neighboring diagonal.\n\nUnfortunately storing all \"lhd\" values require O(d^2) space. Since we don't know d while calculating, we can either do max(m,n)^2 worst-case in single allocation, or use std::vector -like approach to do save up memory by switching to dynamic allocation.\n\nI pause my work on LED right now hoping I will get some better ideas.", "attachment_id": null, "tags": [], "bug_id": 675685, "text": "While trying to extract events from the calculated matrix, I found out that I will most probably need all immediate informations as calculated in a first attachment (though probably better stored). The example that shows precisely why is:\n\nstring 1: dupa\nstring 2: bisdupxa or bisduxpa\n\nno matter what string second is, the diagonal_substitution and horizontal_translation looks the same, and the commands to turn string1 into string2 will differ. The reason is complex - basically a long diagonal slide might not necessarily indicate a string alignment, but may be a result of an alignment on some neighboring diagonal.\n\nUnfortunately storing all \"lhd\" values require O(d^2) space. Since we don't know d while calculating, we can either do max(m,n)^2 worst-case in single allocation, or use std::vector -like approach to do save up memory by switching to dynamic allocation.\n\nI pause my work on LED right now hoping I will get some better ideas.", "is_private": false, "id": 6154748, "count": 20, "author": "andrzej.j.skalski@gmail.com", "creator": "andrzej.j.skalski@gmail.com", "time": "2012-03-20T12:01:07Z", "creation_time": "2012-03-20T12:01:07Z"}]}}, "comments": {}}