{"comments": {}, "bugs": {"653895": {"comments": [{"id": 5440950, "time": "2011-04-30T04:10:56Z", "tags": [], "creation_time": "2011-04-30T04:10:56Z", "bug_id": 653895, "raw_text": "Sometimes we can end up with cached text and selection indexes that are out of sync with each other. The most common scenario is while adding text - the selection is correct but the text hasn't updated, so the selection is out of bounds. This caused bug 617298.", "is_private": false, "text": "Sometimes we can end up with cached text and selection indexes that are out of sync with each other. The most common scenario is while adding text - the selection is correct but the text hasn't updated, so the selection is out of bounds. This caused bug 617298.", "count": 0, "author": "mwu.code@gmail.com", "creator": "mwu.code@gmail.com", "attachment_id": null}, {"time": "2011-04-30T04:51:51Z", "id": 5440975, "is_private": false, "raw_text": "Does anyone understand well why we have inconsistent indices/text?  Is the inconsistent data in the java stuff or gecko?  (I think gecko, right?)  In theory I don't think any IMEs should be able to observe us \"cheating\" if we play our cards right.", "bug_id": 653895, "creation_time": "2011-04-30T04:51:51Z", "tags": [], "author": "cjones.bugs@gmail.com", "text": "Does anyone understand well why we have inconsistent indices/text?  Is the inconsistent data in the java stuff or gecko?  (I think gecko, right?)  In theory I don't think any IMEs should be able to observe us \"cheating\" if we play our cards right.", "count": 1, "attachment_id": null, "creator": "cjones.bugs@gmail.com"}, {"id": 5440985, "time": "2011-04-30T05:03:55Z", "is_private": false, "tags": [], "bug_id": 653895, "creation_time": "2011-04-30T05:03:55Z", "raw_text": "There is at least one inconsistency (which this patch https://bug617298.bugzilla.mozilla.org/attachment.cgi?id=526345 attempts to fix) where async calls from chrome to content set state and the getters that read that state get processed before all the callbacks that update the cached state  (mIMESelectionAnchor, mIMESelectionFocus and mIMECacheText) get called.\n\nThat patch seemed to fix the problem of things getting out of sync when adding text, but then we were getting bit occasionally when deleting text with the swift keyboard, so either this is an incomplete fix or there is some other state inconsistency.", "author": "lassey@chromium.org", "text": "There is at least one inconsistency (which this patch https://bug617298.bugzilla.mozilla.org/attachment.cgi?id=526345 attempts to fix) where async calls from chrome to content set state and the getters that read that state get processed before all the callbacks that update the cached state  (mIMESelectionAnchor, mIMESelectionFocus and mIMECacheText) get called.\n\nThat patch seemed to fix the problem of things getting out of sync when adding text, but then we were getting bit occasionally when deleting text with the swift keyboard, so either this is an incomplete fix or there is some other state inconsistency.", "count": 2, "attachment_id": null, "creator": "lassey@chromium.org"}, {"author": "cjones.bugs@gmail.com", "time": "2011-04-30T05:23:52Z", "id": 5440994, "count": 3, "text": "OK, that makes more sense.  I'm still not 100% clear about the java/gecko interaction here --- if you've got this information, do you mind diagramming the information flow between java/chrome/content?  It sounds like this is a race condition, and nailing down where that's happening would help in designing a fix.", "is_private": false, "attachment_id": null, "raw_text": "OK, that makes more sense.  I'm still not 100% clear about the java/gecko interaction here --- if you've got this information, do you mind diagramming the information flow between java/chrome/content?  It sounds like this is a race condition, and nailing down where that's happening would help in designing a fix.", "bug_id": 653895, "creation_time": "2011-04-30T05:23:52Z", "creator": "cjones.bugs@gmail.com", "tags": []}, {"text": "Brad and I chatted about this a bit on IRC.  It looks like we have two classes of race conditions that are leading to race conditions, which cause us to present inconsistent data to IMEs: first, our Java thread forwards \"set selection\" and \"set text\" and other IME state changes to chrome as the Java thread finds out about them.  These state changes are forwarded from chrome to content as they come in, and content responds to them by updating the cached chrome state as it can process them.  Because state queries from the java thread can come in at any point during the chrome<->content updates, the java thread and IMEs can observe inconsistent cached values.  This problem was causing the crash in SwiftKey.\n\nTo fix this, I think we need\n (1) Treat IME sets/queries as \"transactions\" on the Java thread, in order to present consistent state to IMEs.  This requires\n   - grab a consistent snapshot of IME state in chrome upon first IME action on the java thread\n   - present a consistent view of IME state to IMEs during subsequent actions within the same java-event-loop iteration on the java thread\n   - at the end of the java-event-loop iteration, forward a changeset encapsulating proposed state changes to the chrome thread\n (2) Resolve conflicting IME changesets atomically on the chrome thread, forward them atomically to content, and have content update chrome atomically after resolution\n\nIf we do this, it will be possible for IMEs to observe stale state, but that state will be consistent while the IME is doing stuff.\n\nI think we can achieve this through the following mechanisms\n (i) observe (somehow) when the java thread starts processing events, and observe when it drops back into the event loop.  Brad tells me that we can implement our own event loop.  That should work here.\n (ii) when the java thread notices IME action starting, grab a consistent snapshot of all IME state from chrome.  This could be called the start of an IME transaction. (We may or may not want to block content on the end of the IME transaction.  Unclear atm.)\n (iii) when the java-thread IME transaction ends, forward the updated state atomically to chrome\n (iv) in chrome, resolve conflicts in content updates somehow.  This part isn't clear.  What we do now may be sufficient.\n (v) if the java-thread state changes resolve, forward them to content atomically\n (vi) process state changes atomically in content\n (vii) forward state updates from content->chrome atomically\n\n(i) isn't clear to me.  Brad, how would we implement our own java event loop?\nThe heuristics for (iv) aren't clear, but should be easy to twiddle.\n(v)-(vii) can be done relatively easy in our existing code.\n\nBrad also implied in our chat that IMEs actually only have well-known interactions with our java thread, so fully recorded transactions may not be needed.  But if that's easy enough to implement, that seems to be the way to go IMHO.\n\nDid I understand correctly?  How does this proposal sound?", "count": 4, "id": 5441059, "time": "2011-04-30T08:33:47Z", "author": "cjones.bugs@gmail.com", "tags": [], "creator": "cjones.bugs@gmail.com", "bug_id": 653895, "creation_time": "2011-04-30T08:33:47Z", "raw_text": "Brad and I chatted about this a bit on IRC.  It looks like we have two classes of race conditions that are leading to race conditions, which cause us to present inconsistent data to IMEs: first, our Java thread forwards \"set selection\" and \"set text\" and other IME state changes to chrome as the Java thread finds out about them.  These state changes are forwarded from chrome to content as they come in, and content responds to them by updating the cached chrome state as it can process them.  Because state queries from the java thread can come in at any point during the chrome<->content updates, the java thread and IMEs can observe inconsistent cached values.  This problem was causing the crash in SwiftKey.\n\nTo fix this, I think we need\n (1) Treat IME sets/queries as \"transactions\" on the Java thread, in order to present consistent state to IMEs.  This requires\n   - grab a consistent snapshot of IME state in chrome upon first IME action on the java thread\n   - present a consistent view of IME state to IMEs during subsequent actions within the same java-event-loop iteration on the java thread\n   - at the end of the java-event-loop iteration, forward a changeset encapsulating proposed state changes to the chrome thread\n (2) Resolve conflicting IME changesets atomically on the chrome thread, forward them atomically to content, and have content update chrome atomically after resolution\n\nIf we do this, it will be possible for IMEs to observe stale state, but that state will be consistent while the IME is doing stuff.\n\nI think we can achieve this through the following mechanisms\n (i) observe (somehow) when the java thread starts processing events, and observe when it drops back into the event loop.  Brad tells me that we can implement our own event loop.  That should work here.\n (ii) when the java thread notices IME action starting, grab a consistent snapshot of all IME state from chrome.  This could be called the start of an IME transaction. (We may or may not want to block content on the end of the IME transaction.  Unclear atm.)\n (iii) when the java-thread IME transaction ends, forward the updated state atomically to chrome\n (iv) in chrome, resolve conflicts in content updates somehow.  This part isn't clear.  What we do now may be sufficient.\n (v) if the java-thread state changes resolve, forward them to content atomically\n (vi) process state changes atomically in content\n (vii) forward state updates from content->chrome atomically\n\n(i) isn't clear to me.  Brad, how would we implement our own java event loop?\nThe heuristics for (iv) aren't clear, but should be easy to twiddle.\n(v)-(vii) can be done relatively easy in our existing code.\n\nBrad also implied in our chat that IMEs actually only have well-known interactions with our java thread, so fully recorded transactions may not be needed.  But if that's easy enough to implement, that seems to be the way to go IMHO.\n\nDid I understand correctly?  How does this proposal sound?", "is_private": false, "attachment_id": null}, {"time": "2011-06-16T16:48:53Z", "id": 5536877, "raw_text": "so the idea with this patch is to remove the getting GeckoEvents for text and selection and to always have the results of setter events return synchronously. Since the java main thread isn't the gecko main thread, we can legally block it waiting for the child process to respond.\n\nHaving gone through this less intrusive alternative is also possible in that the getters are called synchronously on the java thread (i.e. not using events) and the getter functions can block the java main thread on the child process. I'm going to go through and implement that approach next and we can see which one is less messy.", "creation_time": "2011-06-16T16:48:53Z", "bug_id": 653895, "tags": [], "is_private": false, "count": 5, "text": "Created attachment 539813\nWIP patch\n\nso the idea with this patch is to remove the getting GeckoEvents for text and selection and to always have the results of setter events return synchronously. Since the java main thread isn't the gecko main thread, we can legally block it waiting for the child process to respond.\n\nHaving gone through this less intrusive alternative is also possible in that the getters are called synchronously on the java thread (i.e. not using events) and the getter functions can block the java main thread on the child process. I'm going to go through and implement that approach next and we can see which one is less messy.", "author": "lassey@chromium.org", "creator": "lassey@chromium.org", "attachment_id": 539813}, {"is_private": false, "tags": [], "raw_text": "I don't feel comfortable enough with the java code to provide feedback here, sorry.\n\nHow does this patch get us closer to the model in comment 4?  (If that's not the model we want, why not?)\n\nCould this change cause us to block the IME on the content process when a chrome-process UI element has focus?  E.g., through a race condition.  I don't think that's going to be acceptable, because then content can DoS the URL bar, e.g.", "creation_time": "2011-06-27T21:42:49Z", "bug_id": 653895, "id": 5559858, "time": "2011-06-27T21:42:49Z", "attachment_id": 539813, "creator": "cjones.bugs@gmail.com", "author": "cjones.bugs@gmail.com", "text": "Comment on attachment 539813\nWIP patch\n\nI don't feel comfortable enough with the java code to provide feedback here, sorry.\n\nHow does this patch get us closer to the model in comment 4?  (If that's not the model we want, why not?)\n\nCould this change cause us to block the IME on the content process when a chrome-process UI element has focus?  E.g., through a race condition.  I don't think that's going to be acceptable, because then content can DoS the URL bar, e.g.", "count": 6}, {"count": 7, "text": "(In reply to comment #6)\n> Comment on attachment 539813 [details] [review]\n> WIP patch\n> \n> I don't feel comfortable enough with the java code to provide feedback here,\n> sorry.\n> \n> How does this patch get us closer to the model in comment 4?  \nIt gets us there, except for the fact that the consistent snapshot is only mutated on the java main thread where all IME transactions take place. The model you spelled out in comment 4 would seem imply that we'd only mutate state in the chrome thread.\n\n> (If that's not\n> the model we want, why not?)\n> \n> Could this change cause us to block the IME on the content process when a\n> chrome-process UI element has focus?  E.g., through a race condition.  I\n> don't think that's going to be acceptable, because then content can DoS the\n> URL bar, e.g.\n\nI not sure that particular scenario is possible, but with this patch the java main process can block on the content process. If we go this route, we'll need the chrome process to monitor and correct for deadlock.\n\nAlso, the alternative impl I mentioned in comment 5 keeps crashing on my atrix, haven't been able to nail down why.", "id": 5560130, "time": "2011-06-27T23:02:09Z", "author": "lassey@chromium.org", "tags": [], "creator": "lassey@chromium.org", "creation_time": "2011-06-27T23:02:09Z", "bug_id": 653895, "raw_text": "(In reply to comment #6)\n> Comment on attachment 539813 [details] [review]\n> WIP patch\n> \n> I don't feel comfortable enough with the java code to provide feedback here,\n> sorry.\n> \n> How does this patch get us closer to the model in comment 4?  \nIt gets us there, except for the fact that the consistent snapshot is only mutated on the java main thread where all IME transactions take place. The model you spelled out in comment 4 would seem imply that we'd only mutate state in the chrome thread.\n\n> (If that's not\n> the model we want, why not?)\n> \n> Could this change cause us to block the IME on the content process when a\n> chrome-process UI element has focus?  E.g., through a race condition.  I\n> don't think that's going to be acceptable, because then content can DoS the\n> URL bar, e.g.\n\nI not sure that particular scenario is possible, but with this patch the java main process can block on the content process. If we go this route, we'll need the chrome process to monitor and correct for deadlock.\n\nAlso, the alternative impl I mentioned in comment 5 keeps crashing on my atrix, haven't been able to nail down why.", "is_private": false, "attachment_id": null}, {"count": 8, "text": "Comment on attachment 539813\nWIP patch\n\nI've tried this patch to see if it will help with SwiftKey (bug 672661, but it's more than just the reported issue).\nThe implementation kind of works, but seems like only because this way we don't provide a proper feedback to SwiftKey. It does not detect the actual changes in the edit box, so its auto-complete feature just does not work as supposed, making the fundamental functionality of SwiftKey useless.\nI'll do more debugging to see what could be improved here.", "id": 5692154, "author": "alex.mozilla@gmail.com", "time": "2011-08-31T22:10:21Z", "creator": "alex.mozilla@gmail.com", "tags": [], "raw_text": "I've tried this patch to see if it will help with SwiftKey (bug 672661, but it's more than just the reported issue).\nThe implementation kind of works, but seems like only because this way we don't provide a proper feedback to SwiftKey. It does not detect the actual changes in the edit box, so its auto-complete feature just does not work as supposed, making the fundamental functionality of SwiftKey useless.\nI'll do more debugging to see what could be improved here.", "creation_time": "2011-08-31T22:10:21Z", "bug_id": 653895, "is_private": false, "attachment_id": 539813}, {"id": 5706552, "time": "2011-09-08T01:00:01Z", "tags": [], "raw_text": "Some stuff is working with this approach, but now it looks like I hit a SynchronousQueue deadlock condition (bug 680311). Have to incorporate those changes.", "creation_time": "2011-09-08T01:00:01Z", "bug_id": 653895, "is_private": false, "text": "Some stuff is working with this approach, but now it looks like I hit a SynchronousQueue deadlock condition (bug 680311). Have to incorporate those changes.", "count": 9, "author": "alex.mozilla@gmail.com", "creator": "alex.mozilla@gmail.com", "attachment_id": null}, {"creator": "alex.mozilla@gmail.com", "attachment_id": null, "count": 10, "text": "Unfortunately using the approach from the bug 680311 defeats the purpose of this implementation, as the whole idea is to have synchronous requests. Need to come up with an alternative solution.", "author": "alex.mozilla@gmail.com", "tags": [], "bug_id": 653895, "creation_time": "2011-09-08T04:50:09Z", "raw_text": "Unfortunately using the approach from the bug 680311 defeats the purpose of this implementation, as the whole idea is to have synchronous requests. Need to come up with an alternative solution.", "is_private": false, "id": 5706837, "time": "2011-09-08T04:50:09Z"}, {"id": 5796962, "time": "2011-10-21T16:10:13Z", "author": "alex.mozilla@gmail.com", "text": "Created attachment 568666\nWIP Patch 2\n\nFixes some non-working bits from the first WIP patch, uses deadlock fix from the bug 680311, implements the text and selection caching in Java layer in attempt to have consistent state all the time. This approach fixes the problems with SwiftKey X, improves work with Swype in some cases, but there are still issues to be fixed.", "count": 11, "is_private": false, "attachment_id": 568666, "tags": [], "creator": "alex.mozilla@gmail.com", "bug_id": 653895, "creation_time": "2011-10-21T16:10:13Z", "raw_text": "Fixes some non-working bits from the first WIP patch, uses deadlock fix from the bug 680311, implements the text and selection caching in Java layer in attempt to have consistent state all the time. This approach fixes the problems with SwiftKey X, improves work with Swype in some cases, but there are still issues to be fixed."}, {"creator": "alex.mozilla@gmail.com", "attachment_id": null, "text": "This bug is postponed for now, as no sync issues have been noticed yet with a new native UI.", "count": 12, "author": "alex.mozilla@gmail.com", "raw_text": "This bug is postponed for now, as no sync issues have been noticed yet with a new native UI.", "creation_time": "2011-10-21T16:11:00Z", "bug_id": 653895, "tags": [], "is_private": false, "time": "2011-10-21T16:11:00Z", "id": 5796965}, {"count": 13, "text": "*** Bug 595008 has been marked as a duplicate of this bug. ***", "author": "alex.mozilla@gmail.com", "creator": "alex.mozilla@gmail.com", "attachment_id": null, "time": "2011-10-21T18:19:52Z", "id": 5797335, "raw_text": "", "bug_id": 653895, "creation_time": "2011-10-21T18:19:52Z", "tags": [], "is_private": false}, {"attachment_id": null, "is_private": false, "tags": [], "creator": "malix0@gmail.com", "creation_time": "2011-11-10T07:47:30Z", "bug_id": 653895, "raw_text": "According to my comment on bug 691163 https://bugzilla.mozilla.org/show_bug.cgi?id=691163#c7 I still have problem with Firefox 8.0 \n\n(In reply to Alex Pakhotin (:alexp) from comment #12)\n> This bug is postponed for now, as no sync issues have been noticed yet with\n> a new native UI.", "id": 5839412, "time": "2011-11-10T07:47:30Z", "author": "malix0@gmail.com", "text": "According to my comment on bug 691163 https://bugzilla.mozilla.org/show_bug.cgi?id=691163#c7 I still have problem with Firefox 8.0 \n\n(In reply to Alex Pakhotin (:alexp) from comment #12)\n> This bug is postponed for now, as no sync issues have been noticed yet with\n> a new native UI.", "count": 14}, {"raw_text": "https://bugzilla.mozilla.org/show_bug.cgi?id=1472046\n\nMove all DOM bugs that haven\u2019t been updated in more than 3 years and has no one currently assigned to P5.\n\nIf you have questions, please contact :mdaly.", "bug_id": 653895, "creation_time": "2018-06-29T04:58:14Z", "tags": [], "is_private": false, "time": "2018-06-29T04:58:14Z", "id": 13436492, "creator": "bug-husbandry-bot@mozilla.bugs", "attachment_id": null, "text": "https://bugzilla.mozilla.org/show_bug.cgi?id=1472046\n\nMove all DOM bugs that haven\u2019t been updated in more than 3 years and has no one currently assigned to P5.\n\nIf you have questions, please contact :mdaly.", "count": 15, "author": "bug-husbandry-bot@mozilla.bugs"}]}}}