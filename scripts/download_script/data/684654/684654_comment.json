{"comments": {}, "bugs": {"684654": {"comments": [{"id": 5700054, "count": 0, "is_private": false, "creation_time": "2011-09-05T03:39:08Z", "time": "2011-09-05T03:39:08Z", "creator": "netzen@gmail.com", "author": "netzen@gmail.com", "attachment_id": null, "raw_text": "As I was creating reftests in Bug 683205 for compressed BMP and ICO images, I noticed that our handling of 16BPP BMP and ICO has always been wrong.  I confirmed in Firefox 6. \nWhat happens is that for 16BPP bitmaps we have for example Red=5bits, Green=5bits, Blue=5bits.\n\nHow we've always done the calculation was:\n\nLet's say all 5 red bits are set: 11111 (full intensity)\nWe'd convert this to an 8 bit value by shifting, giving us: 11111000 (which is 248 base 10).\nBut full intensity should mean 255 not 248.  \n\nI confirmed we are wrong by lookig at Photoshop, IE, MSPaint, other documents on the web.\n\nWe have never noticed this because only the least significant 3 bits of the 5 bit colors are cleared out.  So the color looks almost the same but not exaclty what it should be.  This is noticeable to the human eye but only if you are flipping between 2 images (what it should be vs what it is in FF3, FF6, ...).", "bug_id": 684654, "text": "As I was creating reftests in Bug 683205 for compressed BMP and ICO images, I noticed that our handling of 16BPP BMP and ICO has always been wrong.  I confirmed in Firefox 6. \nWhat happens is that for 16BPP bitmaps we have for example Red=5bits, Green=5bits, Blue=5bits.\n\nHow we've always done the calculation was:\n\nLet's say all 5 red bits are set: 11111 (full intensity)\nWe'd convert this to an 8 bit value by shifting, giving us: 11111000 (which is 248 base 10).\nBut full intensity should mean 255 not 248.  \n\nI confirmed we are wrong by lookig at Photoshop, IE, MSPaint, other documents on the web.\n\nWe have never noticed this because only the least significant 3 bits of the 5 bit colors are cleared out.  So the color looks almost the same but not exaclty what it should be.  This is noticeable to the human eye but only if you are flipping between 2 images (what it should be vs what it is in FF3, FF6, ...).", "tags": []}, {"attachment_id": null, "raw_text": "If performance is an issue, a look-up table could work here, e.g. (from memory, apologies if my integer rounding is off):\n\nfor(i = 0; i < 32768; i++){\n  colorRGB555toRGB888[i] = ((255 * (i >> 10 & 5) + 15) / 31) << 16 |\n                           ((255 * (i >>  5 & 5) + 15) / 31) <<  8 |\n                           ((255 * (i >>  0 & 5) + 15) / 31) <<  0;\n}\n\nAnd similar for RGB565. IIRC another popular strategy is to set the three LSBs of each color channel to the three MSBs of each color channel of the original, which is less correct with regards to rounding but gives regularly spaced peaks in the delta between subsequent colors.", "tags": [], "text": "If performance is an issue, a look-up table could work here, e.g. (from memory, apologies if my integer rounding is off):\n\nfor(i = 0; i < 32768; i++){\n  colorRGB555toRGB888[i] = ((255 * (i >> 10 & 5) + 15) / 31) << 16 |\n                           ((255 * (i >>  5 & 5) + 15) / 31) <<  8 |\n                           ((255 * (i >>  0 & 5) + 15) / 31) <<  0;\n}\n\nAnd similar for RGB565. IIRC another popular strategy is to set the three LSBs of each color channel to the three MSBs of each color channel of the original, which is less correct with regards to rounding but gives regularly spaced peaks in the delta between subsequent colors.", "bug_id": 684654, "id": 5700237, "count": 1, "is_private": false, "creation_time": "2011-09-05T08:15:59Z", "time": "2011-09-05T08:15:59Z", "creator": "emanuel.hoogeveen@protonmail.com", "author": "emanuel.hoogeveen@protonmail.com"}, {"time": "2011-09-05T11:33:36Z", "creation_time": "2011-09-05T11:33:36Z", "creator": "netzen@gmail.com", "author": "netzen@gmail.com", "count": 2, "id": 5700376, "is_private": false, "text": "Thanks for the tip, I've been thinking about the best way for efficiency. \nI Think we could just do a lookup table of size 2^5 (32) instead of 2^15.  And one for 2^6 for the 565 variant.  Ditto 2^4 for the 444 variant.", "bug_id": 684654, "tags": [], "attachment_id": null, "raw_text": "Thanks for the tip, I've been thinking about the best way for efficiency. \nI Think we could just do a lookup table of size 2^5 (32) instead of 2^15.  And one for 2^6 for the 565 variant.  Ditto 2^4 for the 444 variant."}, {"attachment_id": null, "raw_text": "And do 3 lookups instead of 1.", "bug_id": 684654, "text": "And do 3 lookups instead of 1.", "tags": [], "count": 3, "id": 5700377, "is_private": false, "time": "2011-09-05T11:34:22Z", "creation_time": "2011-09-05T11:34:22Z", "creator": "netzen@gmail.com", "author": "netzen@gmail.com"}, {"is_private": false, "id": 5700453, "count": 4, "creator": "emanuel.hoogeveen@protonmail.com", "creation_time": "2011-09-05T12:49:28Z", "time": "2011-09-05T12:49:28Z", "author": "emanuel.hoogeveen@protonmail.com", "attachment_id": null, "raw_text": "That seems like a fair trade-off between memory usage and performance :)\n\nIncidentally, the second version I mentioned would look something like this:\n\nfor(i = 0; i < 32768; i++){\n  colorRGB555toRGB888[i] = (i >> 10 & 0b11111) << 19 | (i >> 12 & 0b111) << 16\n                           (i >>  5 & 0b11111) << 11 | (i >>  7 & 0b111) <<  8\n                           (i >>  0 & 0b11111) <<  3 | (i >>  2 & 0b111) <<  0;\n}\n\n(the & 5 in #comment 1 should also be 0b11111 or 31, my bad)", "text": "That seems like a fair trade-off between memory usage and performance :)\n\nIncidentally, the second version I mentioned would look something like this:\n\nfor(i = 0; i < 32768; i++){\n  colorRGB555toRGB888[i] = (i >> 10 & 0b11111) << 19 | (i >> 12 & 0b111) << 16\n                           (i >>  5 & 0b11111) << 11 | (i >>  7 & 0b111) <<  8\n                           (i >>  0 & 0b11111) <<  3 | (i >>  2 & 0b111) <<  0;\n}\n\n(the & 5 in #comment 1 should also be 0b11111 or 31, my bad)", "bug_id": 684654, "tags": []}, {"attachment_id": null, "raw_text": "I'm seeing a similar issue with 8bit colour bitmaps. For example, the palette index stating that a pixel is magenta: 255,0,255 is being loaded into an image as 255,1,251 - which is shifting away from the original colour.\n\nI can replicate this, and I can see it's correctly handed in other browsers.\n\nFor 8bit and less, the palette table should be being used rather than an algo. I don't know Firefox's source code but would be happy to (attempt) to take a look if someone pointed me in the right direction. It definitely seems odd that colours from a bitmap that includes a palette index would be wrong.\n\nCurrently using: Firefox 80.0.1 (64-bit)", "tags": [], "text": "I'm seeing a similar issue with 8bit colour bitmaps. For example, the palette index stating that a pixel is magenta: 255,0,255 is being loaded into an image as 255,1,251 - which is shifting away from the original colour.\n\nI can replicate this, and I can see it's correctly handed in other browsers.\n\nFor 8bit and less, the palette table should be being used rather than an algo. I don't know Firefox's source code but would be happy to (attempt) to take a look if someone pointed me in the right direction. It definitely seems odd that colours from a bitmap that includes a palette index would be wrong.\n\nCurrently using: Firefox 80.0.1 (64-bit)", "bug_id": 684654, "is_private": false, "count": 5, "id": 15062546, "creator": "remy@remysharp.com", "creation_time": "2020-10-01T09:39:26Z", "time": "2020-10-01T09:39:26Z", "author": "remy@remysharp.com"}]}}}