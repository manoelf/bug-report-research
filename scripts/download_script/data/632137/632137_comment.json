{"comments": {}, "bugs": {"632137": {"comments": [{"id": 5260948, "raw_text": "Using jshashtable is well-nigh impossible in any context that also includes other JS headers, because of mismatches between the expected and actual naming of the functions on the alloc policy class.  In particular, jscntxt.h (included all over the place in Gecko) includes jshashtable in a way that preserves the free/malloc naming, while a non-JS policy ends up with moz_free/moz_malloc.\n\nIt's possible to work around by tossing the \"turn off mozalloc\" crap all over the place, but it's a huge pain.\n\nThe simplest solution here is probably to just change the member names on the alloc policy, I suspect...\n\nThis is blocking bug 598832 at the moment, because pldhash is just too damn slow for what I need there, while jshashtable works great.", "is_private": false, "creation_time": "2011-02-07T20:16:58Z", "text": "Using jshashtable is well-nigh impossible in any context that also includes other JS headers, because of mismatches between the expected and actual naming of the functions on the alloc policy class.  In particular, jscntxt.h (included all over the place in Gecko) includes jshashtable in a way that preserves the free/malloc naming, while a non-JS policy ends up with moz_free/moz_malloc.\n\nIt's possible to work around by tossing the \"turn off mozalloc\" crap all over the place, but it's a huge pain.\n\nThe simplest solution here is probably to just change the member names on the alloc policy, I suspect...\n\nThis is blocking bug 598832 at the moment, because pldhash is just too damn slow for what I need there, while jshashtable works great.", "time": "2011-02-07T20:16:58Z", "tags": [], "count": 0, "creator": "bzbarsky@mit.edu", "bug_id": 632137, "attachment_id": null, "author": "bzbarsky@mit.edu"}, {"time": "2011-02-07T21:40:27Z", "count": 1, "creator": "mail@lukewagner.name", "tags": [], "bug_id": 632137, "id": 5261201, "raw_text": "Sounds good.  Is this for FF4.0?\n\nDespite agreeing with Brendan's general objections about generalization in bug 580314 (oxymoronic as that sounds :), I think the template-parameterization already in place for jshashtable means that there should be zero initial penalties paid by the JS engine.  However, it does make sense to me to keep it under ownership of the JS module like JS_DHashTable.  After all, its embedded in the friggin property tree.  So how about moz/js/tl/HashTable.h ?\n\nAlso, as before, my worry (reaffirmed by bug 610687) is that widespread use of jshashtable will cause distinct binary bloat.  Bug 610687 also reaffirmed my hope that simple techniques can avoid most of this bloat.  Clearly, there is not a danger of 100 instantiations popping up between now and releasing FF4.0 (and I promise to get to this issue before FF5.0 as soon as these pesky 4.0 blockers go away), so it seems safe do the hoisting now.", "is_private": false, "creation_time": "2011-02-07T21:40:27Z", "text": "Sounds good.  Is this for FF4.0?\n\nDespite agreeing with Brendan's general objections about generalization in bug 580314 (oxymoronic as that sounds :), I think the template-parameterization already in place for jshashtable means that there should be zero initial penalties paid by the JS engine.  However, it does make sense to me to keep it under ownership of the JS module like JS_DHashTable.  After all, its embedded in the friggin property tree.  So how about moz/js/tl/HashTable.h ?\n\nAlso, as before, my worry (reaffirmed by bug 610687) is that widespread use of jshashtable will cause distinct binary bloat.  Bug 610687 also reaffirmed my hope that simple techniques can avoid most of this bloat.  Clearly, there is not a danger of 100 instantiations popping up between now and releasing FF4.0 (and I promise to get to this issue before FF5.0 as soon as these pesky 4.0 blockers go away), so it seems safe do the hoisting now.", "attachment_id": null, "author": "mail@lukewagner.name"}, {"time": "2011-02-07T22:14:25Z", "is_private": false, "attachment_id": null, "bug_id": 632137, "creator": "bzbarsky@mit.edu", "count": 2, "tags": [], "raw_text": "> Is this for FF4.0?\n\nNo, but ideally for right after, and I'm out of hardblockers.  ;) I can probably get by for local development with my hacked tree for now to keep working on the patches that are blocked on this.\n\nI have no opinions about location.\n\n> bug 610687\n\nIs that the right bug number?\n\nFor what it's worth this particular hashtable consumer will have one callsite where it does a lookup, one where it does a lookupForAdd and one where it does a clear().  That's it.  So hopefully the code bloat should be somewhat minimized...", "id": 5261317, "text": "> Is this for FF4.0?\n\nNo, but ideally for right after, and I'm out of hardblockers.  ;) I can probably get by for local development with my hacked tree for now to keep working on the patches that are blocked on this.\n\nI have no opinions about location.\n\n> bug 610687\n\nIs that the right bug number?\n\nFor what it's worth this particular hashtable consumer will have one callsite where it does a lookup, one where it does a lookupForAdd and one where it does a clear().  That's it.  So hopefully the code bloat should be somewhat minimized...", "creation_time": "2011-02-07T22:14:25Z", "author": "bzbarsky@mit.edu"}, {"attachment_id": null, "is_private": false, "time": "2011-02-07T22:46:00Z", "author": "mail@lukewagner.name", "creation_time": "2011-02-07T22:46:00Z", "text": "(In reply to comment #2)\n> > bug 610687\n> \n> Is that the right bug number?\n\nOops, bug 610587.\n\n> For what it's worth this particular hashtable consumer will have one callsite\n> where it does a lookup, one where it does a lookupForAdd and one where it does\n> a clear().  That's it.  So hopefully the code bloat should be somewhat\n> minimized...\n\nI have little doubt that every single use you would make of jshashtable will be worth its bytes in gold :)", "id": 5261456, "raw_text": "(In reply to comment #2)\n> > bug 610687\n> \n> Is that the right bug number?\n\nOops, bug 610587.\n\n> For what it's worth this particular hashtable consumer will have one callsite\n> where it does a lookup, one where it does a lookupForAdd and one where it does\n> a clear().  That's it.  So hopefully the code bloat should be somewhat\n> minimized...\n\nI have little doubt that every single use you would make of jshashtable will be worth its bytes in gold :)", "count": 3, "tags": [], "creator": "mail@lukewagner.name", "bug_id": 632137}, {"is_private": false, "creation_time": "2011-02-07T22:59:01Z", "text": "(In reply to comment #1)\n> So how about moz/js/tl/HashTable.h ?\n\nSounds great!\n\n/be", "id": 5261495, "raw_text": "(In reply to comment #1)\n> So how about moz/js/tl/HashTable.h ?\n\nSounds great!\n\n/be", "tags": [], "count": 4, "creator": "brendan@mozilla.org", "time": "2011-02-07T22:59:01Z", "bug_id": 632137, "attachment_id": null, "author": "brendan@mozilla.org"}, {"time": "2011-02-07T23:08:06Z", "is_private": false, "attachment_id": null, "count": 5, "creator": "mail@lukewagner.name", "tags": [], "bug_id": 632137, "creation_time": "2011-02-07T23:08:06Z", "text": "(In reply to comment #4)\n> (In reply to comment #1)\n> > So how about moz/js/tl/HashTable.h ?\n> \n> Sounds great!\n\nI originally cc'd you for comment on comment 1 but it got lost in a mid-air collision. The eye of Brendan sees all!", "id": 5261525, "raw_text": "(In reply to comment #4)\n> (In reply to comment #1)\n> > So how about moz/js/tl/HashTable.h ?\n> \n> Sounds great!\n\nI originally cc'd you for comment on comment 1 but it got lost in a mid-air collision. The eye of Brendan sees all!", "author": "mail@lukewagner.name"}, {"author": "mail@lukewagner.name", "id": 5425588, "raw_text": "Now that we have a bunch of hash table usage in js/src, I did some measurements.  The goal is to understand the current code bloat and potential bloat if used throughout mozilla.\n\nThere are six primary uses that have any real potential for codegen.  All these appear to get fully inlined by gcc in opt builds.  Measuring the length (in bytes) of the generated asm:\n - enumeration        40\n - destruction        40\n - lookup:           256\n - construct+init:   848   (mostly from loop unrolling)\n - lookup+remove:    804\n - lookupForAdd+add: 971\nThis means we can pretty much ignore enumeration/destruction.\n\nAs a theoretical upper-bound, I just #ifdef'd off code and measured the size change in an opt js shell (total 2.8M):\n - nop every single HashMap/Set op:   69K  (2.4%)\n - nop the four expensive ops above:  53K  (1.8%)\nMy libxul is 20M so one could imagine around half a meg spent on hash tables if there is a 10x increase in usage throughout mozilla.\n\nNow, most of the size of add/remove is the changeTable that is getting inlined.  This handles over/under-flow, which should be rare, so I mocked up how I would factor this out into a single non-templated definition called on over/under-flow.  This saves 25K.  (It doesn't work, so I wasn't able to measure perf change.)\n\nAnother source of bloat is that lookup/init/add/remove are getting inlined at every use site.  JS_NEVER_INLINE is magic because it lets you put the definition in the header (no multiple-symbol-defined linker error) but forces the compiler not to inline it so you get one copy.  Putting this on these four ops saves another 20K.\n\nI played with JS_NEVER_INLINE (without the changeTable-hoisting) and it doesn't affect SS but it does appear to ding V8 (under the SS harness) for 1% (10ms).  I'm hoping I can play with this more to see if I can find a sweet spot.\n\nA last idea I have yet to test is to use a monomorphic specialization for any instantiation that matches:\n  HashMap<T*, word-sized, DefaultHasher<T*>, any-hash-policy>\nor\n  HashSet<T*, DefaultHasher<T*>, any-hash-policy>\nsince all instantiations in either class will have the same asm once the alloc-policy use is factored out.  Together, these two patterns account for 17 of 25 uses of HashMap/HashSet in js.\n\nI'll try these three things; hopefully that will leave a hash map/set which we can use everywhere, guilt-free.", "creation_time": "2011-04-22T01:42:07Z", "text": "Now that we have a bunch of hash table usage in js/src, I did some measurements.  The goal is to understand the current code bloat and potential bloat if used throughout mozilla.\n\nThere are six primary uses that have any real potential for codegen.  All these appear to get fully inlined by gcc in opt builds.  Measuring the length (in bytes) of the generated asm:\n - enumeration        40\n - destruction        40\n - lookup:           256\n - construct+init:   848   (mostly from loop unrolling)\n - lookup+remove:    804\n - lookupForAdd+add: 971\nThis means we can pretty much ignore enumeration/destruction.\n\nAs a theoretical upper-bound, I just #ifdef'd off code and measured the size change in an opt js shell (total 2.8M):\n - nop every single HashMap/Set op:   69K  (2.4%)\n - nop the four expensive ops above:  53K  (1.8%)\nMy libxul is 20M so one could imagine around half a meg spent on hash tables if there is a 10x increase in usage throughout mozilla.\n\nNow, most of the size of add/remove is the changeTable that is getting inlined.  This handles over/under-flow, which should be rare, so I mocked up how I would factor this out into a single non-templated definition called on over/under-flow.  This saves 25K.  (It doesn't work, so I wasn't able to measure perf change.)\n\nAnother source of bloat is that lookup/init/add/remove are getting inlined at every use site.  JS_NEVER_INLINE is magic because it lets you put the definition in the header (no multiple-symbol-defined linker error) but forces the compiler not to inline it so you get one copy.  Putting this on these four ops saves another 20K.\n\nI played with JS_NEVER_INLINE (without the changeTable-hoisting) and it doesn't affect SS but it does appear to ding V8 (under the SS harness) for 1% (10ms).  I'm hoping I can play with this more to see if I can find a sweet spot.\n\nA last idea I have yet to test is to use a monomorphic specialization for any instantiation that matches:\n  HashMap<T*, word-sized, DefaultHasher<T*>, any-hash-policy>\nor\n  HashSet<T*, DefaultHasher<T*>, any-hash-policy>\nsince all instantiations in either class will have the same asm once the alloc-policy use is factored out.  Together, these two patterns account for 17 of 25 uses of HashMap/HashSet in js.\n\nI'll try these three things; hopefully that will leave a hash map/set which we can use everywhere, guilt-free.", "creator": "mail@lukewagner.name", "tags": [], "count": 6, "bug_id": 632137, "attachment_id": null, "is_private": false, "time": "2011-04-22T01:42:07Z"}, {"is_private": false, "creation_time": "2011-04-22T02:12:54Z", "text": "For what it's worth, a lot of Gecko hashtable use (not all, but a lot) has a single callsite where things are added to the hashtable and a single callsite where they're removed.  For code that looks like that, bloat of add/remove is not a big deal.  Similarly, init() is usually used in only one place.  So in some ways, it would be best to keep the inlining for the fast path but take changeTable out of line.  I'd be interested in the size of the lookup/remove/add paths at that point, especially as compared to the amount of code involved in a function call.", "id": 5425608, "raw_text": "For what it's worth, a lot of Gecko hashtable use (not all, but a lot) has a single callsite where things are added to the hashtable and a single callsite where they're removed.  For code that looks like that, bloat of add/remove is not a big deal.  Similarly, init() is usually used in only one place.  So in some ways, it would be best to keep the inlining for the fast path but take changeTable out of line.  I'd be interested in the size of the lookup/remove/add paths at that point, especially as compared to the amount of code involved in a function call.", "creator": "bzbarsky@mit.edu", "count": 7, "tags": [], "time": "2011-04-22T02:12:54Z", "bug_id": 632137, "attachment_id": null, "author": "bzbarsky@mit.edu"}, {"id": 5425697, "raw_text": "Ah, good to know, thanks!  Yes, that does seem to indicate that it would be good to lay off the JS_NEVER_INLINE.  Also, I'm measuring on gcc; MSVC with ltcg might be smarter about not inlining when there is a lot of duplication.\n\nlookup does no changeTable or contain any other cold code.  And for remove, basically, sizeof(remove) = sizeof(lookup) + sizeof(changeTable).  Same goes for add() except that it does a bit more work in between (167 bytes worth, apparently :).", "creation_time": "2011-04-22T04:22:35Z", "text": "Ah, good to know, thanks!  Yes, that does seem to indicate that it would be good to lay off the JS_NEVER_INLINE.  Also, I'm measuring on gcc; MSVC with ltcg might be smarter about not inlining when there is a lot of duplication.\n\nlookup does no changeTable or contain any other cold code.  And for remove, basically, sizeof(remove) = sizeof(lookup) + sizeof(changeTable).  Same goes for add() except that it does a bit more work in between (167 bytes worth, apparently :).", "tags": [], "creator": "mail@lukewagner.name", "count": 8, "bug_id": 632137, "author": "mail@lukewagner.name", "is_private": false, "time": "2011-04-22T04:22:35Z", "attachment_id": null}, {"bug_id": 632137, "tags": [], "creator": "mail@lukewagner.name", "time": "2011-04-23T01:49:43Z", "count": 9, "text": "Created attachment 527901\nout-of-line under/over flow WIP\n\nThis patch shrinks the shell by 20K which is ~1/3 of all hash table bloat.  SS/V8 scores don't appear affected.  Its WIP since effectively memcpy elements in changeTable.  (tl::IsPodType will avoid a ptr-to-fun call in the general case.)\n\nThe shared map-of-words and set-of-words patch in progress.", "is_private": false, "creation_time": "2011-04-23T01:49:43Z", "raw_text": "This patch shrinks the shell by 20K which is ~1/3 of all hash table bloat.  SS/V8 scores don't appear affected.  Its WIP since effectively memcpy elements in changeTable.  (tl::IsPodType will avoid a ptr-to-fun call in the general case.)\n\nThe shared map-of-words and set-of-words patch in progress.", "id": 5427607, "author": "mail@lukewagner.name", "attachment_id": 527901}]}}}