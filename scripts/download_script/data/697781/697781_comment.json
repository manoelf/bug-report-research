{"comments": {}, "bugs": {"697781": {"comments": [{"creator": "brian@briansmith.org", "author": "brian@briansmith.org", "count": 0, "text": "+++ This bug was initially created as a clone of Bug #686248 +++\n+++ This bug was initially created as a clone of Bug #575950 +++\n\n1. Two copies of the certificate are stored.\n3. UI strings for the result of certificate validation are stored, when they should be recalculated by revalidating the certificate (see bug 686248).\n3. Error messages are stored; instead, we should just avoid storing pages with SSL errors in the cache.\n3. mSubRequests*Security information can be stored more efficiently. (I believe these fields be made booleans instead of counts.)\n4. The bitfields in nsSSLStatus can be packed into a single byte.\n5. Instead of writing the cipher suite name, we can write the two-byte ID of the cipher suite.\n6. We do not need to write mHaveKeyLengthAndCipher because if we don't have that info, we shouldn't be writing the entry to the cache.\n7. We don't need to write mHaveCertErrorBits, because if we have cert errors, we should just avoid writing the entry to the cache.", "id": 5809598, "bug_id": 697781, "creation_time": "2011-10-27T18:59:05Z", "is_private": false, "time": "2011-10-27T18:59:05Z", "attachment_id": null, "raw_text": "+++ This bug was initially created as a clone of Bug #686248 +++\n+++ This bug was initially created as a clone of Bug #575950 +++\n\n1. Two copies of the certificate are stored.\n3. UI strings for the result of certificate validation are stored, when they should be recalculated by revalidating the certificate (see bug 686248).\n3. Error messages are stored; instead, we should just avoid storing pages with SSL errors in the cache.\n3. mSubRequests*Security information can be stored more efficiently. (I believe these fields be made booleans instead of counts.)\n4. The bitfields in nsSSLStatus can be packed into a single byte.\n5. Instead of writing the cipher suite name, we can write the two-byte ID of the cipher suite.\n6. We do not need to write mHaveKeyLengthAndCipher because if we don't have that info, we shouldn't be writing the entry to the cache.\n7. We don't need to write mHaveCertErrorBits, because if we have cert errors, we should just avoid writing the entry to the cache.", "tags": []}, {"author": "brian@briansmith.org", "count": 1, "text": "Michal, Bjarne, Nick: I would like to do this work in such a way that we DO NOT have to change the cache version number. That is, I don't want to have to throw away the cache when the user upgrades just to make this optimization. But, I also want to ensure that if earlier versions of Firefox use the cache, that they gracefully avoid reading the cache entries where the security-info is written in the new format. That is, I want the older versions to read the cache entry and say \"hey, this security-info isn't in the form I am expecting, so I will just ignore it.\" Do you have any suggestions for doing this? \n\nThe biggest win will come from storing only one copy of the certificate instead of two. That is what I would focus on first, and that doesn't require any prerequisite work or special handling for wyciwyg:// or anything like that.\n\nThese things can also be done without any prerequisite work, beyond the compatibility stuff I mentioned above:\n\n* mSubRequests*Security information can be stored more efficiently. (I believe these fields be made booleans instead of counts.)\n* The bitfields in nsSSLStatus can be packed into a single byte.\n* Instead of writing the cipher suite name, we can write the two-byte ID of the cipher suite.\n* We do not need to write mHaveKeyLengthAndCipher because if we don't have that info, we shouldn't be writing the entry to the cache.\n\nAlso, I think I am wrong about these:\n* Error messages are stored; instead, we should just avoid storing pages with SSL errors in the cache.\n* We don't need to write mHaveCertErrorBits, because if we have cert errors, we should just avoid writing the entry to the cache.\n\nWe may need to support this for WYCIWYG for session restore (only). I suggest that we file a separate bug for \"fixing\" the caching of resources that were retrieved on a connection with cert errors.\n\nThis one can be handled in bug 660749; I would ignore it for now:\n* UI strings for the result of certificate validation are stored, when they should be recalculated by revalidating the certificate (see bug 686248).", "creator": "brian@briansmith.org", "is_private": false, "creation_time": "2011-11-09T20:05:27Z", "id": 5837942, "bug_id": 697781, "attachment_id": null, "raw_text": "Michal, Bjarne, Nick: I would like to do this work in such a way that we DO NOT have to change the cache version number. That is, I don't want to have to throw away the cache when the user upgrades just to make this optimization. But, I also want to ensure that if earlier versions of Firefox use the cache, that they gracefully avoid reading the cache entries where the security-info is written in the new format. That is, I want the older versions to read the cache entry and say \"hey, this security-info isn't in the form I am expecting, so I will just ignore it.\" Do you have any suggestions for doing this? \n\nThe biggest win will come from storing only one copy of the certificate instead of two. That is what I would focus on first, and that doesn't require any prerequisite work or special handling for wyciwyg:// or anything like that.\n\nThese things can also be done without any prerequisite work, beyond the compatibility stuff I mentioned above:\n\n* mSubRequests*Security information can be stored more efficiently. (I believe these fields be made booleans instead of counts.)\n* The bitfields in nsSSLStatus can be packed into a single byte.\n* Instead of writing the cipher suite name, we can write the two-byte ID of the cipher suite.\n* We do not need to write mHaveKeyLengthAndCipher because if we don't have that info, we shouldn't be writing the entry to the cache.\n\nAlso, I think I am wrong about these:\n* Error messages are stored; instead, we should just avoid storing pages with SSL errors in the cache.\n* We don't need to write mHaveCertErrorBits, because if we have cert errors, we should just avoid writing the entry to the cache.\n\nWe may need to support this for WYCIWYG for session restore (only). I suggest that we file a separate bug for \"fixing\" the caching of resources that were retrieved on a connection with cert errors.\n\nThis one can be handled in bug 660749; I would ignore it for now:\n* UI strings for the result of certificate validation are stored, when they should be recalculated by revalidating the certificate (see bug 686248).", "time": "2011-11-09T20:05:27Z", "tags": []}, {"is_private": false, "creation_time": "2011-11-09T21:55:28Z", "creator": "u408661@disabled.tld", "tags": [], "attachment_id": null, "bug_id": 697781, "id": 5838394, "author": "u408661@disabled.tld", "text": "Can you just store the new-style security info in a different (new) metadata field? Say, \"security-info-v2\"? That way, older versions can just gleefully pretend that field doesn't exist, since they'll have no knowledge of it. Of course, if they'll still try to use cached https pages without a security-info field, that could be problematic, but I imagine that would be a problematic situation regardless of the reason security-info doesn't exist.", "count": 2, "raw_text": "Can you just store the new-style security info in a different (new) metadata field? Say, \"security-info-v2\"? That way, older versions can just gleefully pretend that field doesn't exist, since they'll have no knowledge of it. Of course, if they'll still try to use cached https pages without a security-info field, that could be problematic, but I imagine that would be a problematic situation regardless of the reason security-info doesn't exist.", "time": "2011-11-09T21:55:28Z"}, {"id": 5838894, "bug_id": 697781, "is_private": false, "creation_time": "2011-11-10T00:29:54Z", "creator": "brian@briansmith.org", "text": "(In reply to Nick Hurley from comment #2)\n> That way, older versions can just gleefully pretend that field doesn't exist,\n> since they'll have no knowledge of it. Of course, if they'll still try to use \n> cached https pages without a security-info field, that could be problematic,\n> but I imagine that would be a problematic situation regardless of the reason \n> security-info doesn't exist.\n\nThis won't work. We need to prevent older Firefoxes from using these cache entries at all; otherwise (at best) they won't show the right SSL indicators and at worst they could be making incorrect security decisions. I am thinking that, for the new entries, to put something in \"security-info\" that will cause nsNSSSocketInfo::Read() for older versions to return an error. But, we need to make sure that (a) the cache doesn't continue on using the cache entry when nsNSSSocketInfo::Read() fails, and (b) that a failure in nsNSSSocketInfo::Read() will cause the resource to be fetched from the server, instead of just causing a busted page load.", "count": 3, "author": "brian@briansmith.org", "tags": [], "time": "2011-11-10T00:29:54Z", "raw_text": "(In reply to Nick Hurley from comment #2)\n> That way, older versions can just gleefully pretend that field doesn't exist,\n> since they'll have no knowledge of it. Of course, if they'll still try to use \n> cached https pages without a security-info field, that could be problematic,\n> but I imagine that would be a problematic situation regardless of the reason \n> security-info doesn't exist.\n\nThis won't work. We need to prevent older Firefoxes from using these cache entries at all; otherwise (at best) they won't show the right SSL indicators and at worst they could be making incorrect security decisions. I am thinking that, for the new entries, to put something in \"security-info\" that will cause nsNSSSocketInfo::Read() for older versions to return an error. But, we need to make sure that (a) the cache doesn't continue on using the cache entry when nsNSSSocketInfo::Read() fails, and (b) that a failure in nsNSSSocketInfo::Read() will cause the resource to be fetched from the server, instead of just causing a busted page load.", "attachment_id": null}, {"tags": [], "raw_text": "-Packed bitfields in nsSSLStatus in one structure.\n-Instead of writing of cipherSuite name, wrote cipherSuiteID\n-Made GetShortSecurityDescription lazy\n-Made GetOrganization lazy", "attachment_id": 582517, "time": "2011-12-17T12:00:40Z", "is_private": false, "creation_time": "2011-12-17T12:00:40Z", "id": 5924279, "bug_id": 697781, "count": 4, "text": "Created attachment 582517\npatch_1\n\n-Packed bitfields in nsSSLStatus in one structure.\n-Instead of writing of cipherSuite name, wrote cipherSuiteID\n-Made GetShortSecurityDescription lazy\n-Made GetOrganization lazy", "author": "jitenmt@gmail.com", "creator": "jitenmt@gmail.com"}, {"attachment_id": 582517, "tags": [], "creator": "brian@briansmith.org", "is_private": false, "creation_time": "2011-12-18T03:13:59Z", "raw_text": "Review of attachment 582517:\n-----------------------------------------------------------------\n\nThis is a good start.\n\nIt looks like you forgot to remove the redundant writing of the certificate from nsNSSSocketInfo::Write(). The certificate is already written as part of the nsSSLStatus.\n\nI do not think it is necessary to create the nested mDetails field of nsSSLStatus. I guess you did this because you wanted to make the variables bitfields. That isn't necessary. The idea was to pack them into a single byte when writing/reading them. But, in your patch, each bit is still written to disk as a separate byte.\n\nThe biggest savings will be from avoiding writing the short security description string and the redundant certificate to disk. I think we don't have to worry now about trying to save space for the boolean flags. We can do that in a follow-up patch.\n\n::: security/manager/ssl/src/nsNSSCallbacks.cpp\n@@ +844,1 @@\n>      return;\n\nWe cannot return early like this, because we need the following code to always execute.\n\nInstead, we should use NS_ERROR(\"SSL_GetChannelInfo failed\") and set a flag status->mDetails.mGetChannelInfoFailed = true; Then, check this flag in the functions in nsSSLStatus that need the information from SSL_GetChannelInfo.\n\n@@ +844,3 @@\n>      return;\n>    }\n> +  if (SECSuccess != SSL_GetCipherSuiteInfo(channelInfo.cipherSuite, &cipherSuiteInfo, sizeof cipherSuiteInfo)) {\n\nDo not call SSL_GetCipherSuiteInfo here. Instead, when you need some information about the cipher suite in one of the nsSSLStatus methods, just call SSL_GetCipherSuiteInfo in that method.\n\n@@ +853,5 @@\n> +    sslStatus = SSL_SECURITY_STATUS_OFF;}\n> +  else if (encryptBits < 90) {\n> +    sslStatus = SSL_SECURITY_STATUS_ON_LOW;}\n> +  else {\n> +    sslStatus = SSL_SECURITY_STATUS_ON_HIGH;}\n\nMove the calculation of encryptBits to \n\nNote that you will have to save the result of SSL_HandshakeNegotiatedExtension(fd, ssl_renegotiation_info_xtn, &siteSupportsSafeRenego) in a new member variables of nsSSLStatus, since you need to know that to calculate sslStatus.\n\nWhen all of this is done, all the dependencies on nsIWebProgressListener would be gone from this file, and we can then remove the #include \"nsIWebProgressListener.h\"\n\n@@ +913,5 @@\n>      rv = nssComponent->PIPBundleFormatStringFromName(\"SignedBy\",\n>                                                     formatStrings, 1,\n>                                                     shortDesc);\n>  \n>      nsMemory::Free(const_cast<PRUnichar*>(formatStrings[0]));\n\nIt looks like you copied all of this code from line 896 (declaration of peerCert) through line 917 (freeing of formatStrings[0]), that deals with the short security description, to nsSSLStatus::GetShortSecurityDescription. That was the correct thing to do. But, also, you need to delete it from this function.\n\n@@ +968,2 @@\n>      status->mKeyLength = keyLength;\n>      status->mSecretKeyLength = encryptBits;\n\nnsSSLStatus::GetSecretKeyLength() should call SSL_GetCipherSuiteInfo, so that we don't have to have an mSecretKeyLength variable.\n\n::: security/manager/ssl/src/nsNSSIOLayer.cpp\n@@ +456,5 @@\n>    return NS_OK;\n>  }\n>  \n>  NS_IMETHODIMP\n>  nsNSSSocketInfo::GetShortSecurityDescription(PRUnichar** aText) {\n\nNS_ENSURE_ARG_POINTER(aText);\n*aText = nsnull;\nnsRefPtr<nsSSLStatus> status = mSSLStatus;\nif (!status)\n    return NS_ERROR_NOT_AVAILABLE;\nnsCOMPtr<nsIX509Cert> serverCert = status->mServerCert;\nif (!serverCert)\n    return NS_ERROR_NOT_AVAILABLE;\n\nThen, use serverCert below, instead of mSSLtatus->mServerCert.\n\n@@ +476,5 @@\n> +  nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(kNSSComponentCID, &rv));\n> +  if (NS_SUCCEEDED(rv)) {\n> +    rv = nssComponent->PIPBundleFormatStringFromName(\"SignedBy\",\n> +                                                   formatStrings, 1,\n> +                                                   shortDesc);\n\nThe indention is wrong on the two lines above.\n\n@@ +596,5 @@\n>    // to distinguish version number from mSecurityState\n>    // field stored in times before versioning has been introduced.\n>    // This mask value has been chosen as mSecurityState could\n>    // never be assigned such value.\n>    PRUint32 version = 3;\n\nWe need to change the version here (to 4, I guess), since we are changing the format of the security info.\n\nAnd, in Read(), we have to verify that the new version is being used.\n\n@@ +598,5 @@\n>    // This mask value has been chosen as mSecurityState could\n>    // never be assigned such value.\n>    PRUint32 version = 3;\n>    stream->Write32(version | 0xFFFF0000);\n>    stream->Write32(mSecurityState);\n\nInstead of writing mSecurityState, we should write the variables that are used to calculate the security state.\n\n@@ +599,5 @@\n>    // never be assigned such value.\n>    PRUint32 version = 3;\n>    stream->Write32(version | 0xFFFF0000);\n>    stream->Write32(mSecurityState);\n> +  //stream->WriteWStringZ(mShortDesc.get());\n\nRemove this line, instead of commenting it out.\n\n@@ +604,1 @@\n>    stream->WriteWStringZ(mErrorMessage.get());\n\nInstead of writing the error string, we should write the error  code. And, in particular, we should avoid calling formatErrorString() in this method.\n\n@@ +687,2 @@\n>    if ((version & 0xFFFF0000) == 0xFFFF0000) {\n>      version &= ~0xFFFF0000;\n\nWe need to return an error if the security info isn't the version that we expect (version 4).\n\n@@ +691,5 @@\n>    else {\n>      mSecurityState = version;\n>      version = 1;\n>    }\n> +  //stream->ReadString(mShortDesc);\n\nDo not comment out code to remove it; just remove it.", "time": "2011-12-18T03:13:59Z", "author": "brian@briansmith.org", "count": 5, "text": "Comment on attachment 582517\npatch_1\n\nReview of attachment 582517:\n-----------------------------------------------------------------\n\nThis is a good start.\n\nIt looks like you forgot to remove the redundant writing of the certificate from nsNSSSocketInfo::Write(). The certificate is already written as part of the nsSSLStatus.\n\nI do not think it is necessary to create the nested mDetails field of nsSSLStatus. I guess you did this because you wanted to make the variables bitfields. That isn't necessary. The idea was to pack them into a single byte when writing/reading them. But, in your patch, each bit is still written to disk as a separate byte.\n\nThe biggest savings will be from avoiding writing the short security description string and the redundant certificate to disk. I think we don't have to worry now about trying to save space for the boolean flags. We can do that in a follow-up patch.\n\n::: security/manager/ssl/src/nsNSSCallbacks.cpp\n@@ +844,1 @@\n>      return;\n\nWe cannot return early like this, because we need the following code to always execute.\n\nInstead, we should use NS_ERROR(\"SSL_GetChannelInfo failed\") and set a flag status->mDetails.mGetChannelInfoFailed = true; Then, check this flag in the functions in nsSSLStatus that need the information from SSL_GetChannelInfo.\n\n@@ +844,3 @@\n>      return;\n>    }\n> +  if (SECSuccess != SSL_GetCipherSuiteInfo(channelInfo.cipherSuite, &cipherSuiteInfo, sizeof cipherSuiteInfo)) {\n\nDo not call SSL_GetCipherSuiteInfo here. Instead, when you need some information about the cipher suite in one of the nsSSLStatus methods, just call SSL_GetCipherSuiteInfo in that method.\n\n@@ +853,5 @@\n> +    sslStatus = SSL_SECURITY_STATUS_OFF;}\n> +  else if (encryptBits < 90) {\n> +    sslStatus = SSL_SECURITY_STATUS_ON_LOW;}\n> +  else {\n> +    sslStatus = SSL_SECURITY_STATUS_ON_HIGH;}\n\nMove the calculation of encryptBits to \n\nNote that you will have to save the result of SSL_HandshakeNegotiatedExtension(fd, ssl_renegotiation_info_xtn, &siteSupportsSafeRenego) in a new member variables of nsSSLStatus, since you need to know that to calculate sslStatus.\n\nWhen all of this is done, all the dependencies on nsIWebProgressListener would be gone from this file, and we can then remove the #include \"nsIWebProgressListener.h\"\n\n@@ +913,5 @@\n>      rv = nssComponent->PIPBundleFormatStringFromName(\"SignedBy\",\n>                                                     formatStrings, 1,\n>                                                     shortDesc);\n>  \n>      nsMemory::Free(const_cast<PRUnichar*>(formatStrings[0]));\n\nIt looks like you copied all of this code from line 896 (declaration of peerCert) through line 917 (freeing of formatStrings[0]), that deals with the short security description, to nsSSLStatus::GetShortSecurityDescription. That was the correct thing to do. But, also, you need to delete it from this function.\n\n@@ +968,2 @@\n>      status->mKeyLength = keyLength;\n>      status->mSecretKeyLength = encryptBits;\n\nnsSSLStatus::GetSecretKeyLength() should call SSL_GetCipherSuiteInfo, so that we don't have to have an mSecretKeyLength variable.\n\n::: security/manager/ssl/src/nsNSSIOLayer.cpp\n@@ +456,5 @@\n>    return NS_OK;\n>  }\n>  \n>  NS_IMETHODIMP\n>  nsNSSSocketInfo::GetShortSecurityDescription(PRUnichar** aText) {\n\nNS_ENSURE_ARG_POINTER(aText);\n*aText = nsnull;\nnsRefPtr<nsSSLStatus> status = mSSLStatus;\nif (!status)\n    return NS_ERROR_NOT_AVAILABLE;\nnsCOMPtr<nsIX509Cert> serverCert = status->mServerCert;\nif (!serverCert)\n    return NS_ERROR_NOT_AVAILABLE;\n\nThen, use serverCert below, instead of mSSLtatus->mServerCert.\n\n@@ +476,5 @@\n> +  nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(kNSSComponentCID, &rv));\n> +  if (NS_SUCCEEDED(rv)) {\n> +    rv = nssComponent->PIPBundleFormatStringFromName(\"SignedBy\",\n> +                                                   formatStrings, 1,\n> +                                                   shortDesc);\n\nThe indention is wrong on the two lines above.\n\n@@ +596,5 @@\n>    // to distinguish version number from mSecurityState\n>    // field stored in times before versioning has been introduced.\n>    // This mask value has been chosen as mSecurityState could\n>    // never be assigned such value.\n>    PRUint32 version = 3;\n\nWe need to change the version here (to 4, I guess), since we are changing the format of the security info.\n\nAnd, in Read(), we have to verify that the new version is being used.\n\n@@ +598,5 @@\n>    // This mask value has been chosen as mSecurityState could\n>    // never be assigned such value.\n>    PRUint32 version = 3;\n>    stream->Write32(version | 0xFFFF0000);\n>    stream->Write32(mSecurityState);\n\nInstead of writing mSecurityState, we should write the variables that are used to calculate the security state.\n\n@@ +599,5 @@\n>    // never be assigned such value.\n>    PRUint32 version = 3;\n>    stream->Write32(version | 0xFFFF0000);\n>    stream->Write32(mSecurityState);\n> +  //stream->WriteWStringZ(mShortDesc.get());\n\nRemove this line, instead of commenting it out.\n\n@@ +604,1 @@\n>    stream->WriteWStringZ(mErrorMessage.get());\n\nInstead of writing the error string, we should write the error  code. And, in particular, we should avoid calling formatErrorString() in this method.\n\n@@ +687,2 @@\n>    if ((version & 0xFFFF0000) == 0xFFFF0000) {\n>      version &= ~0xFFFF0000;\n\nWe need to return an error if the security info isn't the version that we expect (version 4).\n\n@@ +691,5 @@\n>    else {\n>      mSecurityState = version;\n>      version = 1;\n>    }\n> +  //stream->ReadString(mShortDesc);\n\nDo not comment out code to remove it; just remove it.", "bug_id": 697781, "id": 5924993}, {"time": "2011-12-18T03:17:51Z", "raw_text": "Note that also, we need to check what happens when the cache tries to read a cache entry that was written using an earlier version (version 3) of the nsNSSSocketInfo/nsSSLstatus serialization. We want to make sure that the cache doesn't use the entry and that instead we fetch the resource from disk.\n\nWe should have a test case for that.", "bug_id": 697781, "id": 5925001, "text": "Note that also, we need to check what happens when the cache tries to read a cache entry that was written using an earlier version (version 3) of the nsNSSSocketInfo/nsSSLstatus serialization. We want to make sure that the cache doesn't use the entry and that instead we fetch the resource from disk.\n\nWe should have a test case for that.", "count": 6, "author": "brian@briansmith.org", "tags": [], "attachment_id": null, "creation_time": "2011-12-18T03:17:51Z", "is_private": false, "creator": "brian@briansmith.org"}, {"id": 5925067, "bug_id": 697781, "author": "josh@joshmatthews.net", "count": 7, "text": ">@@ +853,5 @@\n>> +    sslStatus = SSL_SECURITY_STATUS_OFF;}\n>> +  else if (encryptBits < 90) {\n>> +    sslStatus = SSL_SECURITY_STATUS_ON_LOW;}\n>> +  else {\n>> +    sslStatus = SSL_SECURITY_STATUS_ON_HIGH;}\n>\n>Move the calculation of encryptBits to \n\nBrian, I think there's a dangling sentence here.", "time": "2011-12-18T05:34:30Z", "raw_text": ">@@ +853,5 @@\n>> +    sslStatus = SSL_SECURITY_STATUS_OFF;}\n>> +  else if (encryptBits < 90) {\n>> +    sslStatus = SSL_SECURITY_STATUS_ON_LOW;}\n>> +  else {\n>> +    sslStatus = SSL_SECURITY_STATUS_ON_HIGH;}\n>\n>Move the calculation of encryptBits to \n\nBrian, I think there's a dangling sentence here.", "creation_time": "2011-12-18T05:34:30Z", "is_private": false, "creator": "josh@joshmatthews.net", "tags": [], "attachment_id": null}, {"bug_id": 697781, "id": 5925117, "count": 8, "text": "(In reply to Josh Matthews [:jdm] from comment #7)\n> >@@ +853,5 @@\n> >> +    sslStatus = SSL_SECURITY_STATUS_OFF;}\n> >> +  else if (encryptBits < 90) {\n> >> +    sslStatus = SSL_SECURITY_STATUS_ON_LOW;}\n> >> +  else {\n> >> +    sslStatus = SSL_SECURITY_STATUS_ON_HIGH;}\n> >\n> >Move the calculation of encryptBits to \n\n... nsSSLStatus::GetSecretKeyLength.\n\nBy the way, here's why: Instead of storing calculated values in the disk cache, we should store only the inputs to the calculations. That way, if the calculations change in the future, we can still get the correct with old cache entries.", "author": "brian@briansmith.org", "raw_text": "(In reply to Josh Matthews [:jdm] from comment #7)\n> >@@ +853,5 @@\n> >> +    sslStatus = SSL_SECURITY_STATUS_OFF;}\n> >> +  else if (encryptBits < 90) {\n> >> +    sslStatus = SSL_SECURITY_STATUS_ON_LOW;}\n> >> +  else {\n> >> +    sslStatus = SSL_SECURITY_STATUS_ON_HIGH;}\n> >\n> >Move the calculation of encryptBits to \n\n... nsSSLStatus::GetSecretKeyLength.\n\nBy the way, here's why: Instead of storing calculated values in the disk cache, we should store only the inputs to the calculations. That way, if the calculations change in the future, we can still get the correct with old cache entries.", "time": "2011-12-18T07:20:57Z", "is_private": false, "creation_time": "2011-12-18T07:20:57Z", "creator": "brian@briansmith.org", "tags": [], "attachment_id": null}, {"creator": "jitenmt@gmail.com", "creation_time": "2011-12-28T06:22:11Z", "is_private": false, "attachment_id": 584526, "tags": [], "text": "Created attachment 584526\npatch_2\n\n-Created version 4 of cache\n-I have added mGetChannelInfoFailed field but it is not used anywhere", "count": 9, "author": "jitenmt@gmail.com", "bug_id": 697781, "id": 5942304, "raw_text": "-Created version 4 of cache\n-I have added mGetChannelInfoFailed field but it is not used anywhere", "time": "2011-12-28T06:22:11Z"}, {"creator": "brian@briansmith.org", "count": 10, "text": "Comment on attachment 584526\npatch_2\n\nReview of attachment 584526:\n-----------------------------------------------------------------\n\nI added Honza as the superreviewer.\n\n::: security/manager/ssl/src/nsNSSCallbacks.cpp\n@@ -856,4 @@\n>    PRBool siteSupportsSafeRenego;\n>    if (SSL_HandshakeNegotiatedExtension(fd, ssl_renegotiation_info_xtn, &siteSupportsSafeRenego) != SECSuccess\n>        || !siteSupportsSafeRenego) {\n> -\n\nUndo this whitespace change.\n\n@@ -873,5 @@\n>          console->LogStringMessage(msg.get());\n>        }\n>      }\n> -    if (nsSSLIOLayerHelpers::treatUnsafeNegotiationAsBroken()) {\n> -      secStatus = nsIWebProgressListener::STATE_IS_BROKEN;\n\nYou need to save the fact that renegotiation wasn't supported into nsNSSSocketInfo, so that you can calculate the state correctly in nsNSSSocketInfo::GetSecurityState\n\n::: security/manager/ssl/src/nsNSSIOLayer.cpp\n@@ +338,5 @@\n>  \n>  NS_IMETHODIMP\n>  nsNSSSocketInfo::GetSecurityState(PRUint32* state)\n>  {\n> +  if (nsSSLIOLayerHelpers::treatUnsafeNegotiationAsBroken()) {\n\nnsSSLIOLayerHelpers::treatUnsafeNegotiationAsBroken refers to the setting of a preference.\n\nWhat you need to know here is whether the secure renegotiation extension was negotiated. You can do this by creating a new member variable mSecureRenegotiation in nsNSSSocketInfo and setting it in HandshakeCallback.\n\nDon't forget to serialize the new flag in Write() and deserialize it in Read().\n\n@@ +343,5 @@\n> +    *state = nsIWebProgressListener::STATE_IS_BROKEN;\n> +    return NS_OK;\n> +  }\n> +  PRUint32 encryptBits;\n> +  mSSLStatus->GetSecretKeyLength(&encryptBits);\n\nnsresult rv = mSSLStatus->GetSecretKeyLength(&encryptBits);\nNS_ENSURE_SUCCESS(rv, rv);\n\n(Because mSSLStatus->GetSecretKeyLength can fail.)\n\n@@ +426,5 @@\n> +  if (!serverCert)\n> +    return NS_ERROR_NOT_AVAILABLE;\n> +  const char* caName = nsnull; // caName is a pointer only, no ownership\n> +  nsAutoString certOrgName;\n> +  mSSLStatus->mServerCert->GetOrganization(certOrgName);\n\nThis should be GetIssuerOrganization. We want the name of the CA, not the name of the EE.\n\nAlso, check the return value with NS_ENSURE_SUCCESS.\n\n@@ +428,5 @@\n> +  const char* caName = nsnull; // caName is a pointer only, no ownership\n> +  nsAutoString certOrgName;\n> +  mSSLStatus->mServerCert->GetOrganization(certOrgName);\n> +  nsresult rv;\n> +  caName =  ToNewUTF8String(certOrgName);\n\nToNewUTF8String will allocate a new string that needs to be freed.\n\ninstead, you can do something like:\nconst PRUnichar* caName\n    = certIssuerOrgName == \"RSA Data Security, Inc.\"\n    ? NS_LITERAL_STRING(\"Verisign, Inc.\")\n    : certIssuerOrgName.get();\n\nMaybe you have to use .Equals() instead, and/or wrap \"RSA Data Security, Inc.\" with NS_LITERAL_STRING.\n\nMake sure you test this in the browser by looking at the larry popup for sites with Verisign and non-Verisign issued certificates.\n\n@@ +438,5 @@\n> +    caName = verisignName;\n> +  }\n> +\n> +  nsAutoString shortDesc;\n> +  const PRUnichar* formatStrings[1] = {NS_ConvertUTF8toUTF16(caName).get()};\n\nIf you make caName PRUnichar*, you will not need the UTF8-to-UTF16 conversion.\n\n@@ +440,5 @@\n> +\n> +  nsAutoString shortDesc;\n> +  const PRUnichar* formatStrings[1] = {NS_ConvertUTF8toUTF16(caName).get()};\n> +  nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(kNSSComponentCID, &rv));\n> +  if (NS_SUCCEEDED(rv)) {\n\nNS_ENSURE_SUCCESS(rv, rv). Otherwise, you end up returning NS_OK without setting *aText in this (extremely unlikely situation).\n\n@@ +445,5 @@\n> +    rv = nssComponent->PIPBundleFormatStringFromName(\"SignedBy\",\n> +                                                   formatStrings, 1,\n> +                                                   shortDesc);\n> +\n> +    nsMemory::Free(const_cast<PRUnichar*>(formatStrings[0]));\n\nI think we don't need this call to nsMemory::Free, if we make the changes I suggested above.\n\n@@ -413,5 @@\n>    return NS_OK;\n>  }\n>  \n> -nsresult\n> -nsNSSSocketInfo::SetShortSecurityDescription(const PRUnichar* aText) {\n\nRemove the declaration from the class definition too.\n\n@@ +689,5 @@\n>    MutexAutoLock lock(mMutex);\n>  \n> +  // Store the flag that the certificate is not present so that previous versions\n> +  // don't look for redundant certificate object\n> +  stream->WriteBoolean(0);\n\nWe don't need to write this flag any more.\n\nSince we are going to need to create a whole new cache version, we don't have to worry about backward compatibility with this function. We can remove all of the junk dealing with the various formats in both Write() and Read() and just straightforwardly read and write the new format you are creating here.\n\n@@ +702,1 @@\n>    stream->Write32(version | 0xFFFF0000);\n\nWe won't need to mask with 0xFFFF0000 any more.\n\n@@ +703,5 @@\n>  \n>    // XXX: uses nsNSSComponent string bundles off the main thread\n>    nsresult rv = formatErrorMessage(lock); \n>    NS_ENSURE_SUCCESS(rv, rv);\n>    stream->WriteWStringZ(mErrorMessageCached.get());\n\nWe should be writing the mErrorCode instead of mErrorMessageCached. (And, we consequently, we don't need to call formatErrorMessage anymore.)\n\n@@ +705,5 @@\n>    nsresult rv = formatErrorMessage(lock); \n>    NS_ENSURE_SUCCESS(rv, rv);\n>    stream->WriteWStringZ(mErrorMessageCached.get());\n>  \n>    stream->WriteCompoundObject(NS_ISUPPORTS_CAST(nsISSLStatus*, status),\n\nSince this is done holding the lock, there's no use in copy mStatus to status any more.\n\nAdd back the warning about serializing a missing nsNSSocketInfo:\nif (!mSSLStatus) {\n    NS_WARNING(\"Serializing nsNSSSocketInfo without mSSLStatus\");\n}\n\n@@ +772,5 @@\n>          do_CreateInstance(kNSSCertificateCID, &rv);\n>      NS_ENSURE_SUCCESS(rv, rv);\n>  \n>      // This is the redundant copy of the certificate; just ignore it\n>      serializable->Read(stream);\n\nRemove this, because we don't write the redundant copy of the cert any more.\n\n@@ +781,5 @@\n>    // If the version field we have just read is not masked with 0xFFFF0000\n>    // then it is stored mSecurityState field and this is version 1 of\n>    // the binary data stream format.\n>    if ((version & 0xFFFF0000) == 0xFFFF0000) {\n>      version &= ~0xFFFF0000;\n\nWe can remove all of the above masking logic since we don't have to support reading version 1 entries any more.\n\n@@ +783,5 @@\n>    // the binary data stream format.\n>    if ((version & 0xFFFF0000) == 0xFFFF0000) {\n>      version &= ~0xFFFF0000;\n> +    if(version!=4){\n> +      NS_ERROR(\"Cache version is not 4\");\n\nInstead, use NS_ENSURE_TRUE(version == 4, NS_ERROR_INVALID_DATA);\n\n@@ +794,2 @@\n>    stream->ReadString(mErrorMessageCached);\n>    mErrorCode = 0;\n\nThis should be a read of mErrorCode.\n\n::: security/manager/ssl/src/nsSSLStatus.cpp\n@@ +75,5 @@\n>      return NS_ERROR_NOT_AVAILABLE;\n>  \n> +  SSLCipherSuiteInfo cipherSuiteInfo;\n> +  if (SECSuccess != SSL_GetCipherSuiteInfo(mCipherSuiteID, &cipherSuiteInfo, sizeof cipherSuiteInfo)) {\n> +    NS_ERROR(\"SSL_GetCipherSuiteInfo\");\n\ninstead of NS_ERROR, call NS_WARNING and then return NS_ERROR_UNEXPECTED.\n\n@@ +93,5 @@\n> +  SSLCipherSuiteInfo info;\n> +  SECStatus status;\n> +  status = SSL_GetCipherSuiteInfo(mCipherSuiteID, &info, sizeof info);\n> +  if (status != SECSuccess) {\n> +    printf(\"SSL_GetCipherSuiteInfo rejected suite 0x%04x\\n\",\n\nremove this printf.\n\n@@ +95,5 @@\n> +  status = SSL_GetCipherSuiteInfo(mCipherSuiteID, &info, sizeof info);\n> +  if (status != SECSuccess) {\n> +    printf(\"SSL_GetCipherSuiteInfo rejected suite 0x%04x\\n\",\n> +            mCipherSuiteID);\n> +    NS_WARNING(\"SSL_GetCipherSuiteInfo\");\n\nreturn NS_ERROR_UNEXPECTED;\n\n@@ +102,1 @@\n>  \n\nNS_ENSURE_TRUE(*_result, NS_ERROR_OUT_OF_MEMORY);\n\n@@ -134,5 @@\n>  \n>    rv = stream->Read32(&mKeyLength);\n>    NS_ENSURE_SUCCESS(rv, rv);\n> -  rv = stream->Read32(&mSecretKeyLength);\n> -  NS_ENSURE_SUCCESS(rv, rv);\n\nDo not remove the NS_ENSURE_SUCCESS(...) calls.\n\nIn fact, instead we should be adding the missing NS_ENSURE_SUCCESS calls to nsNSSSocketInfo::Read() and Write(). (We can do that in another bug though.)\n\n@@ +150,3 @@\n>    NS_ENSURE_SUCCESS(rv, rv);\n>  \n> +  PRUint32 Details;\n\nlowercase details.\n\n::: security/manager/ssl/src/nsSSLStatus.h\n@@ +52,5 @@\n> +#define ISNOTVALIDATTHISTIME 1\n> +#define ISUNTRUSTED 2\n> +#define HAVEKEYLENGTHANDCIPHER 3\n> +#define HAVECERTERRORBITS 4\n> +#define GETCHANNELINFOFAILED 5\n\nSince these do not need to be used outsode of nsSSLStatus.cpp, move them to nsSSLStatus.cpp. Since they don't need to be used by C code, define them like this:\n\nnamespace {\nconst PRUint32 IS_DOMAIN_MISMATCH = 1;\nconst PRUint32 IS_NOT_VALUE_AT_THIS_TIME = 2;\nconst PRUint32 IS_UNTRUSTED = 4;\nconst PRUint32 HAVE_KEY_LENGTH_AND_CIPHER = 8;\n...\n}\n\nThis way, Read() can do things like this:\n\nmIsDomainMismatch = details & IS_DOMAIN_MISMATCH;\nmIsUntrusted = details & IS_UNTRUSTED;\n...\n\nand Write can be:\n\ndetails |= mIsDomainMismatch ? IS_DOMAIN_MISMATCH : 0;\ndetails |= mIsUntrusted ? IS_UNTRUSTED : 0;\n...\n\nI think this is clearer than the bit shifting.\n\n@@ +83,5 @@\n>  \n>    /* mHaveCertErrrorBits is relied on to determine whether or not a SPDY\n>       connection is eligible for joining in nsNSSSocketInfo::JoinConnection() */\n>    bool mHaveCertErrorBits;\n> +  bool mGetChannelInfoFailed;\n\nHmm...It seems like mGetChannelInfoFailed is always equal to mHaveKeyLengthAndCipher so, I guess we don't need it. (This is why you couldn't find a place to test it.)", "author": "brian@briansmith.org", "bug_id": 697781, "id": 5943100, "is_private": false, "creation_time": "2011-12-28T18:15:42Z", "time": "2011-12-28T18:15:42Z", "raw_text": "Review of attachment 584526:\n-----------------------------------------------------------------\n\nI added Honza as the superreviewer.\n\n::: security/manager/ssl/src/nsNSSCallbacks.cpp\n@@ -856,4 @@\n>    PRBool siteSupportsSafeRenego;\n>    if (SSL_HandshakeNegotiatedExtension(fd, ssl_renegotiation_info_xtn, &siteSupportsSafeRenego) != SECSuccess\n>        || !siteSupportsSafeRenego) {\n> -\n\nUndo this whitespace change.\n\n@@ -873,5 @@\n>          console->LogStringMessage(msg.get());\n>        }\n>      }\n> -    if (nsSSLIOLayerHelpers::treatUnsafeNegotiationAsBroken()) {\n> -      secStatus = nsIWebProgressListener::STATE_IS_BROKEN;\n\nYou need to save the fact that renegotiation wasn't supported into nsNSSSocketInfo, so that you can calculate the state correctly in nsNSSSocketInfo::GetSecurityState\n\n::: security/manager/ssl/src/nsNSSIOLayer.cpp\n@@ +338,5 @@\n>  \n>  NS_IMETHODIMP\n>  nsNSSSocketInfo::GetSecurityState(PRUint32* state)\n>  {\n> +  if (nsSSLIOLayerHelpers::treatUnsafeNegotiationAsBroken()) {\n\nnsSSLIOLayerHelpers::treatUnsafeNegotiationAsBroken refers to the setting of a preference.\n\nWhat you need to know here is whether the secure renegotiation extension was negotiated. You can do this by creating a new member variable mSecureRenegotiation in nsNSSSocketInfo and setting it in HandshakeCallback.\n\nDon't forget to serialize the new flag in Write() and deserialize it in Read().\n\n@@ +343,5 @@\n> +    *state = nsIWebProgressListener::STATE_IS_BROKEN;\n> +    return NS_OK;\n> +  }\n> +  PRUint32 encryptBits;\n> +  mSSLStatus->GetSecretKeyLength(&encryptBits);\n\nnsresult rv = mSSLStatus->GetSecretKeyLength(&encryptBits);\nNS_ENSURE_SUCCESS(rv, rv);\n\n(Because mSSLStatus->GetSecretKeyLength can fail.)\n\n@@ +426,5 @@\n> +  if (!serverCert)\n> +    return NS_ERROR_NOT_AVAILABLE;\n> +  const char* caName = nsnull; // caName is a pointer only, no ownership\n> +  nsAutoString certOrgName;\n> +  mSSLStatus->mServerCert->GetOrganization(certOrgName);\n\nThis should be GetIssuerOrganization. We want the name of the CA, not the name of the EE.\n\nAlso, check the return value with NS_ENSURE_SUCCESS.\n\n@@ +428,5 @@\n> +  const char* caName = nsnull; // caName is a pointer only, no ownership\n> +  nsAutoString certOrgName;\n> +  mSSLStatus->mServerCert->GetOrganization(certOrgName);\n> +  nsresult rv;\n> +  caName =  ToNewUTF8String(certOrgName);\n\nToNewUTF8String will allocate a new string that needs to be freed.\n\ninstead, you can do something like:\nconst PRUnichar* caName\n    = certIssuerOrgName == \"RSA Data Security, Inc.\"\n    ? NS_LITERAL_STRING(\"Verisign, Inc.\")\n    : certIssuerOrgName.get();\n\nMaybe you have to use .Equals() instead, and/or wrap \"RSA Data Security, Inc.\" with NS_LITERAL_STRING.\n\nMake sure you test this in the browser by looking at the larry popup for sites with Verisign and non-Verisign issued certificates.\n\n@@ +438,5 @@\n> +    caName = verisignName;\n> +  }\n> +\n> +  nsAutoString shortDesc;\n> +  const PRUnichar* formatStrings[1] = {NS_ConvertUTF8toUTF16(caName).get()};\n\nIf you make caName PRUnichar*, you will not need the UTF8-to-UTF16 conversion.\n\n@@ +440,5 @@\n> +\n> +  nsAutoString shortDesc;\n> +  const PRUnichar* formatStrings[1] = {NS_ConvertUTF8toUTF16(caName).get()};\n> +  nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(kNSSComponentCID, &rv));\n> +  if (NS_SUCCEEDED(rv)) {\n\nNS_ENSURE_SUCCESS(rv, rv). Otherwise, you end up returning NS_OK without setting *aText in this (extremely unlikely situation).\n\n@@ +445,5 @@\n> +    rv = nssComponent->PIPBundleFormatStringFromName(\"SignedBy\",\n> +                                                   formatStrings, 1,\n> +                                                   shortDesc);\n> +\n> +    nsMemory::Free(const_cast<PRUnichar*>(formatStrings[0]));\n\nI think we don't need this call to nsMemory::Free, if we make the changes I suggested above.\n\n@@ -413,5 @@\n>    return NS_OK;\n>  }\n>  \n> -nsresult\n> -nsNSSSocketInfo::SetShortSecurityDescription(const PRUnichar* aText) {\n\nRemove the declaration from the class definition too.\n\n@@ +689,5 @@\n>    MutexAutoLock lock(mMutex);\n>  \n> +  // Store the flag that the certificate is not present so that previous versions\n> +  // don't look for redundant certificate object\n> +  stream->WriteBoolean(0);\n\nWe don't need to write this flag any more.\n\nSince we are going to need to create a whole new cache version, we don't have to worry about backward compatibility with this function. We can remove all of the junk dealing with the various formats in both Write() and Read() and just straightforwardly read and write the new format you are creating here.\n\n@@ +702,1 @@\n>    stream->Write32(version | 0xFFFF0000);\n\nWe won't need to mask with 0xFFFF0000 any more.\n\n@@ +703,5 @@\n>  \n>    // XXX: uses nsNSSComponent string bundles off the main thread\n>    nsresult rv = formatErrorMessage(lock); \n>    NS_ENSURE_SUCCESS(rv, rv);\n>    stream->WriteWStringZ(mErrorMessageCached.get());\n\nWe should be writing the mErrorCode instead of mErrorMessageCached. (And, we consequently, we don't need to call formatErrorMessage anymore.)\n\n@@ +705,5 @@\n>    nsresult rv = formatErrorMessage(lock); \n>    NS_ENSURE_SUCCESS(rv, rv);\n>    stream->WriteWStringZ(mErrorMessageCached.get());\n>  \n>    stream->WriteCompoundObject(NS_ISUPPORTS_CAST(nsISSLStatus*, status),\n\nSince this is done holding the lock, there's no use in copy mStatus to status any more.\n\nAdd back the warning about serializing a missing nsNSSocketInfo:\nif (!mSSLStatus) {\n    NS_WARNING(\"Serializing nsNSSSocketInfo without mSSLStatus\");\n}\n\n@@ +772,5 @@\n>          do_CreateInstance(kNSSCertificateCID, &rv);\n>      NS_ENSURE_SUCCESS(rv, rv);\n>  \n>      // This is the redundant copy of the certificate; just ignore it\n>      serializable->Read(stream);\n\nRemove this, because we don't write the redundant copy of the cert any more.\n\n@@ +781,5 @@\n>    // If the version field we have just read is not masked with 0xFFFF0000\n>    // then it is stored mSecurityState field and this is version 1 of\n>    // the binary data stream format.\n>    if ((version & 0xFFFF0000) == 0xFFFF0000) {\n>      version &= ~0xFFFF0000;\n\nWe can remove all of the above masking logic since we don't have to support reading version 1 entries any more.\n\n@@ +783,5 @@\n>    // the binary data stream format.\n>    if ((version & 0xFFFF0000) == 0xFFFF0000) {\n>      version &= ~0xFFFF0000;\n> +    if(version!=4){\n> +      NS_ERROR(\"Cache version is not 4\");\n\nInstead, use NS_ENSURE_TRUE(version == 4, NS_ERROR_INVALID_DATA);\n\n@@ +794,2 @@\n>    stream->ReadString(mErrorMessageCached);\n>    mErrorCode = 0;\n\nThis should be a read of mErrorCode.\n\n::: security/manager/ssl/src/nsSSLStatus.cpp\n@@ +75,5 @@\n>      return NS_ERROR_NOT_AVAILABLE;\n>  \n> +  SSLCipherSuiteInfo cipherSuiteInfo;\n> +  if (SECSuccess != SSL_GetCipherSuiteInfo(mCipherSuiteID, &cipherSuiteInfo, sizeof cipherSuiteInfo)) {\n> +    NS_ERROR(\"SSL_GetCipherSuiteInfo\");\n\ninstead of NS_ERROR, call NS_WARNING and then return NS_ERROR_UNEXPECTED.\n\n@@ +93,5 @@\n> +  SSLCipherSuiteInfo info;\n> +  SECStatus status;\n> +  status = SSL_GetCipherSuiteInfo(mCipherSuiteID, &info, sizeof info);\n> +  if (status != SECSuccess) {\n> +    printf(\"SSL_GetCipherSuiteInfo rejected suite 0x%04x\\n\",\n\nremove this printf.\n\n@@ +95,5 @@\n> +  status = SSL_GetCipherSuiteInfo(mCipherSuiteID, &info, sizeof info);\n> +  if (status != SECSuccess) {\n> +    printf(\"SSL_GetCipherSuiteInfo rejected suite 0x%04x\\n\",\n> +            mCipherSuiteID);\n> +    NS_WARNING(\"SSL_GetCipherSuiteInfo\");\n\nreturn NS_ERROR_UNEXPECTED;\n\n@@ +102,1 @@\n>  \n\nNS_ENSURE_TRUE(*_result, NS_ERROR_OUT_OF_MEMORY);\n\n@@ -134,5 @@\n>  \n>    rv = stream->Read32(&mKeyLength);\n>    NS_ENSURE_SUCCESS(rv, rv);\n> -  rv = stream->Read32(&mSecretKeyLength);\n> -  NS_ENSURE_SUCCESS(rv, rv);\n\nDo not remove the NS_ENSURE_SUCCESS(...) calls.\n\nIn fact, instead we should be adding the missing NS_ENSURE_SUCCESS calls to nsNSSSocketInfo::Read() and Write(). (We can do that in another bug though.)\n\n@@ +150,3 @@\n>    NS_ENSURE_SUCCESS(rv, rv);\n>  \n> +  PRUint32 Details;\n\nlowercase details.\n\n::: security/manager/ssl/src/nsSSLStatus.h\n@@ +52,5 @@\n> +#define ISNOTVALIDATTHISTIME 1\n> +#define ISUNTRUSTED 2\n> +#define HAVEKEYLENGTHANDCIPHER 3\n> +#define HAVECERTERRORBITS 4\n> +#define GETCHANNELINFOFAILED 5\n\nSince these do not need to be used outsode of nsSSLStatus.cpp, move them to nsSSLStatus.cpp. Since they don't need to be used by C code, define them like this:\n\nnamespace {\nconst PRUint32 IS_DOMAIN_MISMATCH = 1;\nconst PRUint32 IS_NOT_VALUE_AT_THIS_TIME = 2;\nconst PRUint32 IS_UNTRUSTED = 4;\nconst PRUint32 HAVE_KEY_LENGTH_AND_CIPHER = 8;\n...\n}\n\nThis way, Read() can do things like this:\n\nmIsDomainMismatch = details & IS_DOMAIN_MISMATCH;\nmIsUntrusted = details & IS_UNTRUSTED;\n...\n\nand Write can be:\n\ndetails |= mIsDomainMismatch ? IS_DOMAIN_MISMATCH : 0;\ndetails |= mIsUntrusted ? IS_UNTRUSTED : 0;\n...\n\nI think this is clearer than the bit shifting.\n\n@@ +83,5 @@\n>  \n>    /* mHaveCertErrrorBits is relied on to determine whether or not a SPDY\n>       connection is eligible for joining in nsNSSSocketInfo::JoinConnection() */\n>    bool mHaveCertErrorBits;\n> +  bool mGetChannelInfoFailed;\n\nHmm...It seems like mGetChannelInfoFailed is always equal to mHaveKeyLengthAndCipher so, I guess we don't need it. (This is why you couldn't find a place to test it.)", "attachment_id": 584526, "tags": []}, {"time": "2011-12-28T18:21:33Z", "attachment_id": null, "raw_text": "(In reply to Brian Smith (:bsmith) from comment #10)\n> @@ +95,5 @@\n> > +  status = SSL_GetCipherSuiteInfo(mCipherSuiteID, &info, sizeof info);\n> > +  if (status != SECSuccess) {\n> > +    printf(\"SSL_GetCipherSuiteInfo rejected suite 0x%04x\\n\",\n> > +            mCipherSuiteID);\n> > +    NS_WARNING(\"SSL_GetCipherSuiteInfo\");\n\nRemove this printf too.\n\n> @@ -134,5 @@\n> >  \n> >    rv = stream->Read32(&mKeyLength);\n> >    NS_ENSURE_SUCCESS(rv, rv);\n> > -  rv = stream->Read32(&mSecretKeyLength);\n> > -  NS_ENSURE_SUCCESS(rv, rv);\n> \n> Do not remove the NS_ENSURE_SUCCESS(...) calls.\n\nIgnore this comment. I misread the patch.", "tags": [], "creator": "brian@briansmith.org", "author": "brian@briansmith.org", "text": "(In reply to Brian Smith (:bsmith) from comment #10)\n> @@ +95,5 @@\n> > +  status = SSL_GetCipherSuiteInfo(mCipherSuiteID, &info, sizeof info);\n> > +  if (status != SECSuccess) {\n> > +    printf(\"SSL_GetCipherSuiteInfo rejected suite 0x%04x\\n\",\n> > +            mCipherSuiteID);\n> > +    NS_WARNING(\"SSL_GetCipherSuiteInfo\");\n\nRemove this printf too.\n\n> @@ -134,5 @@\n> >  \n> >    rv = stream->Read32(&mKeyLength);\n> >    NS_ENSURE_SUCCESS(rv, rv);\n> > -  rv = stream->Read32(&mSecretKeyLength);\n> > -  NS_ENSURE_SUCCESS(rv, rv);\n> \n> Do not remove the NS_ENSURE_SUCCESS(...) calls.\n\nIgnore this comment. I misread the patch.", "count": 11, "bug_id": 697781, "id": 5943116, "is_private": false, "creation_time": "2011-12-28T18:21:33Z"}, {"creation_time": "2012-01-01T20:27:32Z", "is_private": false, "creator": "jitenmt@gmail.com", "tags": [], "attachment_id": null, "id": 5949078, "bug_id": 697781, "count": 12, "text": "@@ +705,5 @@\n>    nsresult rv = formatErrorMessage(lock); \n>    NS_ENSURE_SUCCESS(rv, rv);\n>    stream->WriteWStringZ(mErrorMessageCached.get());\n>  \n>    stream->WriteCompoundObject(NS_ISUPPORTS_CAST(nsISSLStatus*, status),\n\nSince this is done holding the lock, there's no use in copy mStatus to status any more.\n\nAdd back the warning about serializing a missing nsNSSocketInfo:\nif (!mSSLStatus) {\n    NS_WARNING(\"Serializing nsNSSSocketInfo without mSSLStatus\");\n}\n\nBrian, can you elaborate this one?", "author": "jitenmt@gmail.com", "raw_text": "@@ +705,5 @@\n>    nsresult rv = formatErrorMessage(lock); \n>    NS_ENSURE_SUCCESS(rv, rv);\n>    stream->WriteWStringZ(mErrorMessageCached.get());\n>  \n>    stream->WriteCompoundObject(NS_ISUPPORTS_CAST(nsISSLStatus*, status),\n\nSince this is done holding the lock, there's no use in copy mStatus to status any more.\n\nAdd back the warning about serializing a missing nsNSSocketInfo:\nif (!mSSLStatus) {\n    NS_WARNING(\"Serializing nsNSSSocketInfo without mSSLStatus\");\n}\n\nBrian, can you elaborate this one?", "time": "2012-01-01T20:27:32Z"}, {"attachment_id": null, "tags": [], "creator": "brian@briansmith.org", "is_private": false, "creation_time": "2012-01-01T22:06:07Z", "time": "2012-01-01T22:06:07Z", "raw_text": "(In reply to Jiten [:deLta30] from comment #12)\n> @@ +705,5 @@\n> >    nsresult rv = formatErrorMessage(lock); \n> >    NS_ENSURE_SUCCESS(rv, rv);\n> >    stream->WriteWStringZ(mErrorMessageCached.get());\n> >  \n> >    stream->WriteCompoundObject(NS_ISUPPORTS_CAST(nsISSLStatus*, status),\n> \n> Since this is done holding the lock, there's no use in copy mStatus to\n> status any more.\n\nI just mean we don't need the \"status\" local variable any more; we can use \"mStatus\" everywhere instead.\n\n> Add back the warning about serializing a missing nsNSSocketInfo:\n> if (!mSSLStatus) {\n>     NS_WARNING(\"Serializing nsNSSSocketInfo without mSSLStatus\");\n> }\n> \n> Brian, can you elaborate this one?\n\nI believe we should never be serializing an nsNSSSocketInfo that is missing the mSSLStatus member. But, I haven't proved it yet. By adding the warning here, we will see it when debugging, if this case ever comes up. It also helps document that we expect that things might not work if this case comes up.", "count": 13, "text": "(In reply to Jiten [:deLta30] from comment #12)\n> @@ +705,5 @@\n> >    nsresult rv = formatErrorMessage(lock); \n> >    NS_ENSURE_SUCCESS(rv, rv);\n> >    stream->WriteWStringZ(mErrorMessageCached.get());\n> >  \n> >    stream->WriteCompoundObject(NS_ISUPPORTS_CAST(nsISSLStatus*, status),\n> \n> Since this is done holding the lock, there's no use in copy mStatus to\n> status any more.\n\nI just mean we don't need the \"status\" local variable any more; we can use \"mStatus\" everywhere instead.\n\n> Add back the warning about serializing a missing nsNSSocketInfo:\n> if (!mSSLStatus) {\n>     NS_WARNING(\"Serializing nsNSSSocketInfo without mSSLStatus\");\n> }\n> \n> Brian, can you elaborate this one?\n\nI believe we should never be serializing an nsNSSSocketInfo that is missing the mSSLStatus member. But, I haven't proved it yet. By adding the warning here, we will see it when debugging, if this case ever comes up. It also helps document that we expect that things might not work if this case comes up.", "author": "brian@briansmith.org", "id": 5949113, "bug_id": 697781}, {"is_private": false, "creation_time": "2012-01-18T12:18:34Z", "id": 5988414, "bug_id": 697781, "author": "jitenmt@gmail.com", "text": "Created attachment 589464\npatch_3\n\nMochitests to be done.", "count": 14, "creator": "jitenmt@gmail.com", "tags": [], "attachment_id": 589464, "raw_text": "Mochitests to be done.", "time": "2012-01-18T12:18:34Z"}, {"author": "josh@joshmatthews.net", "count": 15, "text": "Comment on attachment 589464\npatch_3\n\n>+  const PRUnichar* caName;\n>+  if(certIssuerOrgName.EqualsLiteral(\"RSA Data Security, Inc.\"))\n>+    NS_NAMED_LITERAL_STRING(caName, \"Verisign, Inc.\");\n>+  else\n>+    caName = certIssuerOrgName.get();\n\nNS_NAMED_LITERAL_STRING does not do what you want here. It just declares a local, shadowed string named caName that goes out of scope immediately and leaves the original caName unchanged.", "creator": "josh@joshmatthews.net", "is_private": false, "creation_time": "2012-01-18T17:04:30Z", "id": 5989121, "bug_id": 697781, "attachment_id": 589464, "raw_text": ">+  const PRUnichar* caName;\n>+  if(certIssuerOrgName.EqualsLiteral(\"RSA Data Security, Inc.\"))\n>+    NS_NAMED_LITERAL_STRING(caName, \"Verisign, Inc.\");\n>+  else\n>+    caName = certIssuerOrgName.get();\n\nNS_NAMED_LITERAL_STRING does not do what you want here. It just declares a local, shadowed string named caName that goes out of scope immediately and leaves the original caName unchanged.", "time": "2012-01-18T17:04:30Z", "tags": []}, {"creation_time": "2012-01-18T17:59:45Z", "is_private": false, "id": 5989310, "bug_id": 697781, "count": 16, "text": "Can we change shortSecurityDescription to be a DOMString?", "author": "Ms2ger@gmail.com", "creator": "Ms2ger@gmail.com", "tags": [], "raw_text": "Can we change shortSecurityDescription to be a DOMString?", "attachment_id": null, "time": "2012-01-18T17:59:45Z"}, {"is_private": false, "creation_time": "2012-01-18T18:42:37Z", "id": 5989470, "bug_id": 697781, "count": 17, "text": "Created attachment 589571\npatch_3\n\nSlight refining. Needs to be tested by mochitest.", "author": "jitenmt@gmail.com", "creator": "jitenmt@gmail.com", "tags": [], "raw_text": "Slight refining. Needs to be tested by mochitest.", "attachment_id": 589571, "time": "2012-01-18T18:42:37Z"}, {"creation_time": "2012-02-08T10:38:03Z", "is_private": false, "bug_id": 697781, "id": 6043294, "text": "Try server results:\nhttps://tbpl.mozilla.org/?tree=Try&rev=8a777cc7f598", "count": 18, "author": "jitenmt@gmail.com", "creator": "jitenmt@gmail.com", "tags": [], "raw_text": "Try server results:\nhttps://tbpl.mozilla.org/?tree=Try&rev=8a777cc7f598", "attachment_id": null, "time": "2012-02-08T10:38:03Z"}, {"tags": [], "attachment_id": null, "raw_text": "Looking good; I don't see any failures that look like they were caused by your changes.", "time": "2012-02-08T12:55:58Z", "creation_time": "2012-02-08T12:55:58Z", "is_private": false, "id": 6043493, "bug_id": 697781, "author": "josh@joshmatthews.net", "text": "Looking good; I don't see any failures that look like they were caused by your changes.", "count": 19, "creator": "josh@joshmatthews.net"}, {"is_private": false, "creation_time": "2012-02-14T14:22:30Z", "id": 6059583, "bug_id": 697781, "author": "jitenmt@gmail.com", "count": 20, "text": "Brian, can you have a look at the patch to finalize?", "creator": "jitenmt@gmail.com", "tags": [], "attachment_id": null, "raw_text": "Brian, can you have a look at the patch to finalize?", "time": "2012-02-14T14:22:30Z"}, {"time": "2012-03-30T21:42:14Z", "raw_text": "Looks like this got left on the ground.", "attachment_id": 589571, "tags": [], "creator": "josh@joshmatthews.net", "count": 21, "text": "Comment on attachment 589571\npatch_3\n\nLooks like this got left on the ground.", "author": "josh@joshmatthews.net", "bug_id": 697781, "id": 6186362, "creation_time": "2012-03-30T21:42:14Z", "is_private": false}, {"time": "2012-06-13T19:02:43Z", "raw_text": "Jiten, I did not forget about this patch. It turns out that there are some complicating factors; the laziness is great for desktop but it might not work well for B2G, and I think we need to have two different serializations (one for interprocess communication, one for storage on disk).\n\nThe other issue is that older releases do not implement good error recovery for the case where the security info is not in the old format that they understand. This makes our lives difficult here because we're specifically trying to change on-disk format. We have a mechanism for telling older versions that the *whole cache* is in a new format, but this mechanism currently requires us to throw away the whole cache and start over, which is something we don't want to do. When we started working on this, we had thought that we were going to change the on-disk format of the cache anyway, but that got changed. :(", "attachment_id": null, "tags": [], "creator": "brian@briansmith.org", "count": 22, "text": "Jiten, I did not forget about this patch. It turns out that there are some complicating factors; the laziness is great for desktop but it might not work well for B2G, and I think we need to have two different serializations (one for interprocess communication, one for storage on disk).\n\nThe other issue is that older releases do not implement good error recovery for the case where the security info is not in the old format that they understand. This makes our lives difficult here because we're specifically trying to change on-disk format. We have a mechanism for telling older versions that the *whole cache* is in a new format, but this mechanism currently requires us to throw away the whole cache and start over, which is something we don't want to do. When we started working on this, we had thought that we were going to change the on-disk format of the cache anyway, but that got changed. :(", "author": "brian@briansmith.org", "bug_id": 697781, "id": 6388744, "creation_time": "2012-06-13T19:02:43Z", "is_private": false}, {"author": "brian@briansmith.org", "count": 23, "text": "Comment on attachment 589571\npatch_3\n\nClearing review request. I won't have time to look at this any time soon. At this point everything cache-related probably needs to wait for the new cache to be ready.", "creator": "brian@briansmith.org", "creation_time": "2014-03-10T08:02:41Z", "is_private": false, "bug_id": 697781, "id": 8511579, "attachment_id": 589571, "raw_text": "Clearing review request. I won't have time to look at this any time soon. At this point everything cache-related probably needs to wait for the new cache to be ready.", "time": "2014-03-10T08:02:41Z", "tags": []}, {"tags": [], "time": "2017-09-13T18:41:18Z", "attachment_id": null, "raw_text": "Bulk change to priority: https://bugzilla.mozilla.org/show_bug.cgi?id=1399258", "id": 12659077, "bug_id": 697781, "creation_time": "2017-09-13T18:41:18Z", "is_private": false, "creator": "bug-husbandry-bot@mozilla.bugs", "author": "bug-husbandry-bot@mozilla.bugs", "count": 24, "text": "Bulk change to priority: https://bugzilla.mozilla.org/show_bug.cgi?id=1399258"}]}}}