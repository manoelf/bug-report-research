{"comments": {}, "bugs": {"644210": {"comments": [{"attachment_id": null, "creator": "paul@oshannessy.com", "author": "paul@oshannessy.com", "text": "There are a set of APIs for Ints, but the corresponding support for Uints is incomplete.\n\nUINT_TO_JSVAL and JS_ValueToECMAUint32 exist, but that's about the extent of it.\n\nFor the V8 API, Value::IsInt32 corresponds nicely to JSVAL_IS_INT, but there's nothing so nice for Value::IsUint32 (JSVAL_IS_UINT doesn't exists - understandably since that gets stored as a double internally, bit it would be nice). Instead we are explicitly checking IS_NUMBER && >0 && (IS_INT || < UINT_MAX && floor == ceil) (https://github.com/zpao/v8monkey/blob/722e527e3b0873a7dee69e9a69eb4b9dffbace34/js/src/v8api/v8.cpp#L143-150)\n\nThat's the only one that was annoying so far, but I think there are other cases where there aren't matching APIs.", "count": 0, "is_private": false, "raw_text": "There are a set of APIs for Ints, but the corresponding support for Uints is incomplete.\n\nUINT_TO_JSVAL and JS_ValueToECMAUint32 exist, but that's about the extent of it.\n\nFor the V8 API, Value::IsInt32 corresponds nicely to JSVAL_IS_INT, but there's nothing so nice for Value::IsUint32 (JSVAL_IS_UINT doesn't exists - understandably since that gets stored as a double internally, bit it would be nice). Instead we are explicitly checking IS_NUMBER && >0 && (IS_INT || < UINT_MAX && floor == ceil) (https://github.com/zpao/v8monkey/blob/722e527e3b0873a7dee69e9a69eb4b9dffbace34/js/src/v8api/v8.cpp#L143-150)\n\nThat's the only one that was annoying so far, but I think there are other cases where there aren't matching APIs.", "bug_id": 644210, "creation_time": "2011-03-23T17:08:26Z", "tags": [], "time": "2011-03-23T17:08:26Z", "id": 5362880}, {"tags": [], "creator": "dmandelin@mozilla.com", "creation_time": "2011-03-23T17:33:30Z", "bug_id": 644210, "raw_text": "Random thought: (In reply to comment #0)\n> There are a set of APIs for Ints, but the corresponding support for Uints is\n> incomplete.\n> \n> UINT_TO_JSVAL and JS_ValueToECMAUint32 exist, but that's about the extent of\n> it.\n> \n> For the V8 API, Value::IsInt32 corresponds nicely to JSVAL_IS_INT, \n\nI don't think that's right. \n\n  Value::IsInt32 returns true iff the value can be represented as a 32-bit \n                                  signed integer\n\n  JSVAL_IS_INT   returns true iff the value's actual representation is a 32-bit\n                                  signed integer (i.e., the type tag is int)\n\n> but there's nothing so nice for Value::IsUint32 \n\nI think we need 2 new APIs here. But I have another random thought. Should these be C-style APIs like what we have, or should we add C++ methods to Value so that you can write |Valueify(v).isInt32)?", "attachment_id": null, "is_private": false, "text": "Random thought: (In reply to comment #0)\n> There are a set of APIs for Ints, but the corresponding support for Uints is\n> incomplete.\n> \n> UINT_TO_JSVAL and JS_ValueToECMAUint32 exist, but that's about the extent of\n> it.\n> \n> For the V8 API, Value::IsInt32 corresponds nicely to JSVAL_IS_INT, \n\nI don't think that's right. \n\n  Value::IsInt32 returns true iff the value can be represented as a 32-bit \n                                  signed integer\n\n  JSVAL_IS_INT   returns true iff the value's actual representation is a 32-bit\n                                  signed integer (i.e., the type tag is int)\n\n> but there's nothing so nice for Value::IsUint32 \n\nI think we need 2 new APIs here. But I have another random thought. Should these be C-style APIs like what we have, or should we add C++ methods to Value so that you can write |Valueify(v).isInt32)?", "count": 1, "id": 5362979, "time": "2011-03-23T17:33:30Z", "author": "dmandelin@mozilla.com"}, {"attachment_id": null, "creator": "mail@lukewagner.name", "author": "mail@lukewagner.name", "text": "(In reply to comment #1)\n> I think we need 2 new APIs here. But I have another random thought. Should\n> these be C-style APIs like what we have, or should we add C++ methods to Value\n> so that you can write |Valueify(v).isInt32)?\n\nYou can write Valueify(v).isInt32().\n\nOr do you mean isInt32 in the V8 \"can be represented as\" meaning?  For that purpose, it seems like we would want to define non-member queries/operations analogous to js_ValueToECMAUint32 where we carefully specify what exactly we are doing to derive said uint (which conversions will be used, how do they relate to the standard, etc).", "count": 2, "is_private": false, "tags": [], "raw_text": "(In reply to comment #1)\n> I think we need 2 new APIs here. But I have another random thought. Should\n> these be C-style APIs like what we have, or should we add C++ methods to Value\n> so that you can write |Valueify(v).isInt32)?\n\nYou can write Valueify(v).isInt32().\n\nOr do you mean isInt32 in the V8 \"can be represented as\" meaning?  For that purpose, it seems like we would want to define non-member queries/operations analogous to js_ValueToECMAUint32 where we carefully specify what exactly we are doing to derive said uint (which conversions will be used, how do they relate to the standard, etc).", "bug_id": 644210, "creation_time": "2011-03-23T17:39:23Z", "id": 5363002, "time": "2011-03-23T17:39:23Z"}, {"time": "2011-03-23T17:57:44Z", "id": 5363070, "is_private": false, "bug_id": 644210, "creation_time": "2011-03-23T17:57:44Z", "raw_text": "(In reply to comment #2)\n> You can write Valueify(v).isInt32().\nThis is the first I've seen Value and Valueify.  Are these public APIs?\n\n> Or do you mean isInt32 in the V8 \"can be represented as\" meaning?  For that\n> purpose, it seems like we would want to define non-member queries/operations\n> analogous to js_ValueToECMAUint32 where we carefully specify what exactly we\n> are doing to derive said uint (which conversions will be used, how do they\n> relate to the standard, etc).\nv8 has a type that is designed to represent a Uint32.  You can construct it with a Uint32 value.  Currently, we store this as an int in the jsval if it fits, or store it as a double if it is too big.", "tags": [], "author": "sdwilsh@forerunnerdesigns.com", "text": "(In reply to comment #2)\n> You can write Valueify(v).isInt32().\nThis is the first I've seen Value and Valueify.  Are these public APIs?\n\n> Or do you mean isInt32 in the V8 \"can be represented as\" meaning?  For that\n> purpose, it seems like we would want to define non-member queries/operations\n> analogous to js_ValueToECMAUint32 where we carefully specify what exactly we\n> are doing to derive said uint (which conversions will be used, how do they\n> relate to the standard, etc).\nv8 has a type that is designed to represent a Uint32.  You can construct it with a Uint32 value.  Currently, we store this as an int in the jsval if it fits, or store it as a double if it is too big.", "count": 3, "attachment_id": null, "creator": "sdwilsh@forerunnerdesigns.com"}, {"raw_text": "(In reply to comment #3)\n> (In reply to comment #2)\n> > You can write Valueify(v).isInt32().\n> This is the first I've seen Value and Valueify.  Are these public APIs?\n\nAt the moment its private (it #include's jsprvtd.h, its in namespace 'js'), but that was more of a fastest-route-to-fatvals solution.  It could be made public, but, really, its just C++ syntactic sugar for jsapi.h value manipulation.\n\n> > Or do you mean isInt32 in the V8 \"can be represented as\" meaning?  For that\n> > purpose, it seems like we would want to define non-member queries/operations\n> > analogous to js_ValueToECMAUint32 where we carefully specify what exactly we\n> > are doing to derive said uint (which conversions will be used, how do they\n> > relate to the standard, etc).\n> v8 has a type that is designed to represent a Uint32.  You can construct it\n> with a Uint32 value.  Currently, we store this as an int in the jsval if it\n> fits, or store it as a double if it is too big.\n\nAdding Uint32 to the fundamental value representation would be a huge deal, so your int32/double strategy seems reasonable.  The only scary thing is that this predicate would not be able to distinguish uint32's set via the v8-api that were converted to doubles from doubles that just happened to be whole numbers in the uint32 range.  From a JS semantic pov, this shouldn't matter, but one could imagine pathological v8-API usage...\n\nSo it seems like what is missing from the JSAPI is a JSDOUBLE_IS_UINT32 which would let you to define your own predicate:\n\n IsUint32(v) === JSVAL_IS_INT(v) && JSVAL_TO_INT(v) >= 0 ||\n                 JSVAL_IS_DOUBLE(v) && JSDOUBLE_IS_UINT32(JSVAL_TO_DOUBLE(v))", "bug_id": 644210, "creation_time": "2011-03-23T18:53:35Z", "tags": [], "is_private": false, "time": "2011-03-23T18:53:35Z", "id": 5363326, "creator": "mail@lukewagner.name", "attachment_id": null, "text": "(In reply to comment #3)\n> (In reply to comment #2)\n> > You can write Valueify(v).isInt32().\n> This is the first I've seen Value and Valueify.  Are these public APIs?\n\nAt the moment its private (it #include's jsprvtd.h, its in namespace 'js'), but that was more of a fastest-route-to-fatvals solution.  It could be made public, but, really, its just C++ syntactic sugar for jsapi.h value manipulation.\n\n> > Or do you mean isInt32 in the V8 \"can be represented as\" meaning?  For that\n> > purpose, it seems like we would want to define non-member queries/operations\n> > analogous to js_ValueToECMAUint32 where we carefully specify what exactly we\n> > are doing to derive said uint (which conversions will be used, how do they\n> > relate to the standard, etc).\n> v8 has a type that is designed to represent a Uint32.  You can construct it\n> with a Uint32 value.  Currently, we store this as an int in the jsval if it\n> fits, or store it as a double if it is too big.\n\nAdding Uint32 to the fundamental value representation would be a huge deal, so your int32/double strategy seems reasonable.  The only scary thing is that this predicate would not be able to distinguish uint32's set via the v8-api that were converted to doubles from doubles that just happened to be whole numbers in the uint32 range.  From a JS semantic pov, this shouldn't matter, but one could imagine pathological v8-API usage...\n\nSo it seems like what is missing from the JSAPI is a JSDOUBLE_IS_UINT32 which would let you to define your own predicate:\n\n IsUint32(v) === JSVAL_IS_INT(v) && JSVAL_TO_INT(v) >= 0 ||\n                 JSVAL_IS_DOUBLE(v) && JSDOUBLE_IS_UINT32(JSVAL_TO_DOUBLE(v))", "count": 4, "author": "mail@lukewagner.name"}, {"tags": [], "bug_id": 644210, "creation_time": "2011-03-23T18:56:25Z", "raw_text": "(In reply to comment #4)\n>  IsUint32(v) === JSVAL_IS_INT(v) && JSVAL_TO_INT(v) >= 0 ||\n>                  JSVAL_IS_DOUBLE(v) && JSDOUBLE_IS_UINT32(JSVAL_TO_DOUBLE(v))\nI believe so, but I'll let zpao comment since he's been looking at this a lot more closely than I have been.", "is_private": false, "id": 5363336, "time": "2011-03-23T18:56:25Z", "creator": "sdwilsh@forerunnerdesigns.com", "attachment_id": null, "text": "(In reply to comment #4)\n>  IsUint32(v) === JSVAL_IS_INT(v) && JSVAL_TO_INT(v) >= 0 ||\n>                  JSVAL_IS_DOUBLE(v) && JSDOUBLE_IS_UINT32(JSVAL_TO_DOUBLE(v))\nI believe so, but I'll let zpao comment since he's been looking at this a lot more closely than I have been.", "count": 5, "author": "sdwilsh@forerunnerdesigns.com"}, {"attachment_id": null, "creator": "paul@oshannessy.com", "author": "paul@oshannessy.com", "text": "(In reply to comment #1)\n> > For the V8 API, Value::IsInt32 corresponds nicely to JSVAL_IS_INT, \n> \n> I don't think that's right. \n> \n>   Value::IsInt32 returns true iff the value can be represented as a 32-bit \n>                                   signed integer\n> \n>   JSVAL_IS_INT   returns true iff the value's actual representation is a 32-bit\n>                                   signed integer (i.e., the type tag is int)\n\nAre you sure? I know the V8 documentation isn't great, but I got the impression that v8::Value::IsInt32 returned true iff the value was a 32-bit signed int. The API tests don't actually make that clear though since they only seem to test with numbers.\n\n> I think we need 2 new APIs here. But I have another random thought. Should\n> these be C-style APIs like what we have, or should we add C++ methods to Value\n> so that you can write |Valueify(v).isInt32)?\n\nHonestly, I think we're managing fine with the C-style APIs, but if you're looking for a future generation of APIs to expose, the C++ stuff would be much nicer.\n\n(In reply to comment #5)\n> (In reply to comment #4)\n> >  IsUint32(v) === JSVAL_IS_INT(v) && JSVAL_TO_INT(v) >= 0 ||\n> >                  JSVAL_IS_DOUBLE(v) && JSDOUBLE_IS_UINT32(JSVAL_TO_DOUBLE(v))\n> I believe so, but I'll let zpao comment since he's been looking at this a lot\n> more closely than I have been.\n\nYea, I think that should work better here (I'm assuming JS_NumberValue for false would be 0 which like I mentioned, I don't think we want). It certainly makes the whole situation much more manageable (and indeed allows us to define our own specific conditions), but as somebody completely new to jsapi/v8, it still feels a bit awkward.", "count": 6, "is_private": false, "raw_text": "(In reply to comment #1)\n> > For the V8 API, Value::IsInt32 corresponds nicely to JSVAL_IS_INT, \n> \n> I don't think that's right. \n> \n>   Value::IsInt32 returns true iff the value can be represented as a 32-bit \n>                                   signed integer\n> \n>   JSVAL_IS_INT   returns true iff the value's actual representation is a 32-bit\n>                                   signed integer (i.e., the type tag is int)\n\nAre you sure? I know the V8 documentation isn't great, but I got the impression that v8::Value::IsInt32 returned true iff the value was a 32-bit signed int. The API tests don't actually make that clear though since they only seem to test with numbers.\n\n> I think we need 2 new APIs here. But I have another random thought. Should\n> these be C-style APIs like what we have, or should we add C++ methods to Value\n> so that you can write |Valueify(v).isInt32)?\n\nHonestly, I think we're managing fine with the C-style APIs, but if you're looking for a future generation of APIs to expose, the C++ stuff would be much nicer.\n\n(In reply to comment #5)\n> (In reply to comment #4)\n> >  IsUint32(v) === JSVAL_IS_INT(v) && JSVAL_TO_INT(v) >= 0 ||\n> >                  JSVAL_IS_DOUBLE(v) && JSDOUBLE_IS_UINT32(JSVAL_TO_DOUBLE(v))\n> I believe so, but I'll let zpao comment since he's been looking at this a lot\n> more closely than I have been.\n\nYea, I think that should work better here (I'm assuming JS_NumberValue for false would be 0 which like I mentioned, I don't think we want). It certainly makes the whole situation much more manageable (and indeed allows us to define our own specific conditions), but as somebody completely new to jsapi/v8, it still feels a bit awkward.", "bug_id": 644210, "creation_time": "2011-03-24T05:39:27Z", "tags": [], "time": "2011-03-24T05:39:27Z", "id": 5365087}, {"attachment_id": null, "is_private": false, "raw_text": "JSDOUBLE_IS_UINT32 would just be a simple modification of JSDOUBLE_IS_INT32, which is in js/src/jsvalue.h.  Unfortunately, JSDOUBLE_IS_INT32 is currently in a private header.  It seems reasonable to hoist into jsapi.h, but to do that we'll need to #include math.h/float.h/ieeefp.h from jsapi.h.\n\nJason: can I just do that?", "bug_id": 644210, "creation_time": "2011-03-24T19:37:56Z", "creator": "mail@lukewagner.name", "tags": [], "author": "mail@lukewagner.name", "time": "2011-03-24T19:37:56Z", "id": 5366957, "text": "JSDOUBLE_IS_UINT32 would just be a simple modification of JSDOUBLE_IS_INT32, which is in js/src/jsvalue.h.  Unfortunately, JSDOUBLE_IS_INT32 is currently in a private header.  It seems reasonable to hoist into jsapi.h, but to do that we'll need to #include math.h/float.h/ieeefp.h from jsapi.h.\n\nJason: can I just do that?", "count": 7}, {"text": "Luke, see bug 640494. JSDOUBLE_IS_NEGZERO happens to be a bit of a headache, because using math.h macros causes conflicts with <cmath> under GCC with -stdc++0x. I think what I'm going to do there is reimplement signbit from scratch. :-P", "count": 8, "author": "jorendorff@mozilla.com", "creator": "jorendorff@mozilla.com", "attachment_id": null, "time": "2011-03-25T16:10:09Z", "id": 5369436, "raw_text": "Luke, see bug 640494. JSDOUBLE_IS_NEGZERO happens to be a bit of a headache, because using math.h macros causes conflicts with <cmath> under GCC with -stdc++0x. I think what I'm going to do there is reimplement signbit from scratch. :-P", "bug_id": 644210, "creation_time": "2011-03-25T16:10:09Z", "tags": [], "is_private": false}, {"creator": "sphink@gmail.com", "attachment_id": null, "text": "There's only one -0 in any format we care about, right? So wouldn't this work?:\n\nJS_ALWAYS_INLINE JSBool\nJSDOUBLE_IS_NEGZERO(jsdouble d)\n{\n    static union {\n        jsdouble d;\n        uint64 bits;\n    } NEG_ZERO = { -0.0f };\n    union {\n        jsdouble d;\n        uint64 bits;\n    } x = { d };\n    return x.bits == NEG_ZERO.bits;\n}\n\nOn x86_64:\n\n(gdb) disass is_negzero\nDump of assembler code for function _Z10is_negzerod:\n   0x0000000000400520 <+0>:\tmovsd  %xmm0,-0x8(%rsp)\n   0x0000000000400526 <+6>:\tmov    -0x8(%rsp),%rax\n   0x000000000040052b <+11>:\tcmp    %rax,0x15e(%rip)        # 0x400690 <_ZZ10is_negzerodE8NEG_ZERO>\n   0x0000000000400532 <+18>:\tsete   %al\n   0x0000000000400535 <+21>:\tretq", "count": 9, "author": "sphink@gmail.com", "raw_text": "There's only one -0 in any format we care about, right? So wouldn't this work?:\n\nJS_ALWAYS_INLINE JSBool\nJSDOUBLE_IS_NEGZERO(jsdouble d)\n{\n    static union {\n        jsdouble d;\n        uint64 bits;\n    } NEG_ZERO = { -0.0f };\n    union {\n        jsdouble d;\n        uint64 bits;\n    } x = { d };\n    return x.bits == NEG_ZERO.bits;\n}\n\nOn x86_64:\n\n(gdb) disass is_negzero\nDump of assembler code for function _Z10is_negzerod:\n   0x0000000000400520 <+0>:\tmovsd  %xmm0,-0x8(%rsp)\n   0x0000000000400526 <+6>:\tmov    -0x8(%rsp),%rax\n   0x000000000040052b <+11>:\tcmp    %rax,0x15e(%rip)        # 0x400690 <_ZZ10is_negzerodE8NEG_ZERO>\n   0x0000000000400532 <+18>:\tsete   %al\n   0x0000000000400535 <+21>:\tretq", "creation_time": "2011-03-25T16:48:32Z", "bug_id": 644210, "tags": [], "is_private": false, "time": "2011-03-25T16:48:32Z", "id": 5369560}, {"time": "2011-03-25T17:33:15Z", "id": 5369735, "creation_time": "2011-03-25T17:33:15Z", "bug_id": 644210, "raw_text": "Heh! That's pretty much exactly what I posted in bug 640494. Looking at the assembly under MSVC now...", "tags": [], "is_private": false, "text": "Heh! That's pretty much exactly what I posted in bug 640494. Looking at the assembly under MSVC now...", "count": 10, "author": "jorendorff@mozilla.com", "creator": "jorendorff@mozilla.com", "attachment_id": null}]}}}