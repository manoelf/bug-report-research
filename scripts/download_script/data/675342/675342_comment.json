{"bugs": {"675342": {"comments": [{"creator": "marty.rosenberg@gmail.com", "author": "marty.rosenberg@gmail.com", "text": "With a small test case on arm, I've observed a bunch of branches being created such as:\n[jaeger] Insns            >  ##linkJump         ((0x60)) jumps to ((0x64))\n[jaeger] Insns            >  ##linkJump         ((0xd0)) jumps to ((0xd4))\n[jaeger] Insns            >  ##linkJump         ((0xa8)) jumps to ((0xac))\n[jaeger] Insns            >  ##linkJump         ((0x264)) jumps to ((0x268))\n[jaeger] Insns            >  ##linkJump         ((0x2d4)) jumps to ((0x2d8))\n[jaeger] Insns            >  ##linkJump         ((0x3f0)) jumps to ((0x3f4))\n[jaeger] Insns            >  ##linkJump         ((0x464)) jumps to ((0x468))\n[jaeger] Insns            >  ##linkJump         ((0x4c4)) jumps to ((0x4c8))\n[jaeger] Insns            >  ##linkJump         ((0x558)) jumps to ((0x55c))\n[jaeger] Insns            >  ##linkJump         ((0x5cc)) jumps to ((0x5d0))\n[jaeger] Insns            >  ##linkJump         ((0x404)) jumps to ((0x408))\n[jaeger] Insns            >  ##linkJump         ((0x580)) jumps to ((0x584))\n[jaeger] Insns            >  ##linkJump         ((0xb48)) jumps to ((0xb4c))\n[jaeger] Insns            >  ##linkJump         ((0xf90)) jumps to ((0xf94))\n\nAt least one or two of these branches looked like it would never be patched.\nIf this is in fact the case, we should not do that.", "time": "2011-07-29T22:11:48Z", "attachment_id": null, "raw_text": "With a small test case on arm, I've observed a bunch of branches being created such as:\n[jaeger] Insns            >  ##linkJump         ((0x60)) jumps to ((0x64))\n[jaeger] Insns            >  ##linkJump         ((0xd0)) jumps to ((0xd4))\n[jaeger] Insns            >  ##linkJump         ((0xa8)) jumps to ((0xac))\n[jaeger] Insns            >  ##linkJump         ((0x264)) jumps to ((0x268))\n[jaeger] Insns            >  ##linkJump         ((0x2d4)) jumps to ((0x2d8))\n[jaeger] Insns            >  ##linkJump         ((0x3f0)) jumps to ((0x3f4))\n[jaeger] Insns            >  ##linkJump         ((0x464)) jumps to ((0x468))\n[jaeger] Insns            >  ##linkJump         ((0x4c4)) jumps to ((0x4c8))\n[jaeger] Insns            >  ##linkJump         ((0x558)) jumps to ((0x55c))\n[jaeger] Insns            >  ##linkJump         ((0x5cc)) jumps to ((0x5d0))\n[jaeger] Insns            >  ##linkJump         ((0x404)) jumps to ((0x408))\n[jaeger] Insns            >  ##linkJump         ((0x580)) jumps to ((0x584))\n[jaeger] Insns            >  ##linkJump         ((0xb48)) jumps to ((0xb4c))\n[jaeger] Insns            >  ##linkJump         ((0xf90)) jumps to ((0xf94))\n\nAt least one or two of these branches looked like it would never be patched.\nIf this is in fact the case, we should not do that.", "creation_time": "2011-07-29T22:11:48Z", "bug_id": 675342, "tags": [], "is_private": false, "count": 0, "id": 5622922}, {"author": "Jacob.Bramley@arm.com", "creator": "Jacob.Bramley@arm.com", "id": 5625118, "tags": [], "count": 1, "is_private": false, "bug_id": 675342, "raw_text": "Firstly, I like your title. Secondly, I have covered this in bug 586297. It was really trivial to add to that patch, so in it went.", "creation_time": "2011-08-01T13:52:24Z", "time": "2011-08-01T13:52:24Z", "attachment_id": null, "text": "Firstly, I like your title. Secondly, I have covered this in bug 586297. It was really trivial to add to that patch, so in it went."}, {"creator": "marty.rosenberg@gmail.com", "author": "marty.rosenberg@gmail.com", "is_private": false, "count": 2, "tags": [], "id": 5626934, "bug_id": 675342, "raw_text": "Good to see that it helped!\nAfter poking at it a bit more, I noticed some other things that can be optimized, but with a bit more effort.\n\n[jaeger] Insns            >  ##linkJump         ((0x48)) jumps to ((0xa8))\n[jaeger] Insns            >  ##linkJump         ((0xa8)) jumps to ((0xac))\n\n[jaeger] Insns            >  ##linkJump         ((0x5c)) jumps to ((0xa8))\n[jaeger] Insns            >  ##linkJump         ((0xa8)) jumps to ((0xac))\n\n[jaeger] Insns            >  ##linkJump         ((0x98)) jumps to ((0xdc))\n[jaeger] Insns            ##linkJump         ((0xdc)) jumps to ((0x238))\n[jaeger] Insns            >  ##linkJump         ((0x238)) jumps to ((0x2a4))\n\nwhere in every group of instructions, we have a branch that branches directly to another branch.  If we can get better information about which branches won't be patched later (I believe this was mentioned in bug 586297), we can simply replace all branches in a chain with the last address that will never be patched.  We should also be careful that all intermediate branches are unconditional, but I suspect that if we are branching to an instruction, it will not be a conditional instruction.\n\nAll in all, there are about 15 chains of branches in this simple program (the same one I used for the previous analysis).\n\nIf it is more than a trivial patch on top of the current patch for 586297, I'd like to take a stab at writing it myself after that patch lands.", "creation_time": "2011-08-02T02:35:11Z", "text": "Good to see that it helped!\nAfter poking at it a bit more, I noticed some other things that can be optimized, but with a bit more effort.\n\n[jaeger] Insns            >  ##linkJump         ((0x48)) jumps to ((0xa8))\n[jaeger] Insns            >  ##linkJump         ((0xa8)) jumps to ((0xac))\n\n[jaeger] Insns            >  ##linkJump         ((0x5c)) jumps to ((0xa8))\n[jaeger] Insns            >  ##linkJump         ((0xa8)) jumps to ((0xac))\n\n[jaeger] Insns            >  ##linkJump         ((0x98)) jumps to ((0xdc))\n[jaeger] Insns            ##linkJump         ((0xdc)) jumps to ((0x238))\n[jaeger] Insns            >  ##linkJump         ((0x238)) jumps to ((0x2a4))\n\nwhere in every group of instructions, we have a branch that branches directly to another branch.  If we can get better information about which branches won't be patched later (I believe this was mentioned in bug 586297), we can simply replace all branches in a chain with the last address that will never be patched.  We should also be careful that all intermediate branches are unconditional, but I suspect that if we are branching to an instruction, it will not be a conditional instruction.\n\nAll in all, there are about 15 chains of branches in this simple program (the same one I used for the previous analysis).\n\nIf it is more than a trivial patch on top of the current patch for 586297, I'd like to take a stab at writing it myself after that patch lands.", "time": "2011-08-02T02:35:11Z", "attachment_id": null}, {"bug_id": 675342, "tags": [], "is_private": false, "count": 3, "id": 5627239, "text": "(In reply to comment #2)\n> If we can get better information about which\n> branches won't be patched later (I believe this was mentioned in bug\n> 586297), we can simply replace all branches in a chain with the last address\n> that will never be patched.\n\nInformation about which branches will be repatched is determined in ARMAssembler::fixUpOffsets, but I think all branches are considered patchable. Historically, it was just used because patchable loads (including branches) can't share a literal pool slot with anything else. This might not give you all the information you want. For example, I think all branches are patchable because the branch is generated _before_ it is linked to its target.\n\nIt is all much simpler in NanoJIT, where code is generated backwards.\n\n> We should also be careful that all intermediate\n> branches are unconditional [...]\n\nYou could just check that the other branches have the same condition as the first. Alternatively, if the other branches have the opposite condition, you could branch to the instruction after it, though keeping track of that might be tricky.\n\n> but I suspect that if we are branching to an\n> instruction, it will not be a conditional instruction.\n\nI wouldn't want to make that assumption :-) All sorts of unexpected things turn up in the generated code sometimes. That doesn't mean it should be fixed, of course.\n\nI suspect that a few of these come about due to literal pools. When the pool size reaches a certain threshold (or it is flushed manually for ICs), we emit an unconditional branch to jump over the literal pool, which sits inline in the instruction stream. If this happens in the middle of a compare-and-branch sequence, you'll end up with an unconditional branch to a conditional branch. That doesn't mean that it can't be optimized, of course.\n\n> If it is more than a trivial patch on top of the current patch for 586297,\n> I'd like to take a stab at writing it myself after that patch lands.\n\nI don't think this would be trivial to implement, and it certainly doesn't fit trivially on top of 586297.", "time": "2011-08-02T08:58:33Z", "attachment_id": null, "creation_time": "2011-08-02T08:58:33Z", "raw_text": "(In reply to comment #2)\n> If we can get better information about which\n> branches won't be patched later (I believe this was mentioned in bug\n> 586297), we can simply replace all branches in a chain with the last address\n> that will never be patched.\n\nInformation about which branches will be repatched is determined in ARMAssembler::fixUpOffsets, but I think all branches are considered patchable. Historically, it was just used because patchable loads (including branches) can't share a literal pool slot with anything else. This might not give you all the information you want. For example, I think all branches are patchable because the branch is generated _before_ it is linked to its target.\n\nIt is all much simpler in NanoJIT, where code is generated backwards.\n\n> We should also be careful that all intermediate\n> branches are unconditional [...]\n\nYou could just check that the other branches have the same condition as the first. Alternatively, if the other branches have the opposite condition, you could branch to the instruction after it, though keeping track of that might be tricky.\n\n> but I suspect that if we are branching to an\n> instruction, it will not be a conditional instruction.\n\nI wouldn't want to make that assumption :-) All sorts of unexpected things turn up in the generated code sometimes. That doesn't mean it should be fixed, of course.\n\nI suspect that a few of these come about due to literal pools. When the pool size reaches a certain threshold (or it is flushed manually for ICs), we emit an unconditional branch to jump over the literal pool, which sits inline in the instruction stream. If this happens in the middle of a compare-and-branch sequence, you'll end up with an unconditional branch to a conditional branch. That doesn't mean that it can't be optimized, of course.\n\n> If it is more than a trivial patch on top of the current patch for 586297,\n> I'd like to take a stab at writing it myself after that patch lands.\n\nI don't think this would be trivial to implement, and it certainly doesn't fit trivially on top of 586297.", "creator": "Jacob.Bramley@arm.com", "author": "Jacob.Bramley@arm.com"}]}}, "comments": {}}