{"bugs": {"687082": {"comments": [{"tags": [], "text": "Not whether they hit, but whether they use one at all (either for reading or writing)", "bug_id": 687082, "raw_text": "Not whether they hit, but whether they use one at all (either for reading or writing)", "attachment_id": null, "author": "u408661@disabled.tld", "time": "2011-09-16T16:32:01Z", "creation_time": "2011-09-16T16:32:01Z", "creator": "u408661@disabled.tld", "id": 5720276, "count": 0, "is_private": false}, {"is_private": false, "count": 1, "id": 6538230, "author": "u408661@disabled.tld", "creator": "u408661@disabled.tld", "time": "2012-08-07T21:12:35Z", "creation_time": "2012-08-07T21:12:35Z", "raw_text": "Reassigning to Valentin for a quick first bug", "attachment_id": null, "bug_id": 687082, "text": "Reassigning to Valentin for a quick first bug", "tags": []}, {"creation_time": "2012-08-10T18:37:33Z", "time": "2012-08-10T18:37:33Z", "creator": "valentin.gosu@gmail.com", "tags": [], "bug_id": 687082, "text": "Do we need an actual percentage, or just the number of channels that use cache entry and the total number of http channels?", "author": "valentin.gosu@gmail.com", "id": 6547280, "count": 2, "is_private": false, "attachment_id": null, "raw_text": "Do we need an actual percentage, or just the number of channels that use cache entry and the total number of http channels?"}, {"creator": "u408661@disabled.tld", "creation_time": "2012-08-10T19:15:09Z", "time": "2012-08-10T19:15:09Z", "author": "u408661@disabled.tld", "is_private": false, "count": 3, "id": 6547394, "tags": [], "text": "This should probably be just a boolean telemetry histogram: did the channel have mCacheEntry != null or didn't it?\n\nOr, we could get a (very little) bit more detailed, and have 3 states: No Cache Entry, Cache Entry for Reading, or Cache Entry for Writing.", "bug_id": 687082, "attachment_id": null, "raw_text": "This should probably be just a boolean telemetry histogram: did the channel have mCacheEntry != null or didn't it?\n\nOr, we could get a (very little) bit more detailed, and have 3 states: No Cache Entry, Cache Entry for Reading, or Cache Entry for Writing."}, {"text": "If we issue a telemetry report for every single HTTP request, that's 1) a lot of data? :) and 2) only gives us the aggregate hit rate for \"Firefox\" as a whole.   If we have the browser report what its hit rate is we get 1) less volume of data and 2) some information on how much the hit rate varies for individual users. \n\nOf course the trick with reporting the browser's overall hit rate is, when do we report it?   Issuing one telemetry call at shutdown is the obvious route, but as of 6 months ago I seem to remember telemetry not working at shutdown (but also remember plans to make it work: ask Taras?)", "bug_id": 687082, "tags": [], "raw_text": "If we issue a telemetry report for every single HTTP request, that's 1) a lot of data? :) and 2) only gives us the aggregate hit rate for \"Firefox\" as a whole.   If we have the browser report what its hit rate is we get 1) less volume of data and 2) some information on how much the hit rate varies for individual users. \n\nOf course the trick with reporting the browser's overall hit rate is, when do we report it?   Issuing one telemetry call at shutdown is the obvious route, but as of 6 months ago I seem to remember telemetry not working at shutdown (but also remember plans to make it work: ask Taras?)", "attachment_id": null, "author": "jduell.mcbugs@gmail.com", "creation_time": "2012-08-10T19:22:29Z", "time": "2012-08-10T19:22:29Z", "creator": "jduell.mcbugs@gmail.com", "id": 6547420, "count": 4, "is_private": false}, {"author": "jduell.mcbugs@gmail.com", "creator": "jduell.mcbugs@gmail.com", "creation_time": "2012-08-10T19:25:37Z", "time": "2012-08-10T19:25:37Z", "is_private": false, "count": 5, "id": 6547435, "tags": [], "text": "After thinking for a sec more I think I'm wrong about the volume of data issue (we'd still have one historgram with 3 values, and just high counts on them), but still right about this not capturing variations in hit rates across users.   If it's tricky to capture that variation it would still be much better than the status quo to get the global hit rate.", "bug_id": 687082, "raw_text": "After thinking for a sec more I think I'm wrong about the volume of data issue (we'd still have one historgram with 3 values, and just high counts on them), but still right about this not capturing variations in hit rates across users.   If it's tricky to capture that variation it would still be much better than the status quo to get the global hit rate.", "attachment_id": null}, {"raw_text": "Just need some feedback for now.\nI've added the telemetry::accumulate call to the channel's destructor. I don't know if that's the best thing I should do.", "attachment_id": 651598, "bug_id": 687082, "text": "Created attachment 651598\nCache Telemetry v1.0\n\nJust need some feedback for now.\nI've added the telemetry::accumulate call to the channel's destructor. I don't know if that's the best thing I should do.", "tags": [], "is_private": false, "id": 6552184, "count": 6, "author": "valentin.gosu@gmail.com", "creator": "valentin.gosu@gmail.com", "time": "2012-08-14T01:13:58Z", "creation_time": "2012-08-14T01:13:58Z"}, {"attachment_id": 651598, "raw_text": "Review of attachment 651598:\n-----------------------------------------------------------------\n\nSee comments inline\n\n::: netwerk/protocol/http/nsHttpChannel.cpp\n@@ +321,5 @@\n>      , mFallingBack(false)\n>      , mWaitingForRedirectCallback(false)\n>      , mRequestTimeInitialized(false)\n>      , mDidReval(false)\n> +    , mCacheUsed(kCacheEntryNone)\n\nI'm not sure I like the name mCacheUsed, it sounds like it should be a boolean. Maybe something like mCacheUsage?\n\n@@ +334,5 @@\n>      LOG((\"Destroying nsHttpChannel [this=%p]\\n\", this));\n>  \n>      if (mAuthProvider)\n>          mAuthProvider->Disconnect(NS_ERROR_ABORT);\n> +    mozilla::Telemetry::Accumulate(\n\nI'll leave it to Jason and/or Honza to say whether this is an OK spot for this, or if we should accumulate somewhere else.\n\n@@ +3899,5 @@\n>          LOG((\"nsHttpChannel::InstallCacheListener async tee %p\", tee.get()));\n>          rv = tee->InitAsync(mListener, cacheIOTarget, out, nullptr);\n>      }\n>  \n> +    mCacheUsed = kCacheEntryWrite;\n\nThis should probably go *after* the check for NS_FAILED, since we won't be writing to the cache if we fail to set up the I/O tee.\n\n::: netwerk/protocol/http/nsHttpChannel.h\n@@ +361,5 @@\n>      virtual void DoNotifyListenerCleanup();\n>  \n>  private: // cache telemetry\n>      bool mDidReval;\n> +    PRUint32                          mCacheUsed;                           \n\nSplinter appears to be indicating a bunch of trailing whitespace on this line, trash it :)", "bug_id": 687082, "text": "Comment on attachment 651598\nCache Telemetry v1.0\n\nReview of attachment 651598:\n-----------------------------------------------------------------\n\nSee comments inline\n\n::: netwerk/protocol/http/nsHttpChannel.cpp\n@@ +321,5 @@\n>      , mFallingBack(false)\n>      , mWaitingForRedirectCallback(false)\n>      , mRequestTimeInitialized(false)\n>      , mDidReval(false)\n> +    , mCacheUsed(kCacheEntryNone)\n\nI'm not sure I like the name mCacheUsed, it sounds like it should be a boolean. Maybe something like mCacheUsage?\n\n@@ +334,5 @@\n>      LOG((\"Destroying nsHttpChannel [this=%p]\\n\", this));\n>  \n>      if (mAuthProvider)\n>          mAuthProvider->Disconnect(NS_ERROR_ABORT);\n> +    mozilla::Telemetry::Accumulate(\n\nI'll leave it to Jason and/or Honza to say whether this is an OK spot for this, or if we should accumulate somewhere else.\n\n@@ +3899,5 @@\n>          LOG((\"nsHttpChannel::InstallCacheListener async tee %p\", tee.get()));\n>          rv = tee->InitAsync(mListener, cacheIOTarget, out, nullptr);\n>      }\n>  \n> +    mCacheUsed = kCacheEntryWrite;\n\nThis should probably go *after* the check for NS_FAILED, since we won't be writing to the cache if we fail to set up the I/O tee.\n\n::: netwerk/protocol/http/nsHttpChannel.h\n@@ +361,5 @@\n>      virtual void DoNotifyListenerCleanup();\n>  \n>  private: // cache telemetry\n>      bool mDidReval;\n> +    PRUint32                          mCacheUsed;                           \n\nSplinter appears to be indicating a bunch of trailing whitespace on this line, trash it :)", "tags": [], "count": 7, "id": 6558290, "is_private": false, "time": "2012-08-15T22:18:59Z", "creation_time": "2012-08-15T22:18:59Z", "creator": "u408661@disabled.tld", "author": "u408661@disabled.tld"}, {"is_private": false, "count": 8, "id": 6558647, "creator": "valentin.gosu@gmail.com", "creation_time": "2012-08-16T01:22:59Z", "time": "2012-08-16T01:22:59Z", "author": "valentin.gosu@gmail.com", "attachment_id": 652290, "raw_text": "Renamed mCacheUsed -> mCacheUsage\nmCacheUsed is now set to kCacheEntryWrite after checking for errors\nRemoved trailing whitespace.\n\nTelemetry::Accumulate is still done in the channel's destructor.", "bug_id": 687082, "text": "Created attachment 652290\nCache Telemetry v2.0\n\nRenamed mCacheUsed -> mCacheUsage\nmCacheUsed is now set to kCacheEntryWrite after checking for errors\nRemoved trailing whitespace.\n\nTelemetry::Accumulate is still done in the channel's destructor.", "tags": []}, {"tags": [], "text": "Comment on attachment 652290\nCache Telemetry v2.0\n\nReview of attachment 652290:\n-----------------------------------------------------------------\n\n::: netwerk/protocol/http/nsHttpChannel.cpp\n@@ +335,5 @@\n>  \n>      if (mAuthProvider)\n>          mAuthProvider->Disconnect(NS_ERROR_ABORT);\n> +    mozilla::Telemetry::Accumulate(\n> +        mozilla::Telemetry::HTTP_CACHE_USED, mCacheUsage);\n\nIMO we shouldn't report statistics for channels that were canceled before we hit the cache/net. But I have no idea how common case it is, maybe it is a negligible count.\n\n@@ +3549,5 @@\n>      PRUint32 suspendCount = mSuspendCount;\n>      while (suspendCount--)\n>          mCachePump->Suspend();\n>  \n> +    mCacheUsage = kCacheEntryRead;\n\nWe'll report kCacheEntryNone in case of early return from this method (e.g. cached redirect, cached content is valid but LOAD_ONLY_IF_MODIFIED was specified, ...).\n\n@@ +3902,5 @@\n>  \n>      if (NS_FAILED(rv)) return rv;\n>      mListener = tee;\n> +\n> +    mCacheUsage = kCacheEntryWrite;\n\nThis reports kCacheEntryWrite also for partial entries that we use for both reading and writing. What about defining kCacheEntryReadAndWrite for this use case?\n\n::: toolkit/components/telemetry/TelemetryHistograms.h\n@@ +211,5 @@\n>  HISTOGRAM(CACHE_LM_INCONSISTENT, 0, 1, 2, BOOLEAN,  \"Cache discovered inconsistent last-modified entry\")\n>  HISTOGRAM(CACHE_SERVICE_LOCK_WAIT, 1, 10000, 10000, LINEAR, \"Time spent waiting on the cache service lock (ms)\")\n>  HISTOGRAM(CACHE_SERVICE_LOCK_WAIT_MAINTHREAD, 1, 10000, 10000, LINEAR, \"Time spent waiting on the cache service lock on the main thread (ms)\")\n>  HISTOGRAM(DISK_CACHE_SMART_SIZE_USING_OLD_MAX, 0, 1, 2, BOOLEAN, \"Whether we are using the old default cache smart size\")\n> +HISTOGRAM_ENUMERATED_VALUES(HTTP_CACHE_USED, 4, \"No Cache Entry, Cache Entry for Reading, Cache Entry for Writing\")\n\nWhy N==4 for 3 values?", "bug_id": 687082, "raw_text": "Review of attachment 652290:\n-----------------------------------------------------------------\n\n::: netwerk/protocol/http/nsHttpChannel.cpp\n@@ +335,5 @@\n>  \n>      if (mAuthProvider)\n>          mAuthProvider->Disconnect(NS_ERROR_ABORT);\n> +    mozilla::Telemetry::Accumulate(\n> +        mozilla::Telemetry::HTTP_CACHE_USED, mCacheUsage);\n\nIMO we shouldn't report statistics for channels that were canceled before we hit the cache/net. But I have no idea how common case it is, maybe it is a negligible count.\n\n@@ +3549,5 @@\n>      PRUint32 suspendCount = mSuspendCount;\n>      while (suspendCount--)\n>          mCachePump->Suspend();\n>  \n> +    mCacheUsage = kCacheEntryRead;\n\nWe'll report kCacheEntryNone in case of early return from this method (e.g. cached redirect, cached content is valid but LOAD_ONLY_IF_MODIFIED was specified, ...).\n\n@@ +3902,5 @@\n>  \n>      if (NS_FAILED(rv)) return rv;\n>      mListener = tee;\n> +\n> +    mCacheUsage = kCacheEntryWrite;\n\nThis reports kCacheEntryWrite also for partial entries that we use for both reading and writing. What about defining kCacheEntryReadAndWrite for this use case?\n\n::: toolkit/components/telemetry/TelemetryHistograms.h\n@@ +211,5 @@\n>  HISTOGRAM(CACHE_LM_INCONSISTENT, 0, 1, 2, BOOLEAN,  \"Cache discovered inconsistent last-modified entry\")\n>  HISTOGRAM(CACHE_SERVICE_LOCK_WAIT, 1, 10000, 10000, LINEAR, \"Time spent waiting on the cache service lock (ms)\")\n>  HISTOGRAM(CACHE_SERVICE_LOCK_WAIT_MAINTHREAD, 1, 10000, 10000, LINEAR, \"Time spent waiting on the cache service lock on the main thread (ms)\")\n>  HISTOGRAM(DISK_CACHE_SMART_SIZE_USING_OLD_MAX, 0, 1, 2, BOOLEAN, \"Whether we are using the old default cache smart size\")\n> +HISTOGRAM_ENUMERATED_VALUES(HTTP_CACHE_USED, 4, \"No Cache Entry, Cache Entry for Reading, Cache Entry for Writing\")\n\nWhy N==4 for 3 values?", "attachment_id": 652290, "author": "michal.novotny@gmail.com", "creator": "michal.novotny@gmail.com", "time": "2012-08-20T17:30:11Z", "creation_time": "2012-08-20T17:30:11Z", "is_private": false, "id": 6567850, "count": 9}, {"tags": [], "bug_id": 687082, "text": "(In reply to Michal Novotny (:michal) from comment #9)\n> Comment on attachment 652290\n> Cache Telemetry v2.0\n> \n> Review of attachment 652290:\n> -----------------------------------------------------------------\n> \n> ::: netwerk/protocol/http/nsHttpChannel.cpp\n> @@ +335,5 @@\n> >  \n> >      if (mAuthProvider)\n> >          mAuthProvider->Disconnect(NS_ERROR_ABORT);\nif (!mCancelled)\n> > +    mozilla::Telemetry::Accumulate(\n> > +        mozilla::Telemetry::HTTP_CACHE_USED, mCacheUsage);\n> \n> IMO we shouldn't report statistics for channels that were canceled before we\n> hit the cache/net. But I have no idea how common case it is, maybe it is a\n> negligible count.\n\nThat should fix it.\n> \n> @@ +3549,5 @@\n> >      PRUint32 suspendCount = mSuspendCount;\n> >      while (suspendCount--)\n> >          mCachePump->Suspend();\n> >  \n> > +    mCacheUsage = kCacheEntryRead;\n> \n> We'll report kCacheEntryNone in case of early return from this method (e.g.\n> cached redirect, cached content is valid but LOAD_ONLY_IF_MODIFIED was\n> specified, ...).\n> \n\nThe idea was that we would report kCacheEntryRead only when successfully reading from the cache. Does that still happen in the case of an early return?\n\n> @@ +3902,5 @@\n> >  \n> >      if (NS_FAILED(rv)) return rv;\n> >      mListener = tee;\n> > +\n> > +    mCacheUsage = kCacheEntryWrite;\n> \n> This reports kCacheEntryWrite also for partial entries that we use for both\n> reading and writing. What about defining kCacheEntryReadAndWrite for this\n> use case?\n\nGood idea. I'll try to make it happen.\n\n> \n> ::: toolkit/components/telemetry/TelemetryHistograms.h\n> @@ +211,5 @@\n> >  HISTOGRAM(CACHE_LM_INCONSISTENT, 0, 1, 2, BOOLEAN,  \"Cache discovered inconsistent last-modified entry\")\n> >  HISTOGRAM(CACHE_SERVICE_LOCK_WAIT, 1, 10000, 10000, LINEAR, \"Time spent waiting on the cache service lock (ms)\")\n> >  HISTOGRAM(CACHE_SERVICE_LOCK_WAIT_MAINTHREAD, 1, 10000, 10000, LINEAR, \"Time spent waiting on the cache service lock on the main thread (ms)\")\n> >  HISTOGRAM(DISK_CACHE_SMART_SIZE_USING_OLD_MAX, 0, 1, 2, BOOLEAN, \"Whether we are using the old default cache smart size\")\n> > +HISTOGRAM_ENUMERATED_VALUES(HTTP_CACHE_USED, 4, \"No Cache Entry, Cache Entry for Reading, Cache Entry for Writing\")\n> \n> Why N==4 for 3 values?\n\nI think you're right. I was looking at other HISTOGRAM_ENUMERATED_VALUES\nand they also seem to be off by one.", "raw_text": "(In reply to Michal Novotny (:michal) from comment #9)\n> Comment on attachment 652290\n> Cache Telemetry v2.0\n> \n> Review of attachment 652290:\n> -----------------------------------------------------------------\n> \n> ::: netwerk/protocol/http/nsHttpChannel.cpp\n> @@ +335,5 @@\n> >  \n> >      if (mAuthProvider)\n> >          mAuthProvider->Disconnect(NS_ERROR_ABORT);\nif (!mCancelled)\n> > +    mozilla::Telemetry::Accumulate(\n> > +        mozilla::Telemetry::HTTP_CACHE_USED, mCacheUsage);\n> \n> IMO we shouldn't report statistics for channels that were canceled before we\n> hit the cache/net. But I have no idea how common case it is, maybe it is a\n> negligible count.\n\nThat should fix it.\n> \n> @@ +3549,5 @@\n> >      PRUint32 suspendCount = mSuspendCount;\n> >      while (suspendCount--)\n> >          mCachePump->Suspend();\n> >  \n> > +    mCacheUsage = kCacheEntryRead;\n> \n> We'll report kCacheEntryNone in case of early return from this method (e.g.\n> cached redirect, cached content is valid but LOAD_ONLY_IF_MODIFIED was\n> specified, ...).\n> \n\nThe idea was that we would report kCacheEntryRead only when successfully reading from the cache. Does that still happen in the case of an early return?\n\n> @@ +3902,5 @@\n> >  \n> >      if (NS_FAILED(rv)) return rv;\n> >      mListener = tee;\n> > +\n> > +    mCacheUsage = kCacheEntryWrite;\n> \n> This reports kCacheEntryWrite also for partial entries that we use for both\n> reading and writing. What about defining kCacheEntryReadAndWrite for this\n> use case?\n\nGood idea. I'll try to make it happen.\n\n> \n> ::: toolkit/components/telemetry/TelemetryHistograms.h\n> @@ +211,5 @@\n> >  HISTOGRAM(CACHE_LM_INCONSISTENT, 0, 1, 2, BOOLEAN,  \"Cache discovered inconsistent last-modified entry\")\n> >  HISTOGRAM(CACHE_SERVICE_LOCK_WAIT, 1, 10000, 10000, LINEAR, \"Time spent waiting on the cache service lock (ms)\")\n> >  HISTOGRAM(CACHE_SERVICE_LOCK_WAIT_MAINTHREAD, 1, 10000, 10000, LINEAR, \"Time spent waiting on the cache service lock on the main thread (ms)\")\n> >  HISTOGRAM(DISK_CACHE_SMART_SIZE_USING_OLD_MAX, 0, 1, 2, BOOLEAN, \"Whether we are using the old default cache smart size\")\n> > +HISTOGRAM_ENUMERATED_VALUES(HTTP_CACHE_USED, 4, \"No Cache Entry, Cache Entry for Reading, Cache Entry for Writing\")\n> \n> Why N==4 for 3 values?\n\nI think you're right. I was looking at other HISTOGRAM_ENUMERATED_VALUES\nand they also seem to be off by one.", "attachment_id": null, "author": "valentin.gosu@gmail.com", "creation_time": "2012-08-20T21:27:38Z", "time": "2012-08-20T21:27:38Z", "creator": "valentin.gosu@gmail.com", "count": 10, "id": 6568685, "is_private": false}, {"id": 6569073, "count": 11, "is_private": false, "time": "2012-08-20T23:21:43Z", "creation_time": "2012-08-20T23:21:43Z", "creator": "valentin.gosu@gmail.com", "author": "valentin.gosu@gmail.com", "attachment_id": 653573, "raw_text": "", "tags": [], "text": "Created attachment 653573\nAttachments Cache Telemetry v3.0", "bug_id": 687082}, {"is_private": false, "id": 6574117, "count": 12, "creator": "michal.novotny@gmail.com", "time": "2012-08-22T13:50:40Z", "creation_time": "2012-08-22T13:50:40Z", "author": "michal.novotny@gmail.com", "attachment_id": 653573, "raw_text": ">      mCachedContentIsValid = true;\n> +    mCacheUsage = kCacheEntryReadWrite;\n>      return ReadFromCache(false);\n...\n> +    if (mCacheUsage == kCacheEntryNone)\n> +        mCacheUsage = kCacheEntryRead;\n\nA bit better would be probably to do following in InstallCacheListener()\n\n  if (mCacheUsage == kCacheEntryRead)\n    mCacheUsage = kCacheEntryReadWrite;\n  else\n    mCacheUsage = kCacheEntryWrite;\n\n\n(In reply to Valentin Gosu from comment #10)\n> if (!mCancelled)\n> > > +    mozilla::Telemetry::Accumulate(\n> > > +        mozilla::Telemetry::HTTP_CACHE_USED, mCacheUsage);\n> > \n> > IMO we shouldn't report statistics for channels that were canceled before we\n> > hit the cache/net. But I have no idea how common case it is, maybe it is a\n> > negligible count.\n> \n> That should fix it.\n\nBut that stops reporting also in case the channel is canceled while it already serves data from the cache/net.\n\n\n> > @@ +3549,5 @@\n> The idea was that we would report kCacheEntryRead only when successfully\n> reading from the cache. Does that still happen in the case of an early\n> return?\n\nWell, doing redirect based on cached information is definitely this case. I would say that anytime we use some information even from metadata, we should report that.", "text": "Comment on attachment 653573\nAttachments Cache Telemetry v3.0\n\n>      mCachedContentIsValid = true;\n> +    mCacheUsage = kCacheEntryReadWrite;\n>      return ReadFromCache(false);\n...\n> +    if (mCacheUsage == kCacheEntryNone)\n> +        mCacheUsage = kCacheEntryRead;\n\nA bit better would be probably to do following in InstallCacheListener()\n\n  if (mCacheUsage == kCacheEntryRead)\n    mCacheUsage = kCacheEntryReadWrite;\n  else\n    mCacheUsage = kCacheEntryWrite;\n\n\n(In reply to Valentin Gosu from comment #10)\n> if (!mCancelled)\n> > > +    mozilla::Telemetry::Accumulate(\n> > > +        mozilla::Telemetry::HTTP_CACHE_USED, mCacheUsage);\n> > \n> > IMO we shouldn't report statistics for channels that were canceled before we\n> > hit the cache/net. But I have no idea how common case it is, maybe it is a\n> > negligible count.\n> \n> That should fix it.\n\nBut that stops reporting also in case the channel is canceled while it already serves data from the cache/net.\n\n\n> > @@ +3549,5 @@\n> The idea was that we would report kCacheEntryRead only when successfully\n> reading from the cache. Does that still happen in the case of an early\n> return?\n\nWell, doing redirect based on cached information is definitely this case. I would say that anytime we use some information even from metadata, we should report that.", "bug_id": 687082, "tags": []}, {"raw_text": "(In reply to Michal Novotny (:michal) from comment #12)\n> Comment on attachment 653573\n> \n> (In reply to Valentin Gosu from comment #10)\n> > if (!mCancelled)\n> > > > +    mozilla::Telemetry::Accumulate(\n> > > > +        mozilla::Telemetry::HTTP_CACHE_USED, mCacheUsage);\n> > > \n> > > IMO we shouldn't report statistics for channels that were canceled before we\n> > > hit the cache/net. But I have no idea how common case it is, maybe it is a\n> > > negligible count.\n> > \n> > That should fix it.\n> \n> But that stops reporting also in case the channel is canceled while it\n> already serves data from the cache/net.\n\nWould this be better?\nif (!mCancelled || mCacheUsage!=kCacheEntryNone)\n> > > > +    mozilla::Telemetry::Accumulate(\n> > > > +        mozilla::Telemetry::HTTP_CACHE_USED, mCacheUsage);\n\nWe only report if the Usage has changed (so it definitely read or wrote to the cache) or if the channel has not been cancelled.", "attachment_id": null, "text": "(In reply to Michal Novotny (:michal) from comment #12)\n> Comment on attachment 653573\n> \n> (In reply to Valentin Gosu from comment #10)\n> > if (!mCancelled)\n> > > > +    mozilla::Telemetry::Accumulate(\n> > > > +        mozilla::Telemetry::HTTP_CACHE_USED, mCacheUsage);\n> > > \n> > > IMO we shouldn't report statistics for channels that were canceled before we\n> > > hit the cache/net. But I have no idea how common case it is, maybe it is a\n> > > negligible count.\n> > \n> > That should fix it.\n> \n> But that stops reporting also in case the channel is canceled while it\n> already serves data from the cache/net.\n\nWould this be better?\nif (!mCancelled || mCacheUsage!=kCacheEntryNone)\n> > > > +    mozilla::Telemetry::Accumulate(\n> > > > +        mozilla::Telemetry::HTTP_CACHE_USED, mCacheUsage);\n\nWe only report if the Usage has changed (so it definitely read or wrote to the cache) or if the channel has not been cancelled.", "bug_id": 687082, "tags": [], "is_private": false, "id": 6587910, "count": 13, "author": "valentin.gosu@gmail.com", "creator": "valentin.gosu@gmail.com", "creation_time": "2012-08-27T22:53:05Z", "time": "2012-08-27T22:53:05Z"}, {"count": 14, "id": 6588237, "is_private": false, "time": "2012-08-28T01:09:10Z", "creation_time": "2012-08-28T01:09:10Z", "creator": "valentin.gosu@gmail.com", "author": "valentin.gosu@gmail.com", "attachment_id": null, "raw_text": "How would I test for kCacheEntryReadWrite?\nFrom what I can see from the webpages I visit, the value is either None, Read or Write. Never ReadWrite. I'm either missing something, or this is a really rare situation.", "tags": [], "text": "How would I test for kCacheEntryReadWrite?\nFrom what I can see from the webpages I visit, the value is either None, Read or Write. Never ReadWrite. I'm either missing something, or this is a really rare situation.", "bug_id": 687082}, {"creator": "michal.novotny@gmail.com", "creation_time": "2012-08-29T16:09:28Z", "time": "2012-08-29T16:09:28Z", "author": "michal.novotny@gmail.com", "is_private": false, "count": 15, "id": 6593467, "bug_id": 687082, "text": "(In reply to Valentin Gosu from comment #14)\n> How would I test for kCacheEntryReadWrite?\n> From what I can see from the webpages I visit, the value is either None,\n> Read or Write. Never ReadWrite. I'm either missing something, or this is a\n> really rare situation.\n\nTry to cancel loading of the page in the middle of the loading. This might create bunch of partial entries that would be reused if you reload the page.", "tags": [], "attachment_id": null, "raw_text": "(In reply to Valentin Gosu from comment #14)\n> How would I test for kCacheEntryReadWrite?\n> From what I can see from the webpages I visit, the value is either None,\n> Read or Write. Never ReadWrite. I'm either missing something, or this is a\n> really rare situation.\n\nTry to cancel loading of the page in the middle of the loading. This might create bunch of partial entries that would be reused if you reload the page."}, {"count": 16, "id": 6593633, "is_private": false, "creation_time": "2012-08-29T16:54:52Z", "time": "2012-08-29T16:54:52Z", "creator": "michal.novotny@gmail.com", "author": "michal.novotny@gmail.com", "attachment_id": null, "raw_text": "(In reply to Valentin Gosu from comment #13)\n> Would this be better?\n> if (!mCancelled || mCacheUsage!=kCacheEntryNone)\n> > > > > +    mozilla::Telemetry::Accumulate(\n> > > > > +        mozilla::Telemetry::HTTP_CACHE_USED, mCacheUsage);\n> \n> We only report if the Usage has changed (so it definitely read or wrote to\n> the cache) or if the channel has not been cancelled.\n\nThis is better just a little bit. This won't report if the channel didn't use cache and was canceled while serving the data.\n\nI think we need a separate variable mReportCacheUsage that will be false by default. Set it to true in nsHttpChannel::OnStopRequest() and in some cases (not sure which one right now) where we call DoNotifyListener().", "tags": [], "text": "(In reply to Valentin Gosu from comment #13)\n> Would this be better?\n> if (!mCancelled || mCacheUsage!=kCacheEntryNone)\n> > > > > +    mozilla::Telemetry::Accumulate(\n> > > > > +        mozilla::Telemetry::HTTP_CACHE_USED, mCacheUsage);\n> \n> We only report if the Usage has changed (so it definitely read or wrote to\n> the cache) or if the channel has not been cancelled.\n\nThis is better just a little bit. This won't report if the channel didn't use cache and was canceled while serving the data.\n\nI think we need a separate variable mReportCacheUsage that will be false by default. Set it to true in nsHttpChannel::OnStopRequest() and in some cases (not sure which one right now) where we call DoNotifyListener().", "bug_id": 687082}, {"author": "bug-husbandry-bot@mozilla.bugs", "creator": "bug-husbandry-bot@mozilla.bugs", "time": "2017-09-13T18:40:33Z", "creation_time": "2017-09-13T18:40:33Z", "is_private": false, "count": 17, "id": 12658965, "text": "Bulk change to priority: https://bugzilla.mozilla.org/show_bug.cgi?id=1399258", "bug_id": 687082, "tags": [], "raw_text": "Bulk change to priority: https://bugzilla.mozilla.org/show_bug.cgi?id=1399258", "attachment_id": null}]}}, "comments": {}}