{"comments": {}, "bugs": {"636504": {"comments": [{"time": "2011-02-24T18:15:56Z", "is_private": false, "attachment_id": null, "bug_id": 636504, "creator": "wtc@google.com", "count": 0, "tags": [], "raw_text": "The existing NSPR wrapper for getaddrinfo, PR_GetAddrInfoByName,\nis designed for client applications, which open sockets for\noutgoing connections.\n\nServer applications, which open listening sockets, need to\ncall getaddrinfo with the AI_PASSIVE flag.  We should add either\na new NSPR function that calls getaddrinfo with AI_PASSIVE, or\na general-purpose PR_GetAddrInfo function that can be used by\nboth client and server applications.", "id": 5301896, "text": "The existing NSPR wrapper for getaddrinfo, PR_GetAddrInfoByName,\nis designed for client applications, which open sockets for\noutgoing connections.\n\nServer applications, which open listening sockets, need to\ncall getaddrinfo with the AI_PASSIVE flag.  We should add either\na new NSPR function that calls getaddrinfo with AI_PASSIVE, or\na general-purpose PR_GetAddrInfo function that can be used by\nboth client and server applications.", "creation_time": "2011-02-24T18:15:56Z", "author": "wtc@google.com"}, {"count": 1, "tags": [], "creator": "kaie@kuix.de", "bug_id": 636504, "creation_time": "2011-02-24T19:38:48Z", "text": "The intention of this bug may not be immediately obvious, so I'd like to add a high level explanation.\n\nSome systems have only one IP stack - either IPv4, or IPv6.\n\nSome of our code uses a server socket, and a client socket to connect to it. \n(For example, when using a loopback socket as the implementation for the NSPR pollable event mechanism, or, between the NSS test tools selfserv and tstclnt.)\n\nWe need a NSPR mechanism, that both client code and server code can call, and that will return a working IP address for the local system. The result could be either an IPv4 or an IPv6 address.\n\nBoth client and server code can then use the resulting IP address to connect to each other.\n\n\nI just read the documentation for getaddrinfo and AI_PASSIVE.\n\nIf I understand correctly, when calling getaddrinfo with a NULL hostname parameter, the function will return a LIST of IP addresses.\n\nHow can we ensure that both client and server code will choose the same IP address to listen/connect?\n\nEven if both server code and client code are implemented to always pick the first entry in the returned list, what happens if a bad operating system implementation sometimes returns \"ip4/ip6\" and sometimes \"ip6/ip4\"?\n\n\nI guess there are multiple solutions to my worry.\n\n(a)\nThe server is required to listen and multiple stacks, it must make sure to have an open server socket for each of the IP addresses returned.\n\nThen the client will be able to connect, whatever IP address the client chooses to use.\n\nIs this always *simply* doable for servers, or might multiple-listening cause problems, or unwanted additional complexity for servers?\n\nIf the answer might be similar to a \"yes\" in at least some configurations, I'd rather propose to use one of the following approaches, either (b) or (c).\n\n\n(b)\nThe new NSPR function could always return only one single IP address, which is the preferred address. For scenarios where there are multiple stacks available, the function could use a hardcoded preference, like \"prefer ipv6 if both are available\". If necessary, this preference code could be done using platform specific #idefs\n\n\n(c)\nThe function returns the full list of IP addresses obtained from the operating system, however, the NSPR function guarantees a stable ordering. It should sort the list using a given, NSPR defined priority, e.g. IPv6 addresses will first in the list, IPv4 later.\n\n\nI personally have a tendency for simplicity, and towards (b).\n\nI'd define a new function like:\n  PR_GetPreferredLoopbackIPAddress(PRNetAddr *result);", "id": 5302187, "raw_text": "The intention of this bug may not be immediately obvious, so I'd like to add a high level explanation.\n\nSome systems have only one IP stack - either IPv4, or IPv6.\n\nSome of our code uses a server socket, and a client socket to connect to it. \n(For example, when using a loopback socket as the implementation for the NSPR pollable event mechanism, or, between the NSS test tools selfserv and tstclnt.)\n\nWe need a NSPR mechanism, that both client code and server code can call, and that will return a working IP address for the local system. The result could be either an IPv4 or an IPv6 address.\n\nBoth client and server code can then use the resulting IP address to connect to each other.\n\n\nI just read the documentation for getaddrinfo and AI_PASSIVE.\n\nIf I understand correctly, when calling getaddrinfo with a NULL hostname parameter, the function will return a LIST of IP addresses.\n\nHow can we ensure that both client and server code will choose the same IP address to listen/connect?\n\nEven if both server code and client code are implemented to always pick the first entry in the returned list, what happens if a bad operating system implementation sometimes returns \"ip4/ip6\" and sometimes \"ip6/ip4\"?\n\n\nI guess there are multiple solutions to my worry.\n\n(a)\nThe server is required to listen and multiple stacks, it must make sure to have an open server socket for each of the IP addresses returned.\n\nThen the client will be able to connect, whatever IP address the client chooses to use.\n\nIs this always *simply* doable for servers, or might multiple-listening cause problems, or unwanted additional complexity for servers?\n\nIf the answer might be similar to a \"yes\" in at least some configurations, I'd rather propose to use one of the following approaches, either (b) or (c).\n\n\n(b)\nThe new NSPR function could always return only one single IP address, which is the preferred address. For scenarios where there are multiple stacks available, the function could use a hardcoded preference, like \"prefer ipv6 if both are available\". If necessary, this preference code could be done using platform specific #idefs\n\n\n(c)\nThe function returns the full list of IP addresses obtained from the operating system, however, the NSPR function guarantees a stable ordering. It should sort the list using a given, NSPR defined priority, e.g. IPv6 addresses will first in the list, IPv4 later.\n\n\nI personally have a tendency for simplicity, and towards (b).\n\nI'd define a new function like:\n  PR_GetPreferredLoopbackIPAddress(PRNetAddr *result);", "author": "kaie@kuix.de", "time": "2011-02-24T19:38:48Z", "is_private": false, "attachment_id": null}, {"attachment_id": 514887, "author": "kaie@kuix.de", "creator": "kaie@kuix.de", "time": "2011-02-24T21:20:56Z", "tags": [], "count": 2, "bug_id": 636504, "id": 5302506, "raw_text": "This is a proposed implementation, to get the discussion going.", "is_private": false, "creation_time": "2011-02-24T21:20:56Z", "text": "Created attachment 514887\nPatch v1\n\nThis is a proposed implementation, to get the discussion going."}, {"is_private": false, "time": "2011-02-24T21:21:19Z", "attachment_id": 514888, "id": 5302508, "raw_text": "", "creation_time": "2011-02-24T21:21:19Z", "text": "Created attachment 514888\nv1 - ignoring whitespace - easier to review", "creator": "kaie@kuix.de", "tags": [], "count": 3, "bug_id": 636504, "author": "kaie@kuix.de"}, {"time": "2011-02-24T21:27:18Z", "is_private": false, "attachment_id": 514897, "bug_id": 636504, "tags": [], "count": 4, "creator": "kaie@kuix.de", "raw_text": "", "id": 5302532, "text": "Created attachment 514897\nPatch v2", "creation_time": "2011-02-24T21:27:18Z", "author": "kaie@kuix.de"}, {"author": "kaie@kuix.de", "text": "Created attachment 514898\nv2 - ignoring whitespace - easier to review", "creation_time": "2011-02-24T21:27:57Z", "raw_text": "", "id": 5302535, "bug_id": 636504, "count": 5, "tags": [], "creator": "kaie@kuix.de", "attachment_id": 514898, "is_private": false, "time": "2011-02-24T21:27:57Z"}, {"author": "VYV03354@nifty.ne.jp", "id": 5844465, "raw_text": "> +PR_IMPLEMENT(PRStatus) PR_GetPreferredLoopbackIPAddress(PRNetAddr *result,\n> +    hints.ai_flags = AI_PASSIVE;\n> +    rv = GETADDRINFO(NULL, service, &hints, &res);\nIf getaddrinfo is called with NULL nodename and the AI_PASSIVE flag,\nit will return \"0.0.0.0\" (aka INADDR_ANY) for AF_INET and \"::\" for AF_INET6.\nI don't think it's correct to use it as a loopback address (especially for\nPR_NewPollableEvent implementation on non-Unix platforms).\nIf you do NOT pass AI_PASSIVE to getaddreinfo, it will returns\n\"127.0.0.1\" for AF_INET \"::1\" for AF_INET6 (that is, loopback address).\n\nThis behavior is written in RFC 3493.\nhttps://tools.ietf.org/html/rfc3493#page-25\n>   If the AI_PASSIVE flag is specified, the returned address information\n>   shall be suitable for use in binding a socket for accepting incoming\n>   connections for the specified service (i.e., a call to bind()).  In\n>   this case, if the nodename argument is null, then the IP address\n>   portion of the socket address structure shall be set to INADDR_ANY\n>   for an IPv4 address or IN6ADDR_ANY_INIT for an IPv6 address.  If the\n>   AI_PASSIVE flag is not specified, the returned address information\n>   shall be suitable for a call to connect() (for a connection-mode\n>   protocol) or for a call to connect(), sendto() or sendmsg() (for a\n>   connectionless protocol).  In this case, if the nodename argument is\n>   null, then the IP address portion of the socket address structure\n>   shall be set to the loopback address.  This flag is ignored if the\n>   nodename argument is not null.", "creation_time": "2011-11-12T07:54:29Z", "text": "> +PR_IMPLEMENT(PRStatus) PR_GetPreferredLoopbackIPAddress(PRNetAddr *result,\n> +    hints.ai_flags = AI_PASSIVE;\n> +    rv = GETADDRINFO(NULL, service, &hints, &res);\nIf getaddrinfo is called with NULL nodename and the AI_PASSIVE flag,\nit will return \"0.0.0.0\" (aka INADDR_ANY) for AF_INET and \"::\" for AF_INET6.\nI don't think it's correct to use it as a loopback address (especially for\nPR_NewPollableEvent implementation on non-Unix platforms).\nIf you do NOT pass AI_PASSIVE to getaddreinfo, it will returns\n\"127.0.0.1\" for AF_INET \"::1\" for AF_INET6 (that is, loopback address).\n\nThis behavior is written in RFC 3493.\nhttps://tools.ietf.org/html/rfc3493#page-25\n>   If the AI_PASSIVE flag is specified, the returned address information\n>   shall be suitable for use in binding a socket for accepting incoming\n>   connections for the specified service (i.e., a call to bind()).  In\n>   this case, if the nodename argument is null, then the IP address\n>   portion of the socket address structure shall be set to INADDR_ANY\n>   for an IPv4 address or IN6ADDR_ANY_INIT for an IPv6 address.  If the\n>   AI_PASSIVE flag is not specified, the returned address information\n>   shall be suitable for a call to connect() (for a connection-mode\n>   protocol) or for a call to connect(), sendto() or sendmsg() (for a\n>   connectionless protocol).  In this case, if the nodename argument is\n>   null, then the IP address portion of the socket address structure\n>   shall be set to the loopback address.  This flag is ignored if the\n>   nodename argument is not null.", "creator": "VYV03354@nifty.ne.jp", "tags": [], "count": 6, "bug_id": 636504, "attachment_id": null, "is_private": false, "time": "2011-11-12T07:54:29Z"}]}}}