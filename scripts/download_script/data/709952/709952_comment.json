{"bugs": {"709952": {"comments": [{"text": "I was talking with bz about the possibility of cleaving off and deallocating a big chunk of application memory when we detect an OOM in infallible malloc.\n\nPresumably, you start off by doing easy things flushing any unnecessary caches, and so on. But eventually you may bump up against a hard limit for these fixed size allocations, and your options are limited.\n\nFrom email:\n\n<<EOF\nbz> Right now that's handled entirely inside malloc, which doesn't know what\nbz> page you're on.  So we just abort.\n\nCould we teach it? I guess I'm thinking that, before the abort path,\nbut after the cache flush stuff that doesn't yet exist, we could have\nit chop out and delete the current content page from the browser\nwithout using any extra memory. Or, you could go the OOM killer route\nand just kill the page we think would be most profitable to kill.\n\nbz> We could try doing that, yes.  The latter would be simpler in some ways, because it bz> wouldn't require keeping pervasive track of the \"current page\".\n\nYeah, I was hoping that we wouldn't have to keep track, but that we\ncould somehow infer it from infallible-malloc-accessible state\nsomehow.\nEOF\n\nHow difficult would it be to break ties from a single \"content instance\" (not familiar with the terminology in this domain) to the rest of the browser?", "time": "2011-12-12T21:54:16Z", "attachment_id": null, "raw_text": "I was talking with bz about the possibility of cleaving off and deallocating a big chunk of application memory when we detect an OOM in infallible malloc.\n\nPresumably, you start off by doing easy things flushing any unnecessary caches, and so on. But eventually you may bump up against a hard limit for these fixed size allocations, and your options are limited.\n\nFrom email:\n\n<<EOF\nbz> Right now that's handled entirely inside malloc, which doesn't know what\nbz> page you're on.  So we just abort.\n\nCould we teach it? I guess I'm thinking that, before the abort path,\nbut after the cache flush stuff that doesn't yet exist, we could have\nit chop out and delete the current content page from the browser\nwithout using any extra memory. Or, you could go the OOM killer route\nand just kill the page we think would be most profitable to kill.\n\nbz> We could try doing that, yes.  The latter would be simpler in some ways, because it bz> wouldn't require keeping pervasive track of the \"current page\".\n\nYeah, I was hoping that we wouldn't have to keep track, but that we\ncould somehow infer it from infallible-malloc-accessible state\nsomehow.\nEOF\n\nHow difficult would it be to break ties from a single \"content instance\" (not familiar with the terminology in this domain) to the rest of the browser?", "creation_time": "2011-12-12T21:54:16Z", "bug_id": 709952, "is_private": false, "count": 0, "tags": [], "id": 5910058, "creator": "cdleary@acm.org", "author": "cdleary@acm.org"}, {"author": "khuey@kylehuey.com", "creator": "khuey@kylehuey.com", "id": 5910068, "count": 1, "is_private": false, "tags": [], "bug_id": 709952, "raw_text": "I don't really understand what you want to do here ... do we want to start killing pages on OOM or something?", "creation_time": "2011-12-12T21:56:22Z", "time": "2011-12-12T21:56:22Z", "attachment_id": null, "text": "I don't really understand what you want to do here ... do we want to start killing pages on OOM or something?"}, {"id": 5910116, "tags": [], "count": 2, "is_private": false, "bug_id": 709952, "creation_time": "2011-12-12T22:06:18Z", "raw_text": "That's the proposal, yes.", "time": "2011-12-12T22:06:18Z", "attachment_id": null, "text": "That's the proposal, yes.", "author": "bzbarsky@mit.edu", "creator": "bzbarsky@mit.edu"}, {"author": "khuey@kylehuey.com", "creator": "khuey@kylehuey.com", "attachment_id": null, "time": "2011-12-13T14:17:26Z", "text": "That sounds ... tricky.  Are we planning to reserve some memory so that this kicks in before we hit \"real\" OOM and we still have some memory to work with?  Trying to do anything complex when we are actually OOM sounds like a recipe for bad things.\n\nAlso, we'll need memory around to run the cycle collector, GC, etc.  I think we should be able to kill the layout side of things pretty easily though.", "raw_text": "That sounds ... tricky.  Are we planning to reserve some memory so that this kicks in before we hit \"real\" OOM and we still have some memory to work with?  Trying to do anything complex when we are actually OOM sounds like a recipe for bad things.\n\nAlso, we'll need memory around to run the cycle collector, GC, etc.  I think we should be able to kill the layout side of things pretty easily though.", "creation_time": "2011-12-13T14:17:26Z", "bug_id": 709952, "id": 5911974, "tags": [], "count": 3, "is_private": false}, {"author": "cdleary@acm.org", "creator": "cdleary@acm.org", "time": "2011-12-13T14:46:20Z", "attachment_id": null, "text": "(In reply to Kyle Huey [:khuey] (khuey@mozilla.com) from comment #3)\n> Trying to do anything complex when we are actually OOM sounds like a\n> recipe for bad things.\n\nI'm not at all familiar with the details, so I'm going to ask dumb questions: would we definitely need extra memory to separate the DOM for a content page from the rest of the browser and deallocate it? Can we keep a ballast, as you suggest, because the extra memory required to do this is easily bounded?\n\n> Also, we'll need memory around to run the cycle collector, GC, etc.  I think\n> we should be able to kill the layout side of things pretty easily though.\n\nCan we do these *after* the other resources have been deallocated?", "raw_text": "(In reply to Kyle Huey [:khuey] (khuey@mozilla.com) from comment #3)\n> Trying to do anything complex when we are actually OOM sounds like a\n> recipe for bad things.\n\nI'm not at all familiar with the details, so I'm going to ask dumb questions: would we definitely need extra memory to separate the DOM for a content page from the rest of the browser and deallocate it? Can we keep a ballast, as you suggest, because the extra memory required to do this is easily bounded?\n\n> Also, we'll need memory around to run the cycle collector, GC, etc.  I think\n> we should be able to kill the layout side of things pretty easily though.\n\nCan we do these *after* the other resources have been deallocated?", "creation_time": "2011-12-13T14:46:20Z", "bug_id": 709952, "id": 5912022, "tags": [], "count": 4, "is_private": false}, {"time": "2011-12-13T14:51:48Z", "attachment_id": null, "text": "(In reply to Chris Leary [:cdleary] from comment #4)\n> (In reply to Kyle Huey [:khuey] (khuey@mozilla.com) from comment #3)\n> > Trying to do anything complex when we are actually OOM sounds like a\n> > recipe for bad things.\n> \n> I'm not at all familiar with the details, so I'm going to ask dumb\n> questions: would we definitely need extra memory to separate the DOM for a\n> content page from the rest of the browser and deallocate it?\n\nThe DOM, yes.  Layout data, probably not, we should just be able to drop the relevant arenas.\n\n> Can we keep a\n> ballast, as you suggest, because the extra memory required to do this is\n> easily bounded?\n\nWe can keep a ballast, but I'm not sure that the memory is easily bounded in the pathological cases.  We can probably keep enough around for most sane cases though.\n\n> > Also, we'll need memory around to run the cycle collector, GC, etc.  I think\n> > we should be able to kill the layout side of things pretty easily though.\n> \n> Can we do these *after* the other resources have been deallocated?\n\nWe'll need to run the cycle collector to destroy any substantive amount of DOM stuff.  Our experience with MemShrink is that most of the memory usage of webpages is generally in JS, so we'll probably have to run the GC too (and breaking DOM->JS cycles will require running both, of course).", "creation_time": "2011-12-13T14:51:48Z", "raw_text": "(In reply to Chris Leary [:cdleary] from comment #4)\n> (In reply to Kyle Huey [:khuey] (khuey@mozilla.com) from comment #3)\n> > Trying to do anything complex when we are actually OOM sounds like a\n> > recipe for bad things.\n> \n> I'm not at all familiar with the details, so I'm going to ask dumb\n> questions: would we definitely need extra memory to separate the DOM for a\n> content page from the rest of the browser and deallocate it?\n\nThe DOM, yes.  Layout data, probably not, we should just be able to drop the relevant arenas.\n\n> Can we keep a\n> ballast, as you suggest, because the extra memory required to do this is\n> easily bounded?\n\nWe can keep a ballast, but I'm not sure that the memory is easily bounded in the pathological cases.  We can probably keep enough around for most sane cases though.\n\n> > Also, we'll need memory around to run the cycle collector, GC, etc.  I think\n> > we should be able to kill the layout side of things pretty easily though.\n> \n> Can we do these *after* the other resources have been deallocated?\n\nWe'll need to run the cycle collector to destroy any substantive amount of DOM stuff.  Our experience with MemShrink is that most of the memory usage of webpages is generally in JS, so we'll probably have to run the GC too (and breaking DOM->JS cycles will require running both, of course).", "bug_id": 709952, "id": 5912040, "tags": [], "is_private": false, "count": 5, "author": "khuey@kylehuey.com", "creator": "khuey@kylehuey.com"}, {"id": 5912041, "tags": [], "count": 6, "is_private": false, "bug_id": 709952, "creation_time": "2011-12-13T14:52:16Z", "raw_text": "Olli has been thinking about how to make the cycle collector deal with the DOM better, so looping him in.", "time": "2011-12-13T14:52:16Z", "attachment_id": null, "text": "Olli has been thinking about how to make the cycle collector deal with the DOM better, so looping him in.", "author": "khuey@kylehuey.com", "creator": "khuey@kylehuey.com"}, {"is_private": false, "count": 7, "tags": [], "id": 5912307, "bug_id": 709952, "raw_text": "In my approach to teardown some parts of DOM without CC there is still need for allocation, since\nwe need to keep things alive during the process.\n\nBut, I guess that could be implemented in a bit different way where no allocation is needed.\nHowever, that works only for DOM trees which aren't kept alive anything outside it.\n\"Outside\" being scripts etc.", "creation_time": "2011-12-13T16:36:35Z", "text": "In my approach to teardown some parts of DOM without CC there is still need for allocation, since\nwe need to keep things alive during the process.\n\nBut, I guess that could be implemented in a bit different way where no allocation is needed.\nHowever, that works only for DOM trees which aren't kept alive anything outside it.\n\"Outside\" being scripts etc.", "time": "2011-12-13T16:36:35Z", "attachment_id": null, "creator": "bugs@pettay.fi", "author": "bugs@pettay.fi"}, {"creator": "bzbarsky@mit.edu", "author": "bzbarsky@mit.edu", "raw_text": "Here's an interesting question.  For a typical web page, if we nuke the presshell and then BlastSubtreeToPieces on the root, what fraction of nodes go away?  Obviously anything that has js refs to it won't (needs GC/CC), but on many pages this may be a minority of nodes.", "creation_time": "2011-12-13T16:54:04Z", "text": "Here's an interesting question.  For a typical web page, if we nuke the presshell and then BlastSubtreeToPieces on the root, what fraction of nodes go away?  Obviously anything that has js refs to it won't (needs GC/CC), but on many pages this may be a minority of nodes.", "attachment_id": null, "time": "2011-12-13T16:54:04Z", "is_private": false, "count": 8, "tags": [], "id": 5912352, "bug_id": 709952}, {"text": "And yeah, the actual memory usage for the DOM tree that's not reachable from JS is usualy not that high.  Mine is at most 57MB right now out of a total heap of 1.5GB spread across 88 tabs.  So even if we can drop it, it might not get us the breathing room to GC.  :(", "time": "2011-12-13T16:57:02Z", "attachment_id": null, "creation_time": "2011-12-13T16:57:02Z", "raw_text": "And yeah, the actual memory usage for the DOM tree that's not reachable from JS is usualy not that high.  Mine is at most 57MB right now out of a total heap of 1.5GB spread across 88 tabs.  So even if we can drop it, it might not get us the breathing room to GC.  :(", "bug_id": 709952, "count": 9, "is_private": false, "tags": [], "id": 5912362, "creator": "bzbarsky@mit.edu", "author": "bzbarsky@mit.edu"}, {"creator": "cdleary@acm.org", "author": "cdleary@acm.org", "creation_time": "2011-12-14T22:22:11Z", "raw_text": "Adding Bill, since I think delayed marking should be a viable way of running GC in JS when we're in an OOM state (since it doesn't require additional memory), but I'm not confident. Would a JS-internal heap collection be enough to free up the references you're talking about in comment 8, bz?", "text": "Adding Bill, since I think delayed marking should be a viable way of running GC in JS when we're in an OOM state (since it doesn't require additional memory), but I'm not confident. Would a JS-internal heap collection be enough to free up the references you're talking about in comment 8, bz?", "time": "2011-12-14T22:22:11Z", "attachment_id": null, "count": 10, "is_private": false, "tags": [], "id": 5917120, "bug_id": 709952}, {"bug_id": 709952, "id": 5917139, "is_private": false, "count": 11, "tags": [], "attachment_id": null, "time": "2011-12-14T22:26:45Z", "author": "bzbarsky@mit.edu", "creator": "bzbarsky@mit.edu", "text": "I don't know.  I'm guessing we need cc to clean up js-wrapped nodes, but I could be wrong...", "raw_text": "I don't know.  I'm guessing we need cc to clean up js-wrapped nodes, but I could be wrong...", "creation_time": "2011-12-14T22:26:45Z"}, {"id": 5917140, "tags": [], "is_private": false, "count": 12, "bug_id": 709952, "creation_time": "2011-12-14T22:26:46Z", "raw_text": "We're not supposed to require memory allocation for GC to succeed. If we do, it's a bug.", "time": "2011-12-14T22:26:46Z", "attachment_id": null, "text": "We're not supposed to require memory allocation for GC to succeed. If we do, it's a bug.", "author": "bill.mccloskey@gmail.com", "creator": "bill.mccloskey@gmail.com"}, {"author": "continuation@gmail.com", "creator": "continuation@gmail.com", "bug_id": 709952, "id": 5917169, "tags": [], "count": 13, "is_private": false, "attachment_id": null, "time": "2011-12-14T22:34:35Z", "text": "Yes, the CC is the only thing that will kill JS-wrapped nodes.  It also requires a ton of memory.  Olli's special-purpose DOM freer idea could work, too, and wouldn't require as much memory.", "creation_time": "2011-12-14T22:34:35Z", "raw_text": "Yes, the CC is the only thing that will kill JS-wrapped nodes.  It also requires a ton of memory.  Olli's special-purpose DOM freer idea could work, too, and wouldn't require as much memory."}, {"bug_id": 709952, "is_private": false, "count": 14, "tags": [], "id": 5917175, "text": "It sounds like this overlaps with some discussions we've been having in MemShrink about memory pressure events.", "time": "2011-12-14T22:35:36Z", "attachment_id": null, "raw_text": "It sounds like this overlaps with some discussions we've been having in MemShrink about memory pressure events.", "creation_time": "2011-12-14T22:35:36Z", "creator": "continuation@gmail.com", "author": "continuation@gmail.com"}, {"id": 5917364, "tags": [], "is_private": false, "count": 15, "bug_id": 709952, "creation_time": "2011-12-14T23:21:02Z", "raw_text": "(In reply to Andrew McCreight [:mccr8] from comment #14)\n> It sounds like this overlaps with some discussions we've been having in\n> MemShrink about memory pressure events.\n\nYeah, probably some overlap -- the reason I started asking about this is that I'm specifically concerned about handling \"real OOMs\" without aborting the application -- ideally we would display a comprehensible error message to the user when we start nuking their tabs.", "attachment_id": null, "time": "2011-12-14T23:21:02Z", "text": "(In reply to Andrew McCreight [:mccr8] from comment #14)\n> It sounds like this overlaps with some discussions we've been having in\n> MemShrink about memory pressure events.\n\nYeah, probably some overlap -- the reason I started asking about this is that I'm specifically concerned about handling \"real OOMs\" without aborting the application -- ideally we would display a comprehensible error message to the user when we start nuking their tabs.", "author": "cdleary@acm.org", "creator": "cdleary@acm.org"}, {"creator": "cdleary@acm.org", "author": "cdleary@acm.org", "text": "(In reply to Olli Pettay [:smaug] from comment #7)\n> However, that works only for DOM trees which aren't kept alive anything\n> outside it.\n> \"Outside\" being scripts etc.\n\nIs that the common case? If it is the common case, can we turn those external references into \"remembered\" sets of references that we can NULL out from the referee-side due to OOM killer activity?", "attachment_id": null, "time": "2011-12-14T23:23:00Z", "raw_text": "(In reply to Olli Pettay [:smaug] from comment #7)\n> However, that works only for DOM trees which aren't kept alive anything\n> outside it.\n> \"Outside\" being scripts etc.\n\nIs that the common case? If it is the common case, can we turn those external references into \"remembered\" sets of references that we can NULL out from the referee-side due to OOM killer activity?", "creation_time": "2011-12-14T23:23:00Z", "bug_id": 709952, "is_private": false, "count": 16, "tags": [], "id": 5917372}, {"creator": "bzbarsky@mit.edu", "author": "bzbarsky@mit.edu", "creation_time": "2011-12-15T00:00:55Z", "raw_text": "> Is that the common case?\n\nFor cases where we can drop lots of memory, probably yes.  See my numbers from comment 9.  If we had reporting working for orphaned DOM subtrees (soon, hopefully) I could get you better numbers on those, which must be owned by JS.", "text": "> Is that the common case?\n\nFor cases where we can drop lots of memory, probably yes.  See my numbers from comment 9.  If we had reporting working for orphaned DOM subtrees (soon, hopefully) I could get you better numbers on those, which must be owned by JS.", "time": "2011-12-15T00:00:55Z", "attachment_id": null, "count": 17, "is_private": false, "tags": [], "id": 5917488, "bug_id": 709952}, {"raw_text": "This is exactly what I was talking about in the last paragraph of bug 710501 comment 0.", "creation_time": "2011-12-15T00:23:01Z", "attachment_id": null, "time": "2011-12-15T00:23:01Z", "text": "This is exactly what I was talking about in the last paragraph of bug 710501 comment 0.", "id": 5917560, "count": 18, "is_private": false, "tags": [], "bug_id": 709952, "author": "n.nethercote@gmail.com", "creator": "n.nethercote@gmail.com"}, {"id": 5917634, "is_private": false, "count": 19, "tags": [], "bug_id": 709952, "creation_time": "2011-12-15T00:52:38Z", "raw_text": "(In reply to Boris Zbarsky (:bz) from comment #17)\n> For cases where we can drop lots of memory, probably yes.\n\nSo given that it's probably yes, are the pointers that would refer to these DOM trees from the content that we'd be OOM killing (in which case we don't care) or from elsewhere?\n\nI would assume that \"elsewhere\" would be Chrome, in which case we'd have wrappers anyway, right?", "time": "2011-12-15T00:52:38Z", "attachment_id": null, "text": "(In reply to Boris Zbarsky (:bz) from comment #17)\n> For cases where we can drop lots of memory, probably yes.\n\nSo given that it's probably yes, are the pointers that would refer to these DOM trees from the content that we'd be OOM killing (in which case we don't care) or from elsewhere?\n\nI would assume that \"elsewhere\" would be Chrome, in which case we'd have wrappers anyway, right?", "author": "cdleary@acm.org", "creator": "cdleary@acm.org"}, {"author": "justin.lebar+bug@gmail.com", "creator": "justin.lebar+bug@gmail.com", "bug_id": 709952, "id": 5917704, "count": 20, "is_private": false, "tags": [], "attachment_id": null, "time": "2011-12-15T01:17:55Z", "text": "We can, in theory, anyway, catch OOM arbitrarily early with something like bug 670967.\n\nOnce malloc() is failing, it's very hard to recover...", "creation_time": "2011-12-15T01:17:55Z", "raw_text": "We can, in theory, anyway, catch OOM arbitrarily early with something like bug 670967.\n\nOnce malloc() is failing, it's very hard to recover..."}, {"attachment_id": null, "time": "2011-12-15T01:51:23Z", "text": "(In reply to Justin Lebar [:jlebar] from comment #20)\n> Once malloc() is failing, it's very hard to recover...\n\nThat's the question that I'm bothering people about in this bug -- how hard is it really to do something more sensible than abort? In the same sense that Chrome displays something sensible when a tab group OOMs (due to catching the intentional crash that they cause), we should evaluate whether we can provide a similar experience without process isolation (and ideally not just on Windows).", "raw_text": "(In reply to Justin Lebar [:jlebar] from comment #20)\n> Once malloc() is failing, it's very hard to recover...\n\nThat's the question that I'm bothering people about in this bug -- how hard is it really to do something more sensible than abort? In the same sense that Chrome displays something sensible when a tab group OOMs (due to catching the intentional crash that they cause), we should evaluate whether we can provide a similar experience without process isolation (and ideally not just on Windows).", "creation_time": "2011-12-15T01:51:23Z", "bug_id": 709952, "id": 5917776, "count": 21, "is_private": false, "tags": [], "author": "cdleary@acm.org", "creator": "cdleary@acm.org"}, {"time": "2011-12-15T01:58:26Z", "attachment_id": null, "text": "To be clear, we can extend bug 670967 to more than Windows, if that approach is successful.\n\nBut it's really hard to write code which does something sensible without ever calling malloc.  Consider that, when malloc fails, you pretty much have to return to the event loop before you can do anything serious.  Code will break very hard if malloc() can trigger a GC.  (I speak from experience.  :)  So now you have to audit the whole path down from wherever you happen to be into and through the event loop and make sure there are no allocations.\n\nIf we can detect low memory before we're entirely out of virtual memory, that seems to make our life a lot easier.", "creation_time": "2011-12-15T01:58:26Z", "raw_text": "To be clear, we can extend bug 670967 to more than Windows, if that approach is successful.\n\nBut it's really hard to write code which does something sensible without ever calling malloc.  Consider that, when malloc fails, you pretty much have to return to the event loop before you can do anything serious.  Code will break very hard if malloc() can trigger a GC.  (I speak from experience.  :)  So now you have to audit the whole path down from wherever you happen to be into and through the event loop and make sure there are no allocations.\n\nIf we can detect low memory before we're entirely out of virtual memory, that seems to make our life a lot easier.", "bug_id": 709952, "id": 5917785, "is_private": false, "count": 22, "tags": [], "author": "justin.lebar+bug@gmail.com", "creator": "justin.lebar+bug@gmail.com"}, {"raw_text": "> are the pointers that would refer to these DOM trees from the content that we'd be OOM\n> killing (in which case we don't care)\n\nThe pointers are probably from the content JS heap.", "creation_time": "2011-12-15T04:01:59Z", "text": "> are the pointers that would refer to these DOM trees from the content that we'd be OOM\n> killing (in which case we don't care)\n\nThe pointers are probably from the content JS heap.", "creator": "bzbarsky@mit.edu", "time": "2011-12-15T04:01:59Z", "attachment_id": null, "author": "bzbarsky@mit.edu", "is_private": false, "count": 23, "tags": [], "id": 5917918, "bug_id": 709952}, {"creator": "cdleary@acm.org", "author": "cdleary@acm.org", "bug_id": 709952, "tags": [], "count": 24, "is_private": false, "id": 5928526, "text": "(In reply to Justin Lebar [:jlebar] from comment #22)\n> Consider that, when malloc fails, you pretty much have\n> to return to the event loop before you can do anything serious.  Code will\n> break very hard if malloc() can trigger a GC.  (I speak from experience.  :)\n> So now you have to audit the whole path down from wherever you happen to be\n> into and through the event loop and make sure there are no allocations.\n\nOkay, that's a really good point. The whole benefit of infallible malloc is to avoid having a way of bubbling back to the event loop, so anything that we could do in this OOM scenario would have to be from under (within) the malloc call itself.\n\nDo you have a bug / comment on how code breaks when malloc can trigger GC? After I read about that I'd be happy to close this as INVALID and start reading up on the low-memory approach.", "attachment_id": null, "time": "2011-12-20T01:29:48Z", "creation_time": "2011-12-20T01:29:48Z", "raw_text": "(In reply to Justin Lebar [:jlebar] from comment #22)\n> Consider that, when malloc fails, you pretty much have\n> to return to the event loop before you can do anything serious.  Code will\n> break very hard if malloc() can trigger a GC.  (I speak from experience.  :)\n> So now you have to audit the whole path down from wherever you happen to be\n> into and through the event loop and make sure there are no allocations.\n\nOkay, that's a really good point. The whole benefit of infallible malloc is to avoid having a way of bubbling back to the event loop, so anything that we could do in this OOM scenario would have to be from under (within) the malloc call itself.\n\nDo you have a bug / comment on how code breaks when malloc can trigger GC? After I read about that I'd be happy to close this as INVALID and start reading up on the low-memory approach."}, {"creator": "justin.lebar+bug@gmail.com", "author": "justin.lebar+bug@gmail.com", "raw_text": "> Do you have a bug / comment on how code breaks when malloc can trigger GC?\n\nIt was a while ago, but as I recall, everything went to hell when code called malloc() while holding the GC lock.  One could trivially not trigger a GC in this case, but then do you just give up and crash?", "creation_time": "2011-12-20T01:38:46Z", "text": "> Do you have a bug / comment on how code breaks when malloc can trigger GC?\n\nIt was a while ago, but as I recall, everything went to hell when code called malloc() while holding the GC lock.  One could trivially not trigger a GC in this case, but then do you just give up and crash?", "time": "2011-12-20T01:38:46Z", "attachment_id": null, "tags": [], "is_private": false, "count": 25, "id": 5928547, "bug_id": 709952}, {"bug_id": 709952, "is_private": false, "count": 26, "tags": [], "id": 5930937, "text": "Do you agree this is INVALID/WONTFIX, Chris?", "attachment_id": null, "time": "2011-12-20T22:06:25Z", "creation_time": "2011-12-20T22:06:25Z", "raw_text": "Do you agree this is INVALID/WONTFIX, Chris?", "creator": "justin.lebar+bug@gmail.com", "author": "justin.lebar+bug@gmail.com"}, {"text": "(In reply to Justin Lebar [:jlebar] from comment #26)\n> Do you agree this is INVALID/WONTFIX, Chris?\n\nNo, if the evidence is just that inserting a GC call under malloc caused some things to fail. Are there systematic rooting issues that could only be solved with a complex static analysis, or is it just having the GC lock held? Like you say, you could abort() in the GC lock held case if it only happens a small percentage of the time and still get most of the gain.", "attachment_id": null, "time": "2011-12-20T22:17:37Z", "raw_text": "(In reply to Justin Lebar [:jlebar] from comment #26)\n> Do you agree this is INVALID/WONTFIX, Chris?\n\nNo, if the evidence is just that inserting a GC call under malloc caused some things to fail. Are there systematic rooting issues that could only be solved with a complex static analysis, or is it just having the GC lock held? Like you say, you could abort() in the GC lock held case if it only happens a small percentage of the time and still get most of the gain.", "creation_time": "2011-12-20T22:17:37Z", "bug_id": 709952, "tags": [], "count": 27, "is_private": false, "id": 5930969, "creator": "cdleary@acm.org", "author": "cdleary@acm.org"}, {"tags": [], "is_private": false, "count": 28, "id": 5931024, "bug_id": 709952, "raw_text": "If you want to do an experiment, AvailableMemoryTracker.cpp lets you hook in really deep (when VirtualAlloc is called on Windows).  You could easily hook in there and synchronously fire a memory pressure event, or a GC, or whatever, when rand() <= 0.01 or something.", "creation_time": "2011-12-20T22:32:42Z", "text": "If you want to do an experiment, AvailableMemoryTracker.cpp lets you hook in really deep (when VirtualAlloc is called on Windows).  You could easily hook in there and synchronously fire a memory pressure event, or a GC, or whatever, when rand() <= 0.01 or something.", "time": "2011-12-20T22:32:42Z", "attachment_id": null, "creator": "justin.lebar+bug@gmail.com", "author": "justin.lebar+bug@gmail.com"}, {"author": "cdleary@acm.org", "creator": "cdleary@acm.org", "attachment_id": null, "time": "2011-12-22T22:07:02Z", "text": "(In reply to Justin Lebar [:jlebar] from comment #28)\n\nYeah, I think it's definitely experimentation time. When I get back from holiday I'm going to chat with folks and see what I can hack up.", "raw_text": "(In reply to Justin Lebar [:jlebar] from comment #28)\n\nYeah, I think it's definitely experimentation time. When I get back from holiday I'm going to chat with folks and see what I can hack up.", "creation_time": "2011-12-22T22:07:02Z", "bug_id": 709952, "id": 5936447, "tags": [], "count": 29, "is_private": false}, {"creation_time": "2012-10-10T21:06:55Z", "raw_text": "(In reply to Justin Lebar [:jlebar] from comment #22)\n> But it's really hard to write code which does something sensible without\n> ever calling malloc.  Consider that, when malloc fails, you pretty much have\n> to return to the event loop before you can do anything serious.\n\nHow about asking other threads to free *their* memory?  Should be safe regardless of what the OOMing thread is in the middle of doing.", "time": "2012-10-10T21:06:55Z", "attachment_id": null, "text": "(In reply to Justin Lebar [:jlebar] from comment #22)\n> But it's really hard to write code which does something sensible without\n> ever calling malloc.  Consider that, when malloc fails, you pretty much have\n> to return to the event loop before you can do anything serious.\n\nHow about asking other threads to free *their* memory?  Should be safe regardless of what the OOMing thread is in the middle of doing.", "id": 6717046, "tags": [], "count": 30, "is_private": false, "bug_id": 709952, "author": "jruderman@gmail.com", "creator": "jruderman@gmail.com"}, {"creator": "khuey@kylehuey.com", "author": "khuey@kylehuey.com", "raw_text": "Depending on what \"asking other threads to free their memory\" means, that could easily lead to deadlocks.  It also has the problem that the main thread owns most of the memory.", "creation_time": "2012-10-10T21:35:21Z", "text": "Depending on what \"asking other threads to free their memory\" means, that could easily lead to deadlocks.  It also has the problem that the main thread owns most of the memory.", "attachment_id": null, "time": "2012-10-10T21:35:21Z", "count": 31, "is_private": false, "tags": [], "id": 6717153, "bug_id": 709952}]}}, "comments": {}}