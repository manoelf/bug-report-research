{"comments": {}, "bugs": {"651981": {"comments": [{"raw_text": "Eventually we may want to fix the GfxInfo API.\n\nHere's one problem: getters can throw, which is a pain for the JS programmer, see bug 642502 comment 13.", "tags": [], "is_private": false, "creation_time": "2011-04-21T22:00:04Z", "text": "Eventually we may want to fix the GfxInfo API.\n\nHere's one problem: getters can throw, which is a pain for the JS programmer, see bug 642502 comment 13.", "attachment_id": null, "id": 5425093, "count": 0, "bug_id": 651981, "time": "2011-04-21T22:00:04Z", "author": "jacob.benoit.1@gmail.com", "creator": "jacob.benoit.1@gmail.com"}, {"time": "2011-04-21T22:05:32Z", "is_private": false, "tags": [], "raw_text": "Yes, the getters should never throw.", "bug_id": 651981, "count": 1, "attachment_id": null, "id": 5425116, "creator": "jmuizelaar@mozilla.com", "text": "Yes, the getters should never throw.", "author": "jmuizelaar@mozilla.com", "creation_time": "2011-04-21T22:05:32Z"}, {"creation_time": "2011-04-26T18:01:42Z", "creator": "jacob.benoit.1@gmail.com", "text": "As discussed over lunch:\n 1) GfxInfo should only provide, well, info about gfx. The blacklisting decision process should be taken out of it, into a new class.\n 2) maybe GfxInfo should just provide a \"GfxInfo objet\" from which the JS programmer could access properties, instead of being an interface with getters. The benefit of such an OO approach becomes clearer in conjunction with 1) : one would first obtain a GfxInfo object, then pass it to the blacklisting decision function.", "id": 5432363, "attachment_id": null, "author": "jacob.benoit.1@gmail.com", "bug_id": 651981, "raw_text": "As discussed over lunch:\n 1) GfxInfo should only provide, well, info about gfx. The blacklisting decision process should be taken out of it, into a new class.\n 2) maybe GfxInfo should just provide a \"GfxInfo objet\" from which the JS programmer could access properties, instead of being an interface with getters. The benefit of such an OO approach becomes clearer in conjunction with 1) : one would first obtain a GfxInfo object, then pass it to the blacklisting decision function.", "count": 2, "time": "2011-04-26T18:01:42Z", "tags": [], "is_private": false}, {"time": "2011-05-03T17:34:29Z", "bug_id": 651981, "count": 3, "creator": "jacob.benoit.1@gmail.com", "author": "jacob.benoit.1@gmail.com", "tags": [], "is_private": false, "raw_text": "From bug 642502 comment 22:\n\n> >+#ifdef XP_WIN\n> >+    // If ANGLE is not available but OpenGL is, we want to report on the OpenGL feature, because that's what's going to get used.\n> >+    // In all other cases we want to report on the ANGLE feature.\n> >+    var webglfeature = gfxInfo.FEATURE_WEBGL_ANGLE;\n> >+    if (gfxInfo.getFeatureStatus(gfxInfo.FEATURE_WEBGL_ANGLE)  != gfxInfo.FEATURE_NO_INFO &&\n> >+        gfxInfo.getFeatureStatus(gfxInfo.FEATURE_WEBGL_OPENGL) == gfxInfo.FEATURE_NO_INFO)\n> >+      webglfeature = gfxInfo.FEATURE_WEBGL_OPENGL;\n> >+#else\n> >+    var webglfeature = gfxInfo.FEATURE_WEBGL_OPENGL;\n> >+#endif\n> \n> A slightly more general comment: it seems fragile to have this logic here,\n> because it needs to be manually kept in sync with the back-end logic that\n> actually decides what gets used when. Having about:support do nothing but just\n> unconditionally call GfxInfo APIs and print their return values directly seems\n> like the ideal state that we want to strive for. Maybe that should be the\n> overarching goal for bug 651981?\n\nYes, this is exactly where we want to go.", "text": "From bug 642502 comment 22:\n\n> >+#ifdef XP_WIN\n> >+    // If ANGLE is not available but OpenGL is, we want to report on the OpenGL feature, because that's what's going to get used.\n> >+    // In all other cases we want to report on the ANGLE feature.\n> >+    var webglfeature = gfxInfo.FEATURE_WEBGL_ANGLE;\n> >+    if (gfxInfo.getFeatureStatus(gfxInfo.FEATURE_WEBGL_ANGLE)  != gfxInfo.FEATURE_NO_INFO &&\n> >+        gfxInfo.getFeatureStatus(gfxInfo.FEATURE_WEBGL_OPENGL) == gfxInfo.FEATURE_NO_INFO)\n> >+      webglfeature = gfxInfo.FEATURE_WEBGL_OPENGL;\n> >+#else\n> >+    var webglfeature = gfxInfo.FEATURE_WEBGL_OPENGL;\n> >+#endif\n> \n> A slightly more general comment: it seems fragile to have this logic here,\n> because it needs to be manually kept in sync with the back-end logic that\n> actually decides what gets used when. Having about:support do nothing but just\n> unconditionally call GfxInfo APIs and print their return values directly seems\n> like the ideal state that we want to strive for. Maybe that should be the\n> overarching goal for bug 651981?\n\nYes, this is exactly where we want to go.", "attachment_id": null, "id": 5446096, "creation_time": "2011-05-03T17:34:29Z"}, {"raw_text": "Also, bug 642502 comment 27: for features that are not applicable to the host OS, we need to decide on a standard behavior for getFeatureStatus(). I suggest adding a new kind of status code, like FEATURE_NOT_PRESENT_ON_THIS_OS. Currently it seems that we just return NO_INFO and that could vary between GfxInfo OS-specific implementations.", "bug_id": 651981, "count": 4, "time": "2011-05-03T19:30:39Z", "is_private": false, "tags": [], "creation_time": "2011-05-03T19:30:39Z", "attachment_id": null, "id": 5446498, "creator": "jacob.benoit.1@gmail.com", "text": "Also, bug 642502 comment 27: for features that are not applicable to the host OS, we need to decide on a standard behavior for getFeatureStatus(). I suggest adding a new kind of status code, like FEATURE_NOT_PRESENT_ON_THIS_OS. Currently it seems that we just return NO_INFO and that could vary between GfxInfo OS-specific implementations.", "author": "jacob.benoit.1@gmail.com"}, {"raw_text": "", "tags": [], "is_private": false, "creation_time": "2011-08-26T14:55:18Z", "text": "Created attachment 556030\nHere's a sketch of what this could look like", "attachment_id": 556030, "id": 5680609, "bug_id": 651981, "count": 5, "time": "2011-08-26T14:55:18Z", "creator": "jmuizelaar@mozilla.com", "author": "jmuizelaar@mozilla.com"}, {"bug_id": 651981, "count": 6, "time": "2011-10-14T19:13:13Z", "creator": "jmuizelaar@mozilla.com", "author": "jmuizelaar@mozilla.com", "raw_text": "", "tags": [], "is_private": false, "creation_time": "2011-10-14T19:13:13Z", "text": "Created attachment 567156\nHere's a more shippable version", "id": 5783404, "attachment_id": 567156}, {"raw_text": "Review of attachment 567156:\n-----------------------------------------------------------------\n\nr=me except for the JSAPI stuff (InfoObject), need another reviewer.", "bug_id": 651981, "count": 7, "time": "2011-10-25T21:04:25Z", "is_private": false, "tags": [], "creation_time": "2011-10-25T21:04:25Z", "attachment_id": 567156, "id": 5804372, "creator": "jacob.benoit.1@gmail.com", "text": "Comment on attachment 567156\nHere's a more shippable version\n\nReview of attachment 567156:\n-----------------------------------------------------------------\n\nr=me except for the JSAPI stuff (InfoObject), need another reviewer.", "author": "jacob.benoit.1@gmail.com"}, {"creator": "jmuizelaar@mozilla.com", "author": "jmuizelaar@mozilla.com", "bug_id": 651981, "count": 8, "time": "2011-11-02T20:49:27Z", "creation_time": "2011-11-02T20:49:27Z", "text": "Created attachment 571446\nAgain, this time with error handling", "id": 5821867, "attachment_id": 571446, "raw_text": "", "tags": [], "is_private": false}, {"creator": "Ms2ger@gmail.com", "text": "Comment on attachment 571446\nAgain, this time with error handling\n\nDrive-by comments:\n\n>--- a/widget/src/xpwidgets/GfxInfoBase.cpp\n>+++ b/widget/src/xpwidgets/GfxInfoBase.cpp\n>+nsresult GfxInfoBase::GetInfo(JSContext* aCx, jsval* aResult)\n>+{\n>+  if (obj.mOk) {\n>+    *aResult = OBJECT_TO_JSVAL(obj.mObj);\n>+    return NS_OK;\n>+  } else {\n>+    return NS_ERROR_FAILURE;\n>+  }\n\nNit:\n\nif (!obj.mOk) {\n  return NS_ERROR_FAILURE;\n}\n\n*aResult = OBJECT_TO_JSVAL(obj.mObj);\nreturn NS_OK;\n\nAlso, inconsistent indentation.\n\n>+GfxInfoBase::RemoveCollector(GfxInfoCollectorBase* collector)\n>+    for (unsigned int i = 0; i < sCollectors->Length(); i++) {\n\nPRUint32?\n\n>--- /dev/null\n>+++ b/widget/src/xpwidgets/GfxInfoCollector.h\n>@@ -0,0 +1,96 @@\n\nLicense header!\n\n>+#ifndef __mozilla_widget_GfxInfoCollector_h__\n>+#define __mozilla_widget_GfxInfoCollector_h__\n\nNo leading or trailing underscores please.\n\n>+class InfoObject\n>+    InfoObject(JSContext *aCx) : mCx(aCx)\n>+    {\n>+        mObj = JS_NewObject(mCx, NULL, NULL, NULL);\n>+        if (!mObj)\n>+            mOk = JS_TRUE;\n\nNot mOk = JS_FALSE?\n\n>+    JSBool mOk;\n\nNot a bool?\n\n>+class GfxInfoCollectorBase\n>+{\n>+  public:\n>+    GfxInfoCollectorBase();\n>+    virtual void GetInfo(InfoObject &obj) = 0;\n>+    ~GfxInfoCollectorBase();\n\nvirtual destructor? (Disclaimer: I don't know C++)", "attachment_id": 571446, "id": 5821888, "author": "Ms2ger@gmail.com", "creation_time": "2011-11-02T20:58:59Z", "time": "2011-11-02T20:58:59Z", "tags": [], "is_private": false, "bug_id": 651981, "raw_text": "Drive-by comments:\n\n>--- a/widget/src/xpwidgets/GfxInfoBase.cpp\n>+++ b/widget/src/xpwidgets/GfxInfoBase.cpp\n>+nsresult GfxInfoBase::GetInfo(JSContext* aCx, jsval* aResult)\n>+{\n>+  if (obj.mOk) {\n>+    *aResult = OBJECT_TO_JSVAL(obj.mObj);\n>+    return NS_OK;\n>+  } else {\n>+    return NS_ERROR_FAILURE;\n>+  }\n\nNit:\n\nif (!obj.mOk) {\n  return NS_ERROR_FAILURE;\n}\n\n*aResult = OBJECT_TO_JSVAL(obj.mObj);\nreturn NS_OK;\n\nAlso, inconsistent indentation.\n\n>+GfxInfoBase::RemoveCollector(GfxInfoCollectorBase* collector)\n>+    for (unsigned int i = 0; i < sCollectors->Length(); i++) {\n\nPRUint32?\n\n>--- /dev/null\n>+++ b/widget/src/xpwidgets/GfxInfoCollector.h\n>@@ -0,0 +1,96 @@\n\nLicense header!\n\n>+#ifndef __mozilla_widget_GfxInfoCollector_h__\n>+#define __mozilla_widget_GfxInfoCollector_h__\n\nNo leading or trailing underscores please.\n\n>+class InfoObject\n>+    InfoObject(JSContext *aCx) : mCx(aCx)\n>+    {\n>+        mObj = JS_NewObject(mCx, NULL, NULL, NULL);\n>+        if (!mObj)\n>+            mOk = JS_TRUE;\n\nNot mOk = JS_FALSE?\n\n>+    JSBool mOk;\n\nNot a bool?\n\n>+class GfxInfoCollectorBase\n>+{\n>+  public:\n>+    GfxInfoCollectorBase();\n>+    virtual void GetInfo(InfoObject &obj) = 0;\n>+    ~GfxInfoCollectorBase();\n\nvirtual destructor? (Disclaimer: I don't know C++)", "count": 9}, {"creator": "jmuizelaar@mozilla.com", "author": "jmuizelaar@mozilla.com", "time": "2011-11-02T21:39:16Z", "bug_id": 651981, "count": 10, "id": 5822026, "attachment_id": 571463, "text": "Created attachment 571463\nAgain, this time with betterness\n\nFixes Ms2ger's comments.", "creation_time": "2011-11-02T21:39:16Z", "is_private": false, "tags": [], "raw_text": "Fixes Ms2ger's comments."}, {"is_private": false, "tags": [], "time": "2011-11-02T21:56:11Z", "count": 11, "raw_text": "Review of attachment 571446:\n-----------------------------------------------------------------\n\nr=me for the JSAPI usage, but there are a few bugs that must be fixed for this code to work at all (see below).\n\nI'm not a peer in widget/src, so I guess this might need another review.\n\n::: widget/src/xpwidgets/GfxInfoBase.cpp\n@@ +689,5 @@\n> +InitCollectors()\n> +{\n> +    if (!sCollectors)\n> +        sCollectors = new nsTArray<GfxInfoCollectorBase*>;\n> +}\n\nNit: these indents are 4 spaces, but I think this code probably wants 2-space indents.\n\n@@ +697,5 @@\n> +  InitCollectors();\n> +  InfoObject obj(aCx);\n> +\n> +  for (PRUint32 i = 0; i < sCollectors->Length(); i++) {\n> +      (*sCollectors)[i]->GetInfo(obj);\n\nSame nit on this line.\n\n::: widget/src/xpwidgets/GfxInfoCollector.h\n@@ +7,5 @@\n> +namespace widget {\n> +\n> +\n> +/* this is handy wrapper around JSAPI to make it more pleasant to use */\n> +class InfoObject\n\nSince this class keeps a pointer to a JSObject, which is subject to garbage collection, it is important that this class be instantiated only on the stack (which the GC scans, searching for such pointers). Making the constructor private, and declaring a private copy constructor that isn't defined anywhere, could help ensure that.\n\nThe error handling in this class is fine as long as mCx definitely won't be used for anything else for the lifetime of the InfoObject. That might be hard to guarantee, but it depends on what the GetInfo methods are like. If they're all as simple as your example, it's fine.\n\n@@ +17,5 @@\n> +    {\n> +        mObj = JS_NewObject(mCx, NULL, NULL, NULL);\n> +        if (!mObj)\n> +            mOk = JS_TRUE;\n> +    }\n\nThis constructor does not always initialize mOk. Also it seems like JS_TRUE is the wrong value here. Maybe you want to say:\n  mOk = (mObj != NULL);\n\n@@ +22,5 @@\n> +\n> +    void DefineProperty(const char *name, int value)\n> +    {\n> +        if (mOk)\n> +            return;\n\nif (!mOk), right?\n\nYou could write this instead:\n    mOk = mOk && JS_DefineProperty( ... );\n\n@@ +30,5 @@\n> +\n> +    void DefineProperty(const char *name, nsAString &value)\n> +    {\n> +        if (mOk)\n> +            return;\n\nif (!mOk), right?\n\n@@ +35,5 @@\n> +\n> +        const nsPromiseFlatString &flat = PromiseFlatString(value);\n> +        JSString *string = JS_NewUCStringCopyN(mCx, static_cast<const jschar*>(flat.get()), flat.Length());\n> +        if (!string)\n> +            mOk = JS_TRUE;\n\nJS_FALSE.\n\n@@ +38,5 @@\n> +        if (!string)\n> +            mOk = JS_TRUE;\n> +\n> +        if (!mOk)\n> +            mOk = JS_DefineProperty(mCx, mObj, name, STRING_TO_JSVAL(string), NULL, NULL, JSPROP_ENUMERATE);\n\nYou could use && here too.\n\n@@ +52,5 @@\n> +\n> +Here's an example usage:\n> +\n> +class Foo {\n> +    Joe::Joe() : mInfoCollector(this, &Foo::GetAweseomeness) {}\n\nFoo::Foo, not Joe::Joe, right?", "bug_id": 651981, "author": "jorendorff@mozilla.com", "attachment_id": 571446, "id": 5822076, "text": "Comment on attachment 571446\nAgain, this time with error handling\n\nReview of attachment 571446:\n-----------------------------------------------------------------\n\nr=me for the JSAPI usage, but there are a few bugs that must be fixed for this code to work at all (see below).\n\nI'm not a peer in widget/src, so I guess this might need another review.\n\n::: widget/src/xpwidgets/GfxInfoBase.cpp\n@@ +689,5 @@\n> +InitCollectors()\n> +{\n> +    if (!sCollectors)\n> +        sCollectors = new nsTArray<GfxInfoCollectorBase*>;\n> +}\n\nNit: these indents are 4 spaces, but I think this code probably wants 2-space indents.\n\n@@ +697,5 @@\n> +  InitCollectors();\n> +  InfoObject obj(aCx);\n> +\n> +  for (PRUint32 i = 0; i < sCollectors->Length(); i++) {\n> +      (*sCollectors)[i]->GetInfo(obj);\n\nSame nit on this line.\n\n::: widget/src/xpwidgets/GfxInfoCollector.h\n@@ +7,5 @@\n> +namespace widget {\n> +\n> +\n> +/* this is handy wrapper around JSAPI to make it more pleasant to use */\n> +class InfoObject\n\nSince this class keeps a pointer to a JSObject, which is subject to garbage collection, it is important that this class be instantiated only on the stack (which the GC scans, searching for such pointers). Making the constructor private, and declaring a private copy constructor that isn't defined anywhere, could help ensure that.\n\nThe error handling in this class is fine as long as mCx definitely won't be used for anything else for the lifetime of the InfoObject. That might be hard to guarantee, but it depends on what the GetInfo methods are like. If they're all as simple as your example, it's fine.\n\n@@ +17,5 @@\n> +    {\n> +        mObj = JS_NewObject(mCx, NULL, NULL, NULL);\n> +        if (!mObj)\n> +            mOk = JS_TRUE;\n> +    }\n\nThis constructor does not always initialize mOk. Also it seems like JS_TRUE is the wrong value here. Maybe you want to say:\n  mOk = (mObj != NULL);\n\n@@ +22,5 @@\n> +\n> +    void DefineProperty(const char *name, int value)\n> +    {\n> +        if (mOk)\n> +            return;\n\nif (!mOk), right?\n\nYou could write this instead:\n    mOk = mOk && JS_DefineProperty( ... );\n\n@@ +30,5 @@\n> +\n> +    void DefineProperty(const char *name, nsAString &value)\n> +    {\n> +        if (mOk)\n> +            return;\n\nif (!mOk), right?\n\n@@ +35,5 @@\n> +\n> +        const nsPromiseFlatString &flat = PromiseFlatString(value);\n> +        JSString *string = JS_NewUCStringCopyN(mCx, static_cast<const jschar*>(flat.get()), flat.Length());\n> +        if (!string)\n> +            mOk = JS_TRUE;\n\nJS_FALSE.\n\n@@ +38,5 @@\n> +        if (!string)\n> +            mOk = JS_TRUE;\n> +\n> +        if (!mOk)\n> +            mOk = JS_DefineProperty(mCx, mObj, name, STRING_TO_JSVAL(string), NULL, NULL, JSPROP_ENUMERATE);\n\nYou could use && here too.\n\n@@ +52,5 @@\n> +\n> +Here's an example usage:\n> +\n> +class Foo {\n> +    Joe::Joe() : mInfoCollector(this, &Foo::GetAweseomeness) {}\n\nFoo::Foo, not Joe::Joe, right?", "creator": "jorendorff@mozilla.com", "creation_time": "2011-11-02T21:56:11Z"}, {"is_private": false, "tags": [], "time": "2011-11-02T23:21:47Z", "count": 12, "raw_text": "Carrying forward r+.", "bug_id": 651981, "author": "jorendorff@mozilla.com", "attachment_id": 571463, "id": 5822381, "text": "Comment on attachment 571463\nAgain, this time with betterness\n\nCarrying forward r+.", "creator": "jorendorff@mozilla.com", "creation_time": "2011-11-02T23:21:47Z"}, {"creator": "joe@drew.ca", "author": "joe@drew.ca", "bug_id": 651981, "count": 13, "time": "2011-11-04T23:24:36Z", "creation_time": "2011-11-04T23:24:36Z", "id": 5827823, "attachment_id": null, "text": "(In reply to Jason Orendorff [:jorendorff] from comment #11)\n\n> > +class Foo {\n> > +    Joe::Joe() : mInfoCollector(this, &Foo::GetAweseomeness) {}\n> \n> Foo::Foo, not Joe::Joe, right?\n\nJeff has numerous copies of joe-sucks.cpp and joe-sucks.png on his various computers.", "raw_text": "(In reply to Jason Orendorff [:jorendorff] from comment #11)\n\n> > +class Foo {\n> > +    Joe::Joe() : mInfoCollector(this, &Foo::GetAweseomeness) {}\n> \n> Foo::Foo, not Joe::Joe, right?\n\nJeff has numerous copies of joe-sucks.cpp and joe-sucks.png on his various computers.", "is_private": false, "tags": []}, {"time": "2011-11-15T11:42:32Z", "bug_id": 651981, "count": 14, "creator": "matt.woodrow@gmail.com", "author": "matt.woodrow@gmail.com", "is_private": false, "tags": [], "raw_text": "Review of attachment 571463:\n-----------------------------------------------------------------\n\n::: widget/src/xpwidgets/GfxInfoCollector.h\n@@ +79,5 @@\n> +  InfoObject(JSContext *aCx) : mCx(aCx)\n> +  {\n> +    mObj = JS_NewObject(mCx, NULL, NULL, NULL);\n> +    if (!mObj)\n> +      mOk = JS_TRUE;\n\nmOk is uninitialized here if we don't hit this branch.\n\nAlso having mOk be true when there's an error seems a little backwards maybe?", "id": 5849083, "attachment_id": 571463, "text": "Comment on attachment 571463\nAgain, this time with betterness\n\nReview of attachment 571463:\n-----------------------------------------------------------------\n\n::: widget/src/xpwidgets/GfxInfoCollector.h\n@@ +79,5 @@\n> +  InfoObject(JSContext *aCx) : mCx(aCx)\n> +  {\n> +    mObj = JS_NewObject(mCx, NULL, NULL, NULL);\n> +    if (!mObj)\n> +      mOk = JS_TRUE;\n\nmOk is uninitialized here if we don't hit this branch.\n\nAlso having mOk be true when there's an error seems a little backwards maybe?", "creation_time": "2011-11-15T11:42:32Z"}, {"id": 5852176, "attachment_id": null, "text": "https://hg.mozilla.org/mozilla-central/rev/831f0b92c182\n\nTo save time/mistakes when merging, please could you set assignee + target milestone when landing on inbound (https://wiki.mozilla.org/Tree_Rules/Inbound#Please_do_the_following_after_pushing_to_inbound).\n\nThanks :-)", "creation_time": "2011-11-16T11:12:48Z", "is_private": false, "tags": [], "raw_text": "https://hg.mozilla.org/mozilla-central/rev/831f0b92c182\n\nTo save time/mistakes when merging, please could you set assignee + target milestone when landing on inbound (https://wiki.mozilla.org/Tree_Rules/Inbound#Please_do_the_following_after_pushing_to_inbound).\n\nThanks :-)", "creator": "emorley@mozilla.com", "author": "emorley@mozilla.com", "time": "2011-11-16T11:12:48Z", "bug_id": 651981, "count": 15}, {"time": "2011-11-16T13:00:11Z", "bug_id": 651981, "count": 16, "creator": "jacob.benoit.1@gmail.com", "author": "jacob.benoit.1@gmail.com", "tags": [], "is_private": false, "raw_text": "This is a tracking bug for all present and future GfxInfo problems; I suppose that the first problem was that we shouldn't have attached any patches to it, instead create blocking bugs.", "text": "This is a tracking bug for all present and future GfxInfo problems; I suppose that the first problem was that we shouldn't have attached any patches to it, instead create blocking bugs.", "id": 5852316, "attachment_id": null, "creation_time": "2011-11-16T13:00:11Z"}, {"author": "joe@drew.ca", "creator": "joe@drew.ca", "text": "I'm not entirely convinced about the utility of indefinite-life metabugs whose only purpose is to draw dependent bugs. Should we just close this and track everything separately--for example, using the status whiteboard?", "id": 5996794, "attachment_id": null, "creation_time": "2012-01-20T22:09:26Z", "tags": [], "is_private": false, "time": "2012-01-20T22:09:26Z", "count": 17, "bug_id": 651981, "raw_text": "I'm not entirely convinced about the utility of indefinite-life metabugs whose only purpose is to draw dependent bugs. Should we just close this and track everything separately--for example, using the status whiteboard?"}, {"creation_time": "2012-01-20T22:13:37Z", "creator": "jacob.benoit.1@gmail.com", "text": "I think that meta bugs are useful as long as they have useful still open blockers. In this case, this allowed me to find back bug 701948 which is still worth doing if it's not done already.\n\nstatus whiteboard? seems harder to agree on a whiteboard conventions etc. than the cost of keeping one bug around (though I understand that in the context of bugkill that cost seems higher).\n\nmaybe what we need is a refinement of bugkill query to omit tracking bugs? we can have a whiteboard/keyword to identify them.", "id": 5996807, "attachment_id": null, "author": "jacob.benoit.1@gmail.com", "bug_id": 651981, "raw_text": "I think that meta bugs are useful as long as they have useful still open blockers. In this case, this allowed me to find back bug 701948 which is still worth doing if it's not done already.\n\nstatus whiteboard? seems harder to agree on a whiteboard conventions etc. than the cost of keeping one bug around (though I understand that in the context of bugkill that cost seems higher).\n\nmaybe what we need is a refinement of bugkill query to omit tracking bugs? we can have a whiteboard/keyword to identify them.", "count": 18, "time": "2012-01-20T22:13:37Z", "tags": [], "is_private": false}]}}}