{"bugs": {"661752": {"comments": [{"raw_text": "Right now if a webpage access <input>.files[0].size we'll synchronously touch the disk on the main thread to figure out the size.  We can avoid this by pre-statting off the main thread and delaying onchange for files until those stats are done.\n\nWe create two new runnables here.  The first is the FileSizeGetter runnable that calls GetFileSize on the underlying nsIFile.  This is created from the constructor of the nsDOMFile and dispatched to the stream transport service's nsIEventTarget.  It takes an optional callback/closure which is used by:\n\nThe second is the FileOnChangeDispatcher runnable.  This is created by the AsyncOnClickHandler runnable and receives a callback from each FileSizeGetter runnable.  Once all callbacks are received it dispatches itself to the main thread and fires <input>.onchange (and sets <input.files>).\n\nThe tricky bits here are:\n\n1. FileSizeGetter does not hold the nsIDOMFile alive, so the File object revokes the FileSizeGetter in its dtor if the getter hasn't run yet.\n2. The FileOnChangeDispatcher has to remember if any of the FileSizeGetters were revoked.  The callback from FileSizeGetter must still be dispatched (otherwise the FileOnChangeDispatcher will leak) but the FileOnChangeDispatcher must not fire events at the page.\n3. The count of waiting callbacks in FileOnChangeDispatcher can go negative if some FileSizeGetters complete while the AsyncOnClickHandler is still running.  We handle this OK since we only increase the count once, so we can't prematurely hit 0.\n4. If we end up in File.size before the FileSizeGetter completes, we run the getter synchronously on the main thread.  This won't happen for <input>.file, but I couldn't convince myself that we won't end up in File.size early with one of the other ways that Files are created, so I added this.\n\nJonas told me to request review from bent since there are threads involved :-)", "attachment_id": 537070, "tags": [], "text": "Created attachment 537070\nPatch\n\nRight now if a webpage access <input>.files[0].size we'll synchronously touch the disk on the main thread to figure out the size.  We can avoid this by pre-statting off the main thread and delaying onchange for files until those stats are done.\n\nWe create two new runnables here.  The first is the FileSizeGetter runnable that calls GetFileSize on the underlying nsIFile.  This is created from the constructor of the nsDOMFile and dispatched to the stream transport service's nsIEventTarget.  It takes an optional callback/closure which is used by:\n\nThe second is the FileOnChangeDispatcher runnable.  This is created by the AsyncOnClickHandler runnable and receives a callback from each FileSizeGetter runnable.  Once all callbacks are received it dispatches itself to the main thread and fires <input>.onchange (and sets <input.files>).\n\nThe tricky bits here are:\n\n1. FileSizeGetter does not hold the nsIDOMFile alive, so the File object revokes the FileSizeGetter in its dtor if the getter hasn't run yet.\n2. The FileOnChangeDispatcher has to remember if any of the FileSizeGetters were revoked.  The callback from FileSizeGetter must still be dispatched (otherwise the FileOnChangeDispatcher will leak) but the FileOnChangeDispatcher must not fire events at the page.\n3. The count of waiting callbacks in FileOnChangeDispatcher can go negative if some FileSizeGetters complete while the AsyncOnClickHandler is still running.  We handle this OK since we only increase the count once, so we can't prematurely hit 0.\n4. If we end up in File.size before the FileSizeGetter completes, we run the getter synchronously on the main thread.  This won't happen for <input>.file, but I couldn't convince myself that we won't end up in File.size early with one of the other ways that Files are created, so I added this.\n\nJonas told me to request review from bent since there are threads involved :-)", "bug_id": 661752, "is_private": false, "id": 5510322, "count": 0, "author": "khuey@kylehuey.com", "creator": "khuey@kylehuey.com", "creation_time": "2011-06-03T03:54:01Z", "time": "2011-06-03T03:54:01Z"}, {"attachment_id": 537073, "raw_text": "This is totally a micro-optimization, but it's easy enough to do.", "bug_id": 661752, "text": "Created attachment 537073\nAdd nsRevocableEventPtr.swap()\n\nThis is totally a micro-optimization, but it's easy enough to do.", "tags": [], "count": 1, "id": 5510332, "is_private": false, "creation_time": "2011-06-03T04:06:50Z", "time": "2011-06-03T04:06:50Z", "creator": "khuey@kylehuey.com", "author": "khuey@kylehuey.com"}, {"author": "bent.mozilla@gmail.com", "creator": "bent.mozilla@gmail.com", "creation_time": "2011-06-05T19:31:36Z", "time": "2011-06-05T19:31:36Z", "is_private": false, "id": 5514222, "count": 2, "bug_id": 661752, "text": "Comment on attachment 537070\nPatch\n\nDiscussed with Kyle over IRC, he's going to attempt to make this simpler (and lockless) by holding the nsIDOMFile alive while figuring out its size.", "tags": [], "raw_text": "Discussed with Kyle over IRC, he's going to attempt to make this simpler (and lockless) by holding the nsIDOMFile alive while figuring out its size.", "attachment_id": 537070}, {"tags": [], "bug_id": 661752, "text": "Created attachment 586045\nPatch\n\nNow with no locking.", "raw_text": "Now with no locking.", "attachment_id": 586045, "author": "khuey@kylehuey.com", "creation_time": "2012-01-05T13:24:41Z", "time": "2012-01-05T13:24:41Z", "creator": "khuey@kylehuey.com", "count": 3, "id": 5956863, "is_private": false}, {"attachment_id": 586045, "raw_text": "Review of attachment 586045:\n-----------------------------------------------------------------\n\n::: content/base/public/nsDOMFile.h\n@@ +236,5 @@\n> +  // off the main thread but on the same thread.\n> +  nsresult PreStat(StatDoneCallback aCallback, void* aClosure);\n> +\n> +private:\n> +\n\nNit: Nuke extra newline.\n\n::: content/base/src/nsDOMFile.cpp\n@@ +153,5 @@\n> +  if (!gDOMFileIOThread) {\n> +    gDOMFileIOThread = new LazyIdleThread(DEFAULT_THREAD_TIMEOUT_MS,\n> +                                          LazyIdleThread::AutomaticShutdown);\n> +\n> +    ClearOnShutdown(&gDOMFileIOThread);\n\nHm, this is weird. The thing is ClearOnShutdown happens after threads are already shut down. I think we should figure out a better way to do this.\n\n::: content/html/content/src/nsHTMLInputElement.cpp\n@@ +237,5 @@\n>  \n>  NS_IMPL_ISUPPORTS1(nsHTMLInputElementState, nsHTMLInputElementState)\n>  NS_DEFINE_STATIC_IID_ACCESSOR(nsHTMLInputElementState, NS_INPUT_ELEMENT_STATE_IID)\n>  \n> +class FileOnChangeDispatcher : public nsRunnable {\n\nNit: { on its own line.\n\n@@ +279,5 @@\n> +\n> +  NS_IMETHOD Run();\n> +\n> +protected:\n> +  nsCOMArray<nsIDOMFile> mFiles;\n\nEw. Please replace with nsTArray\n\n@@ +299,5 @@\n> +  mFilesRemaining = aFiles.Length();\n> +  NS_ASSERTION(mFilesRemaining, \"Don't call me if you have no files!\");\n> +\n> +  // stat our files in the background and dispatch when we're done.\n> +  nsresult rv = NS_OK;\n\nYou're not really using this, remove and just do |if (NS_FAILED(file->PreStat(...)))| below.\n\n@@ +308,5 @@\n> +    if (NS_FAILED(rv)) {\n> +      // NB: We may have already dispatched some runnables.  Some of them may\n> +      // have even completed already.  Go ahead and dispatch synchronously,\n> +      // noting that we can't dispatch twice because the number of runnables\n> +      // we dispatched is less than mFilesRemaining.\n\nThis seems like something we should warn about.\n\n@@ +332,5 @@\n> +FileOnChangeDispatcher::Run()\n> +{\n> +  NS_ASSERTION(NS_IsMainThread(), \"Wrong thread!\");\n> +\n> +  NS_RELEASE_THIS(); // We are held alive by our caller.\n\nThis doesn't seem safe. What if this is the last reference?\n\n@@ +343,5 @@\n> +  mInput->mFileOnChangeDispatcher = nsnull;\n> +\n> +  mInput->SetFiles(mFiles, true);\n> +  nsContentUtils::DispatchTrustedEvent(mInput->OwnerDoc(),\n> +                                       static_cast<nsIDOMHTMLInputElement*>(mInput.get()),\n\nIs this cast needed? What happens if the cast doesn't equal the result you would get if you tried to QI to nsIDOMHTMLInputElement?", "bug_id": 661752, "text": "Comment on attachment 586045\nPatch\n\nReview of attachment 586045:\n-----------------------------------------------------------------\n\n::: content/base/public/nsDOMFile.h\n@@ +236,5 @@\n> +  // off the main thread but on the same thread.\n> +  nsresult PreStat(StatDoneCallback aCallback, void* aClosure);\n> +\n> +private:\n> +\n\nNit: Nuke extra newline.\n\n::: content/base/src/nsDOMFile.cpp\n@@ +153,5 @@\n> +  if (!gDOMFileIOThread) {\n> +    gDOMFileIOThread = new LazyIdleThread(DEFAULT_THREAD_TIMEOUT_MS,\n> +                                          LazyIdleThread::AutomaticShutdown);\n> +\n> +    ClearOnShutdown(&gDOMFileIOThread);\n\nHm, this is weird. The thing is ClearOnShutdown happens after threads are already shut down. I think we should figure out a better way to do this.\n\n::: content/html/content/src/nsHTMLInputElement.cpp\n@@ +237,5 @@\n>  \n>  NS_IMPL_ISUPPORTS1(nsHTMLInputElementState, nsHTMLInputElementState)\n>  NS_DEFINE_STATIC_IID_ACCESSOR(nsHTMLInputElementState, NS_INPUT_ELEMENT_STATE_IID)\n>  \n> +class FileOnChangeDispatcher : public nsRunnable {\n\nNit: { on its own line.\n\n@@ +279,5 @@\n> +\n> +  NS_IMETHOD Run();\n> +\n> +protected:\n> +  nsCOMArray<nsIDOMFile> mFiles;\n\nEw. Please replace with nsTArray\n\n@@ +299,5 @@\n> +  mFilesRemaining = aFiles.Length();\n> +  NS_ASSERTION(mFilesRemaining, \"Don't call me if you have no files!\");\n> +\n> +  // stat our files in the background and dispatch when we're done.\n> +  nsresult rv = NS_OK;\n\nYou're not really using this, remove and just do |if (NS_FAILED(file->PreStat(...)))| below.\n\n@@ +308,5 @@\n> +    if (NS_FAILED(rv)) {\n> +      // NB: We may have already dispatched some runnables.  Some of them may\n> +      // have even completed already.  Go ahead and dispatch synchronously,\n> +      // noting that we can't dispatch twice because the number of runnables\n> +      // we dispatched is less than mFilesRemaining.\n\nThis seems like something we should warn about.\n\n@@ +332,5 @@\n> +FileOnChangeDispatcher::Run()\n> +{\n> +  NS_ASSERTION(NS_IsMainThread(), \"Wrong thread!\");\n> +\n> +  NS_RELEASE_THIS(); // We are held alive by our caller.\n\nThis doesn't seem safe. What if this is the last reference?\n\n@@ +343,5 @@\n> +  mInput->mFileOnChangeDispatcher = nsnull;\n> +\n> +  mInput->SetFiles(mFiles, true);\n> +  nsContentUtils::DispatchTrustedEvent(mInput->OwnerDoc(),\n> +                                       static_cast<nsIDOMHTMLInputElement*>(mInput.get()),\n\nIs this cast needed? What happens if the cast doesn't equal the result you would get if you tried to QI to nsIDOMHTMLInputElement?", "tags": [], "count": 4, "id": 6096799, "is_private": false, "time": "2012-02-27T21:44:29Z", "creation_time": "2012-02-27T21:44:29Z", "creator": "bent.mozilla@gmail.com", "author": "bent.mozilla@gmail.com"}, {"raw_text": "I think we discussed a different way to do this.", "attachment_id": 586045, "text": "Comment on attachment 586045\nPatch\n\nI think we discussed a different way to do this.", "bug_id": 661752, "tags": [], "is_private": false, "id": 6131248, "count": 5, "author": "bent.mozilla@gmail.com", "creator": "bent.mozilla@gmail.com", "time": "2012-03-11T23:27:06Z", "creation_time": "2012-03-11T23:27:06Z"}]}}, "comments": {}}