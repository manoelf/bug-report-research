{"bugs": {"683240": {"comments": [{"creation_time": "2011-08-30T18:46:32Z", "author": "ehsan.akhgari@gmail.com", "text": "From an email conversation with roc:\n\n\"There is another systematic fix that I'd very much like to do: annotate functions that can internally run script/perform restyling, with static analysis to verify the consistency of the annotations and do some other checks that frame pointers aren't used across potential script-running points. This would be useful for a lot more than just dead-frame issues.\"", "tags": [], "bug_id": 683240, "time": "2011-08-30T18:46:32Z", "is_private": false, "creator": "ehsan.akhgari@gmail.com", "count": 0, "id": 5688446, "attachment_id": null, "raw_text": "From an email conversation with roc:\n\n\"There is another systematic fix that I'd very much like to do: annotate functions that can internally run script/perform restyling, with static analysis to verify the consistency of the annotations and do some other checks that frame pointers aren't used across potential script-running points. This would be useful for a lot more than just dead-frame issues.\""}, {"creator": "taras.mozilla@glek.net", "is_private": false, "count": 1, "author": "taras.mozilla@glek.net", "creation_time": "2011-08-30T18:50:19Z", "tags": [], "time": "2011-08-30T18:50:19Z", "bug_id": 683240, "text": "Brian, is sixgill well-suited for this?", "attachment_id": null, "raw_text": "Brian, is sixgill well-suited for this?", "id": 5688464}, {"is_private": false, "creator": "bhackett1024@gmail.com", "count": 2, "creation_time": "2011-08-30T19:12:33Z", "author": "bhackett1024@gmail.com", "text": "Without knowing the details, this sounds a lot like the moving-GC liveness problem I've used sixgill for.  (Nothing actively being worked on right now, but I want to use this analysis to migrate off the conservative GC and onto an exact one, no timeframe).\n\nThe problem there is determining whether a pointer to a GC thing is held live across a call which can trigger a GC.  This requires the analysis to find transitive callers of GC, and then do the liveness analysis on dereferences and copies of values of specific types.  sixgill is very good at these tasks, reports at sixgill.m.o.\n\nThe main pitfall I see is that we would need an accurate callgraph for the browser.  sixgill handles indirect calls, but the information surrounding calls through interface pointers is just so terrible (every call looks like it's calling every possible callee) that all these call edges get suppressed.  This would need to be fixed to correctly propagate information about interface calls that can run script or perform restyling.", "tags": [], "bug_id": 683240, "time": "2011-08-30T19:12:33Z", "attachment_id": null, "raw_text": "Without knowing the details, this sounds a lot like the moving-GC liveness problem I've used sixgill for.  (Nothing actively being worked on right now, but I want to use this analysis to migrate off the conservative GC and onto an exact one, no timeframe).\n\nThe problem there is determining whether a pointer to a GC thing is held live across a call which can trigger a GC.  This requires the analysis to find transitive callers of GC, and then do the liveness analysis on dereferences and copies of values of specific types.  sixgill is very good at these tasks, reports at sixgill.m.o.\n\nThe main pitfall I see is that we would need an accurate callgraph for the browser.  sixgill handles indirect calls, but the information surrounding calls through interface pointers is just so terrible (every call looks like it's calling every possible callee) that all these call edges get suppressed.  This would need to be fixed to correctly propagate information about interface calls that can run script or perform restyling.", "id": 5688532}, {"creator": "Pidgeot18@gmail.com", "is_private": false, "count": 3, "author": "Pidgeot18@gmail.com", "creation_time": "2011-08-30T19:24:16Z", "time": "2011-08-30T19:24:16Z", "tags": [], "bug_id": 683240, "text": "(In reply to Brian Hackett from comment #2)\n> The main pitfall I see is that we would need an accurate callgraph for the\n> browser.  sixgill handles indirect calls, but the information surrounding\n> calls through interface pointers is just so terrible (every call looks like\n> it's calling every possible callee) that all these call edges get\n> suppressed.  This would need to be fixed to correctly propagate information\n> about interface calls that can run script or perform restyling.\n\nI don't know how sixgill is working, but I would suspect that you could use type information to get the data (i.e., nsIFoo *bar; bar->Foo(); would only call the Foo method of anything that inherits nsIFoo). If you want a more complete callgraph, any method that is marked NS_SCRIPTABLE (in C++-land) that is not on a [builtinclass] interface can wind up calling the magic in nsIXPTProxyStub.", "attachment_id": null, "raw_text": "(In reply to Brian Hackett from comment #2)\n> The main pitfall I see is that we would need an accurate callgraph for the\n> browser.  sixgill handles indirect calls, but the information surrounding\n> calls through interface pointers is just so terrible (every call looks like\n> it's calling every possible callee) that all these call edges get\n> suppressed.  This would need to be fixed to correctly propagate information\n> about interface calls that can run script or perform restyling.\n\nI don't know how sixgill is working, but I would suspect that you could use type information to get the data (i.e., nsIFoo *bar; bar->Foo(); would only call the Foo method of anything that inherits nsIFoo). If you want a more complete callgraph, any method that is marked NS_SCRIPTABLE (in C++-land) that is not on a [builtinclass] interface can wind up calling the magic in nsIXPTProxyStub.", "id": 5688573}]}}, "comments": {}}