{"bugs": {"664840": {"comments": [{"text": "User-Agent:       Mozilla/5.0 (X11; U; Linux x86_64; en-US; rv:1.9.2.17) Gecko/20110421 Red Hat/3.6.17-1.el6_0 Firefox/3.6.17\nBuild Identifier: \n\nI want this for my embeddding; when I get a C data type unsigned char* + size_t len, to convert it to a native Uint8Array.\n\nReproducible: Always", "bug_id": 664840, "tags": [], "attachment_id": null, "raw_text": "User-Agent:       Mozilla/5.0 (X11; U; Linux x86_64; en-US; rv:1.9.2.17) Gecko/20110421 Red Hat/3.6.17-1.el6_0 Firefox/3.6.17\nBuild Identifier: \n\nI want this for my embeddding; when I get a C data type unsigned char* + size_t len, to convert it to a native Uint8Array.\n\nReproducible: Always", "creation_time": "2011-06-16T21:26:52Z", "time": "2011-06-16T21:26:52Z", "creator": "walters@verbum.org", "author": "walters@verbum.org", "id": 5537778, "count": 0, "is_private": false}, {"bug_id": 664840, "text": "I propose this interface:\n\n/*\n * Creates a new typed array of the specified kind with the given length.\n * The array's contents are either zeroed or filled with the values in vals,\n * if vals is non-null.  The array will be created using the appropriate\n * constructor from the provided global object.\n */\nJSBool JS_NewUint8Array(JSContext* cx, const uint8_t* vals, size_t length, JSObject* global);\n// ...and the others\n\nWe should have separate methods for each kind of typed array, partly because vals should be a type specific to the typed array kind, partly because it's nicer having methods to do things than to have an enum or something, and partly because in JS it's \"new Uint8Array(...)\" and not \"new TypedArray(TypedArray.UINT8, ...)\".  We should have an explicit global object argument (which is asserted to be a global object -- we want to avoid entrenching the requirement that all objects have parents, or muddying the waters by making users learn what objects will and won't have them) to be clearer about what global object is used to create the typed array -- a change that we should gradually make to the rest of our APIs, for the same reason.  (See also bug 631135.)", "tags": [], "attachment_id": null, "raw_text": "I propose this interface:\n\n/*\n * Creates a new typed array of the specified kind with the given length.\n * The array's contents are either zeroed or filled with the values in vals,\n * if vals is non-null.  The array will be created using the appropriate\n * constructor from the provided global object.\n */\nJSBool JS_NewUint8Array(JSContext* cx, const uint8_t* vals, size_t length, JSObject* global);\n// ...and the others\n\nWe should have separate methods for each kind of typed array, partly because vals should be a type specific to the typed array kind, partly because it's nicer having methods to do things than to have an enum or something, and partly because in JS it's \"new Uint8Array(...)\" and not \"new TypedArray(TypedArray.UINT8, ...)\".  We should have an explicit global object argument (which is asserted to be a global object -- we want to avoid entrenching the requirement that all objects have parents, or muddying the waters by making users learn what objects will and won't have them) to be clearer about what global object is used to create the typed array -- a change that we should gradually make to the rest of our APIs, for the same reason.  (See also bug 631135.)", "creator": "jwalden@mit.edu", "time": "2011-06-16T22:31:25Z", "creation_time": "2011-06-16T22:31:25Z", "author": "jwalden@mit.edu", "is_private": false, "count": 1, "id": 5538005}, {"raw_text": "(In reply to comment #1)\n>\n> We should have separate methods for each kind of typed array, partly because\n> vals should be a type specific to the typed array kind, partly because it's\n> nicer having methods to do things than to have an enum or something, \n\nHmm.  So I hadn't seen this comment when I decided to spend a few minutes on adding the API.  Now, honestly I think I prefer the enum.  There are 8 different kinds of arrays - that's a lot of C API.  I could be convinced otherwise though...\n\n> We should have an explicit global\n> object argument (which is asserted to be a global object -- we want to avoid\n> entrenching the requirement that all objects have parents, or muddying the\n> waters by making users learn what objects will and won't have them)\n\nI'm uncertain about this.  I'll happily do it if that's the rough consensus, but it's different than all the current JSAPI, right?  It seems like a clearer here-to-there path is something like:\n\nJS_PushGlobalObject(JSContext *cx, JSObject *global);\n...\ncall JS_NewObject()  or JS_NewArrayObject() or JS_NewTypedArrayObject()\n...\nJS_PopGlobalObject(JSContext *cx, JSObject *global);", "attachment_id": null, "bug_id": 664840, "text": "(In reply to comment #1)\n>\n> We should have separate methods for each kind of typed array, partly because\n> vals should be a type specific to the typed array kind, partly because it's\n> nicer having methods to do things than to have an enum or something, \n\nHmm.  So I hadn't seen this comment when I decided to spend a few minutes on adding the API.  Now, honestly I think I prefer the enum.  There are 8 different kinds of arrays - that's a lot of C API.  I could be convinced otherwise though...\n\n> We should have an explicit global\n> object argument (which is asserted to be a global object -- we want to avoid\n> entrenching the requirement that all objects have parents, or muddying the\n> waters by making users learn what objects will and won't have them)\n\nI'm uncertain about this.  I'll happily do it if that's the rough consensus, but it's different than all the current JSAPI, right?  It seems like a clearer here-to-there path is something like:\n\nJS_PushGlobalObject(JSContext *cx, JSObject *global);\n...\ncall JS_NewObject()  or JS_NewArrayObject() or JS_NewTypedArrayObject()\n...\nJS_PopGlobalObject(JSContext *cx, JSObject *global);", "tags": [], "is_private": false, "count": 2, "id": 5544405, "author": "walters@verbum.org", "creator": "walters@verbum.org", "time": "2011-06-21T01:44:24Z", "creation_time": "2011-06-21T01:44:24Z"}, {"author": "walters@verbum.org", "bug_id": 664840, "text": "Created attachment 540651\nadd public JSAPI for typed arrays\n\nThis patch is generated with git against https://github.com/doublec/mozilla-central\n\nI can redo it to be hg if desired (it's just that git is really better).", "tags": [], "creator": "walters@verbum.org", "time": "2011-06-21T01:46:22Z", "creation_time": "2011-06-21T01:46:22Z", "raw_text": "This patch is generated with git against https://github.com/doublec/mozilla-central\n\nI can redo it to be hg if desired (it's just that git is really better).", "attachment_id": 540651, "is_private": false, "id": 5544407, "count": 3}, {"text": "Comment on attachment 540651\nadd public JSAPI for typed arrays\n\nPosting patches without soliciting review generally doesn't work, just a note for the future.  :-)  I'll take a look at this shortly.\n\n(The must-request-from-a-person system is not so great, admittedly.  Mozilla's thought about ways to improve it but hasn't had any obviously great ideas yet.)", "bug_id": 664840, "tags": [], "raw_text": "Posting patches without soliciting review generally doesn't work, just a note for the future.  :-)  I'll take a look at this shortly.\n\n(The must-request-from-a-person system is not so great, admittedly.  Mozilla's thought about ways to improve it but hasn't had any obviously great ideas yet.)", "attachment_id": 540651, "author": "jwalden@mit.edu", "creator": "jwalden@mit.edu", "creation_time": "2011-07-08T02:14:10Z", "time": "2011-07-08T02:14:10Z", "is_private": false, "count": 4, "id": 5580152}, {"author": "jwalden@mit.edu", "creator": "jwalden@mit.edu", "time": "2011-07-12T02:03:20Z", "creation_time": "2011-07-12T02:03:20Z", "is_private": false, "id": 5585869, "count": 5, "tags": [], "bug_id": 664840, "text": "Comment on attachment 540651\nadd public JSAPI for typed arrays\n\nReview of attachment 540651:\n-----------------------------------------------------------------\n\nThis should be enough feedback for further discussion, noodling, etc.\n\nHm, yeah, I guess the push/pop thing is the direction we're moving (although we're likely to do it via JS_BeginRequest and JS_EndRequest), so ignore that consideration.\n\nIf there's no JS_IsArrayBuffer method now (or if it's friendy), there needs to be, in order for users of these methods to be able to safely use them in general.\n\n::: js/src/jsapi.cpp\n@@ +4090,5 @@\n>  }\n>  \n> +JS_PUBLIC_API(JSObject *)\n> +JS_NewArrayBuffer(JSContext *cx, jsint js_length,\n> +                  void *source, jsuint source_len)\n\nNot sure if you're aware, but line limit is 99ch now, and this fits.\n\n@@ +4093,5 @@\n> +JS_NewArrayBuffer(JSContext *cx, jsint js_length,\n> +                  void *source, jsuint source_len)\n> +{\n> +    JSObject *obj;\n> +    CHECK_REQUEST(cx);\n\nThese days we use C++-style delay-declaration-as-long-as-possible.\n\n@@ +4097,5 @@\n> +    CHECK_REQUEST(cx);\n> +\n> +    obj = js_CreateArrayBuffer(cx, js_length);\n> +    if (obj != NULL && source != NULL)\n> +        js_SetArrayBufferContents(cx, obj, 0, source_len, source);\n\nif (obj) {\n    if (source)\n        ...;\n}\n\n@@ +4118,5 @@\n> +    CHECK_REQUEST(cx);\n> +\n> +    JS_ASSERT(kind >= TypedArray::TYPE_INT8 && kind <= TypedArray::TYPE_FLOAT64);\n> +\n> +    return js_CreateTypedArrayWithBuffer(cx, type, buffer, byteoffset, js_length);\n\nPart of the reason to have eight different methods here rather than keying on an enum is that, if you look at js_CreateTypedArrayWithBuffer, you'll see it calls a method which then proceeds to un-fork this into calls to a bunch of different methods.  It seems better to me to have one method for the preliminary setup in those methods, then have each of the eight call the specific Int8Array::create, etc. appropriate for it.  (Incidentally, js_CreateTypedArrayWithBuffer is dead code right now; wonder how many other methods we have that are friend-ish that are dead code...)\n\n::: js/src/jsapi.h\n@@ +2475,5 @@\n> +} JSTypedArrayKind;\n> +\n> +\n> +extern JS_PUBLIC_API(JSObject *)\n> +JS_NewArrayBuffer(JSContext *cx, jsint js_length, void *source, jsuint source_len);\n\nWhat is the use case for specifying a length for the created ArrayBuffer, and a separate length for the bytes to copy into it?\n\nIt seems best for |source| to be |uint8*|, and for |source_len| to be |size_t|.\n\n@@ +2478,5 @@\n> +extern JS_PUBLIC_API(JSObject *)\n> +JS_NewArrayBuffer(JSContext *cx, jsint js_length, void *source, jsuint source_len);\n> +\n> +extern JS_PUBLIC_API(void *)\n> +JS_GetArrayBufferContents(JSContext *cx, JSObject *buffer);\n\nIt seems to me this should also take a |size_t*| and initialize it to the length of the ArrayBuffer.  I wouldn't necessarily assume every user of this would always know the buffer's length.  Also, it should return |uint8*|.  |void*| forces everyone to cast, but I can well imagine code using this specifically for its ability to store bytes, in which case using |uint8*| for all this would avoid making such code perform pointless casts.\n\n::: js/src/jstypedarray.cpp\n@@ +1628,5 @@\n>      return ArrayBuffer::create(cx, nbytes);\n>  }\n>  \n> +// Note: No synchronization is performed with any consumers of the\n> +// buffer.  This function is best used immediately after construction.\n\nSpiderMonkey objects in general are no longer threadsafe, so there shouldn't be any synchronization worries here, at least not unless it's through some sort of cross-compartment-and-thread wrapper, which would not concern itself with this method, because it'd be locking at a higher level.\n\n::: js/src/jstypedarray.h\n@@ +197,5 @@\n>  JS_FRIEND_API(JSObject *)\n>  js_CreateArrayBuffer(JSContext *cx, jsuint nbytes);\n>  \n> +JS_FRIEND_API(void)\n> +js_SetArrayBufferContents(JSContext *cx, JSObject *buf, jsuint offset, jsuint nbytes, void *contents);\n\nI think this should be a public API:\n\nJS_FillArrayBuffer(JSContext *cx, JSObject *buf, jsuint offset, uint8 *src, size_t nbytes)\n\nJS_ReadBytes, JS_WriteBytes, JS_realloc, etc. suggest inversion of the order of contents and nbytes.  And contents should be src, following naming for the JS_Encode* and JS_Decode* methods.  (And I guess nbytes should then be srclen?)", "raw_text": "Review of attachment 540651:\n-----------------------------------------------------------------\n\nThis should be enough feedback for further discussion, noodling, etc.\n\nHm, yeah, I guess the push/pop thing is the direction we're moving (although we're likely to do it via JS_BeginRequest and JS_EndRequest), so ignore that consideration.\n\nIf there's no JS_IsArrayBuffer method now (or if it's friendy), there needs to be, in order for users of these methods to be able to safely use them in general.\n\n::: js/src/jsapi.cpp\n@@ +4090,5 @@\n>  }\n>  \n> +JS_PUBLIC_API(JSObject *)\n> +JS_NewArrayBuffer(JSContext *cx, jsint js_length,\n> +                  void *source, jsuint source_len)\n\nNot sure if you're aware, but line limit is 99ch now, and this fits.\n\n@@ +4093,5 @@\n> +JS_NewArrayBuffer(JSContext *cx, jsint js_length,\n> +                  void *source, jsuint source_len)\n> +{\n> +    JSObject *obj;\n> +    CHECK_REQUEST(cx);\n\nThese days we use C++-style delay-declaration-as-long-as-possible.\n\n@@ +4097,5 @@\n> +    CHECK_REQUEST(cx);\n> +\n> +    obj = js_CreateArrayBuffer(cx, js_length);\n> +    if (obj != NULL && source != NULL)\n> +        js_SetArrayBufferContents(cx, obj, 0, source_len, source);\n\nif (obj) {\n    if (source)\n        ...;\n}\n\n@@ +4118,5 @@\n> +    CHECK_REQUEST(cx);\n> +\n> +    JS_ASSERT(kind >= TypedArray::TYPE_INT8 && kind <= TypedArray::TYPE_FLOAT64);\n> +\n> +    return js_CreateTypedArrayWithBuffer(cx, type, buffer, byteoffset, js_length);\n\nPart of the reason to have eight different methods here rather than keying on an enum is that, if you look at js_CreateTypedArrayWithBuffer, you'll see it calls a method which then proceeds to un-fork this into calls to a bunch of different methods.  It seems better to me to have one method for the preliminary setup in those methods, then have each of the eight call the specific Int8Array::create, etc. appropriate for it.  (Incidentally, js_CreateTypedArrayWithBuffer is dead code right now; wonder how many other methods we have that are friend-ish that are dead code...)\n\n::: js/src/jsapi.h\n@@ +2475,5 @@\n> +} JSTypedArrayKind;\n> +\n> +\n> +extern JS_PUBLIC_API(JSObject *)\n> +JS_NewArrayBuffer(JSContext *cx, jsint js_length, void *source, jsuint source_len);\n\nWhat is the use case for specifying a length for the created ArrayBuffer, and a separate length for the bytes to copy into it?\n\nIt seems best for |source| to be |uint8*|, and for |source_len| to be |size_t|.\n\n@@ +2478,5 @@\n> +extern JS_PUBLIC_API(JSObject *)\n> +JS_NewArrayBuffer(JSContext *cx, jsint js_length, void *source, jsuint source_len);\n> +\n> +extern JS_PUBLIC_API(void *)\n> +JS_GetArrayBufferContents(JSContext *cx, JSObject *buffer);\n\nIt seems to me this should also take a |size_t*| and initialize it to the length of the ArrayBuffer.  I wouldn't necessarily assume every user of this would always know the buffer's length.  Also, it should return |uint8*|.  |void*| forces everyone to cast, but I can well imagine code using this specifically for its ability to store bytes, in which case using |uint8*| for all this would avoid making such code perform pointless casts.\n\n::: js/src/jstypedarray.cpp\n@@ +1628,5 @@\n>      return ArrayBuffer::create(cx, nbytes);\n>  }\n>  \n> +// Note: No synchronization is performed with any consumers of the\n> +// buffer.  This function is best used immediately after construction.\n\nSpiderMonkey objects in general are no longer threadsafe, so there shouldn't be any synchronization worries here, at least not unless it's through some sort of cross-compartment-and-thread wrapper, which would not concern itself with this method, because it'd be locking at a higher level.\n\n::: js/src/jstypedarray.h\n@@ +197,5 @@\n>  JS_FRIEND_API(JSObject *)\n>  js_CreateArrayBuffer(JSContext *cx, jsuint nbytes);\n>  \n> +JS_FRIEND_API(void)\n> +js_SetArrayBufferContents(JSContext *cx, JSObject *buf, jsuint offset, jsuint nbytes, void *contents);\n\nI think this should be a public API:\n\nJS_FillArrayBuffer(JSContext *cx, JSObject *buf, jsuint offset, uint8 *src, size_t nbytes)\n\nJS_ReadBytes, JS_WriteBytes, JS_realloc, etc. suggest inversion of the order of contents and nbytes.  And contents should be src, following naming for the JS_Encode* and JS_Decode* methods.  (And I guess nbytes should then be srclen?)", "attachment_id": 540651}]}}, "comments": {}}