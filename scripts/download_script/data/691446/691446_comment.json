{"comments": {}, "bugs": {"691446": {"comments": [{"creator": "soubok@gmail.com", "author": "soubok@gmail.com", "bug_id": 691446, "is_private": false, "count": 0, "tags": [], "id": 5754837, "text": "I need to create a new TypedArray from a buffer already allocated with JS_malloc.\nThe aim is to avoid useless buffer copy.", "attachment_id": null, "time": "2011-10-03T19:02:51Z", "raw_text": "I need to create a new TypedArray from a buffer already allocated with JS_malloc.\nThe aim is to avoid useless buffer copy.", "creation_time": "2011-10-03T19:02:51Z"}, {"tags": [], "count": 1, "is_private": false, "id": 5755184, "bug_id": 691446, "raw_text": "Needs tests if we think this is a good idea.", "creation_time": "2011-10-03T20:33:33Z", "creator": "cdleary@acm.org", "text": "Created attachment 564312\nBuffer stealing API.\n\nNeeds tests if we think this is a good idea.", "author": "cdleary@acm.org", "attachment_id": 564312, "time": "2011-10-03T20:33:33Z"}, {"author": "cdleary@acm.org", "creator": "cdleary@acm.org", "creation_time": "2011-10-03T21:06:08Z", "raw_text": "qref", "attachment_id": 564321, "time": "2011-10-03T21:06:08Z", "text": "Created attachment 564321\nWIP: buffer stealing API.\n\nqref", "id": 5755318, "count": 2, "is_private": false, "tags": [], "bug_id": 691446}, {"creator": "cdleary@acm.org", "author": "cdleary@acm.org", "text": "Franck, this is definitely an implementation-detail API that would only exist for performance reasons and could totally break in the future. (In retrospect, I should have made it a JS_FRIEND_API.)\n\nOur internal implementation for the ArrayBuffer's backing store is a js::Value-modulo sized array buffer where the uint32 at the front of the buffer is the length of the array (per the comments on the API function). If you have to move all the values in order to stick the uint32 in front, you won't really be avoiding much overhead. Does this work for your use case?", "attachment_id": null, "time": "2011-10-03T21:10:12Z", "raw_text": "Franck, this is definitely an implementation-detail API that would only exist for performance reasons and could totally break in the future. (In retrospect, I should have made it a JS_FRIEND_API.)\n\nOur internal implementation for the ArrayBuffer's backing store is a js::Value-modulo sized array buffer where the uint32 at the front of the buffer is the length of the array (per the comments on the API function). If you have to move all the values in order to stick the uint32 in front, you won't really be avoiding much overhead. Does this work for your use case?", "creation_time": "2011-10-03T21:10:12Z", "bug_id": 691446, "tags": [], "count": 3, "is_private": false, "id": 5755333}, {"bug_id": 691446, "count": 4, "is_private": false, "tags": [], "id": 5755695, "text": "(In reply to Franck from comment #0)\n> I need to create a new TypedArray from a buffer already allocated with\n> JS_malloc.\n> The aim is to avoid useless buffer copy.\n\nWhy not do it the other way around?\n\n\"I need to be able to access the buffer from an already allocated TypedArray.\"\n\nThat can be much more future-proof, I think.  If we don't have this API (I seem to recall a bug on it awhile back), we should add it.", "attachment_id": null, "time": "2011-10-03T22:48:10Z", "raw_text": "(In reply to Franck from comment #0)\n> I need to create a new TypedArray from a buffer already allocated with\n> JS_malloc.\n> The aim is to avoid useless buffer copy.\n\nWhy not do it the other way around?\n\n\"I need to be able to access the buffer from an already allocated TypedArray.\"\n\nThat can be much more future-proof, I think.  If we don't have this API (I seem to recall a bug on it awhile back), we should add it.", "creation_time": "2011-10-03T22:48:10Z", "creator": "jwalden@mit.edu", "author": "jwalden@mit.edu"}, {"text": "My use case is quite simple:\nAmong other, I have a socket.Read() function that reads an undefined amount of data in a byte buffer (JS_malloc/JS_realloc).\nThis buffer is wrapped with a Blob JSObject and returned from socket.Read()\nThen the user can get a string version or a TypedArray version (or whatever version) of the buffer through the Blob object (after that, the Blob object become invalidated).\n\n1/ The first proposition from Chris Leary means that the Socket.Read() will need to reserve a uint32 at the front of its buffer even if the string version will be used later.\n\n2/ The proposition from Jeff Walden means that the TypedArray needs to be created, even if it will not be used.\n\nMaybe, and If the TypedArray allow to be resized (like realloc), I will be able to replace my Blob with a TypeArray,\nand create an new ExternalString that points to the begining of TypeArray buffer ?", "time": "2011-10-04T11:28:58Z", "attachment_id": null, "raw_text": "My use case is quite simple:\nAmong other, I have a socket.Read() function that reads an undefined amount of data in a byte buffer (JS_malloc/JS_realloc).\nThis buffer is wrapped with a Blob JSObject and returned from socket.Read()\nThen the user can get a string version or a TypedArray version (or whatever version) of the buffer through the Blob object (after that, the Blob object become invalidated).\n\n1/ The first proposition from Chris Leary means that the Socket.Read() will need to reserve a uint32 at the front of its buffer even if the string version will be used later.\n\n2/ The proposition from Jeff Walden means that the TypedArray needs to be created, even if it will not be used.\n\nMaybe, and If the TypedArray allow to be resized (like realloc), I will be able to replace my Blob with a TypeArray,\nand create an new ExternalString that points to the begining of TypeArray buffer ?", "creation_time": "2011-10-04T11:28:58Z", "bug_id": 691446, "tags": [], "is_private": false, "count": 5, "id": 5756987, "creator": "soubok@gmail.com", "author": "soubok@gmail.com"}, {"bug_id": 691446, "count": 6, "is_private": false, "tags": [], "id": 5757561, "text": "Typed arrays can't be resized.  You create the typed array, it has a length, it has it forever.  I don't think we should change this.  We'd be different from everyone else, and the problems from doing so would be all our own.\n\nI've thought about the reallocing problem and typed arrays before, in the context of the web server used in Mochitests.  It's not clear to me what the best solution is, that avoids buffer copying, without either forcing certain storage requirements under the hood or requiring that the code that does the read have the typed array and store directly into it.\n\nDigging a little deeper into your socket.Read(): what's the underlying interface you're wrapping?  available() plus read(n, buffer with size at least n)?  Or something else?  I'm wondering if we could possibly avoid the realloc somehow, or come up with some other clever trick here.", "attachment_id": null, "time": "2011-10-04T16:00:31Z", "raw_text": "Typed arrays can't be resized.  You create the typed array, it has a length, it has it forever.  I don't think we should change this.  We'd be different from everyone else, and the problems from doing so would be all our own.\n\nI've thought about the reallocing problem and typed arrays before, in the context of the web server used in Mochitests.  It's not clear to me what the best solution is, that avoids buffer copying, without either forcing certain storage requirements under the hood or requiring that the code that does the read have the typed array and store directly into it.\n\nDigging a little deeper into your socket.Read(): what's the underlying interface you're wrapping?  available() plus read(n, buffer with size at least n)?  Or something else?  I'm wondering if we could possibly avoid the realloc somehow, or come up with some other clever trick here.", "creation_time": "2011-10-04T16:00:31Z", "creator": "jwalden@mit.edu", "author": "jwalden@mit.edu"}, {"creator": "soubok@gmail.com", "author": "soubok@gmail.com", "raw_text": "I use NSPR that has PR_Available(). However my function socket.Read has an optional [amount] argument. When not given, the function tries to read everything until the socket is closed.\nFurthermore, in some situations, it is not possible to know the length in advance (HTTP1.0 connection: close, recording an audio or video stream, data serialization, data encoding, \u2026)\nUsually, to manage these situations, I use realloc() or I allocate a series of small buffers that I join into a new buffer once the whole data is read.", "creation_time": "2011-10-05T12:08:44Z", "text": "I use NSPR that has PR_Available(). However my function socket.Read has an optional [amount] argument. When not given, the function tries to read everything until the socket is closed.\nFurthermore, in some situations, it is not possible to know the length in advance (HTTP1.0 connection: close, recording an audio or video stream, data serialization, data encoding, \u2026)\nUsually, to manage these situations, I use realloc() or I allocate a series of small buffers that I join into a new buffer once the whole data is read.", "time": "2011-10-05T12:08:44Z", "attachment_id": null, "tags": [], "count": 7, "is_private": false, "id": 5759925, "bug_id": 691446}, {"author": "mrbkap@gmail.com", "creator": "mrbkap@gmail.com", "creation_time": "2011-10-06T20:10:37Z", "raw_text": "Review of attachment 564321:\n-----------------------------------------------------------------\n\nThis patch is fine modulo one nit, but given that this isn't quite useful for anyone yet, let's hold off on committing it.\n\n::: js/src/jsapi.cpp\n@@ +4625,5 @@\n>  \n> +JS_PUBLIC_API(JSObject *)\n> +JS_CreateArrayBuffer(JSContext *cx, char *bytes, size_t size)\n> +{\n> +    JS_ASSERT((size & uint32(-1)) == 0);\n\nThis isn't quite what you want.\n\nJS_ASSERT(size == uint32(size)) seems like a simpler way of doing what you want.", "time": "2011-10-06T20:10:37Z", "attachment_id": 564321, "text": "Comment on attachment 564321\nWIP: buffer stealing API.\n\nReview of attachment 564321:\n-----------------------------------------------------------------\n\nThis patch is fine modulo one nit, but given that this isn't quite useful for anyone yet, let's hold off on committing it.\n\n::: js/src/jsapi.cpp\n@@ +4625,5 @@\n>  \n> +JS_PUBLIC_API(JSObject *)\n> +JS_CreateArrayBuffer(JSContext *cx, char *bytes, size_t size)\n> +{\n> +    JS_ASSERT((size & uint32(-1)) == 0);\n\nThis isn't quite what you want.\n\nJS_ASSERT(size == uint32(size)) seems like a simpler way of doing what you want.", "id": 5764450, "count": 8, "is_private": false, "tags": [], "bug_id": 691446}, {"creator": "josh@joshmatthews.net", "author": "josh@joshmatthews.net", "creation_time": "2011-10-28T16:55:52Z", "raw_text": "> This patch is fine modulo one nit, but given that this isn't quite useful\n> for anyone yet, let's hold off on committing it.\n\nAccording to the readme at https://github.com/mbebenita/Broadway, this patch does have some use to the wider world.", "text": "> This patch is fine modulo one nit, but given that this isn't quite useful\n> for anyone yet, let's hold off on committing it.\n\nAccording to the readme at https://github.com/mbebenita/Broadway, this patch does have some use to the wider world.", "attachment_id": null, "time": "2011-10-28T16:55:52Z", "is_private": false, "count": 9, "tags": [], "id": 5811632, "bug_id": 691446}, {"id": 5931230, "count": 10, "is_private": false, "tags": [], "bug_id": 691446, "creation_time": "2011-12-20T23:35:16Z", "raw_text": "Oh my, the readme does say it's dependent on this patch. I suppose we should land it. I'll sr? dmandelin for the API change.", "attachment_id": null, "time": "2011-12-20T23:35:16Z", "text": "Oh my, the readme does say it's dependent on this patch. I suppose we should land it. I'll sr? dmandelin for the API change.", "author": "cdleary@acm.org", "creator": "cdleary@acm.org"}, {"id": 5931692, "tags": [], "is_private": false, "count": 11, "bug_id": 691446, "creation_time": "2011-12-21T02:50:09Z", "raw_text": "I usually don't sr patches until they've been r+d. The API seems OK...., but is pretty sharp-edged. I'd like to see a concise rationale for (a) why a new API is necessary at all, and (b) why this API in particular.", "author": "dmandelin@mozilla.com", "time": "2011-12-21T02:50:09Z", "attachment_id": 564321, "text": "Comment on attachment 564321\nWIP: buffer stealing API.\n\nI usually don't sr patches until they've been r+d. The API seems OK...., but is pretty sharp-edged. I'd like to see a concise rationale for (a) why a new API is necessary at all, and (b) why this API in particular.", "creator": "dmandelin@mozilla.com"}, {"author": "till@tillschneidereit.net", "creator": "till@tillschneidereit.net", "attachment_id": null, "time": "2013-03-27T11:40:48Z", "text": "Mass-reassigning cdleary's bugs to default. He won't work on any of them, anymore. I guess, at least.\n\n@cdleary: shout if you take issue with this.", "raw_text": "Mass-reassigning cdleary's bugs to default. He won't work on any of them, anymore. I guess, at least.\n\n@cdleary: shout if you take issue with this.", "creation_time": "2013-03-27T11:40:48Z", "bug_id": 691446, "id": 7248827, "count": 12, "is_private": false, "tags": []}]}}}