{"comments": {}, "bugs": {"641234": {"comments": [{"count": 0, "text": "Created attachment 518957\nPaper describing lastChange prototype work\n\nFor the 'lastChange' querypoint debugging technique we need a unique identifier for every JavaScript object, an 'object identifier'. We want to compare this id at two different points in the execution sequence to test equality of an earlier reference to a current reference without storing the earlier reference and thus changing the program behavior.\n\nTo be clear, the id here is similar to a memory address. The value needs only be unique for one execution and one object creation. Two objects which are conceptually the same, eg window.foo now and window.foo in the last page reload, are not the same object and their object ids are not related.\n\nThe object id would also be useful for memory analysis.", "author": "johnjbarton@johnjbarton.com", "creator": "johnjbarton@johnjbarton.com", "attachment_id": 518957, "id": 5341270, "time": "2011-03-12T18:22:20Z", "tags": [], "raw_text": "For the 'lastChange' querypoint debugging technique we need a unique identifier for every JavaScript object, an 'object identifier'. We want to compare this id at two different points in the execution sequence to test equality of an earlier reference to a current reference without storing the earlier reference and thus changing the program behavior.\n\nTo be clear, the id here is similar to a memory address. The value needs only be unique for one execution and one object creation. Two objects which are conceptually the same, eg window.foo now and window.foo in the last page reload, are not the same object and their object ids are not related.\n\nThe object id would also be useful for memory analysis.", "creation_time": "2011-03-12T18:22:20Z", "bug_id": 641234, "is_private": false}, {"is_private": false, "tags": [], "bug_id": 641234, "creation_time": "2011-03-12T18:22:59Z", "raw_text": "Bug 317485 - Implement getObjectId for js\nSeems very similar, never landed", "id": 5341272, "time": "2011-03-12T18:22:59Z", "attachment_id": null, "creator": "johnjbarton@johnjbarton.com", "author": "johnjbarton@johnjbarton.com", "count": 1, "text": "Bug 317485 - Implement getObjectId for js\nSeems very similar, never landed"}, {"id": 5342071, "author": "bzbarsky@mit.edu", "time": "2011-03-13T19:50:00Z", "count": 2, "text": "Memory address doesn't work unless you keep objects alive, right?", "attachment_id": null, "is_private": false, "creator": "bzbarsky@mit.edu", "tags": [], "raw_text": "Memory address doesn't work unless you keep objects alive, right?", "creation_time": "2011-03-13T19:50:00Z", "bug_id": 641234}, {"text": "We don't need the id for objects unless they are alive. But memory addresses by themselves won't work without some mechanism to know about GC. We need to know an object id is no longer valid; if GC can move objects we need the id to be updated.", "count": 3, "author": "johnjbarton@johnjbarton.com", "creator": "johnjbarton@johnjbarton.com", "attachment_id": null, "time": "2011-03-13T21:12:17Z", "id": 5342158, "creation_time": "2011-03-13T21:12:17Z", "bug_id": 641234, "raw_text": "We don't need the id for objects unless they are alive. But memory addresses by themselves won't work without some mechanism to know about GC. We need to know an object id is no longer valid; if GC can move objects we need the id to be updated.", "tags": [], "is_private": false}, {"raw_text": "Do you really need an id?  Or do you want something like ephemeron maps?", "creation_time": "2011-03-14T02:15:03Z", "bug_id": 641234, "tags": [], "is_private": false, "time": "2011-03-14T02:15:03Z", "id": 5342437, "creator": "bzbarsky@mit.edu", "attachment_id": null, "text": "Do you really need an id?  Or do you want something like ephemeron maps?", "count": 4, "author": "bzbarsky@mit.edu"}, {"count": 5, "text": "Well an id is easy to think about and to use, whereas:\n\nB. Hayes,  \"Ephemerons: A New Finalization Mechanism\",  in Proc. OOPSLA, 1997, pp.176-183. \nAbstract:\nFinalization occurs when a garbage collector informs an application that an object is \"almost collectable.\" It is used to help an application maintain its invariants. To make finalization more useful, this paper defines \"almost collectable\" in terms of a new class of objects, called ephemerons. Ephemerons are similar to weak pairs, but an object in an ephemeron's key field may be classed as \"almost collectable\" even if it is reachable from the epehemeron's value fields.", "author": "johnjbarton@johnjbarton.com", "creator": "johnjbarton@johnjbarton.com", "attachment_id": null, "id": 5342492, "time": "2011-03-14T03:26:50Z", "tags": [], "creation_time": "2011-03-14T03:26:50Z", "bug_id": 641234, "raw_text": "Well an id is easy to think about and to use, whereas:\n\nB. Hayes,  \"Ephemerons: A New Finalization Mechanism\",  in Proc. OOPSLA, 1997, pp.176-183. \nAbstract:\nFinalization occurs when a garbage collector informs an application that an object is \"almost collectable.\" It is used to help an application maintain its invariants. To make finalization more useful, this paper defines \"almost collectable\" in terms of a new class of objects, called ephemerons. Ephemerons are similar to weak pairs, but an object in an ephemeron's key field may be classed as \"almost collectable\" even if it is reachable from the epehemeron's value fields.", "is_private": false}, {"creator": "bzbarsky@mit.edu", "attachment_id": null, "count": 6, "text": "Yes, but the upshot is that you can use the object itself as a key in a table and it'll automagically get cleaned up for you if the object is GCed.  So you can basically use the object itself as your \"unique id\".", "author": "bzbarsky@mit.edu", "raw_text": "Yes, but the upshot is that you can use the object itself as a key in a table and it'll automagically get cleaned up for you if the object is GCed.  So you can basically use the object itself as your \"unique id\".", "bug_id": 641234, "creation_time": "2011-03-14T03:29:35Z", "tags": [], "is_private": false, "time": "2011-03-14T03:29:35Z", "id": 5342496}, {"count": 7, "text": "So let me see if I get this:\n   var efm = new EphemeronMap();\n   {\n       var foo = { bar: 1, baz: 2};  // the object I want to track\n\n       efm.add(foo, new FabulousDebugInfo(foo));\n   }\n   // force gc\n   var isMyFoo = efm.get(x);  // undefined since x can't ref foo *and* since \n                              // foo was GC anyway it's not even in the table.", "author": "johnjbarton@johnjbarton.com", "time": "2011-03-14T03:42:19Z", "id": 5342500, "raw_text": "So let me see if I get this:\n   var efm = new EphemeronMap();\n   {\n       var foo = { bar: 1, baz: 2};  // the object I want to track\n\n       efm.add(foo, new FabulousDebugInfo(foo));\n   }\n   // force gc\n   var isMyFoo = efm.get(x);  // undefined since x can't ref foo *and* since \n                              // foo was GC anyway it's not even in the table.", "bug_id": 641234, "creation_time": "2011-03-14T03:42:19Z", "creator": "johnjbarton@johnjbarton.com", "tags": [], "is_private": false, "attachment_id": null}, {"time": "2011-03-14T12:15:22Z", "id": 5342916, "bug_id": 641234, "creation_time": "2011-03-14T12:15:22Z", "raw_text": "As I understand, that's the idea, yes.", "tags": [], "is_private": false, "text": "As I understand, that's the idea, yes.", "count": 8, "author": "bzbarsky@mit.edu", "creator": "bzbarsky@mit.edu", "attachment_id": null}, {"is_private": false, "creation_time": "2011-03-14T12:22:39Z", "bug_id": 641234, "raw_text": "It is true that \"we don't need id for objects unless they are alive\" but the id uniqueness during the execution should be preserved. Therefore I think \"memory address\" won't work (at least alone).\n\nI guess ephemeron maps are not what we need for this case. The reason is that we should keep collected debug info even for already dead objects. It is necessary for longer sequences of lastChange. \n\nWe consider the fact that we usually need object Id for a very small proportion of objects in heap, therefore the mechanism should not add overhead to all objects.\n\nI can think of these two solutions:\n\n1) Like what we did in our prototype a hidden property is used for keeping the object id. The first time objectId() is called on the object, the property is added to the object. The only issue is getting the id value itself. In our prototype we simply get the new id by incrementing an integer. Here, I guess we must do it in a thread-safe manner. \n\n2) We can use memory address as the id but we need to be informed when the object is garbage collected. Then we know the id is obsolete, and we can recognize the next object with this id as a different object.\nThis approach needs a kind of hook for garbage collection, moreover we need to keep track of obsoleted ids.\n\nJust to remind, we also need Id for scopes. Are scopes treated the same way?", "tags": [], "time": "2011-03-14T12:22:39Z", "id": 5342926, "attachment_id": null, "creator": "salman.mirghasemi@gmail.com", "author": "salman.mirghasemi@gmail.com", "count": 9, "text": "It is true that \"we don't need id for objects unless they are alive\" but the id uniqueness during the execution should be preserved. Therefore I think \"memory address\" won't work (at least alone).\n\nI guess ephemeron maps are not what we need for this case. The reason is that we should keep collected debug info even for already dead objects. It is necessary for longer sequences of lastChange. \n\nWe consider the fact that we usually need object Id for a very small proportion of objects in heap, therefore the mechanism should not add overhead to all objects.\n\nI can think of these two solutions:\n\n1) Like what we did in our prototype a hidden property is used for keeping the object id. The first time objectId() is called on the object, the property is added to the object. The only issue is getting the id value itself. In our prototype we simply get the new id by incrementing an integer. Here, I guess we must do it in a thread-safe manner. \n\n2) We can use memory address as the id but we need to be informed when the object is garbage collected. Then we know the id is obsolete, and we can recognize the next object with this id as a different object.\nThis approach needs a kind of hook for garbage collection, moreover we need to keep track of obsoleted ids.\n\nJust to remind, we also need Id for scopes. Are scopes treated the same way?"}, {"text": "I don't get it.  Most of comment 9 is talking about how you have to invalidate IDs when the object is GCed, but the second paragraph talks about how you need the ID to outlive the object... which is it?", "count": 10, "author": "bzbarsky@mit.edu", "creator": "bzbarsky@mit.edu", "attachment_id": null, "time": "2011-03-14T13:26:24Z", "id": 5342999, "raw_text": "I don't get it.  Most of comment 9 is talking about how you have to invalidate IDs when the object is GCed, but the second paragraph talks about how you need the ID to outlive the object... which is it?", "creation_time": "2011-03-14T13:26:24Z", "bug_id": 641234, "tags": [], "is_private": false}, {"creator": "salman.mirghasemi@gmail.com", "tags": [], "raw_text": "We don't need to outlive the object. I just said we must keep the collected debug info about the object. So the object can be garbage collected but the collected debug info should be saved. Therefore we need object id (as a key) for this collected debug info.\nClear?", "bug_id": 641234, "creation_time": "2011-03-14T13:35:00Z", "is_private": false, "attachment_id": null, "count": 11, "text": "We don't need to outlive the object. I just said we must keep the collected debug info about the object. So the object can be garbage collected but the collected debug info should be saved. Therefore we need object id (as a key) for this collected debug info.\nClear?", "id": 5343011, "author": "salman.mirghasemi@gmail.com", "time": "2011-03-14T13:35:00Z"}, {"time": "2011-03-14T13:45:33Z", "id": 5343023, "creation_time": "2011-03-14T13:45:33Z", "bug_id": 641234, "raw_text": "Ah, so you're storing the \"id\" in some other data structures too, so need to retrieve debug info for objects that are no longer live because something else is referencing the debug info via the id?", "tags": [], "is_private": false, "count": 12, "text": "Ah, so you're storing the \"id\" in some other data structures too, so need to retrieve debug info for objects that are no longer live because something else is referencing the debug info via the id?", "author": "bzbarsky@mit.edu", "creator": "bzbarsky@mit.edu", "attachment_id": null}, {"bug_id": 641234, "creation_time": "2011-03-14T13:46:23Z", "raw_text": "correct.", "tags": [], "is_private": false, "time": "2011-03-14T13:46:23Z", "id": 5343024, "creator": "salman.mirghasemi@gmail.com", "attachment_id": null, "count": 13, "text": "correct.", "author": "salman.mirghasemi@gmail.com"}]}}}