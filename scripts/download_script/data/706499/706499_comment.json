{"comments": {}, "bugs": {"706499": {"comments": [{"creator": "b56girard@gmail.com", "author": "b56girard@gmail.com", "count": 0, "text": "We currently draw plugins async. This means we should be able to draw them asynchronously from the main thread with OMTC. \n\nThis is, at the very least, be possible on Mac and gives us an opportunity to clean up our usage of IOSurface. We currently call CGLTexImageIOSurface2D every frame where we should instead let the image layer know that were using 2 IOSurface as a double buffer and simply swap which IOSurface backed texture were drawing from.\n\nThe only foreseeable problem is that we communicate surface updates to the main gecko thread using:\n  sync Show(NPRect updatedRect, SurfaceDescriptor newSurface)\n    returns (SurfaceDescriptor prevSurface);\n\nWe could create a channel between the compositing thread and the plugin. What would you suggest Chris?", "bug_id": 706499, "id": 5882307, "is_private": false, "creation_time": "2011-11-30T16:28:28Z", "time": "2011-11-30T16:28:28Z", "attachment_id": null, "raw_text": "We currently draw plugins async. This means we should be able to draw them asynchronously from the main thread with OMTC. \n\nThis is, at the very least, be possible on Mac and gives us an opportunity to clean up our usage of IOSurface. We currently call CGLTexImageIOSurface2D every frame where we should instead let the image layer know that were using 2 IOSurface as a double buffer and simply swap which IOSurface backed texture were drawing from.\n\nThe only foreseeable problem is that we communicate surface updates to the main gecko thread using:\n  sync Show(NPRect updatedRect, SurfaceDescriptor newSurface)\n    returns (SurfaceDescriptor prevSurface);\n\nWe could create a channel between the compositing thread and the plugin. What would you suggest Chris?", "tags": []}, {"attachment_id": null, "tags": [], "creator": "cjones.bugs@gmail.com", "is_private": false, "creation_time": "2011-11-30T16:52:23Z", "raw_text": "This is approximately what bug 598277 originally covered.  Some of the framework is already in place.\n\nYes, creating a channel between plugin and compositing thread is the right approach with the current codebase.  There's some new code coming in with the new async drawing model that might have different requirements.", "time": "2011-11-30T16:52:23Z", "author": "cjones.bugs@gmail.com", "text": "This is approximately what bug 598277 originally covered.  Some of the framework is already in place.\n\nYes, creating a channel between plugin and compositing thread is the right approach with the current codebase.  There's some new code coming in with the new async drawing model that might have different requirements.", "count": 1, "id": 5882392, "bug_id": 706499}, {"is_private": false, "creation_time": "2011-11-30T22:18:12Z", "creator": "roc@ocallahan.org", "tags": [], "attachment_id": null, "id": 5883566, "bug_id": 706499, "count": 2, "text": "(In reply to Chris Jones [:cjones] [:warhammer] from comment #1)\n> There's some new code coming in with\n> the new async drawing model that might have different requirements.\n\nNo, that is not going to use IPDL for setting the surface, we'll use some kind of cross-process mutex instead.", "author": "roc@ocallahan.org", "time": "2011-11-30T22:18:12Z", "raw_text": "(In reply to Chris Jones [:cjones] [:warhammer] from comment #1)\n> There's some new code coming in with\n> the new async drawing model that might have different requirements.\n\nNo, that is not going to use IPDL for setting the surface, we'll use some kind of cross-process mutex instead."}, {"id": 5883864, "bug_id": 706499, "author": "cjones.bugs@gmail.com", "text": "Right, different requirements.\n\nWe could argue about that approach but I don't care about plugins anymore ;).", "count": 3, "time": "2011-12-01T00:01:16Z", "raw_text": "Right, different requirements.\n\nWe could argue about that approach but I don't care about plugins anymore ;).", "is_private": false, "creation_time": "2011-12-01T00:01:16Z", "creator": "cjones.bugs@gmail.com", "tags": [], "attachment_id": null}, {"tags": [], "attachment_id": null, "creation_time": "2011-12-01T01:58:53Z", "is_private": false, "creator": "roc@ocallahan.org", "time": "2011-12-01T01:58:53Z", "raw_text": "If you have something against that approach, let me know somewhere other than this bug --- I'd like your feedback.", "bug_id": 706499, "id": 5884194, "author": "roc@ocallahan.org", "text": "If you have something against that approach, let me know somewhere other than this bug --- I'd like your feedback.", "count": 4}, {"creator": "cjones.bugs@gmail.com", "creation_time": "2011-12-02T20:24:43Z", "is_private": false, "attachment_id": null, "tags": [], "author": "cjones.bugs@gmail.com", "text": "As we discussed before, that approach is going to make it much harder to have non-glitchy drawing of multiple plugin instances, but \"meh\" at this point.  This also makes cross-process plugin drawing code diverge even more from cross-process content drawing, which is suboptimal maintenance-wise.  Bullet-proofing the cross-process mutex code against buggy plugins will also be a bit nontrivial.", "count": 5, "bug_id": 706499, "id": 5889175, "raw_text": "As we discussed before, that approach is going to make it much harder to have non-glitchy drawing of multiple plugin instances, but \"meh\" at this point.  This also makes cross-process plugin drawing code diverge even more from cross-process content drawing, which is suboptimal maintenance-wise.  Bullet-proofing the cross-process mutex code against buggy plugins will also be a bit nontrivial.", "time": "2011-12-02T20:24:43Z"}, {"count": 6, "text": "I don't understand any of those points.", "author": "roc@ocallahan.org", "id": 5889540, "bug_id": 706499, "time": "2011-12-02T22:22:01Z", "raw_text": "I don't understand any of those points.", "creator": "roc@ocallahan.org", "creation_time": "2011-12-02T22:22:01Z", "is_private": false, "attachment_id": null, "tags": []}, {"id": 5920667, "bug_id": 706499, "author": "b56girard@gmail.com", "text": "I'm ready to begin work on this for the Mac. We've verified that composition is async by the FPS counter continuing but this seems like an easy candidate to test the feature. Also mac plugin rendering using basic layers is horrible since we go IOSurface->thebes layer->texture.\n\nWhat's the best way to get an IPC channel between the plugin thread, in the plugin process and the compositor thread.", "count": 7, "raw_text": "I'm ready to begin work on this for the Mac. We've verified that composition is async by the FPS counter continuing but this seems like an easy candidate to test the feature. Also mac plugin rendering using basic layers is horrible since we go IOSurface->thebes layer->texture.\n\nWhat's the best way to get an IPC channel between the plugin thread, in the plugin process and the compositor thread.", "time": "2011-12-16T00:17:13Z", "is_private": false, "creation_time": "2011-12-16T00:17:13Z", "creator": "b56girard@gmail.com", "tags": [], "attachment_id": null}, {"is_private": false, "creation_time": "2011-12-16T00:27:14Z", "id": 5920689, "bug_id": 706499, "text": "You want to use the |opens| IPDL feature.  See \n\nhttp://mxr.mozilla.org/mozilla-central/source/ipc/ipdl/test/cxx/PTestOpens.ipdl\n\nfor IPDL syntax, and \n\nhttp://mxr.mozilla.org/mozilla-central/source/ipc/ipdl/test/cxx/TestOpens.cpp\n\nfor C++ usage.  You can create the channel from either the chrome or plugin process (not sure which is more convenient for you).  Then you'll want to Open() the parent end of the channel (see .cpp above) on the compositor thread in chrome, and the child end on the main thread in the plugin process.\n\nNot sure how this should interacts with new drawing APIs.  But assuming those aren't going to land within the next few days, I would start by improving the current impl.", "count": 8, "author": "cjones.bugs@gmail.com", "creator": "cjones.bugs@gmail.com", "tags": [], "raw_text": "You want to use the |opens| IPDL feature.  See \n\nhttp://mxr.mozilla.org/mozilla-central/source/ipc/ipdl/test/cxx/PTestOpens.ipdl\n\nfor IPDL syntax, and \n\nhttp://mxr.mozilla.org/mozilla-central/source/ipc/ipdl/test/cxx/TestOpens.cpp\n\nfor C++ usage.  You can create the channel from either the chrome or plugin process (not sure which is more convenient for you).  Then you'll want to Open() the parent end of the channel (see .cpp above) on the compositor thread in chrome, and the child end on the main thread in the plugin process.\n\nNot sure how this should interacts with new drawing APIs.  But assuming those aren't going to land within the next few days, I would start by improving the current impl.", "attachment_id": null, "time": "2011-12-16T00:27:14Z"}, {"time": "2011-12-16T00:30:45Z", "raw_text": "Also, you should be able to use the same PCompositor protocol for this channel as I assume you'll be using across main<-->compositor threads.", "id": 5920700, "bug_id": 706499, "count": 9, "text": "Also, you should be able to use the same PCompositor protocol for this channel as I assume you'll be using across main<-->compositor threads.", "author": "cjones.bugs@gmail.com", "tags": [], "attachment_id": null, "is_private": false, "creation_time": "2011-12-16T00:30:45Z", "creator": "cjones.bugs@gmail.com"}, {"tags": [], "time": "2011-12-16T00:33:35Z", "attachment_id": null, "raw_text": "The current approach Bas is working on is to add a mode to ImageContainer which exports a cross-process mutex and a piece of shared memory that another process can use to set the current image on the container --- take the mutex and write some shared handle value into the shared memory. I'm not sure where he's at with that, you guys should coordinate.\n\nWe can use this for ShadowImageContainers as well. In fact maybe we can just use it for all ImageContainers. They're already a cross-thread container for images, making them cross-process makes sense.\n\nThe only problem is that sometimes we need to make SetCurrentImage happen as part of a transaction. Probably we should just have a separate method for that, that goes through IPDL and sets the image on the compositor thread. That method would be main-thread-only and used only by layout, not plugins or video decoding.", "bug_id": 706499, "id": 5920708, "creation_time": "2011-12-16T00:33:35Z", "is_private": false, "creator": "roc@ocallahan.org", "author": "roc@ocallahan.org", "text": "The current approach Bas is working on is to add a mode to ImageContainer which exports a cross-process mutex and a piece of shared memory that another process can use to set the current image on the container --- take the mutex and write some shared handle value into the shared memory. I'm not sure where he's at with that, you guys should coordinate.\n\nWe can use this for ShadowImageContainers as well. In fact maybe we can just use it for all ImageContainers. They're already a cross-thread container for images, making them cross-process makes sense.\n\nThe only problem is that sometimes we need to make SetCurrentImage happen as part of a transaction. Probably we should just have a separate method for that, that goes through IPDL and sets the image on the compositor thread. That method would be main-thread-only and used only by layout, not plugins or video decoding.", "count": 10}, {"creation_time": "2011-12-16T00:37:24Z", "is_private": false, "creator": "roc@ocallahan.org", "tags": [], "attachment_id": null, "id": 5920728, "bug_id": 706499, "count": 11, "text": "(In reply to Robert O'Callahan (:roc) (Mozilla Corporation) from comment #10)\n> The current approach Bas is working on is to add a mode to ImageContainer\n> which exports a cross-process mutex and a piece of shared memory that\n> another process can use to set the current image on the container --- take\n> the mutex and write some shared handle value into the shared memory.\n\nThat assumes Mac plugins can work that way. If they can't, then, uh, talk to Bas!", "author": "roc@ocallahan.org", "raw_text": "(In reply to Robert O'Callahan (:roc) (Mozilla Corporation) from comment #10)\n> The current approach Bas is working on is to add a mode to ImageContainer\n> which exports a cross-process mutex and a piece of shared memory that\n> another process can use to set the current image on the container --- take\n> the mutex and write some shared handle value into the shared memory.\n\nThat assumes Mac plugins can work that way. If they can't, then, uh, talk to Bas!", "time": "2011-12-16T00:37:24Z"}, {"creation_time": "2011-12-16T01:58:34Z", "is_private": false, "creator": "b56girard@gmail.com", "tags": [], "attachment_id": null, "id": 5920903, "bug_id": 706499, "author": "b56girard@gmail.com", "text": "(In reply to Chris Jones [:cjones] [:warhammer] from comment #8)\nThanks for the info. I'm going to start on this tomorrow (unless we decide I should block on bas' changes).\n\n(In reply to Robert O'Callahan (:roc) (Mozilla Corporation) from comment #10)\n> The only problem is that sometimes we need to make SetCurrentImage happen as\n> part of a transaction. Probably we should just have a separate method for\n> that, that goes through IPDL and sets the image on the compositor thread.\n\nI'm not particularly clear on what needs and doesn't need to be happen within a transaction? I assume that all async plugin can stand on its own?\n\nRe: Cross process mutex\n\nI see 4 options we can use:\n1) We can use the cross process mutex but that means the compositor can block on a lock. The block should be really fast assuming cross process mutex are cheap.\n2) We can reuse the current 'sync Show()' architecture. This suck because the plugin can block on the compositor which could be waiting on vsync.\n3) We can triple buffer. No blocking anywhere but it's wasteful.\n4) We can send the back buffer async between the compositor and the plugin. This can lead to a situation where the plugin wants to paint but does not own the back buffer. This happens if it's painting faster then we're compositing. In that case we delay the plugin repaint. This has the nice effect of throttling the plugin redraw to be no faster then what we're compositing, there's no blocking and no wasted memory to a triple buffer.\n\nAs you can see my favorite option is #4. Thoughts?\n\n(In reply to Robert O'Callahan (:roc) (Mozilla Corporation) from comment #11)\n> That assumes Mac plugins can work that way. If they can't, then, uh, talk to\n> Bas!\n\nThe're both easy on Mac. IOSurfaces are very flexible.", "count": 12, "raw_text": "(In reply to Chris Jones [:cjones] [:warhammer] from comment #8)\nThanks for the info. I'm going to start on this tomorrow (unless we decide I should block on bas' changes).\n\n(In reply to Robert O'Callahan (:roc) (Mozilla Corporation) from comment #10)\n> The only problem is that sometimes we need to make SetCurrentImage happen as\n> part of a transaction. Probably we should just have a separate method for\n> that, that goes through IPDL and sets the image on the compositor thread.\n\nI'm not particularly clear on what needs and doesn't need to be happen within a transaction? I assume that all async plugin can stand on its own?\n\nRe: Cross process mutex\n\nI see 4 options we can use:\n1) We can use the cross process mutex but that means the compositor can block on a lock. The block should be really fast assuming cross process mutex are cheap.\n2) We can reuse the current 'sync Show()' architecture. This suck because the plugin can block on the compositor which could be waiting on vsync.\n3) We can triple buffer. No blocking anywhere but it's wasteful.\n4) We can send the back buffer async between the compositor and the plugin. This can lead to a situation where the plugin wants to paint but does not own the back buffer. This happens if it's painting faster then we're compositing. In that case we delay the plugin repaint. This has the nice effect of throttling the plugin redraw to be no faster then what we're compositing, there's no blocking and no wasted memory to a triple buffer.\n\nAs you can see my favorite option is #4. Thoughts?\n\n(In reply to Robert O'Callahan (:roc) (Mozilla Corporation) from comment #11)\n> That assumes Mac plugins can work that way. If they can't, then, uh, talk to\n> Bas!\n\nThe're both easy on Mac. IOSurfaces are very flexible.", "time": "2011-12-16T01:58:34Z"}, {"tags": [], "attachment_id": null, "is_private": false, "creation_time": "2011-12-16T02:22:43Z", "creator": "roc@ocallahan.org", "raw_text": "(In reply to Benoit Girard (:BenWa) from comment #12)\n> (In reply to Robert O'Callahan (:roc) (Mozilla Corporation) from comment #10)\n> > The only problem is that sometimes we need to make SetCurrentImage happen as\n> > part of a transaction. Probably we should just have a separate method for\n> > that, that goes through IPDL and sets the image on the compositor thread.\n> \n> I'm not particularly clear on what needs and doesn't need to be happen\n> within a transaction? I assume that all async plugin can stand on its own?\n\nRight. It can.\n\n> Re: Cross process mutex\n> \n> I see 4 options we can use:\n> 1) We can use the cross process mutex but that means the compositor can\n> block on a lock. The block should be really fast assuming cross process\n> mutex are cheap.\n\nI don't think this is a problem ultimately for the compositor. SetCurrentImage should be over very fast.\n\n> As you can see my favorite option is #4. Thoughts?\n\nMine and Bas's is #1.\n\nWe've gone backwards and forwards on #4. It affects the plugin async drawing API design. I'm OK with it, but Bas loathes it. We'll have a separate notification that the plugin can use to throttle drawing.", "time": "2011-12-16T02:22:43Z", "id": 5920953, "bug_id": 706499, "author": "roc@ocallahan.org", "count": 13, "text": "(In reply to Benoit Girard (:BenWa) from comment #12)\n> (In reply to Robert O'Callahan (:roc) (Mozilla Corporation) from comment #10)\n> > The only problem is that sometimes we need to make SetCurrentImage happen as\n> > part of a transaction. Probably we should just have a separate method for\n> > that, that goes through IPDL and sets the image on the compositor thread.\n> \n> I'm not particularly clear on what needs and doesn't need to be happen\n> within a transaction? I assume that all async plugin can stand on its own?\n\nRight. It can.\n\n> Re: Cross process mutex\n> \n> I see 4 options we can use:\n> 1) We can use the cross process mutex but that means the compositor can\n> block on a lock. The block should be really fast assuming cross process\n> mutex are cheap.\n\nI don't think this is a problem ultimately for the compositor. SetCurrentImage should be over very fast.\n\n> As you can see my favorite option is #4. Thoughts?\n\nMine and Bas's is #1.\n\nWe've gone backwards and forwards on #4. It affects the plugin async drawing API design. I'm OK with it, but Bas loathes it. We'll have a separate notification that the plugin can use to throttle drawing."}, {"tags": [], "time": "2011-12-16T02:43:18Z", "raw_text": "(In reply to Robert O'Callahan (:roc) (Mozilla Corporation) from comment #13)\n> We've gone backwards and forwards on #4. It affects the plugin async drawing\n> API design. I'm OK with it, but Bas loathes it. We'll have a separate\n> notification that the plugin can use to throttle drawing.\n\nIt does make sense for the async NPAPI proposal but it's not as clear for the exists models. Plug-ins don't receive anything like DidComposite so it's up to us to throttle them. So #4 let's us throttle and swap surfaces all in one.\n\nIn any case I don't feel too strongly since there both good designs.", "attachment_id": null, "bug_id": 706499, "id": 5920988, "is_private": false, "creation_time": "2011-12-16T02:43:18Z", "creator": "b56girard@gmail.com", "text": "(In reply to Robert O'Callahan (:roc) (Mozilla Corporation) from comment #13)\n> We've gone backwards and forwards on #4. It affects the plugin async drawing\n> API design. I'm OK with it, but Bas loathes it. We'll have a separate\n> notification that the plugin can use to throttle drawing.\n\nIt does make sense for the async NPAPI proposal but it's not as clear for the exists models. Plug-ins don't receive anything like DidComposite so it's up to us to throttle them. So #4 let's us throttle and swap surfaces all in one.\n\nIn any case I don't feel too strongly since there both good designs.", "count": 14, "author": "b56girard@gmail.com"}, {"is_private": false, "creation_time": "2011-12-16T07:23:55Z", "creator": "cjones.bugs@gmail.com", "tags": [], "attachment_id": null, "bug_id": 706499, "id": 5921223, "count": 15, "text": "Sorry, missed this while traveling.\n\n(In reply to Robert O'Callahan (:roc) (Mozilla Corporation) from comment #6)\n> I don't understand any of those points.\n\n(In reply to Chris Jones [:cjones] [:warhammer] from comment #5)\n> As we discussed before, that approach is going to make it much harder to\n> have non-glitchy drawing of multiple plugin instances, but \"meh\" at this\n> point.\n\nAssume we have a page with instances A, B of plugin P.  If there are pages that expect A, B to be drawn during the same \"event-loop iteration\", i.e. \"atomically\", it's much harder to do this with the mutex design.  Does that make sense?  But like I said, I don't care about this case anymore.  \n\n> This also makes cross-process plugin drawing code diverge even more\n> from cross-process content drawing, which is suboptimal maintenance-wise.\n\nNot sure what's unclear about this.  The original plan was to use PLayers for plugins as well as content and compositor.  Now we have a second (third in the current setup) system to maintain.\n\n> Bullet-proofing the cross-process mutex code against buggy plugins will also\n> be a bit nontrivial.\n\nWe have to prove that no sequence of plugin crashes will deadlock the browser or lead to other bad behavior.  This is the kind of thing I would use a model checker for.  It's not easy.  Frankly, my faith that client OS's get this right is quite low.  In fact, I'm pretty sure the linux cross-process mutex primitive is vulnerable to a race condition that could deadlock the compositor.  So we would need to build in another mechanism to guard against that.", "author": "cjones.bugs@gmail.com", "time": "2011-12-16T07:23:55Z", "raw_text": "Sorry, missed this while traveling.\n\n(In reply to Robert O'Callahan (:roc) (Mozilla Corporation) from comment #6)\n> I don't understand any of those points.\n\n(In reply to Chris Jones [:cjones] [:warhammer] from comment #5)\n> As we discussed before, that approach is going to make it much harder to\n> have non-glitchy drawing of multiple plugin instances, but \"meh\" at this\n> point.\n\nAssume we have a page with instances A, B of plugin P.  If there are pages that expect A, B to be drawn during the same \"event-loop iteration\", i.e. \"atomically\", it's much harder to do this with the mutex design.  Does that make sense?  But like I said, I don't care about this case anymore.  \n\n> This also makes cross-process plugin drawing code diverge even more\n> from cross-process content drawing, which is suboptimal maintenance-wise.\n\nNot sure what's unclear about this.  The original plan was to use PLayers for plugins as well as content and compositor.  Now we have a second (third in the current setup) system to maintain.\n\n> Bullet-proofing the cross-process mutex code against buggy plugins will also\n> be a bit nontrivial.\n\nWe have to prove that no sequence of plugin crashes will deadlock the browser or lead to other bad behavior.  This is the kind of thing I would use a model checker for.  It's not easy.  Frankly, my faith that client OS's get this right is quite low.  In fact, I'm pretty sure the linux cross-process mutex primitive is vulnerable to a race condition that could deadlock the compositor.  So we would need to build in another mechanism to guard against that."}, {"time": "2011-12-16T08:51:47Z", "raw_text": "(In reply to Chris Jones [:cjones] [:warhammer] from comment #15)\n> Assume we have a page with instances A, B of plugin P.  If there are pages\n> that expect A, B to be drawn during the same \"event-loop iteration\", i.e.\n> \"atomically\", it's much harder to do this with the mutex design.  Does that\n> make sense?  But like I said, I don't care about this case anymore.\n\nI can't think of a page I've seen that would care about this.\n\n> > This also makes cross-process plugin drawing code diverge even more\n> > from cross-process content drawing, which is suboptimal maintenance-wise.\n> \n> Not sure what's unclear about this.  The original plan was to use PLayers\n> for plugins as well as content and compositor.  Now we have a second (third\n> in the current setup) system to maintain.\n\nI want to integrate this deeply into our existing ImageContainer logic. It already supports atomic SetCurrentImage across threads in the same process, extending this across process isn't too strange.\n\n> We have to prove that no sequence of plugin crashes will deadlock the\n> browser or lead to other bad behavior.  This is the kind of thing I would\n> use a model checker for.  It's not easy.  Frankly, my faith that client OS's\n> get this right is quite low.  In fact, I'm pretty sure the linux\n> cross-process mutex primitive is vulnerable to a race condition that could\n> deadlock the compositor.  So we would need to build in another mechanism to\n> guard against that.\n\nIs there some specific bug in Linux PTHREAD_PROCESS_SHARED mutexes and PTHREAD_MUTEX_ROBUST_NP that you're thinking of?", "author": "roc@ocallahan.org", "text": "(In reply to Chris Jones [:cjones] [:warhammer] from comment #15)\n> Assume we have a page with instances A, B of plugin P.  If there are pages\n> that expect A, B to be drawn during the same \"event-loop iteration\", i.e.\n> \"atomically\", it's much harder to do this with the mutex design.  Does that\n> make sense?  But like I said, I don't care about this case anymore.\n\nI can't think of a page I've seen that would care about this.\n\n> > This also makes cross-process plugin drawing code diverge even more\n> > from cross-process content drawing, which is suboptimal maintenance-wise.\n> \n> Not sure what's unclear about this.  The original plan was to use PLayers\n> for plugins as well as content and compositor.  Now we have a second (third\n> in the current setup) system to maintain.\n\nI want to integrate this deeply into our existing ImageContainer logic. It already supports atomic SetCurrentImage across threads in the same process, extending this across process isn't too strange.\n\n> We have to prove that no sequence of plugin crashes will deadlock the\n> browser or lead to other bad behavior.  This is the kind of thing I would\n> use a model checker for.  It's not easy.  Frankly, my faith that client OS's\n> get this right is quite low.  In fact, I'm pretty sure the linux\n> cross-process mutex primitive is vulnerable to a race condition that could\n> deadlock the compositor.  So we would need to build in another mechanism to\n> guard against that.\n\nIs there some specific bug in Linux PTHREAD_PROCESS_SHARED mutexes and PTHREAD_MUTEX_ROBUST_NP that you're thinking of?", "count": 16, "bug_id": 706499, "id": 5921294, "attachment_id": null, "tags": [], "creator": "roc@ocallahan.org", "creation_time": "2011-12-16T08:51:47Z", "is_private": false}, {"creation_time": "2011-12-17T07:15:33Z", "is_private": false, "creator": "cjones.bugs@gmail.com", "tags": [], "attachment_id": null, "id": 5924120, "bug_id": 706499, "count": 17, "text": "(In reply to Robert O'Callahan (:roc) (Mozilla Corporation) from comment #16)\n> > We have to prove that no sequence of plugin crashes will deadlock the\n> > browser or lead to other bad behavior.  This is the kind of thing I would\n> > use a model checker for.  It's not easy.  Frankly, my faith that client OS's\n> > get this right is quite low.  In fact, I'm pretty sure the linux\n> > cross-process mutex primitive is vulnerable to a race condition that could\n> > deadlock the compositor.  So we would need to build in another mechanism to\n> > guard against that.\n> \n> Is there some specific bug in Linux PTHREAD_PROCESS_SHARED mutexes and\n> PTHREAD_MUTEX_ROBUST_NP that you're thinking of?\n\nThere was a problem I was worried about, but there's a pretty fabulous little hack that looks to correctly avoid it.  So nothing concrete worrying me for linux.  Fwiw, I feel more confident about win32 cross-process mutexes than linux ones.\n\nThe odds of this being implemented correctly in bionic (android libc) are just about 0%.  We'll probably need a fallback path for when we don't have this primitive.", "author": "cjones.bugs@gmail.com", "time": "2011-12-17T07:15:33Z", "raw_text": "(In reply to Robert O'Callahan (:roc) (Mozilla Corporation) from comment #16)\n> > We have to prove that no sequence of plugin crashes will deadlock the\n> > browser or lead to other bad behavior.  This is the kind of thing I would\n> > use a model checker for.  It's not easy.  Frankly, my faith that client OS's\n> > get this right is quite low.  In fact, I'm pretty sure the linux\n> > cross-process mutex primitive is vulnerable to a race condition that could\n> > deadlock the compositor.  So we would need to build in another mechanism to\n> > guard against that.\n> \n> Is there some specific bug in Linux PTHREAD_PROCESS_SHARED mutexes and\n> PTHREAD_MUTEX_ROBUST_NP that you're thinking of?\n\nThere was a problem I was worried about, but there's a pretty fabulous little hack that looks to correctly avoid it.  So nothing concrete worrying me for linux.  Fwiw, I feel more confident about win32 cross-process mutexes than linux ones.\n\nThe odds of this being implemented correctly in bionic (android libc) are just about 0%.  We'll probably need a fallback path for when we don't have this primitive."}, {"creation_time": "2011-12-17T10:20:05Z", "is_private": false, "creator": "cjones.bugs@gmail.com", "tags": [], "attachment_id": null, "id": 5924207, "bug_id": 706499, "text": "To summarize, my main objections to the cross-process swap approach were\n (1) Eliminates possibility of atomic updates across plugin instances from the same plugin type\nI don't care about this anymore, maybe no one ever did.\n\n (2) Making impl robust to plugin crashes\nglibc/linux impl looks OK, win32 should be as good (hopefully).  Not sure about mac.  bionic/linux almost certainly broken.\n - Was using an atomic swap instead of mutex+update considered?  Easier to maintain than OS/libc-specific cross-process mutex for Tier Is: just two architectures.  Possibly worse for < Tier I, but then again we'd have to look at cross-process impl for < Tier I too.\n\n (3) Optimizing existing IPC to handle this case instead of building new mechanism\nOdds of getting someone to do this soon are low, new mechanism seems OK.\n\nIf we can use an atomic swap instead of a cross-process mutex, I'd feel a little better about the approach.  But it seems OK overall.", "count": 18, "author": "cjones.bugs@gmail.com", "raw_text": "To summarize, my main objections to the cross-process swap approach were\n (1) Eliminates possibility of atomic updates across plugin instances from the same plugin type\nI don't care about this anymore, maybe no one ever did.\n\n (2) Making impl robust to plugin crashes\nglibc/linux impl looks OK, win32 should be as good (hopefully).  Not sure about mac.  bionic/linux almost certainly broken.\n - Was using an atomic swap instead of mutex+update considered?  Easier to maintain than OS/libc-specific cross-process mutex for Tier Is: just two architectures.  Possibly worse for < Tier I, but then again we'd have to look at cross-process impl for < Tier I too.\n\n (3) Optimizing existing IPC to handle this case instead of building new mechanism\nOdds of getting someone to do this soon are low, new mechanism seems OK.\n\nIf we can use an atomic swap instead of a cross-process mutex, I'd feel a little better about the approach.  But it seems OK overall.", "time": "2011-12-17T10:20:05Z"}, {"tags": [], "attachment_id": null, "raw_text": "I think using shared memory (ashmem) and atomic operations would work with bionic. In fact, that's the only thing I think would work on bionic, unless we basically reimplement the right APIs on top of what the kernel provides, which is much much more than what bionic exposes.", "time": "2011-12-17T12:03:17Z", "is_private": false, "creation_time": "2011-12-17T12:03:17Z", "bug_id": 706499, "id": 5924283, "author": "mh+mozilla@glandium.org", "text": "I think using shared memory (ashmem) and atomic operations would work with bionic. In fact, that's the only thing I think would work on bionic, unless we basically reimplement the right APIs on top of what the kernel provides, which is much much more than what bionic exposes.", "count": 19, "creator": "mh+mozilla@glandium.org"}, {"bug_id": 706499, "id": 5924365, "text": "(In reply to Chris Jones [:cjones] [:warhammer] from comment #18)\n> To summarize, my main objections to the cross-process swap approach were\n>  (1) Eliminates possibility of atomic updates across plugin instances from\n> the same plugin type\n> I don't care about this anymore, maybe no one ever did.\n> \n>  (2) Making impl robust to plugin crashes\n> glibc/linux impl looks OK, win32 should be as good (hopefully).  Not sure\n> about mac.  bionic/linux almost certainly broken.\n>  - Was using an atomic swap instead of mutex+update considered?\n\nI did consider this, the problem is you need to block while the actual surface data is being composited. So in the rare case the compositor is -actually- currently blitting the plugin you want to wait for that to finish, so a simple interlocked exchange on the pointer won't work.", "count": 20, "author": "bas@basschouten.com", "raw_text": "(In reply to Chris Jones [:cjones] [:warhammer] from comment #18)\n> To summarize, my main objections to the cross-process swap approach were\n>  (1) Eliminates possibility of atomic updates across plugin instances from\n> the same plugin type\n> I don't care about this anymore, maybe no one ever did.\n> \n>  (2) Making impl robust to plugin crashes\n> glibc/linux impl looks OK, win32 should be as good (hopefully).  Not sure\n> about mac.  bionic/linux almost certainly broken.\n>  - Was using an atomic swap instead of mutex+update considered?\n\nI did consider this, the problem is you need to block while the actual surface data is being composited. So in the rare case the compositor is -actually- currently blitting the plugin you want to wait for that to finish, so a simple interlocked exchange on the pointer won't work.", "time": "2011-12-17T14:46:38Z", "is_private": false, "creation_time": "2011-12-17T14:46:38Z", "creator": "bas@basschouten.com", "tags": [], "attachment_id": null}, {"is_private": false, "creation_time": "2011-12-17T15:19:33Z", "bug_id": 706499, "id": 5924388, "author": "bas@basschouten.com", "text": "(In reply to Mike Hommey [:glandium] from comment #19)\n> I think using shared memory (ashmem) and atomic operations would work with\n> bionic. In fact, that's the only thing I think would work on bionic, unless\n> we basically reimplement the right APIs on top of what the kernel provides,\n> which is much much more than what bionic exposes.\n\nFor NPAPI Async Drawing the contention situation should be rare. We could do a spinlock through shared memory on bionic. That's pretty horrible though, but if there's no way to do it properly throught he scheduler, that might be the only option.\n\nFwiw, as far as I understand it, NPAPI Async Drawing is mainly wanted by adobe for windows.", "count": 21, "creator": "bas@basschouten.com", "tags": [], "attachment_id": null, "raw_text": "(In reply to Mike Hommey [:glandium] from comment #19)\n> I think using shared memory (ashmem) and atomic operations would work with\n> bionic. In fact, that's the only thing I think would work on bionic, unless\n> we basically reimplement the right APIs on top of what the kernel provides,\n> which is much much more than what bionic exposes.\n\nFor NPAPI Async Drawing the contention situation should be rare. We could do a spinlock through shared memory on bionic. That's pretty horrible though, but if there's no way to do it properly throught he scheduler, that might be the only option.\n\nFwiw, as far as I understand it, NPAPI Async Drawing is mainly wanted by adobe for windows.", "time": "2011-12-17T15:19:33Z"}, {"raw_text": "Ugh. Busy-waiting is a really bad failure mode. Maybe we could somehow ignore Android for our immediate needs here but it seems likely this would come back to bite us.\n\nUsing IPDL and threads, though, means we have to do\n  plugin main thread SetCurrentAsyncSurface sends message to plugin helper thread, blocks\n  plugin helper thread makes async IPDL call to compositor thread\n  compositor thread does SetCurrentImage\n  compositor thread sends async IPDL reply to plugin helper thread\n  plugin helper thread sends message to plugin main thread, which wakes and returns from SetCurrentAsyncSurface\n\nMaybe we can hide that behind some abstraction that can also be implemented with a cross-process mutex.\n\nWe can change the plugin API so that SetCurrentAsyncSurface is a fully async operation, with a separate reply method, which gets us (I think) to\n\n  plugin main thread makes async IPDL call to compositor thread and returns to event loop\n  compositor thread does SetCurrentImage\n  compositor thread sends async IPDL reply to plugin main thread\n\nBut Bas gets upset when I suggest that.", "time": "2011-12-18T09:37:13Z", "author": "roc@ocallahan.org", "count": 22, "text": "Ugh. Busy-waiting is a really bad failure mode. Maybe we could somehow ignore Android for our immediate needs here but it seems likely this would come back to bite us.\n\nUsing IPDL and threads, though, means we have to do\n  plugin main thread SetCurrentAsyncSurface sends message to plugin helper thread, blocks\n  plugin helper thread makes async IPDL call to compositor thread\n  compositor thread does SetCurrentImage\n  compositor thread sends async IPDL reply to plugin helper thread\n  plugin helper thread sends message to plugin main thread, which wakes and returns from SetCurrentAsyncSurface\n\nMaybe we can hide that behind some abstraction that can also be implemented with a cross-process mutex.\n\nWe can change the plugin API so that SetCurrentAsyncSurface is a fully async operation, with a separate reply method, which gets us (I think) to\n\n  plugin main thread makes async IPDL call to compositor thread and returns to event loop\n  compositor thread does SetCurrentImage\n  compositor thread sends async IPDL reply to plugin main thread\n\nBut Bas gets upset when I suggest that.", "id": 5925184, "bug_id": 706499, "attachment_id": null, "tags": [], "creator": "roc@ocallahan.org", "is_private": false, "creation_time": "2011-12-18T09:37:13Z"}, {"tags": [], "time": "2011-12-18T16:10:08Z", "raw_text": "(In reply to Robert O'Callahan (:roc) (Mozilla Corporation) from comment #22)\n> We can change the plugin API so that SetCurrentAsyncSurface is a fully async\n> operation, with a separate reply method, which gets us (I think) to\n> \n>   plugin main thread makes async IPDL call to compositor thread and returns\n> to event loop\n>   compositor thread does SetCurrentImage\n>   compositor thread sends async IPDL reply to plugin main thread\n> \n> But Bas gets upset when I suggest that.\n\nI think that designing the plugin API to expect an async response give us more flexibility. In cases where we know we can use a cross process mutex we can deliver the reply right away without hitting IPDL. In platforms where we can't get cross process mutex it lets us do something like you mention. The major problem with doing it this way is that we either have to have it go through the plugin's main thread or we need a separate thread in the cases where we need to use IPDL.\n\nWe should either make this API windows specific if that's the need we have, or we should make the API general enough to be implemented across platform.", "attachment_id": null, "bug_id": 706499, "id": 5925376, "is_private": false, "creation_time": "2011-12-18T16:10:08Z", "creator": "b56girard@gmail.com", "count": 23, "text": "(In reply to Robert O'Callahan (:roc) (Mozilla Corporation) from comment #22)\n> We can change the plugin API so that SetCurrentAsyncSurface is a fully async\n> operation, with a separate reply method, which gets us (I think) to\n> \n>   plugin main thread makes async IPDL call to compositor thread and returns\n> to event loop\n>   compositor thread does SetCurrentImage\n>   compositor thread sends async IPDL reply to plugin main thread\n> \n> But Bas gets upset when I suggest that.\n\nI think that designing the plugin API to expect an async response give us more flexibility. In cases where we know we can use a cross process mutex we can deliver the reply right away without hitting IPDL. In platforms where we can't get cross process mutex it lets us do something like you mention. The major problem with doing it this way is that we either have to have it go through the plugin's main thread or we need a separate thread in the cases where we need to use IPDL.\n\nWe should either make this API windows specific if that's the need we have, or we should make the API general enough to be implemented across platform.", "author": "b56girard@gmail.com"}, {"creator": "cjones.bugs@gmail.com", "creation_time": "2011-12-18T21:47:21Z", "is_private": false, "attachment_id": null, "tags": [], "author": "cjones.bugs@gmail.com", "count": 24, "text": "Why do we have to busy wait while a swapped image is being composited?  That doesn't make sense to me.", "id": 5925660, "bug_id": 706499, "time": "2011-12-18T21:47:21Z", "raw_text": "Why do we have to busy wait while a swapped image is being composited?  That doesn't make sense to me."}, {"tags": [], "attachment_id": null, "creation_time": "2011-12-18T23:14:53Z", "is_private": false, "creator": "roc@ocallahan.org", "time": "2011-12-18T23:14:53Z", "raw_text": "We can't return the \"old current\" surface from SetCurrentAsyncSurface until the compositor has finished with it. So SetCurrentAsyncSurface as currently specced has to wait.", "bug_id": 706499, "id": 5925730, "count": 25, "text": "We can't return the \"old current\" surface from SetCurrentAsyncSurface until the compositor has finished with it. So SetCurrentAsyncSurface as currently specced has to wait.", "author": "roc@ocallahan.org"}, {"tags": [], "time": "2011-12-18T23:37:20Z", "attachment_id": null, "raw_text": "So the spec says SetCurrent is guaranteed to succeed and return the previous surface?  If so, ok I understand, but that's possibly a bit unfortunate.", "bug_id": 706499, "id": 5925764, "is_private": false, "creation_time": "2011-12-18T23:37:20Z", "creator": "cjones.bugs@gmail.com", "author": "cjones.bugs@gmail.com", "count": 26, "text": "So the spec says SetCurrent is guaranteed to succeed and return the previous surface?  If so, ok I understand, but that's possibly a bit unfortunate."}, {"creator": "roc@ocallahan.org", "text": "See comments #22 and #23. Bas is strongly opposed to the obvious alternative.", "count": 27, "author": "roc@ocallahan.org", "bug_id": 706499, "id": 5925843, "is_private": false, "creation_time": "2011-12-19T01:40:21Z", "time": "2011-12-19T01:40:21Z", "raw_text": "See comments #22 and #23. Bas is strongly opposed to the obvious alternative.", "attachment_id": null, "tags": []}, {"count": 28, "text": "(In reply to Benoit Girard (:BenWa) from comment #23)\n> (In reply to Robert O'Callahan (:roc) (Mozilla Corporation) from comment #22)\n> > We can change the plugin API so that SetCurrentAsyncSurface is a fully async\n> > operation, with a separate reply method, which gets us (I think) to\n> > \n> >   plugin main thread makes async IPDL call to compositor thread and returns\n> > to event loop\n> >   compositor thread does SetCurrentImage\n> >   compositor thread sends async IPDL reply to plugin main thread\n> > \n> > But Bas gets upset when I suggest that.\n> \n> I think that designing the plugin API to expect an async response give us\n> more flexibility. In cases where we know we can use a cross process mutex we\n> can deliver the reply right away without hitting IPDL.\n\nThe problem is that you'd get that message on some thread where you're running our message loop. Meaning you'd still need to wait on whatever thread receives the reply in order to continue drawing. Meaning if you want to do what you'd do for example with Direct3D or GL, where you want to present your backbuffer and go on drawing right away to your old backbuffer, you wouldn't be able to take that approach.\n\nI wonder if there's something that can be done using pipes to implement a sort of cross-process mutex on Android(perhaps in a sub-optimal way), without busy-waiting.", "author": "bas@basschouten.com", "id": 5925921, "bug_id": 706499, "raw_text": "(In reply to Benoit Girard (:BenWa) from comment #23)\n> (In reply to Robert O'Callahan (:roc) (Mozilla Corporation) from comment #22)\n> > We can change the plugin API so that SetCurrentAsyncSurface is a fully async\n> > operation, with a separate reply method, which gets us (I think) to\n> > \n> >   plugin main thread makes async IPDL call to compositor thread and returns\n> > to event loop\n> >   compositor thread does SetCurrentImage\n> >   compositor thread sends async IPDL reply to plugin main thread\n> > \n> > But Bas gets upset when I suggest that.\n> \n> I think that designing the plugin API to expect an async response give us\n> more flexibility. In cases where we know we can use a cross process mutex we\n> can deliver the reply right away without hitting IPDL.\n\nThe problem is that you'd get that message on some thread where you're running our message loop. Meaning you'd still need to wait on whatever thread receives the reply in order to continue drawing. Meaning if you want to do what you'd do for example with Direct3D or GL, where you want to present your backbuffer and go on drawing right away to your old backbuffer, you wouldn't be able to take that approach.\n\nI wonder if there's something that can be done using pipes to implement a sort of cross-process mutex on Android(perhaps in a sub-optimal way), without busy-waiting.", "time": "2011-12-19T03:14:10Z", "creator": "bas@basschouten.com", "is_private": false, "creation_time": "2011-12-19T03:14:10Z", "attachment_id": null, "tags": []}, {"bug_id": 706499, "id": 5925951, "author": "roc@ocallahan.org", "count": 29, "text": "> I wonder if there's something that can be done using pipes to implement a sort of\n> cross-process mutex on Android(perhaps in a sub-optimal way), without\n> busy-waiting.\n\nThe problem is making that robust if the plugin process hangs or dies.", "time": "2011-12-19T03:51:28Z", "raw_text": "> I wonder if there's something that can be done using pipes to implement a sort of\n> cross-process mutex on Android(perhaps in a sub-optimal way), without\n> busy-waiting.\n\nThe problem is making that robust if the plugin process hangs or dies.", "creation_time": "2011-12-19T03:51:28Z", "is_private": false, "creator": "roc@ocallahan.org", "tags": [], "attachment_id": null}, {"tags": [], "time": "2011-12-19T04:39:18Z", "raw_text": "Here's a thought\n - in SetCurrent, try to atomic-swap back/front.  This should succeed most of the time.\n - if the front buffer is \"busy\", fall back on a synchronous swap with IPC.  Something like comment 22 if I understand the general idea correctly (some details are fuzzy).\n\nThis is faster than mutex-swap in the common case, and doesn't require an OS cross-process mutex primitive.  In the uncommon case, or on platforms where we don't have atomic swap primitives, we fall back safely.", "attachment_id": null, "bug_id": 706499, "id": 5925979, "creation_time": "2011-12-19T04:39:18Z", "is_private": false, "creator": "cjones.bugs@gmail.com", "count": 30, "text": "Here's a thought\n - in SetCurrent, try to atomic-swap back/front.  This should succeed most of the time.\n - if the front buffer is \"busy\", fall back on a synchronous swap with IPC.  Something like comment 22 if I understand the general idea correctly (some details are fuzzy).\n\nThis is faster than mutex-swap in the common case, and doesn't require an OS cross-process mutex primitive.  In the uncommon case, or on platforms where we don't have atomic swap primitives, we fall back safely.", "author": "cjones.bugs@gmail.com"}, {"is_private": false, "creation_time": "2011-12-19T04:45:05Z", "id": 5925988, "bug_id": 706499, "author": "roc@ocallahan.org", "text": "That sounds like it would work.", "count": 31, "creator": "roc@ocallahan.org", "tags": [], "attachment_id": null, "raw_text": "That sounds like it would work.", "time": "2011-12-19T04:45:05Z"}, {"tags": [], "attachment_id": null, "raw_text": "(In reply to Chris Jones [:cjones] [:warhammer] from comment #30)\n> Here's a thought\n>  - in SetCurrent, try to atomic-swap back/front.  This should succeed most\n> of the time.\n>  - if the front buffer is \"busy\", fall back on a synchronous swap with IPC. \n> Something like comment 22 if I understand the general idea correctly (some\n> details are fuzzy).\n> \n> This is faster than mutex-swap in the common case, and doesn't require an OS\n> cross-process mutex primitive.  In the uncommon case, or on platforms where\n> we don't have atomic swap primitives, we fall back safely.\n\nYeah, so, I'm wondering, couldn't we hide the second approach behind a 'cross-process' mutex abstraction, and only use it on android where we don't have actual cross-process mutex?\n\nI.e. on a system without a cross-process mutex, do an interlocked compare and exchange, if it succeeds we're all good and continue, if it fails we send an IPDL synchronous message that does the job. That way the majority of our platforms that do support cross-process mutices get the easy, fast thing, and the more complex situation only needs to exist on platforms without a solid cross-process mutex.\n\nPerhaps this is what you meant :) Just making sure. I'd hate to have this complexity in the actual async plugin code.", "time": "2011-12-19T16:34:02Z", "creation_time": "2011-12-19T16:34:02Z", "is_private": false, "id": 5926840, "bug_id": 706499, "author": "bas@basschouten.com", "text": "(In reply to Chris Jones [:cjones] [:warhammer] from comment #30)\n> Here's a thought\n>  - in SetCurrent, try to atomic-swap back/front.  This should succeed most\n> of the time.\n>  - if the front buffer is \"busy\", fall back on a synchronous swap with IPC. \n> Something like comment 22 if I understand the general idea correctly (some\n> details are fuzzy).\n> \n> This is faster than mutex-swap in the common case, and doesn't require an OS\n> cross-process mutex primitive.  In the uncommon case, or on platforms where\n> we don't have atomic swap primitives, we fall back safely.\n\nYeah, so, I'm wondering, couldn't we hide the second approach behind a 'cross-process' mutex abstraction, and only use it on android where we don't have actual cross-process mutex?\n\nI.e. on a system without a cross-process mutex, do an interlocked compare and exchange, if it succeeds we're all good and continue, if it fails we send an IPDL synchronous message that does the job. That way the majority of our platforms that do support cross-process mutices get the easy, fast thing, and the more complex situation only needs to exist on platforms without a solid cross-process mutex.\n\nPerhaps this is what you meant :) Just making sure. I'd hate to have this complexity in the actual async plugin code.", "count": 32, "creator": "bas@basschouten.com"}, {"tags": [], "raw_text": "Can we do this at least for the platforms that support OMTC today? Though plugins are going away, I suspect this may benefit GMPs and the CDM as well.", "attachment_id": null, "time": "2014-05-24T17:03:26Z", "creation_time": "2014-05-24T17:03:26Z", "is_private": false, "bug_id": 706499, "id": 8838109, "count": 33, "text": "Can we do this at least for the platforms that support OMTC today? Though plugins are going away, I suspect this may benefit GMPs and the CDM as well.", "author": "fb+mozdev@quantumedia.de", "creator": "fb+mozdev@quantumedia.de"}, {"attachment_id": null, "raw_text": "(In reply to Florian Bender from comment #33)\n> Can we do this at least for the platforms that support OMTC today? Though\n> plugins are going away, I suspect this may benefit GMPs and the CDM as well.\n\nWhat's the status/plan with Quantum and this bug now? Can we close this or are there actionable items left?", "time": "2017-09-01T20:22:48Z", "tags": [], "author": "fb+mozdev@quantumedia.de", "count": 34, "text": "(In reply to Florian Bender from comment #33)\n> Can we do this at least for the platforms that support OMTC today? Though\n> plugins are going away, I suspect this may benefit GMPs and the CDM as well.\n\nWhat's the status/plan with Quantum and this bug now? Can we close this or are there actionable items left?", "creator": "fb+mozdev@quantumedia.de", "is_private": false, "creation_time": "2017-09-01T20:22:48Z", "id": 12621851, "bug_id": 706499}, {"tags": [], "time": "2017-09-01T20:45:51Z", "attachment_id": null, "raw_text": "I think we're covered for Flash, not sure there is much more we'd do here.", "bug_id": 706499, "id": 12621909, "is_private": false, "creation_time": "2017-09-01T20:45:51Z", "creator": "milaninbugzilla@gmail.com", "author": "milaninbugzilla@gmail.com", "count": 35, "text": "I think we're covered for Flash, not sure there is much more we'd do here."}, {"text": "I concur with Milan.", "count": 36, "author": "bas@basschouten.com", "creator": "bas@basschouten.com", "creation_time": "2017-09-04T04:09:30Z", "is_private": false, "bug_id": 706499, "id": 12626267, "raw_text": "I concur with Milan.", "attachment_id": null, "time": "2017-09-04T04:09:30Z", "tags": []}]}}}