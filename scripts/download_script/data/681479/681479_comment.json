{"bugs": {"681479": {"comments": [{"attachment_id": null, "raw_text": "In Bug 680847, the reporter presents a testcase that churns up a lot of FileReader objects each loading a few MB of data into memory.  This doesn't trigger GC, however, because those MB of memory are consumed in the DOM side of things, which leads to explosive memory growth.\n\nWe ran into a similar problem with Images a while back, but I couldn't find the bug.\n\nCCing some of the usual suspects for DOM/js gc interactions.", "time": "2011-08-23T21:39:51Z", "tags": [], "author": "khuey@kylehuey.com", "text": "In Bug 680847, the reporter presents a testcase that churns up a lot of FileReader objects each loading a few MB of data into memory.  This doesn't trigger GC, however, because those MB of memory are consumed in the DOM side of things, which leads to explosive memory growth.\n\nWe ran into a similar problem with Images a while back, but I couldn't find the bug.\n\nCCing some of the usual suspects for DOM/js gc interactions.", "count": 0, "creator": "khuey@kylehuey.com", "creation_time": "2011-08-23T21:39:51Z", "is_private": false, "bug_id": 681479, "id": 5673116}, {"author": "josh@joshmatthews.net", "text": "Created attachment 555214\nReport FileReader buffer sizes to JS context to encourage good GC practices.\n\nSomething along these lines?", "count": 1, "bug_id": 681479, "id": 5673188, "time": "2011-08-23T21:58:46Z", "raw_text": "Something along these lines?", "creator": "josh@joshmatthews.net", "is_private": false, "creation_time": "2011-08-23T21:58:46Z", "attachment_id": 555214, "tags": []}, {"is_private": false, "creation_time": "2011-08-23T22:00:46Z", "bug_id": 681479, "id": 5673196, "text": "Sorry, I wrote a patch too quickly. This would probably help for the bug in question, but I guess this bug would be about creating some sort of general system by which GCed objects could report some amount of non-GCed memory usage to encourage sensible GCing?", "count": 2, "author": "josh@joshmatthews.net", "creator": "josh@joshmatthews.net", "tags": [], "raw_text": "Sorry, I wrote a patch too quickly. This would probably help for the bug in question, but I guess this bug would be about creating some sort of general system by which GCed objects could report some amount of non-GCed memory usage to encourage sensible GCing?", "attachment_id": null, "time": "2011-08-23T22:00:46Z"}, {"is_private": false, "creation_time": "2011-08-23T22:01:29Z", "id": 5673197, "bug_id": 681479, "author": "khuey@kylehuey.com", "count": 3, "text": "Something like that (you want to report the delta, not the total amount) .... is that the canonical way to do this?", "creator": "khuey@kylehuey.com", "tags": [], "attachment_id": null, "raw_text": "Something like that (you want to report the delta, not the total amount) .... is that the canonical way to do this?", "time": "2011-08-23T22:01:29Z"}, {"creator": "khuey@kylehuey.com", "is_private": false, "creation_time": "2011-08-23T22:02:14Z", "attachment_id": null, "tags": [], "text": "(In reply to Josh Matthews [:jdm] from comment #2)\n> Sorry, I wrote a patch too quickly. This would probably help for the bug in\n> question, but I guess this bug would be about creating some sort of general\n> system by which GCed objects could report some amount of non-GCed memory\n> usage to encourage sensible GCing?\n\nRight.  If the solution is to one-off everything like that we can do that, but we seem to be running into this a fair amount.", "count": 4, "author": "khuey@kylehuey.com", "bug_id": 681479, "id": 5673200, "raw_text": "(In reply to Josh Matthews [:jdm] from comment #2)\n> Sorry, I wrote a patch too quickly. This would probably help for the bug in\n> question, but I guess this bug would be about creating some sort of general\n> system by which GCed objects could report some amount of non-GCed memory\n> usage to encourage sensible GCing?\n\nRight.  If the solution is to one-off everything like that we can do that, but we seem to be running into this a fair amount.", "time": "2011-08-23T22:02:14Z"}, {"raw_text": "We have a manual hack for this for canvas right now, fwiw.....  It does feel really nasty.  :(", "time": "2011-08-24T02:13:52Z", "author": "bzbarsky@mit.edu", "count": 5, "text": "We have a manual hack for this for canvas right now, fwiw.....  It does feel really nasty.  :(", "id": 5673849, "bug_id": 681479, "attachment_id": null, "tags": [], "creator": "bzbarsky@mit.edu", "creation_time": "2011-08-24T02:13:52Z", "is_private": false}, {"creator": "khuey@kylehuey.com", "creation_time": "2011-08-24T13:42:41Z", "is_private": false, "attachment_id": null, "tags": [], "author": "khuey@kylehuey.com", "text": "(In reply to Boris Zbarsky (:bz) from comment #5)\n> We have a manual hack for this for canvas right now, fwiw.....  It does feel\n> really nasty.  :(\n\nYeah, it's pretty ugly. :-/", "count": 6, "id": 5674746, "bug_id": 681479, "raw_text": "(In reply to Boris Zbarsky (:bz) from comment #5)\n> We have a manual hack for this for canvas right now, fwiw.....  It does feel\n> really nasty.  :(\n\nYeah, it's pretty ugly. :-/", "time": "2011-08-24T13:42:41Z"}, {"is_private": false, "creation_time": "2011-08-31T01:18:34Z", "bug_id": 681479, "id": 5689571, "author": "bill.mccloskey@gmail.com", "count": 7, "text": "It seems hard to come up with a solution to this problem that's actually good. Here's why I'm worried.\n\nOur basic malloc heuristic works as follows. We use a counter, M, to count how many bytes have been malloced since the last GC. If it reaches 128MB, we GC. A general solution to this problem would be to replace calls to malloc and free with JS_malloc and JS_free, since these will increment the counter. (You could use JS_updateMallocBytes, but it seems pretty hacky to me.)\n\nHowever, I think it's potentially bad if memory that we allocate via JS_malloc can be freed outside of a GC finalizer. The problem is that it's pretty easy to churn through 128MB and cause spurious GCs. I'm worried about code that looks like this:\n  for (...) { ... void *x = malloc(...); ... free(x); ... }\n(Not that we would write such a loop directly, but it's easy to create such patterns when lots of abstraction is involved.) The problem is that the malloc will increment M, but the free will not decrement it.\n\nLooking at the code in the bug, it seems like we only would want to use JS_malloc if the only reference to the file reader is from JS. Otherwise there is no way that a GC could free the memory. However, this seems impractical.\n\nSo I guess I would propose the following instead. We need a way to decrement the counter when a realloc or free happens. To do this, we need to be able to figure out how big the buffer is. We could require that this value be passed in explicitly to JS_realloc/JS_free. Or we could get the info out of jemalloc somehow.\n\nIf we did this, then we could start converting lots of malloc calls in the DOM over to JS_malloc. This seems like a somewhat general solution. It's a lot of work, though, and I'm not sure it's worth it. Patching these when they break doesn't seem like it's been too bad so far.", "creator": "bill.mccloskey@gmail.com", "tags": [], "attachment_id": null, "raw_text": "It seems hard to come up with a solution to this problem that's actually good. Here's why I'm worried.\n\nOur basic malloc heuristic works as follows. We use a counter, M, to count how many bytes have been malloced since the last GC. If it reaches 128MB, we GC. A general solution to this problem would be to replace calls to malloc and free with JS_malloc and JS_free, since these will increment the counter. (You could use JS_updateMallocBytes, but it seems pretty hacky to me.)\n\nHowever, I think it's potentially bad if memory that we allocate via JS_malloc can be freed outside of a GC finalizer. The problem is that it's pretty easy to churn through 128MB and cause spurious GCs. I'm worried about code that looks like this:\n  for (...) { ... void *x = malloc(...); ... free(x); ... }\n(Not that we would write such a loop directly, but it's easy to create such patterns when lots of abstraction is involved.) The problem is that the malloc will increment M, but the free will not decrement it.\n\nLooking at the code in the bug, it seems like we only would want to use JS_malloc if the only reference to the file reader is from JS. Otherwise there is no way that a GC could free the memory. However, this seems impractical.\n\nSo I guess I would propose the following instead. We need a way to decrement the counter when a realloc or free happens. To do this, we need to be able to figure out how big the buffer is. We could require that this value be passed in explicitly to JS_realloc/JS_free. Or we could get the info out of jemalloc somehow.\n\nIf we did this, then we could start converting lots of malloc calls in the DOM over to JS_malloc. This seems like a somewhat general solution. It's a lot of work, though, and I'm not sure it's worth it. Patching these when they break doesn't seem like it's been too bad so far.", "time": "2011-08-31T01:18:34Z"}, {"creator": "khuey@kylehuey.com", "text": "I thought about this some more on the plane back from the all hands.  The issue with decrementing the counter when the file reader is destroyed is that you run into the following scenario:\n\n- JS creates a FileReader which results in 20 MB of memory being allocated.\n- The FileReader tells the JS engine to advance the malloc counter by 20 MB.\n- Lets say the malloc counter is now at 50 MB.\n- Sometime later (after multiple GCs) the FileReader is destroyed.\n- The malloc counter is at 10 MB.\n- The FileReader tells the JS engine to advance the malloc counter by -20 MB.\n- The malloc counter is now at -10 MB.\n\nIt seems like what we really want to do is decrement the counter on free if there has been no GC since the allocation.  That sounds pretty hard.\n\nAlso, FWIW, the number of call sites on the DOM side that we're talking about here is pretty small.", "count": 8, "author": "khuey@kylehuey.com", "id": 5722139, "bug_id": 681479, "is_private": false, "creation_time": "2011-09-18T17:27:24Z", "time": "2011-09-18T17:27:24Z", "raw_text": "I thought about this some more on the plane back from the all hands.  The issue with decrementing the counter when the file reader is destroyed is that you run into the following scenario:\n\n- JS creates a FileReader which results in 20 MB of memory being allocated.\n- The FileReader tells the JS engine to advance the malloc counter by 20 MB.\n- Lets say the malloc counter is now at 50 MB.\n- Sometime later (after multiple GCs) the FileReader is destroyed.\n- The malloc counter is at 10 MB.\n- The FileReader tells the JS engine to advance the malloc counter by -20 MB.\n- The malloc counter is now at -10 MB.\n\nIt seems like what we really want to do is decrement the counter on free if there has been no GC since the allocation.  That sounds pretty hard.\n\nAlso, FWIW, the number of call sites on the DOM side that we're talking about here is pretty small.", "attachment_id": null, "tags": []}, {"time": "2011-09-19T00:38:51Z", "raw_text": "If we track frees, then we can make the malloc bytes heuristic work the same way as the normal GC scheduling heuristic. It works as follows:\n\nWe track the total number of bytes allocated by the GC in gcBytes. At the end of a GC, this holds the number of bytes of live data. We schedule another GC when gcBytes reaches three times this number. This allows us to bound the memory overhead of gabrage collection to a factor of 3.\n\nIf we track frees, we can do the same thing with malloc bytes. We would not reset malloc bytes during GC, so it could never hit a negative value.", "attachment_id": null, "tags": [], "creator": "bill.mccloskey@gmail.com", "count": 9, "text": "If we track frees, then we can make the malloc bytes heuristic work the same way as the normal GC scheduling heuristic. It works as follows:\n\nWe track the total number of bytes allocated by the GC in gcBytes. At the end of a GC, this holds the number of bytes of live data. We schedule another GC when gcBytes reaches three times this number. This allows us to bound the memory overhead of gabrage collection to a factor of 3.\n\nIf we track frees, we can do the same thing with malloc bytes. We would not reset malloc bytes during GC, so it could never hit a negative value.", "author": "bill.mccloskey@gmail.com", "id": 5722390, "bug_id": 681479, "is_private": false, "creation_time": "2011-09-19T00:38:51Z"}, {"creator": "bill.mccloskey@gmail.com", "count": 10, "text": "I checked in bug 730447. We should start using this API in the browser instead of JS_updateMallocCounter.", "author": "bill.mccloskey@gmail.com", "bug_id": 681479, "id": 6124735, "is_private": false, "creation_time": "2012-03-08T17:34:35Z", "time": "2012-03-08T17:34:35Z", "raw_text": "I checked in bug 730447. We should start using this API in the browser instead of JS_updateMallocCounter.", "attachment_id": null, "tags": []}, {"creator": "bug-husbandry-bot@mozilla.bugs", "author": "bug-husbandry-bot@mozilla.bugs", "count": 11, "text": "https://bugzilla.mozilla.org/show_bug.cgi?id=1472046\n\nMove all DOM bugs that haven't been updated in more than 3 years and has no one currently assigned to P5.\n\nIf you have questions, please contact :mdaly.", "bug_id": 681479, "id": 13435418, "is_private": false, "creation_time": "2018-06-29T04:40:26Z", "time": "2018-06-29T04:40:26Z", "attachment_id": null, "raw_text": "https://bugzilla.mozilla.org/show_bug.cgi?id=1472046\n\nMove all DOM bugs that haven't been updated in more than 3 years and has no one currently assigned to P5.\n\nIf you have questions, please contact :mdaly.", "tags": []}]}}, "comments": {}}