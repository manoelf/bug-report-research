{"comments": {}, "bugs": {"665672": {"comments": [{"raw_text": "at some point someone provided noxpcom versions of the methods for this interface and started using them in msaa/ and atk/ so lets finish moving the interface off nsAccessible", "attachment_id": null, "id": 5543527, "count": 0, "is_private": false, "creator": "tbsaunde+mozbugs@tbsaunde.org", "text": "at some point someone provided noxpcom versions of the methods for this interface and started using them in msaa/ and atk/ so lets finish moving the interface off nsAccessible", "tags": [], "time": "2011-06-20T20:28:56Z", "bug_id": 665672, "creation_time": "2011-06-20T20:28:56Z", "author": "tbsaunde+mozbugs@tbsaunde.org"}, {"author": "tbsaunde+mozbugs@tbsaunde.org", "creation_time": "2011-06-20T20:36:40Z", "time": "2011-06-20T20:36:40Z", "tags": [], "text": "Created attachment 540582\nwip\n\n- create xpcom/nsHyperLinkAccessible.{cpp,h} containing an xpcom class nsHyperLinkAccessible that implements nsIAccesssibleHyperLink by calling the nonxpcom methods on nsAccessible.\n\nI think we'll need to change the way some classes that always implement nsIAccessibleHyperLink implement QueryInterface().", "creator": "tbsaunde+mozbugs@tbsaunde.org", "is_private": false, "id": 5543548, "attachment_id": 540582, "raw_text": "- create xpcom/nsHyperLinkAccessible.{cpp,h} containing an xpcom class nsHyperLinkAccessible that implements nsIAccesssibleHyperLink by calling the nonxpcom methods on nsAccessible.\n\nI think we'll need to change the way some classes that always implement nsIAccessibleHyperLink implement QueryInterface().", "bug_id": 665672, "count": 1}, {"creator": "surkov.alexander@gmail.com", "is_private": false, "count": 2, "author": "surkov.alexander@gmail.com", "creation_time": "2011-06-21T05:17:31Z", "bug_id": 665672, "time": "2011-06-21T05:17:31Z", "tags": [], "text": "I'm not sure I like the idea to create new object every time when it was requested.", "attachment_id": null, "raw_text": "I'm not sure I like the idea to create new object every time when it was requested.", "id": 5544592}, {"attachment_id": null, "raw_text": "(In reply to comment #2)\n> I'm not sure I like the idea to create new object every time when it was\n> requested.\n\nthat's fine, how about we keep a pointer to one we create on the first request in nsAccessible?\n\nalso, does it seem reasonable to write some temporary qi impls where we currntly use macro ones so that we return the object we want not ourselves?", "id": 5544604, "creator": "tbsaunde+mozbugs@tbsaunde.org", "is_private": false, "author": "tbsaunde+mozbugs@tbsaunde.org", "creation_time": "2011-06-21T05:34:41Z", "tags": [], "time": "2011-06-21T05:34:41Z", "text": "(In reply to comment #2)\n> I'm not sure I like the idea to create new object every time when it was\n> requested.\n\nthat's fine, how about we keep a pointer to one we create on the first request in nsAccessible?\n\nalso, does it seem reasonable to write some temporary qi impls where we currntly use macro ones so that we return the object we want not ourselves?", "count": 3, "bug_id": 665672}, {"raw_text": "(In reply to comment #3)\n> (In reply to comment #2)\n> > I'm not sure I like the idea to create new object every time when it was\n> > requested.\n> \n> that's fine, how about we keep a pointer to one we create on the first\n> request in nsAccessible?\n\ndon't like either. I want to keep xpcom implementation separately from internal objects.\n\n> also, does it seem reasonable to write some temporary qi impls where we\n> currntly use macro ones so that we return the object we want not ourselves?\n\nI don't see real advantages in our case to not use the same object for querying.", "attachment_id": null, "id": 5544610, "count": 4, "is_private": false, "creator": "surkov.alexander@gmail.com", "text": "(In reply to comment #3)\n> (In reply to comment #2)\n> > I'm not sure I like the idea to create new object every time when it was\n> > requested.\n> \n> that's fine, how about we keep a pointer to one we create on the first\n> request in nsAccessible?\n\ndon't like either. I want to keep xpcom implementation separately from internal objects.\n\n> also, does it seem reasonable to write some temporary qi impls where we\n> currntly use macro ones so that we return the object we want not ourselves?\n\nI don't see real advantages in our case to not use the same object for querying.", "tags": [], "time": "2011-06-21T05:50:33Z", "bug_id": 665672, "creation_time": "2011-06-21T05:50:33Z", "author": "surkov.alexander@gmail.com"}, {"is_private": false, "creator": "tbsaunde+mozbugs@tbsaunde.org", "count": 5, "creation_time": "2011-06-24T06:44:14Z", "author": "tbsaunde+mozbugs@tbsaunde.org", "text": "Created attachment 541614\nadd a cache for xpcom accessibles", "tags": [], "bug_id": 665672, "time": "2011-06-24T06:44:14Z", "attachment_id": 541614, "raw_text": "", "id": 5553376}, {"bug_id": 665672, "count": 6, "id": 5553377, "attachment_id": 541615, "raw_text": "", "creation_time": "2011-06-24T06:44:18Z", "author": "tbsaunde+mozbugs@tbsaunde.org", "text": "Created attachment 541615\nbug 665672 - move nsIAccessibleHyperLink off nsAccessible", "tags": [], "time": "2011-06-24T06:44:18Z", "is_private": false, "creator": "tbsaunde+mozbugs@tbsaunde.org"}, {"count": 7, "is_private": false, "creator": "tbsaunde+mozbugs@tbsaunde.org", "text": "Created attachment 541617\nbuild fixes and  start using cached xpcom accessibles", "time": "2011-06-24T06:54:25Z", "bug_id": 665672, "tags": [], "creation_time": "2011-06-24T06:54:25Z", "author": "tbsaunde+mozbugs@tbsaunde.org", "raw_text": "", "attachment_id": 541617, "id": 5553389}, {"count": 8, "bug_id": 665672, "creator": "surkov.alexander@gmail.com", "is_private": false, "time": "2011-06-24T06:59:06Z", "tags": [], "text": "Comment on attachment 541617\nbuild fixes and  start using cached xpcom accessibles\n\nthis patch is based on something and doesn't provide whole picture", "author": "surkov.alexander@gmail.com", "creation_time": "2011-06-24T06:59:06Z", "raw_text": "this patch is based on something and doesn't provide whole picture", "attachment_id": 541617, "id": 5553399}, {"raw_text": "(In reply to comment #8)\n> Comment on attachment 541617 [details] [review]\n> build fixes and  start using cached xpcom accessibles\n> \n> this patch is based on something and doesn't provide whole picture\n\nyes, the other two patches I just attached, together hopefully there's more of a picture if its easier I can give you one patch containing all three.", "attachment_id": null, "id": 5553427, "count": 9, "creator": "tbsaunde+mozbugs@tbsaunde.org", "is_private": false, "bug_id": 665672, "time": "2011-06-24T07:25:58Z", "tags": [], "text": "(In reply to comment #8)\n> Comment on attachment 541617 [details] [review]\n> build fixes and  start using cached xpcom accessibles\n> \n> this patch is based on something and doesn't provide whole picture\n\nyes, the other two patches I just attached, together hopefully there's more of a picture if its easier I can give you one patch containing all three.", "author": "tbsaunde+mozbugs@tbsaunde.org", "creation_time": "2011-06-24T07:25:58Z"}, {"creator": "surkov.alexander@gmail.com", "is_private": false, "count": 10, "author": "surkov.alexander@gmail.com", "creation_time": "2011-06-24T07:33:19Z", "time": "2011-06-24T07:33:19Z", "tags": [], "bug_id": 665672, "text": "maybe not neccessary. So you suggest to have one big object that has implementation of all XPCOM interfaces?", "attachment_id": null, "raw_text": "maybe not neccessary. So you suggest to have one big object that has implementation of all XPCOM interfaces?", "id": 5553439}, {"author": "tbsaunde+mozbugs@tbsaunde.org", "creation_time": "2011-06-24T08:03:37Z", "time": "2011-06-24T08:03:37Z", "tags": [], "text": "(In reply to comment #10)\n> maybe not neccessary. So you suggest to have one big object that has\n> implementation of all XPCOM interfaces?\n\nwell, atleast those implemented  on nsAccessNode and children.  That should be more efficient since we'll only ever have one  xpcom object for each accessible, and it may also cut down the header boilerplate we'd need if each interface  got its own class / object.", "creator": "tbsaunde+mozbugs@tbsaunde.org", "is_private": false, "id": 5553455, "attachment_id": null, "raw_text": "(In reply to comment #10)\n> maybe not neccessary. So you suggest to have one big object that has\n> implementation of all XPCOM interfaces?\n\nwell, atleast those implemented  on nsAccessNode and children.  That should be more efficient since we'll only ever have one  xpcom object for each accessible, and it may also cut down the header boilerplate we'd need if each interface  got its own class / object.", "bug_id": 665672, "count": 11}, {"creator": "surkov.alexander@gmail.com", "is_private": false, "count": 12, "author": "surkov.alexander@gmail.com", "creation_time": "2011-06-24T09:37:42Z", "bug_id": 665672, "tags": [], "time": "2011-06-24T09:37:42Z", "text": "(In reply to comment #11)\n> (In reply to comment #10)\n> > maybe not neccessary. So you suggest to have one big object that has\n> > implementation of all XPCOM interfaces?\n> \n> well, atleast those implemented  on nsAccessNode and children.\n\nI meant any kind of XPCOM interface, like table and etc. Can you show me class hierarchy for xpcom objects you keep in mind?", "attachment_id": null, "raw_text": "(In reply to comment #11)\n> (In reply to comment #10)\n> > maybe not neccessary. So you suggest to have one big object that has\n> > implementation of all XPCOM interfaces?\n> \n> well, atleast those implemented  on nsAccessNode and children.\n\nI meant any kind of XPCOM interface, like table and etc. Can you show me class hierarchy for xpcom objects you keep in mind?", "id": 5553585}, {"count": 13, "bug_id": 665672, "is_private": false, "creator": "tbsaunde+mozbugs@tbsaunde.org", "creation_time": "2011-06-24T09:58:27Z", "author": "tbsaunde+mozbugs@tbsaunde.org", "text": "(In reply to comment #12)\n> (In reply to comment #11)\n> > (In reply to comment #10)\n> > > maybe not neccessary. So you suggest to have one big object that has\n> > > implementation of all XPCOM interfaces?\n> > \n> > well, atleast those implemented  on nsAccessNode and children.\n> \n> I meant any kind of XPCOM interface, like table and etc. Can you show me\n> class hierarchy for xpcom objects you keep in mind?\n\nI mean XPCOMAccessible would implement nsIAccessNode nsIAccessibleTable nsIAccessibleTableCell nsIAccessibleApplication etc, just not nsIAccessible relation nsIAccessibilityService nsIAccessibleProvider  does that make more sense?  basically all the ones it would make sense to exist on an accessible but not the other ones we have.", "tags": [], "time": "2011-06-24T09:58:27Z", "attachment_id": null, "raw_text": "(In reply to comment #12)\n> (In reply to comment #11)\n> > (In reply to comment #10)\n> > > maybe not neccessary. So you suggest to have one big object that has\n> > > implementation of all XPCOM interfaces?\n> > \n> > well, atleast those implemented  on nsAccessNode and children.\n> \n> I meant any kind of XPCOM interface, like table and etc. Can you show me\n> class hierarchy for xpcom objects you keep in mind?\n\nI mean XPCOMAccessible would implement nsIAccessNode nsIAccessibleTable nsIAccessibleTableCell nsIAccessibleApplication etc, just not nsIAccessible relation nsIAccessibilityService nsIAccessibleProvider  does that make more sense?  basically all the ones it would make sense to exist on an accessible but not the other ones we have.", "id": 5553623}, {"id": 5553644, "attachment_id": null, "raw_text": "It should be ok until xpcom interfaces impl requires to keep members. Do you think to keep all interface implementation in one file or keeping them in different classes and then use multiple inheritance?", "creation_time": "2011-06-24T10:08:24Z", "author": "surkov.alexander@gmail.com", "text": "It should be ok until xpcom interfaces impl requires to keep members. Do you think to keep all interface implementation in one file or keeping them in different classes and then use multiple inheritance?", "tags": [], "time": "2011-06-24T10:08:24Z", "is_private": false, "creator": "surkov.alexander@gmail.com", "bug_id": 665672, "count": 14}, {"raw_text": "Alex, tell me if you'd like me to change how these are broken up, but I'd like to see what you think of this implementation of the cache and what you want done differently :-)", "attachment_id": 541614, "id": 5563713, "is_private": false, "creator": "tbsaunde+mozbugs@tbsaunde.org", "text": "Comment on attachment 541614\nadd a cache for xpcom accessibles\n\nAlex, tell me if you'd like me to change how these are broken up, but I'd like to see what you think of this implementation of the cache and what you want done differently :-)", "time": "2011-06-29T03:51:00Z", "tags": [], "creation_time": "2011-06-29T03:51:00Z", "author": "tbsaunde+mozbugs@tbsaunde.org", "count": 15, "bug_id": 665672}, {"id": 5563886, "attachment_id": null, "raw_text": "the approach should be fine, except I don't like many thousand lines files (isn't multiple inheritance approach nicer?)", "author": "surkov.alexander@gmail.com", "creation_time": "2011-06-29T07:13:34Z", "tags": [], "time": "2011-06-29T07:13:34Z", "text": "the approach should be fine, except I don't like many thousand lines files (isn't multiple inheritance approach nicer?)", "creator": "surkov.alexander@gmail.com", "is_private": false, "bug_id": 665672, "count": 16}, {"bug_id": 665672, "count": 17, "creation_time": "2011-06-29T07:31:12Z", "author": "tbsaunde+mozbugs@tbsaunde.org", "text": "(In reply to comment #16)\n> the approach should be fine, except I don't like many thousand lines files\n> (isn't multiple inheritance approach nicer?)\n\nCould you explain the multiple inheritance idea? I roughly see that we could have one xpcom class that's just nsIAccessible implementor and something that inherits from that for nsIAccessible table as a second xpcom class, but wouldn't this lead to need for a lot of classes? supose you have an accessible that should implement nsIAccessibleHyperText nsIAccessibleTableCell and nsIAccessible?  \n\nI think we should only have one xpcom object per each accessible for memory reasons, but other than that I'm happy to consider other ways.    That's why for example I didn't take the route of having a class for each interface, and each accessible would have as many objects as implemented interfaces.\n\nI'm not aware of any rule that says all the implementation of a class must be in one file, so in this case it might be reasonable to have the implementation of each interfaces functions in a different cpp file, but all would belong to one class.\n\nI think this should be nice, but I think in general we'd prefer to just work with the code outside of xpcom/ and leave this code alone right?", "time": "2011-06-29T07:31:12Z", "tags": [], "is_private": false, "creator": "tbsaunde+mozbugs@tbsaunde.org", "id": 5563905, "attachment_id": null, "raw_text": "(In reply to comment #16)\n> the approach should be fine, except I don't like many thousand lines files\n> (isn't multiple inheritance approach nicer?)\n\nCould you explain the multiple inheritance idea? I roughly see that we could have one xpcom class that's just nsIAccessible implementor and something that inherits from that for nsIAccessible table as a second xpcom class, but wouldn't this lead to need for a lot of classes? supose you have an accessible that should implement nsIAccessibleHyperText nsIAccessibleTableCell and nsIAccessible?  \n\nI think we should only have one xpcom object per each accessible for memory reasons, but other than that I'm happy to consider other ways.    That's why for example I didn't take the route of having a class for each interface, and each accessible would have as many objects as implemented interfaces.\n\nI'm not aware of any rule that says all the implementation of a class must be in one file, so in this case it might be reasonable to have the implementation of each interfaces functions in a different cpp file, but all would belong to one class.\n\nI think this should be nice, but I think in general we'd prefer to just work with the code outside of xpcom/ and leave this code alone right?"}, {"id": 5563932, "attachment_id": null, "raw_text": "for multiple inheritance we could have one class for one interface, then we have several classes, each is for set of interfaces, similar to IA2 implementation.\n\nIn this case objects should take less memory than having one big objects. Correct?", "author": "surkov.alexander@gmail.com", "creation_time": "2011-06-29T08:00:15Z", "time": "2011-06-29T08:00:15Z", "tags": [], "bug_id": 665672, "text": "for multiple inheritance we could have one class for one interface, then we have several classes, each is for set of interfaces, similar to IA2 implementation.\n\nIn this case objects should take less memory than having one big objects. Correct?", "creator": "surkov.alexander@gmail.com", "is_private": false, "count": 18}, {"count": 19, "bug_id": 665672, "is_private": false, "creator": "tbsaunde+mozbugs@tbsaunde.org", "creation_time": "2011-06-29T10:54:29Z", "author": "tbsaunde+mozbugs@tbsaunde.org", "text": "(In reply to comment #18)\n> for multiple inheritance we could have one class for one interface, then we\n> have several classes, each is for set of interfaces, similar to IA2\n> implementation.\n\nyou mean  the tearoffish things for CAccessibleHyperalsam\nyou mean like the way \n> \n> In this case objects should take less memory than having one big objects.\n> Correct?", "tags": [], "time": "2011-06-29T10:54:29Z", "attachment_id": null, "raw_text": "(In reply to comment #18)\n> for multiple inheritance we could have one class for one interface, then we\n> have several classes, each is for set of interfaces, similar to IA2\n> implementation.\n\nyou mean  the tearoffish things for CAccessibleHyperalsam\nyou mean like the way \n> \n> In this case objects should take less memory than having one big objects.\n> Correct?", "id": 5564113}, {"bug_id": 665672, "count": 20, "time": "2011-07-05T18:38:47Z", "tags": [], "text": "(In reply to comment #18)\n> for multiple inheritance we could have one class for one interface, then we\n> have several classes, each is for set of interfaces, similar to IA2\n> implementation.\n> \n> In this case objects should take less memory than having one big objects.\n> Correct?\n\nno, I think it would be the same as 1 big class module the number of vtables.  either way you have one class that  ends up implementing all the interfaces either through inheritance or not, and has one member the pointer to the native accessible right?\n\ncurrently it seems like this approach would be worse, because you have to downcast this to the class that iplements  all the interfaces, and has the pointer to the accessible.  We wouldn't neccessarily need to use do_QueryObject() like we do in msaa/ now but we'd need something which would add to the amount of code we'd need, and maybe hurt perf a little.", "author": "tbsaunde+mozbugs@tbsaunde.org", "creation_time": "2011-07-05T18:38:47Z", "creator": "tbsaunde+mozbugs@tbsaunde.org", "is_private": false, "id": 5574439, "raw_text": "(In reply to comment #18)\n> for multiple inheritance we could have one class for one interface, then we\n> have several classes, each is for set of interfaces, similar to IA2\n> implementation.\n> \n> In this case objects should take less memory than having one big objects.\n> Correct?\n\nno, I think it would be the same as 1 big class module the number of vtables.  either way you have one class that  ends up implementing all the interfaces either through inheritance or not, and has one member the pointer to the native accessible right?\n\ncurrently it seems like this approach would be worse, because you have to downcast this to the class that iplements  all the interfaces, and has the pointer to the accessible.  We wouldn't neccessarily need to use do_QueryObject() like we do in msaa/ now but we'd need something which would add to the amount of code we'd need, and maybe hurt perf a little.", "attachment_id": null}, {"count": 21, "bug_id": 665672, "creator": "surkov.alexander@gmail.com", "is_private": false, "author": "surkov.alexander@gmail.com", "creation_time": "2011-07-11T04:43:25Z", "tags": [], "time": "2011-07-11T04:43:25Z", "text": "(In reply to comment #20)\n> (In reply to comment #18)\n> > for multiple inheritance we could have one class for one interface, then we\n> > have several classes, each is for set of interfaces, similar to IA2\n> > implementation.\n> > \n> > In this case objects should take less memory than having one big objects.\n> > Correct?\n> \n> no, I think it would be the same as 1 big class module the number of\n> vtables.  either way you have one class that  ends up implementing all the\n> interfaces either through inheritance or not, and has one member the pointer\n> to the native accessible right?\n\nIt's not evident why we should end up with one class implementing all interfaces. \n\nFollowing this way all XPCOM objects will have the same size, i.e. 11 (amount of interfaces) + 1 (pointer to native object). Taking into account that most objects need to implement 1 interface (combined version of nsIAccessible + nsIAccessNode), we have 48 vs 8 bytes per each object on 32 bit systems. That's not what we can do.\n\n> currently it seems like this approach would be worse, because you have to\n> downcast this to the class that iplements  all the interfaces, and has the\n> pointer to the accessible.  We wouldn't neccessarily need to use\n> do_QueryObject() like we do in msaa/ now but we'd need something which would\n> add to the amount of code we'd need, and maybe hurt perf a little.\n\nwe always deal with memory savings vs perf. In this case I don't think downcasting hits a perf really (trivial if and static cast).", "attachment_id": null, "raw_text": "(In reply to comment #20)\n> (In reply to comment #18)\n> > for multiple inheritance we could have one class for one interface, then we\n> > have several classes, each is for set of interfaces, similar to IA2\n> > implementation.\n> > \n> > In this case objects should take less memory than having one big objects.\n> > Correct?\n> \n> no, I think it would be the same as 1 big class module the number of\n> vtables.  either way you have one class that  ends up implementing all the\n> interfaces either through inheritance or not, and has one member the pointer\n> to the native accessible right?\n\nIt's not evident why we should end up with one class implementing all interfaces. \n\nFollowing this way all XPCOM objects will have the same size, i.e. 11 (amount of interfaces) + 1 (pointer to native object). Taking into account that most objects need to implement 1 interface (combined version of nsIAccessible + nsIAccessNode), we have 48 vs 8 bytes per each object on 32 bit systems. That's not what we can do.\n\n> currently it seems like this approach would be worse, because you have to\n> downcast this to the class that iplements  all the interfaces, and has the\n> pointer to the accessible.  We wouldn't neccessarily need to use\n> do_QueryObject() like we do in msaa/ now but we'd need something which would\n> add to the amount of code we'd need, and maybe hurt perf a little.\n\nwe always deal with memory savings vs perf. In this case I don't think downcasting hits a perf really (trivial if and static cast).", "id": 5583876}, {"text": "(In reply to comment #21)\n\n> we have 48 vs 8 bytes per each object on 32\n> bit systems.\n\nactually I speculated by numbers, most of objects are hypertext object but anyway they don't implement half of interfaces (like table, tablecell, image, value, application, document, selectable interfaces).", "tags": [], "time": "2011-07-11T04:52:20Z", "creation_time": "2011-07-11T04:52:20Z", "author": "surkov.alexander@gmail.com", "is_private": false, "creator": "surkov.alexander@gmail.com", "id": 5583880, "raw_text": "(In reply to comment #21)\n\n> we have 48 vs 8 bytes per each object on 32\n> bit systems.\n\nactually I speculated by numbers, most of objects are hypertext object but anyway they don't implement half of interfaces (like table, tablecell, image, value, application, document, selectable interfaces).", "attachment_id": null, "bug_id": 665672, "count": 22}, {"id": 5592920, "raw_text": "approach multiple classes for accessibles that implement different interfaces.\nso, one class XPCOMAccessible implements nsIAccessible\nmultiple classes inherit from XPCOMAccessible one for objects that should implment nsIAccessibleTable a different class for nsIAccessibleFooText\nto do this  we'll probably need to only have a few of this types because nsIAccessibleHyperText and nsIAccessibleEditableText need to be implemented on the same object, but nsIAccessibleTable shouldn't need to be on that object same with TableCell or Value.", "attachment_id": 546093, "tags": [], "time": "2011-07-15T03:56:25Z", "bug_id": 665672, "text": "Created attachment 546093\nwip\n\napproach multiple classes for accessibles that implement different interfaces.\nso, one class XPCOMAccessible implements nsIAccessible\nmultiple classes inherit from XPCOMAccessible one for objects that should implment nsIAccessibleTable a different class for nsIAccessibleFooText\nto do this  we'll probably need to only have a few of this types because nsIAccessibleHyperText and nsIAccessibleEditableText need to be implemented on the same object, but nsIAccessibleTable shouldn't need to be on that object same with TableCell or Value.", "author": "tbsaunde+mozbugs@tbsaunde.org", "creation_time": "2011-07-15T03:56:25Z", "count": 23, "creator": "tbsaunde+mozbugs@tbsaunde.org", "is_private": false}, {"id": 5592946, "raw_text": "based on our irc chat and latest patch to make sure we talk about same things:\n\n1) introduce xpClass that implements one of set of xpcom interfaces (can be inherited from each other), for example, xpAccessible (nsIAccessible, nsIAccessibleHyperLink), xpHyperTextAccessible (nsIAccessibleText, nsIAccessibleEditableText and etc), xpTableAccessible (nsIAccessibleTable). These are bricks to build final classes.\n\n2) introduce nsClass that are inherited from xpClass, for example, nsARIAGridAccessible inherited from xpTableAccessible and xpHyperTextAccessible. Classes that conincide with xp classes can be defined as typedefs.\n\n3) xpClass and nsClass are template that take native class, that allows to avoid downcasting. Native class knows final type of nsClass and responsible to create nsClass instance (is there better option)?\n\n4) root accessible manages the cache of xpcom objects", "attachment_id": null, "text": "based on our irc chat and latest patch to make sure we talk about same things:\n\n1) introduce xpClass that implements one of set of xpcom interfaces (can be inherited from each other), for example, xpAccessible (nsIAccessible, nsIAccessibleHyperLink), xpHyperTextAccessible (nsIAccessibleText, nsIAccessibleEditableText and etc), xpTableAccessible (nsIAccessibleTable). These are bricks to build final classes.\n\n2) introduce nsClass that are inherited from xpClass, for example, nsARIAGridAccessible inherited from xpTableAccessible and xpHyperTextAccessible. Classes that conincide with xp classes can be defined as typedefs.\n\n3) xpClass and nsClass are template that take native class, that allows to avoid downcasting. Native class knows final type of nsClass and responsible to create nsClass instance (is there better option)?\n\n4) root accessible manages the cache of xpcom objects", "tags": [], "time": "2011-07-15T04:26:48Z", "creation_time": "2011-07-15T04:26:48Z", "author": "surkov.alexander@gmail.com", "is_private": false, "creator": "surkov.alexander@gmail.com", "bug_id": 665672, "count": 24}, {"bug_id": 665672, "count": 25, "id": 5592952, "attachment_id": null, "raw_text": "> \n> 2) introduce nsClass that are inherited from xpClass, for example,\n> nsARIAGridAccessible inherited from xpTableAccessible and\n> xpHyperTextAccessible. Classes that conincide with xp classes can be defined\n\ndoes it actually make sense for the grid itself to be both a table and have text? (just a nit pick for the example not general question)\n\n> as typedefs.\n\nok, I think the generally makes sense, but lets implement this as we have  interfaces we can move off native accessibles and see how it goes.\n\n> 3) xpClass and nsClass are template that take native class, that allows to\n> avoid downcasting. Native class knows final type of nsClass and responsible\n\ni'M NOT SURE THE TEMPLATING IS NEEDED.  i  WAS THINKING WE'D  have all classes inherit from one class that holds the pointer to the non xpcom accessible then we could just use accessible downcasting on it to get the interface we need  which should be pretty fast since in many cases that downcast will just be a check of mFlags inlined.\n\n> to create nsClass instance (is there better option)?\n\nwhen everything is done, I think the only place we need to be able to create xpcom accessibles is  in the impl for nsIAccessibilityService for java script and whoever else outside of our code wants to use the service.", "creation_time": "2011-07-15T04:42:21Z", "author": "tbsaunde+mozbugs@tbsaunde.org", "text": "> \n> 2) introduce nsClass that are inherited from xpClass, for example,\n> nsARIAGridAccessible inherited from xpTableAccessible and\n> xpHyperTextAccessible. Classes that conincide with xp classes can be defined\n\ndoes it actually make sense for the grid itself to be both a table and have text? (just a nit pick for the example not general question)\n\n> as typedefs.\n\nok, I think the generally makes sense, but lets implement this as we have  interfaces we can move off native accessibles and see how it goes.\n\n> 3) xpClass and nsClass are template that take native class, that allows to\n> avoid downcasting. Native class knows final type of nsClass and responsible\n\ni'M NOT SURE THE TEMPLATING IS NEEDED.  i  WAS THINKING WE'D  have all classes inherit from one class that holds the pointer to the non xpcom accessible then we could just use accessible downcasting on it to get the interface we need  which should be pretty fast since in many cases that downcast will just be a check of mFlags inlined.\n\n> to create nsClass instance (is there better option)?\n\nwhen everything is done, I think the only place we need to be able to create xpcom accessibles is  in the impl for nsIAccessibilityService for java script and whoever else outside of our code wants to use the service.", "tags": [], "time": "2011-07-15T04:42:21Z", "is_private": false, "creator": "tbsaunde+mozbugs@tbsaunde.org"}, {"creator": "surkov.alexander@gmail.com", "is_private": false, "count": 26, "author": "surkov.alexander@gmail.com", "creation_time": "2011-07-15T05:06:14Z", "tags": [], "time": "2011-07-15T05:06:14Z", "bug_id": 665672, "text": "(In reply to comment #25)\n> > \n> > 2) introduce nsClass that are inherited from xpClass, for example,\n> > nsARIAGridAccessible inherited from xpTableAccessible and\n> > xpHyperTextAccessible. Classes that conincide with xp classes can be defined\n> \n> does it actually make sense for the grid itself to be both a table and have\n> text? (just a nit pick for the example not general question)\n\nideally probably not, because of IA2 restrictions all tables should implement it (though we don't always follow it).\n\n> > as typedefs.\n> \n> ok, I think the generally makes sense, but lets implement this as we have \n> interfaces we can move off native accessibles and see how it goes.\n\nnot sure I share this point, we'd need to understand how we are going to implement.\n\n> > 3) xpClass and nsClass are template that take native class, that allows to\n> > avoid downcasting. Native class knows final type of nsClass and responsible\n> \n> i'M NOT SURE THE TEMPLATING IS NEEDED.  i  WAS THINKING WE'D  have all\n> classes inherit from one class that holds the pointer to the non xpcom\n> accessible then we could just use accessible downcasting on it to get the\n> interface we need  which should be pretty fast since in many cases that\n> downcast will just be a check of mFlags inlined.\n\nsure you can do downcasting but that sound strange since downcasting is just workaround the xpcom class doesn't know everything about native class. Templating is going to fix that. The approach assumes we have few or several template specializations so extra memory issue isn't a problem here.\n\n> > to create nsClass instance (is there better option)?\n> \n> when everything is done, I think the only place we need to be able to create\n> xpcom accessibles is  in the impl for nsIAccessibilityService for java\n> script and whoever else outside of our code wants to use the service.\n\nthat requires accessibility service to know which type of xpcom class the native class is going to use. Making native class to create xpcom object or provide a type of xpcom class (the second might be overkill) allows to avoid many ifs in accessibility service. Note, in your latest patch xpcom class type information is provided by native class. But you can avoid templates usage if native class creates it itself.", "attachment_id": null, "raw_text": "(In reply to comment #25)\n> > \n> > 2) introduce nsClass that are inherited from xpClass, for example,\n> > nsARIAGridAccessible inherited from xpTableAccessible and\n> > xpHyperTextAccessible. Classes that conincide with xp classes can be defined\n> \n> does it actually make sense for the grid itself to be both a table and have\n> text? (just a nit pick for the example not general question)\n\nideally probably not, because of IA2 restrictions all tables should implement it (though we don't always follow it).\n\n> > as typedefs.\n> \n> ok, I think the generally makes sense, but lets implement this as we have \n> interfaces we can move off native accessibles and see how it goes.\n\nnot sure I share this point, we'd need to understand how we are going to implement.\n\n> > 3) xpClass and nsClass are template that take native class, that allows to\n> > avoid downcasting. Native class knows final type of nsClass and responsible\n> \n> i'M NOT SURE THE TEMPLATING IS NEEDED.  i  WAS THINKING WE'D  have all\n> classes inherit from one class that holds the pointer to the non xpcom\n> accessible then we could just use accessible downcasting on it to get the\n> interface we need  which should be pretty fast since in many cases that\n> downcast will just be a check of mFlags inlined.\n\nsure you can do downcasting but that sound strange since downcasting is just workaround the xpcom class doesn't know everything about native class. Templating is going to fix that. The approach assumes we have few or several template specializations so extra memory issue isn't a problem here.\n\n> > to create nsClass instance (is there better option)?\n> \n> when everything is done, I think the only place we need to be able to create\n> xpcom accessibles is  in the impl for nsIAccessibilityService for java\n> script and whoever else outside of our code wants to use the service.\n\nthat requires accessibility service to know which type of xpcom class the native class is going to use. Making native class to create xpcom object or provide a type of xpcom class (the second might be overkill) allows to avoid many ifs in accessibility service. Note, in your latest patch xpcom class type information is provided by native class. But you can avoid templates usage if native class creates it itself.", "id": 5592984}, {"raw_text": "canceling review until we get an agreement", "attachment_id": 541614, "id": 5685030, "count": 27, "is_private": false, "creator": "surkov.alexander@gmail.com", "text": "Comment on attachment 541614\nadd a cache for xpcom accessibles\n\ncanceling review until we get an agreement", "time": "2011-08-29T15:59:02Z", "tags": [], "bug_id": 665672, "creation_time": "2011-08-29T15:59:02Z", "author": "surkov.alexander@gmail.com"}]}}}