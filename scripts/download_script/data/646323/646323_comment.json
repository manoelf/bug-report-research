{"bugs": {"646323": {"comments": [{"author": "kinetik@flim.org", "is_private": false, "id": 5379514, "creation_time": "2011-03-30T03:16:18Z", "tags": [], "attachment_id": null, "bug_id": 646323, "time": "2011-03-30T03:16:18Z", "count": 0, "raw_text": "There are a bunch of places in the media code where we cast (either old-style or static_cast) numeric types to smaller types, or from signed to unsigned types.  To ensure these are safe, it's necessary to check that the value being cast is in the range of the target type.\n\nBoost's numeric_cast does roughly what we want, so let's implement a simplified version that handles the conversions we use and included it in VideoUtils.h.  If it turns out to be more generally useful we can move it into xpcom/base sometime later.\n\nxpcom/ds/CheckedInt.h already provides most of the framework for this (including a replacement for std::numeric_limits, which apparently can't be used with PR types).", "creator": "kinetik@flim.org", "text": "There are a bunch of places in the media code where we cast (either old-style or static_cast) numeric types to smaller types, or from signed to unsigned types.  To ensure these are safe, it's necessary to check that the value being cast is in the range of the target type.\n\nBoost's numeric_cast does roughly what we want, so let's implement a simplified version that handles the conversions we use and included it in VideoUtils.h.  If it turns out to be more generally useful we can move it into xpcom/base sometime later.\n\nxpcom/ds/CheckedInt.h already provides most of the framework for this (including a replacement for std::numeric_limits, which apparently can't be used with PR types)."}, {"id": 7510358, "is_private": false, "count": 1, "time": "2013-06-07T16:37:54Z", "author": "peyrard.max43@gmail.com", "bug_id": 646323, "text": "Created attachment 759788\nExtension of mfbt/Casting.h to Floating type for overflow detection. Application and test in content/media\n\nThe patch is long because of the use of SafeCast in content/media the tests begin at line 765  and the code for Casting.h at 1530", "attachment_id": 759788, "tags": [], "creation_time": "2013-06-07T16:37:54Z", "creator": "peyrard.max43@gmail.com", "raw_text": "The patch is long because of the use of SafeCast in content/media the tests begin at line 765  and the code for Casting.h at 1530"}, {"bug_id": 646323, "text": "Comment on attachment 759788\nExtension of mfbt/Casting.h to Floating type for overflow detection. Application and test in content/media\n\nReview of attachment 759788:\n-----------------------------------------------------------------\n\nBefore we get to adding in floating-point behavior at all, you're misunderstanding how SafeCast works.  It takes a value of From type, asserts that that value is in To type's range, then casts to To.  (The current description is a little misleading -- it probably shouldn't talk about \"safe cast\" at all, only about whether the input value exists in the output type.)  But I see several casts here along the lines of SafeCast<uint16_t>(-1) -- and -1 is clearly not in uint16_t range.  So at least some of the casts here -- I saw some, probably missed others skimming -- are definitely wrong, and should remain as static_cast<>.\n\nPast that, I have concerns about your overall approach.  The existing SafeCast allows the cast *only* if the value will remain unchanged.  This is *not* the same as whether the cast only invokes defined behavior.  For example, static_cast<unsigned>(-1) is perfectly well-defined, but SafeCast<unsigned>(-1) is verboten.  Your patch checks whether the cast will only invoke defined behavior.  (I think; I haven't puzzled through all its intricacies, because of the other issues I see here.)  I'm pretty sure you accept SafeCast<int>(5.5), for example.\n\nI think we probably don't want SafeCast to truncate.  That's an actual numeric change; a method that may change the input value should be clear that it might do so.  Adding\n\ntemplate<typename To, typename From>\ninline To\nTruncate(const From from);\n\nto FloatingPoint.h, that returns a truncated value (and asserts if given Nan or an infinity or a number that, after truncation, is out of range)  seems preferable to me.  If SafeCast should accept floating point types as well as integral, I think it should only do so if the input value is exactly the output value.\n\nAssuming you want to push forward with making SafeCast accept floating-point types so long as the conversion would be exact, and with some sort of separate Truncate method might change the input value, in the process of converting it, I'd appreciate if you kept the Casting.h/TestCasting.cpp changes in a separate patch from all the uses.  I'd like to look at both, but it'd be nice to sort through the implementation bits without being distracted by the uses at the same time.\n\n::: content/media/gstreamer/GStreamerFormatHelper.cpp\n@@ +53,4 @@\n>  \n>  GStreamerFormatHelper::GStreamerFormatHelper()\n>    : mFactories(nullptr),\n> +    mCookie(SafeCast<uint32_t>(-1))\n\nNot actually okay.  :-)\n\n::: content/media/ogg/OggCodecState.cpp\n@@ +41,4 @@\n>  {\n>    uint32_t lo = LEUint32(p);\n>    uint32_t hi = LEUint32(p + 4);\n> +  return SafeCast<int64_t>(lo) | (SafeCast<int64_t>(hi) << 32);\n\nPre-existing, but if |hi| has its highest bit set, this invokes undefined behavior.  Shifting a 1 into (or past) the sign bit in a signed type is a no-no.\n\nMore fundamentally, this method shouldn't exist.  This code wants mozilla::LittleEndian::readInt64 instead from mozilla/Endian.h.  All the callers should just be replaced with calls to that.  Same for LEUint32, LEUint16, and LEInt16.\n\n@@ +53,4 @@\n>  // Reads a little-endian encoded signed 16bit integer at p.\n>  static int16_t LEInt16(const unsigned char* p)\n>  {\n> +  return SafeCast<int16_t>(LEUint16(p));\n\nAnother misapprehension of what SafeCast does, which will assert if the high bit of the uint16_t that's read is set.\n\n::: content/media/omx/OmxDecoder.cpp\n@@ +120,4 @@\n>  status_t MediaStreamSource::getSize(off64_t *size)\n>  {\n>    uint64_t length = mResource->GetLength();\n> +  if (length == SafeCast<uint64_t>(-1))\n\nWon't work.\n\n::: content/media/test/TestSafeCast.cpp\n@@ +1,1 @@\n> +#include \"../../../xpcom/tests/TestHarness.h\"\n\nThis should be in mfbt/tests/, not here, following the pattern of those files.\n\n::: content/media/wave/WaveReader.cpp\n@@ +103,4 @@\n>    int16_t\n>    ReadInt16LE(const char** aBuffer)\n>    {\n> +    return SafeCast<int16_t>(ReadUint16LE(aBuffer));\n\nAll the methods here should be implemented in terms of mozilla::LittleEndian::readSomething.\n\n::: mfbt/Casting.h\n@@ +159,5 @@\n>  };\n>  \n> +\n> +// Conversion from floating point type to integral type\n> +enum FIToSigned { FIToIsSigned, FIToIsNotSigned };\n\nenum FToIntegral { FToSignedI, FToUnsignedI } would be better.\n\n@@ +162,5 @@\n> +// Conversion from floating point type to integral type\n> +enum FIToSigned { FIToIsSigned, FIToIsNotSigned };\n> +\n> +template<typename From, typename To,\n> +         bool FIToSigned = IsSigned<To>::value ? FIToIsSigned : FIToIsNotSigned>\n\nUse FToIntegral as the type of the param, not bool.", "attachment_id": 759788, "creation_time": "2013-06-21T01:07:37Z", "tags": [], "creator": "jwalden@mit.edu", "raw_text": "Review of attachment 759788:\n-----------------------------------------------------------------\n\nBefore we get to adding in floating-point behavior at all, you're misunderstanding how SafeCast works.  It takes a value of From type, asserts that that value is in To type's range, then casts to To.  (The current description is a little misleading -- it probably shouldn't talk about \"safe cast\" at all, only about whether the input value exists in the output type.)  But I see several casts here along the lines of SafeCast<uint16_t>(-1) -- and -1 is clearly not in uint16_t range.  So at least some of the casts here -- I saw some, probably missed others skimming -- are definitely wrong, and should remain as static_cast<>.\n\nPast that, I have concerns about your overall approach.  The existing SafeCast allows the cast *only* if the value will remain unchanged.  This is *not* the same as whether the cast only invokes defined behavior.  For example, static_cast<unsigned>(-1) is perfectly well-defined, but SafeCast<unsigned>(-1) is verboten.  Your patch checks whether the cast will only invoke defined behavior.  (I think; I haven't puzzled through all its intricacies, because of the other issues I see here.)  I'm pretty sure you accept SafeCast<int>(5.5), for example.\n\nI think we probably don't want SafeCast to truncate.  That's an actual numeric change; a method that may change the input value should be clear that it might do so.  Adding\n\ntemplate<typename To, typename From>\ninline To\nTruncate(const From from);\n\nto FloatingPoint.h, that returns a truncated value (and asserts if given Nan or an infinity or a number that, after truncation, is out of range)  seems preferable to me.  If SafeCast should accept floating point types as well as integral, I think it should only do so if the input value is exactly the output value.\n\nAssuming you want to push forward with making SafeCast accept floating-point types so long as the conversion would be exact, and with some sort of separate Truncate method might change the input value, in the process of converting it, I'd appreciate if you kept the Casting.h/TestCasting.cpp changes in a separate patch from all the uses.  I'd like to look at both, but it'd be nice to sort through the implementation bits without being distracted by the uses at the same time.\n\n::: content/media/gstreamer/GStreamerFormatHelper.cpp\n@@ +53,4 @@\n>  \n>  GStreamerFormatHelper::GStreamerFormatHelper()\n>    : mFactories(nullptr),\n> +    mCookie(SafeCast<uint32_t>(-1))\n\nNot actually okay.  :-)\n\n::: content/media/ogg/OggCodecState.cpp\n@@ +41,4 @@\n>  {\n>    uint32_t lo = LEUint32(p);\n>    uint32_t hi = LEUint32(p + 4);\n> +  return SafeCast<int64_t>(lo) | (SafeCast<int64_t>(hi) << 32);\n\nPre-existing, but if |hi| has its highest bit set, this invokes undefined behavior.  Shifting a 1 into (or past) the sign bit in a signed type is a no-no.\n\nMore fundamentally, this method shouldn't exist.  This code wants mozilla::LittleEndian::readInt64 instead from mozilla/Endian.h.  All the callers should just be replaced with calls to that.  Same for LEUint32, LEUint16, and LEInt16.\n\n@@ +53,4 @@\n>  // Reads a little-endian encoded signed 16bit integer at p.\n>  static int16_t LEInt16(const unsigned char* p)\n>  {\n> +  return SafeCast<int16_t>(LEUint16(p));\n\nAnother misapprehension of what SafeCast does, which will assert if the high bit of the uint16_t that's read is set.\n\n::: content/media/omx/OmxDecoder.cpp\n@@ +120,4 @@\n>  status_t MediaStreamSource::getSize(off64_t *size)\n>  {\n>    uint64_t length = mResource->GetLength();\n> +  if (length == SafeCast<uint64_t>(-1))\n\nWon't work.\n\n::: content/media/test/TestSafeCast.cpp\n@@ +1,1 @@\n> +#include \"../../../xpcom/tests/TestHarness.h\"\n\nThis should be in mfbt/tests/, not here, following the pattern of those files.\n\n::: content/media/wave/WaveReader.cpp\n@@ +103,4 @@\n>    int16_t\n>    ReadInt16LE(const char** aBuffer)\n>    {\n> +    return SafeCast<int16_t>(ReadUint16LE(aBuffer));\n\nAll the methods here should be implemented in terms of mozilla::LittleEndian::readSomething.\n\n::: mfbt/Casting.h\n@@ +159,5 @@\n>  };\n>  \n> +\n> +// Conversion from floating point type to integral type\n> +enum FIToSigned { FIToIsSigned, FIToIsNotSigned };\n\nenum FToIntegral { FToSignedI, FToUnsignedI } would be better.\n\n@@ +162,5 @@\n> +// Conversion from floating point type to integral type\n> +enum FIToSigned { FIToIsSigned, FIToIsNotSigned };\n> +\n> +template<typename From, typename To,\n> +         bool FIToSigned = IsSigned<To>::value ? FIToIsSigned : FIToIsNotSigned>\n\nUse FToIntegral as the type of the param, not bool.", "id": 7559710, "is_private": false, "count": 2, "author": "jwalden@mit.edu", "time": "2013-06-21T01:07:37Z"}, {"creator": "jwalden@mit.edu", "raw_text": "Nathan, do my thoughts on extending SafeCast to take To/From as floating point types, and adding a separate Truncate method (or some other name -- that's just what came to mind first) that might also change the input value in the conversion process, seem reasonable to you?", "attachment_id": null, "tags": [], "creation_time": "2013-06-21T01:09:37Z", "text": "Nathan, do my thoughts on extending SafeCast to take To/From as floating point types, and adding a separate Truncate method (or some other name -- that's just what came to mind first) that might also change the input value in the conversion process, seem reasonable to you?", "bug_id": 646323, "count": 3, "author": "jwalden@mit.edu", "time": "2013-06-21T01:09:37Z", "is_private": false, "id": 7559717}, {"count": 4, "time": "2013-06-21T15:08:45Z", "creator": "froydnj+bz@gmail.com", "raw_text": "(In reply to Jeff Walden [:Waldo] (remove +bmo to email) from comment #3)\n> Nathan, do my thoughts on extending SafeCast to take To/From as floating\n> point types, and adding a separate Truncate method (or some other name --\n> that's just what came to mind first) that might also change the input value\n> in the conversion process, seem reasonable to you?\n\nI think you only want to enable cases in SafeCast for integer to floating point and floating point to floating point.  Floating point to integer conversions should be forced to use Truncate so it's a little more obvious what's going on.  No situations where SafeCast would be preferred over Truncate in floating point to integer conversions come to mind, though I'd be happy to be shown otherwise.\n\nI suppose Truncate should also support converting from integer/floating point values to floating point too.  Although, hm, I see from reading my C++ draft that it's implementation-defined whether you chose the lower or higher bound if your source value falls between two representable floating point numbers (4.8p1, 4.9p2).  Ugh.  Can we get by without those cases for the time being?\n\nMy bikeshed has Truncate in Casting.h instead of FloatingPoint.h.", "text": "(In reply to Jeff Walden [:Waldo] (remove +bmo to email) from comment #3)\n> Nathan, do my thoughts on extending SafeCast to take To/From as floating\n> point types, and adding a separate Truncate method (or some other name --\n> that's just what came to mind first) that might also change the input value\n> in the conversion process, seem reasonable to you?\n\nI think you only want to enable cases in SafeCast for integer to floating point and floating point to floating point.  Floating point to integer conversions should be forced to use Truncate so it's a little more obvious what's going on.  No situations where SafeCast would be preferred over Truncate in floating point to integer conversions come to mind, though I'd be happy to be shown otherwise.\n\nI suppose Truncate should also support converting from integer/floating point values to floating point too.  Although, hm, I see from reading my C++ draft that it's implementation-defined whether you chose the lower or higher bound if your source value falls between two representable floating point numbers (4.8p1, 4.9p2).  Ugh.  Can we get by without those cases for the time being?\n\nMy bikeshed has Truncate in Casting.h instead of FloatingPoint.h.", "author": "froydnj+bz@gmail.com", "is_private": false, "id": 7561263, "attachment_id": null, "creation_time": "2013-06-21T15:08:45Z", "tags": [], "bug_id": 646323}, {"bug_id": 646323, "text": "(In reply to Nathan Froyd (:froydnj) from comment #4)\n> I think you only want to enable cases in SafeCast for integer to floating\n> point and floating point to floating point.  Floating point to integer\n> conversions should be forced to use Truncate so it's a little more obvious\n> what's going on.\n\nYeah, that makes sense.\n\n> No situations where SafeCast would be preferred over\n> Truncate in floating point to integer conversions come to mind, though I'd\n> be happy to be shown otherwise.\n\nAnd that.\n\n> I suppose Truncate should also support converting from integer/floating\n> point values to floating point too.  Although, hm, I see from reading my C++\n> draft that it's implementation-defined whether you chose the lower or higher\n> bound if your source value falls between two representable floating point\n> numbers (4.8p1, 4.9p2).  Ugh.  Can we get by without those cases for the\n> time being?\n\nSounds good to me.  (I'm guessing the implementation-defined bit is a nod to configurable FPU rounding modes, so it's probably not as bad as it sounds in practice.  Still, best avoided if we can.)\n\n> My bikeshed has Truncate in Casting.h instead of FloatingPoint.h.\n\nIt's a little nitpicky.  Putting floating point methods in Casting.h probably means the format-constants like DoubleExponentBias and such would have to move to Casting.h, which feels really weird.  I dunno.  Maybe they have to move to implement even the restrictive bits of SafeCast you/we suggest.  Blargh.", "attachment_id": null, "creation_time": "2013-06-21T18:54:54Z", "tags": [], "creator": "jwalden@mit.edu", "raw_text": "(In reply to Nathan Froyd (:froydnj) from comment #4)\n> I think you only want to enable cases in SafeCast for integer to floating\n> point and floating point to floating point.  Floating point to integer\n> conversions should be forced to use Truncate so it's a little more obvious\n> what's going on.\n\nYeah, that makes sense.\n\n> No situations where SafeCast would be preferred over\n> Truncate in floating point to integer conversions come to mind, though I'd\n> be happy to be shown otherwise.\n\nAnd that.\n\n> I suppose Truncate should also support converting from integer/floating\n> point values to floating point too.  Although, hm, I see from reading my C++\n> draft that it's implementation-defined whether you chose the lower or higher\n> bound if your source value falls between two representable floating point\n> numbers (4.8p1, 4.9p2).  Ugh.  Can we get by without those cases for the\n> time being?\n\nSounds good to me.  (I'm guessing the implementation-defined bit is a nod to configurable FPU rounding modes, so it's probably not as bad as it sounds in practice.  Still, best avoided if we can.)\n\n> My bikeshed has Truncate in Casting.h instead of FloatingPoint.h.\n\nIt's a little nitpicky.  Putting floating point methods in Casting.h probably means the format-constants like DoubleExponentBias and such would have to move to Casting.h, which feels really weird.  I dunno.  Maybe they have to move to implement even the restrictive bits of SafeCast you/we suggest.  Blargh.", "id": 7562092, "is_private": false, "count": 5, "time": "2013-06-21T18:54:54Z", "author": "jwalden@mit.edu"}, {"text": "FWIW as to double-to-float casts, mozilla::IsFloatRepresentable now exists as the necessary primitive to use to test that double-to-float casting will not change value, and it could be integrated into Casting.h support for AssertedCast of floating-to-floating.\n\nAnd as to float-to-integer casts, mozilla::Number{Is,Equals}Int32 exist to support verifying that float-to-int32_t casts won't change value.  But the underlying algorithm is template-defined in integer-type-agnostic fashion, so it should be easy to add different-width variations as needed.  And the template algorithm itself could be exposed publicly (currently it's in mozilla::detail) if a templated version were helpful.\n\nBut there remains no well-defined truncating operation, if such is actually desired in any of this.  (Memory hazy, I'm just skimming comments here.)", "raw_text": "FWIW as to double-to-float casts, mozilla::IsFloatRepresentable now exists as the necessary primitive to use to test that double-to-float casting will not change value, and it could be integrated into Casting.h support for AssertedCast of floating-to-floating.\n\nAnd as to float-to-integer casts, mozilla::Number{Is,Equals}Int32 exist to support verifying that float-to-int32_t casts won't change value.  But the underlying algorithm is template-defined in integer-type-agnostic fashion, so it should be easy to add different-width variations as needed.  And the template algorithm itself could be exposed publicly (currently it's in mozilla::detail) if a templated version were helpful.\n\nBut there remains no well-defined truncating operation, if such is actually desired in any of this.  (Memory hazy, I'm just skimming comments here.)", "creator": "jwalden@mit.edu", "time": "2018-06-18T23:26:58Z", "count": 6, "bug_id": 646323, "tags": [], "creation_time": "2018-06-18T23:26:58Z", "attachment_id": null, "id": 13411631, "is_private": false, "author": "jwalden@mit.edu"}]}}, "comments": {}}