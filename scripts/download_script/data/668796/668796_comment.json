{"bugs": {"668796": {"comments": [{"bug_id": 668796, "id": 5569336, "is_private": false, "creation_time": "2011-07-01T12:39:51Z", "creator": "joey@mozilla.com", "author": "joey@mozilla.com", "text": "Double colon rule use in rules.mak will contribute to a huge number of shells spawned.  Per directory a shell will be invoked at least 3/4 times to process export, libs, dep and tools targets.\n\nIf :: rules are replaced with macros/dependency chains that would be processed as deps within the same make session most of the overhead should go away.\n\n## Added shells\nbuild:\n   $(MAKE) export\n   $(MAKE) deps\n   $(MAKE) libs\n   $(MAKE) tools\n\n## Dependency chains\ntodo=$(NULL)\nifneeded export\n  todo += export\nendif\nifneeded deps\n  todo += deps\nendif\n\nbuild: $(todo)\n\n\nAlso I'm still working through the traversal logic but TIER deps/expansion will likely add an entire new dimension to the number of shells spawned.  If tier/module dependency check/build is needed prior to building a given module there are likely a lot more shells on the way.\n\nDo not have a good answer to address this problem at the moment but one approach that could be taken { in addition to the use of tiers to impose a build order within peer elements } is to create a directory hierarchy that would implicitly impose basic tier ordering between levels 1..[n].\n\nMake is then able to traverse tiers serially and build major dependencies w/o explicitly having to code that dependency knowledge into make.  Dependencies that exist between peer elements within a tier could be handled by the addition of normal make deps or added subdirectories.\n\nFor a completely contrived example assuming tier n+1 contains no dependencies on tier n:\n\ntier1 - core and standalone elements\ntier2 - firefox / thunderbird\ntier2 - modules & add-ons\ntier3 - testing\n\nTo perform testing in stages along the way fractional tiers { coded into makefiles as a dependency/target } could be introduced:\n  tier1.1 - unit & standalone tests", "count": 0, "tags": [], "time": "2011-07-01T12:39:51Z", "attachment_id": null, "raw_text": "Double colon rule use in rules.mak will contribute to a huge number of shells spawned.  Per directory a shell will be invoked at least 3/4 times to process export, libs, dep and tools targets.\n\nIf :: rules are replaced with macros/dependency chains that would be processed as deps within the same make session most of the overhead should go away.\n\n## Added shells\nbuild:\n   $(MAKE) export\n   $(MAKE) deps\n   $(MAKE) libs\n   $(MAKE) tools\n\n## Dependency chains\ntodo=$(NULL)\nifneeded export\n  todo += export\nendif\nifneeded deps\n  todo += deps\nendif\n\nbuild: $(todo)\n\n\nAlso I'm still working through the traversal logic but TIER deps/expansion will likely add an entire new dimension to the number of shells spawned.  If tier/module dependency check/build is needed prior to building a given module there are likely a lot more shells on the way.\n\nDo not have a good answer to address this problem at the moment but one approach that could be taken { in addition to the use of tiers to impose a build order within peer elements } is to create a directory hierarchy that would implicitly impose basic tier ordering between levels 1..[n].\n\nMake is then able to traverse tiers serially and build major dependencies w/o explicitly having to code that dependency knowledge into make.  Dependencies that exist between peer elements within a tier could be handled by the addition of normal make deps or added subdirectories.\n\nFor a completely contrived example assuming tier n+1 contains no dependencies on tier n:\n\ntier1 - core and standalone elements\ntier2 - firefox / thunderbird\ntier2 - modules & add-ons\ntier3 - testing\n\nTo perform testing in stages along the way fractional tiers { coded into makefiles as a dependency/target } could be introduced:\n  tier1.1 - unit & standalone tests"}, {"creator": "benjamin@smedbergs.us", "creation_time": "2011-07-01T14:21:34Z", "is_private": false, "attachment_id": null, "tags": [], "author": "benjamin@smedbergs.us", "count": 1, "text": "At least in the first part of your example, the todo: target is still flawed in the face of parallel make: you'd have to add a rule of the form\n\nlibs:: export\n\nto ensure that the export phase completed before the libs phase. But even that is not sufficient, because make could decide to start doing compilation tasks needed for the libs phase before export was finished (which won't work), so you'd need to add an export:: dependency on *every* compilation target.", "id": 5569485, "bug_id": 668796, "raw_text": "At least in the first part of your example, the todo: target is still flawed in the face of parallel make: you'd have to add a rule of the form\n\nlibs:: export\n\nto ensure that the export phase completed before the libs phase. But even that is not sufficient, because make could decide to start doing compilation tasks needed for the libs phase before export was finished (which won't work), so you'd need to add an export:: dependency on *every* compilation target.", "time": "2011-07-01T14:21:34Z"}, {"bug_id": 668796, "id": 5569525, "author": "joey@mozilla.com", "count": 2, "text": "(In reply to comment #1)\n> At least in the first part of your example, the todo: target is still flawed\n> in the face of parallel make: you'd have to add a rule of the form\n> \n> libs:: export\n> \n> to ensure that the export phase completed before the libs phase. But even\n> that is not sufficient, because make could decide to start doing compilation\n> tasks needed for the libs phase before export was finished (which won't\n> work), so you'd need to add an export:: dependency on *every* compilation\n> target.\n\nThe todo section was only simple pseudo code intended to identify the problem and a possible direction.  Yes there will be a boatload of details to contend with in any implementation.  One basic assumption should be that proper make dependencies are in play or all bets are off.\n\n>> dependency on *every* compilation target.\n\nThat answer would be a bit excessive and unmaintainable, esp if circular dependencies are in play.  There are ways to implement synchronization logic like this w/o having to introduce a huge number of new dependencies.", "time": "2011-07-01T14:44:04Z", "raw_text": "(In reply to comment #1)\n> At least in the first part of your example, the todo: target is still flawed\n> in the face of parallel make: you'd have to add a rule of the form\n> \n> libs:: export\n> \n> to ensure that the export phase completed before the libs phase. But even\n> that is not sufficient, because make could decide to start doing compilation\n> tasks needed for the libs phase before export was finished (which won't\n> work), so you'd need to add an export:: dependency on *every* compilation\n> target.\n\nThe todo section was only simple pseudo code intended to identify the problem and a possible direction.  Yes there will be a boatload of details to contend with in any implementation.  One basic assumption should be that proper make dependencies are in play or all bets are off.\n\n>> dependency on *every* compilation target.\n\nThat answer would be a bit excessive and unmaintainable, esp if circular dependencies are in play.  There are ways to implement synchronization logic like this w/o having to introduce a huge number of new dependencies.", "creation_time": "2011-07-01T14:44:04Z", "is_private": false, "creator": "joey@mozilla.com", "tags": [], "attachment_id": null}]}}, "comments": {}}