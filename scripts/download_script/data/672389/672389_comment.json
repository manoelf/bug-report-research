{"bugs": {"672389": {"comments": [{"count": 0, "is_private": false, "creator": "jruderman@gmail.com", "text": "Whenever an IDL interface is guaranteed to only have a single implementation, casts can be made free.  This happens when there is exactly one implementation in the tree and the interface is marked as [builtinclass] or non-scriptable.\n\nIn particular, \"slow\" casts such as do_QueryInterface and do_QueryObject can safely be replaced by the \"free\" static_cast<>.\n\nWith a static analysis script, we could automatically identify safe interface/class pairs and...\n\nA) Replace slow casts with static_cast<>.\n\nB) Replace slow casts with a macro that does static_cast<> while signaling to the analysis \"I statically assert that this is safe; tell me if it becomes unsafe\".\n\nC) Allow compilers to automatically apply the optimization without source changes.\n\nThis will provide (tiny?) performance wins throughout our code and reduce the temptation to apply the optimization unsafely by hand.", "time": "2011-07-18T22:55:44Z", "bug_id": 672389, "tags": [], "creation_time": "2011-07-18T22:55:44Z", "author": "jruderman@gmail.com", "raw_text": "Whenever an IDL interface is guaranteed to only have a single implementation, casts can be made free.  This happens when there is exactly one implementation in the tree and the interface is marked as [builtinclass] or non-scriptable.\n\nIn particular, \"slow\" casts such as do_QueryInterface and do_QueryObject can safely be replaced by the \"free\" static_cast<>.\n\nWith a static analysis script, we could automatically identify safe interface/class pairs and...\n\nA) Replace slow casts with static_cast<>.\n\nB) Replace slow casts with a macro that does static_cast<> while signaling to the analysis \"I statically assert that this is safe; tell me if it becomes unsafe\".\n\nC) Allow compilers to automatically apply the optimization without source changes.\n\nThis will provide (tiny?) performance wins throughout our code and reduce the temptation to apply the optimization unsafely by hand.", "attachment_id": null, "id": 5597960}, {"attachment_id": null, "raw_text": "I guess this would also turn some \"is the result of the cast null?\" branches into dead code.", "id": 5597970, "creator": "jruderman@gmail.com", "is_private": false, "count": 1, "author": "jruderman@gmail.com", "creation_time": "2011-07-18T22:57:42Z", "tags": [], "time": "2011-07-18T22:57:42Z", "bug_id": 672389, "text": "I guess this would also turn some \"is the result of the cast null?\" branches into dead code."}, {"attachment_id": null, "raw_text": "This is just wrong.  Binary extensions can implement builtinclass interfaces.", "id": 5598173, "creator": "khuey@kylehuey.com", "is_private": false, "author": "khuey@kylehuey.com", "creation_time": "2011-07-19T00:12:57Z", "time": "2011-07-19T00:12:57Z", "tags": [], "text": "This is just wrong.  Binary extensions can implement builtinclass interfaces.", "count": 2, "bug_id": 672389}, {"id": 5598175, "raw_text": "(In reply to comment #2)\n> This is just wrong.  Binary extensions can implement builtinclass interfaces.\n\nthey can..and they will cause crashes. All of the stuff in Services.h should be safe for this.", "attachment_id": null, "text": "(In reply to comment #2)\n> This is just wrong.  Binary extensions can implement builtinclass interfaces.\n\nthey can..and they will cause crashes. All of the stuff in Services.h should be safe for this.", "tags": [], "time": "2011-07-19T00:14:18Z", "creation_time": "2011-07-19T00:14:18Z", "author": "taras.mozilla@glek.net", "is_private": false, "creator": "taras.mozilla@glek.net", "bug_id": 672389, "count": 3}, {"raw_text": "(In reply to comment #2)\n> This is just wrong.  Binary extensions can implement builtinclass interfaces.\n\nPerhaps we ought to change the semantics of [builtinclass] (or add a similar attribute) to \"we have one canonical implementation and THAT'S IT\"--i.e., preventing overriding in component registrar.\n\nBut I totally agree that just because an interface isn't scriptable, we shouldn't assume that this is the case.", "attachment_id": null, "id": 5598183, "creator": "Pidgeot18@gmail.com", "is_private": false, "time": "2011-07-19T00:18:27Z", "tags": [], "text": "(In reply to comment #2)\n> This is just wrong.  Binary extensions can implement builtinclass interfaces.\n\nPerhaps we ought to change the semantics of [builtinclass] (or add a similar attribute) to \"we have one canonical implementation and THAT'S IT\"--i.e., preventing overriding in component registrar.\n\nBut I totally agree that just because an interface isn't scriptable, we shouldn't assume that this is the case.", "author": "Pidgeot18@gmail.com", "creation_time": "2011-07-19T00:18:27Z", "count": 4, "bug_id": 672389}, {"id": 5598184, "raw_text": "(In reply to comment #3)\n> (In reply to comment #2)\n> > This is just wrong.  Binary extensions can implement builtinclass interfaces.\n> \n> they can..and they will cause crashes. All of the stuff in Services.h should\n> be safe for this.\n\nSure, some things are safe, but some aren't.  If we're going to assert that builtinclass interfaces must have no non-libxul implementations we should make that explicit before we go running around marking things as builtinclass.", "attachment_id": null, "text": "(In reply to comment #3)\n> (In reply to comment #2)\n> > This is just wrong.  Binary extensions can implement builtinclass interfaces.\n> \n> they can..and they will cause crashes. All of the stuff in Services.h should\n> be safe for this.\n\nSure, some things are safe, but some aren't.  If we're going to assert that builtinclass interfaces must have no non-libxul implementations we should make that explicit before we go running around marking things as builtinclass.", "bug_id": 672389, "tags": [], "time": "2011-07-19T00:18:56Z", "creation_time": "2011-07-19T00:18:56Z", "author": "khuey@kylehuey.com", "count": 5, "is_private": false, "creator": "khuey@kylehuey.com"}, {"raw_text": "(In reply to comment #4)\n> (In reply to comment #2)\n> > This is just wrong.  Binary extensions can implement builtinclass interfaces.\n> \n> Perhaps we ought to change the semantics of [builtinclass] (or add a similar\n> attribute) to \"we have one canonical implementation and THAT'S IT\"--i.e.,\n> preventing overriding in component registrar.\n\nSure, but that applies to components, not interfaces.  And if we wanted to stick a bit in the xpcom registration goop that says \"don't allow overriding this contract id\" I'd ask why we don't just construct by CID to begin with.", "attachment_id": null, "id": 5598194, "creator": "khuey@kylehuey.com", "is_private": false, "time": "2011-07-19T00:23:59Z", "tags": [], "text": "(In reply to comment #4)\n> (In reply to comment #2)\n> > This is just wrong.  Binary extensions can implement builtinclass interfaces.\n> \n> Perhaps we ought to change the semantics of [builtinclass] (or add a similar\n> attribute) to \"we have one canonical implementation and THAT'S IT\"--i.e.,\n> preventing overriding in component registrar.\n\nSure, but that applies to components, not interfaces.  And if we wanted to stick a bit in the xpcom registration goop that says \"don't allow overriding this contract id\" I'd ask why we don't just construct by CID to begin with.", "author": "khuey@kylehuey.com", "creation_time": "2011-07-19T00:23:59Z", "count": 6, "bug_id": 672389}, {"id": 5598223, "attachment_id": null, "raw_text": "Binary addons can always do anything that'll crash us. All we can do is to say \"Don't implement interfaces marked with [builtinclass]\".\n\nFor what it's worth, i think this bug is WONTFIX. At the most we could have a tool that marks potential optimizations, but replacing them all automatically runs a terribly large risk that we'll add additional implementations in the future.", "creation_time": "2011-07-19T00:40:54Z", "author": "jonas@sicking.cc", "text": "Binary addons can always do anything that'll crash us. All we can do is to say \"Don't implement interfaces marked with [builtinclass]\".\n\nFor what it's worth, i think this bug is WONTFIX. At the most we could have a tool that marks potential optimizations, but replacing them all automatically runs a terribly large risk that we'll add additional implementations in the future.", "bug_id": 672389, "tags": [], "time": "2011-07-19T00:40:54Z", "is_private": false, "creator": "jonas@sicking.cc", "count": 7}, {"creation_time": "2011-07-19T02:19:12Z", "author": "jruderman@gmail.com", "text": "(B) and (C) would ensure the optimization goes away if you add additional implementations in the future.\n\nA fourth option is:\n\nD) Only do this optimizations for interfaces that explicitly claim to have only one implementation, e.g. [builtinclass(nsConcreteClass)].\n\nThen super-reviewers would make sure that if you remove the annotation, you also scour the codebase for unsafe casts and other no-longer-valid assumptions.", "tags": [], "time": "2011-07-19T02:19:12Z", "bug_id": 672389, "is_private": false, "creator": "jruderman@gmail.com", "count": 8, "id": 5598339, "attachment_id": null, "raw_text": "(B) and (C) would ensure the optimization goes away if you add additional implementations in the future.\n\nA fourth option is:\n\nD) Only do this optimizations for interfaces that explicitly claim to have only one implementation, e.g. [builtinclass(nsConcreteClass)].\n\nThen super-reviewers would make sure that if you remove the annotation, you also scour the codebase for unsafe casts and other no-longer-valid assumptions."}]}}, "comments": {}}