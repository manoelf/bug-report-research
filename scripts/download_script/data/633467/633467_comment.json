{"comments": {}, "bugs": {"633467": {"comments": [{"attachment_id": null, "is_private": false, "time": "2011-02-11T10:02:51Z", "author": "m_kato@ga2.so-net.ne.jp", "creation_time": "2011-02-11T10:02:51Z", "text": "See the following source.  We allocate and create same table in 2 area.  We should merge this.\n \nhttp://mxr.mozilla.org/mozilla-central/source/content/canvas/src/nsCanvasRenderingContext2D.cpp?mark=469-478#470 and http://mxr.mozilla.org/mozilla-central/source/gfx/thebes/gfxUtils.cpp?mark=48-49#48", "id": 5272069, "raw_text": "See the following source.  We allocate and create same table in 2 area.  We should merge this.\n \nhttp://mxr.mozilla.org/mozilla-central/source/content/canvas/src/nsCanvasRenderingContext2D.cpp?mark=469-478#470 and http://mxr.mozilla.org/mozilla-central/source/gfx/thebes/gfxUtils.cpp?mark=48-49#48", "count": 0, "creator": "m_kato@ga2.so-net.ne.jp", "tags": [], "bug_id": 633467}, {"is_private": false, "time": "2011-02-18T02:47:10Z", "attachment_id": 513348, "text": "Created attachment 513348\nPart 1 use const table instead of dyanmic allocation", "creation_time": "2011-02-18T02:47:10Z", "raw_text": "", "id": 5288538, "bug_id": 633467, "tags": [], "count": 1, "creator": "m_kato@ga2.so-net.ne.jp", "author": "m_kato@ga2.so-net.ne.jp"}, {"attachment_id": 513349, "is_private": false, "time": "2011-02-18T02:48:45Z", "author": "m_kato@ga2.so-net.ne.jp", "creation_time": "2011-02-18T02:48:45Z", "text": "Created attachment 513349\nPart 2 use gfxUtils in canvas", "id": 5288541, "raw_text": "", "creator": "m_kato@ga2.so-net.ne.jp", "tags": [], "count": 2, "bug_id": 633467}, {"attachment_id": null, "time": "2011-02-25T16:27:23Z", "is_private": false, "author": "jmuizelaar@mozilla.com", "bug_id": 633467, "tags": [], "count": 3, "creator": "jmuizelaar@mozilla.com", "raw_text": "It seems like this could have a negative impact on startup. I'm not convinced that having a static lookup table is a good idea.", "id": 5304154, "text": "It seems like this could have a negative impact on startup. I'm not convinced that having a static lookup table is a good idea.", "creation_time": "2011-02-25T16:27:23Z"}, {"author": "alfredkayser@gmail.com", "tags": [], "count": 4, "creator": "alfredkayser@gmail.com", "bug_id": 633467, "id": 5707063, "raw_text": "One make it so that these matrices are only initialized on demand, but in gfxUtils the space is already 'static const' 'allocated' at startup.\n48 static PRUint8 sUnpremultiplyTable[256*256];\n49 static PRUint8 sPremultiplyTable[256*256];\n50 static PRBool sTablesInitialized = PR_FALSE;\n\nSo making canvas reuse those is better than having canvas allocate its own set.\nThe only thing missing in the patch is the check that the matrices are initialized by calling:\n118     if (!sTablesInitialized)\n119         CalculateTables();", "creation_time": "2011-09-08T08:19:57Z", "text": "One make it so that these matrices are only initialized on demand, but in gfxUtils the space is already 'static const' 'allocated' at startup.\n48 static PRUint8 sUnpremultiplyTable[256*256];\n49 static PRUint8 sPremultiplyTable[256*256];\n50 static PRBool sTablesInitialized = PR_FALSE;\n\nSo making canvas reuse those is better than having canvas allocate its own set.\nThe only thing missing in the patch is the check that the matrices are initialized by calling:\n118     if (!sTablesInitialized)\n119         CalculateTables();", "attachment_id": null, "time": "2011-09-08T08:19:57Z", "is_private": false}, {"is_private": false, "time": "2012-01-11T20:52:10Z", "attachment_id": 587787, "text": "Created attachment 587787\nalternate patch\n\nHere's an alternate approach that dynamically allocates the tables in gfxUtils.  I was motivated to do this when I saw that sPremultiplyTable and sUnpremultiplyTable are two of the largest statically allocated objects in libxul.\n\nHiding the tables themselves behind getters means that we don't have to do checks every access.\n\nThere's no good place to free the tables, so they will show up as a memory \"leak\".  I'm honestly not sure this is worth fixing; the OS will deallocate them when there are no more users (i.e. the process is exiting).  We can't do any better than that.\n\nFuture cleanups could take the (un)premultiplication loops and stick them in gfxUtils.  That would eliminate more duplication and any optimizations could take place in gfxUtils directly.\n\nI'm not a graphics person, so the comments in gfxUtils may be dodgy.  Please advise on better ones if necessary.", "creation_time": "2012-01-11T20:52:10Z", "raw_text": "Here's an alternate approach that dynamically allocates the tables in gfxUtils.  I was motivated to do this when I saw that sPremultiplyTable and sUnpremultiplyTable are two of the largest statically allocated objects in libxul.\n\nHiding the tables themselves behind getters means that we don't have to do checks every access.\n\nThere's no good place to free the tables, so they will show up as a memory \"leak\".  I'm honestly not sure this is worth fixing; the OS will deallocate them when there are no more users (i.e. the process is exiting).  We can't do any better than that.\n\nFuture cleanups could take the (un)premultiplication loops and stick them in gfxUtils.  That would eliminate more duplication and any optimizations could take place in gfxUtils directly.\n\nI'm not a graphics person, so the comments in gfxUtils may be dodgy.  Please advise on better ones if necessary.", "id": 5973191, "bug_id": 633467, "tags": [], "creator": "froydnj+bz@gmail.com", "count": 5, "author": "froydnj+bz@gmail.com"}, {"author": "justin.lebar+bug@gmail.com", "attachment_id": null, "bug_id": 633467, "tags": [], "count": 6, "creator": "justin.lebar+bug@gmail.com", "time": "2012-01-11T20:59:30Z", "text": "There are a number of ways you can deal with the \"leak\":\n\nOne is to hand out a refcounted {Un,}PremutiplyTable object, created on-demand.  You could hold onto a weak reference to this table, so that you'd re-calculate the table whenever it's needed, after it's deleted.\n\nOr you could keep around a strong reference to this object, and call ClearOnShutdown() on that nsRefPtr.\n\nOr you could register a shutdown observer and delete the pointers.  See the code in ClearOnShutdown.h for an example of this.", "is_private": false, "creation_time": "2012-01-11T20:59:30Z", "raw_text": "There are a number of ways you can deal with the \"leak\":\n\nOne is to hand out a refcounted {Un,}PremutiplyTable object, created on-demand.  You could hold onto a weak reference to this table, so that you'd re-calculate the table whenever it's needed, after it's deleted.\n\nOr you could keep around a strong reference to this object, and call ClearOnShutdown() on that nsRefPtr.\n\nOr you could register a shutdown observer and delete the pointers.  See the code in ClearOnShutdown.h for an example of this.", "id": 5973217}, {"is_private": false, "time": "2012-01-11T21:00:47Z", "attachment_id": null, "id": 5973227, "raw_text": "> I was motivated to do this when I saw that sPremultiplyTable and sUnpremultiplyTable are two of the \n> largest statically allocated objects in libxul.\n\nNot that these changes aren't virtuous in their own right, but does this have any practical effects (on startup time, or something)?  The tables have value zero initially, so I didn't think they'd matter much.", "creation_time": "2012-01-11T21:00:47Z", "text": "> I was motivated to do this when I saw that sPremultiplyTable and sUnpremultiplyTable are two of the \n> largest statically allocated objects in libxul.\n\nNot that these changes aren't virtuous in their own right, but does this have any practical effects (on startup time, or something)?  The tables have value zero initially, so I didn't think they'd matter much.", "creator": "justin.lebar+bug@gmail.com", "tags": [], "count": 7, "bug_id": 633467, "author": "justin.lebar+bug@gmail.com"}, {"attachment_id": null, "time": "2012-01-11T22:24:32Z", "is_private": false, "author": "jgilbert@mozilla.com", "count": 8, "creator": "jgilbert@mozilla.com", "tags": [], "bug_id": 633467, "id": 5973588, "raw_text": "The tables should only amount to 128k, though, so I wouldn't think size would be much of an issue. Static allocation also gives you the memory management for free.", "creation_time": "2012-01-11T22:24:32Z", "text": "The tables should only amount to 128k, though, so I wouldn't think size would be much of an issue. Static allocation also gives you the memory management for free."}, {"author": "jmuizelaar@mozilla.com", "count": 9, "tags": [], "creator": "jmuizelaar@mozilla.com", "bug_id": 633467, "id": 5983470, "raw_text": "I would rather we consolidate the methods for (un)premultiplying and not expose the tables at all. Is that feasible?", "creation_time": "2012-01-16T20:40:08Z", "text": "Comment on attachment 587787\nalternate patch\n\nI would rather we consolidate the methods for (un)premultiplying and not expose the tables at all. Is that feasible?", "attachment_id": 587787, "time": "2012-01-16T20:40:08Z", "is_private": false}, {"raw_text": "Yes please. Maybe even somewhere in mozilla::gfx?", "id": 5983478, "text": "Yes please. Maybe even somewhere in mozilla::gfx?", "creation_time": "2012-01-16T20:42:55Z", "bug_id": 633467, "creator": "Ms2ger@gmail.com", "tags": [], "count": 10, "author": "Ms2ger@gmail.com", "is_private": false, "time": "2012-01-16T20:42:55Z", "attachment_id": null}, {"time": "2012-01-16T21:39:39Z", "creator": "froydnj+bz@gmail.com", "tags": [], "count": 11, "bug_id": 633467, "is_private": false, "creation_time": "2012-01-16T21:39:39Z", "text": "(In reply to Justin Lebar [:jlebar] from comment #7)\n> > I was motivated to do this when I saw that sPremultiplyTable and sUnpremultiplyTable are two of the \n> > largest statically allocated objects in libxul.\n> \n> Not that these changes aren't virtuous in their own right, but does this\n> have any practical effects (on startup time, or something)?  The tables have\n> value zero initially, so I didn't think they'd matter much.\n\nI haven't measured.  I suppose they are (should be) allocated in .bss, so the only effect is touching pages and not any extra I/O.\n\n(In reply to Jeff Muizelaar [:jrmuizel] from comment #9)\n> I would rather we consolidate the methods for (un)premultiplying and not\n> expose the tables at all. Is that feasible?\n\nSure, I can take a whack at that.", "id": 5983635, "raw_text": "(In reply to Justin Lebar [:jlebar] from comment #7)\n> > I was motivated to do this when I saw that sPremultiplyTable and sUnpremultiplyTable are two of the \n> > largest statically allocated objects in libxul.\n> \n> Not that these changes aren't virtuous in their own right, but does this\n> have any practical effects (on startup time, or something)?  The tables have\n> value zero initially, so I didn't think they'd matter much.\n\nI haven't measured.  I suppose they are (should be) allocated in .bss, so the only effect is touching pages and not any extra I/O.\n\n(In reply to Jeff Muizelaar [:jrmuizel] from comment #9)\n> I would rather we consolidate the methods for (un)premultiplying and not\n> expose the tables at all. Is that feasible?\n\nSure, I can take a whack at that.", "attachment_id": null, "author": "froydnj+bz@gmail.com"}, {"tags": [], "time": "2012-01-27T15:11:33Z", "creator": "froydnj+bz@gmail.com", "count": 12, "bug_id": 633467, "id": 6014271, "raw_text": "(In reply to Jeff Muizelaar [:jrmuizel] from comment #9)\n> Comment on attachment 587787\n> alternate patch\n> \n> I would rather we consolidate the methods for (un)premultiplying and not\n> expose the tables at all. Is that feasible?\n\nSome issues:\n\n1) The canvas methods include extra increments for source and destination data as they might not be tightly packed--which the gfxUtils method assumes;\n2) The canvas methods write data quite differently: e.g. their premultiplication methods always write out in big-endian RGBA format (regardless of host endianness), whereas the gfxUtils method writes host-endian ARGB;\n3) It looks like source and dest don't have to be identically sized in the canvas methods, whereas they do in the gfxUtils method.\n\nOne can, of course, add parameters to deal with all this, but then some of the usefulness of consolidation goes away.  My feeling is that the consolidation isn't worth it with the added complexity of getting everything right.  WDYT?", "creation_time": "2012-01-27T15:11:33Z", "is_private": false, "text": "(In reply to Jeff Muizelaar [:jrmuizel] from comment #9)\n> Comment on attachment 587787\n> alternate patch\n> \n> I would rather we consolidate the methods for (un)premultiplying and not\n> expose the tables at all. Is that feasible?\n\nSome issues:\n\n1) The canvas methods include extra increments for source and destination data as they might not be tightly packed--which the gfxUtils method assumes;\n2) The canvas methods write data quite differently: e.g. their premultiplication methods always write out in big-endian RGBA format (regardless of host endianness), whereas the gfxUtils method writes host-endian ARGB;\n3) It looks like source and dest don't have to be identically sized in the canvas methods, whereas they do in the gfxUtils method.\n\nOne can, of course, add parameters to deal with all this, but then some of the usefulness of consolidation goes away.  My feeling is that the consolidation isn't worth it with the added complexity of getting everything right.  WDYT?", "attachment_id": null, "author": "froydnj+bz@gmail.com"}, {"attachment_id": null, "author": "jmuizelaar@mozilla.com", "creator": "jmuizelaar@mozilla.com", "tags": [], "time": "2012-01-27T15:26:22Z", "count": 13, "bug_id": 633467, "creation_time": "2012-01-27T15:26:22Z", "is_private": false, "text": "(In reply to Nathan Froyd (:froydnj) from comment #12)\n> (In reply to Jeff Muizelaar [:jrmuizel] from comment #9)\n> > Comment on attachment 587787\n> > alternate patch\n> > \n> > I would rather we consolidate the methods for (un)premultiplying and not\n> > expose the tables at all. Is that feasible?\n> \n> Some issues:\n> \n> 1) The canvas methods include extra increments for source and destination\n> data as they might not be tightly packed--which the gfxUtils method assumes;\n> 2) The canvas methods write data quite differently: e.g. their\n> premultiplication methods always write out in big-endian RGBA format\n> (regardless of host endianness), whereas the gfxUtils method writes\n> host-endian ARGB;\n> 3) It looks like source and dest don't have to be identically sized in the\n> canvas methods, whereas they do in the gfxUtils method.\n> \n> One can, of course, add parameters to deal with all this, but then some of\n> the usefulness of consolidation goes away.  My feeling is that the\n> consolidation isn't worth it with the added complexity of getting everything\n> right.  WDYT?\n\nI'd suggest just moving the canvas code to gfxUtils and having (Un)PremultiplyForCanvas methods in addition to the existing ones. This way we still get these similar things near each other and we don't have to worry about having a single more complex one-size-fits-all method.", "id": 6014325, "raw_text": "(In reply to Nathan Froyd (:froydnj) from comment #12)\n> (In reply to Jeff Muizelaar [:jrmuizel] from comment #9)\n> > Comment on attachment 587787\n> > alternate patch\n> > \n> > I would rather we consolidate the methods for (un)premultiplying and not\n> > expose the tables at all. Is that feasible?\n> \n> Some issues:\n> \n> 1) The canvas methods include extra increments for source and destination\n> data as they might not be tightly packed--which the gfxUtils method assumes;\n> 2) The canvas methods write data quite differently: e.g. their\n> premultiplication methods always write out in big-endian RGBA format\n> (regardless of host endianness), whereas the gfxUtils method writes\n> host-endian ARGB;\n> 3) It looks like source and dest don't have to be identically sized in the\n> canvas methods, whereas they do in the gfxUtils method.\n> \n> One can, of course, add parameters to deal with all this, but then some of\n> the usefulness of consolidation goes away.  My feeling is that the\n> consolidation isn't worth it with the added complexity of getting everything\n> right.  WDYT?\n\nI'd suggest just moving the canvas code to gfxUtils and having (Un)PremultiplyForCanvas methods in addition to the existing ones. This way we still get these similar things near each other and we don't have to worry about having a single more complex one-size-fits-all method."}, {"creator": "jgilbert@mozilla.com", "tags": [], "count": 14, "bug_id": 633467, "id": 6039123, "raw_text": "For some experimental work on pixel format conversions, I am using the following two files for premultiplication:\n\nheader: http://pastebin.mozilla.org/1477450\nsource: http://pastebin.mozilla.org/1477451\n\nThe interface is really simple, and for same-pixel-format premultiplication, it gets ~350 megapixels per second on my machine. (For reference, ABGR->RGBA conversion is 630MP/s)\n\nI also tested using a LUT vs. doing the math, functions using bytes vs. dwords, and even using a dword-based LUT.\nResults in MP/s:\nwith LUT:\n336 with Byte\n351 with DWord\n\nwithout LUT:\n196 with Byte\n231 with DWord\n\nwith DWord LUT:\n247 with Byte\n253 with DWord", "creation_time": "2012-02-07T00:36:41Z", "text": "For some experimental work on pixel format conversions, I am using the following two files for premultiplication:\n\nheader: http://pastebin.mozilla.org/1477450\nsource: http://pastebin.mozilla.org/1477451\n\nThe interface is really simple, and for same-pixel-format premultiplication, it gets ~350 megapixels per second on my machine. (For reference, ABGR->RGBA conversion is 630MP/s)\n\nI also tested using a LUT vs. doing the math, functions using bytes vs. dwords, and even using a dword-based LUT.\nResults in MP/s:\nwith LUT:\n336 with Byte\n351 with DWord\n\nwithout LUT:\n196 with Byte\n231 with DWord\n\nwith DWord LUT:\n247 with Byte\n253 with DWord", "author": "jgilbert@mozilla.com", "time": "2012-02-07T00:36:41Z", "is_private": false, "attachment_id": null}]}}}