{"comments": {}, "bugs": {"703446": {"comments": [{"author": "igor@mir2.org", "text": "The bug #701560 changes the merge sort implementation to use a comparator template, not a function pointer, without changing the implementation itself. It would be interesting to investigate at least the following:\n\n1. Investigate different values of INS_SORT_LIMIT. I observed that setting INS_SORT_LIMIT to 3 instead of the current 4 made the sort to run up to 10% in few samples. But this requires broader testing.\n\n2. Investigate dynamic INS_SORT_LIMIT to eliminate the need for the final copy as suggested in bug 701560 comment 2.\n\n3. Investigate another suggestion from the bug 701560 comment 2 of using a binary merge when the second array run is much smaller than the first one.\n\n4. Consider decreasing the scratch space length requirement to nelems/2 via using in place merge when the smaller run to merge is copied first to the scratch space.", "count": 0, "creator": "igor@mir2.org", "creation_time": "2011-11-18T00:53:37Z", "is_private": false, "bug_id": 703446, "id": 5856993, "attachment_id": null, "raw_text": "The bug #701560 changes the merge sort implementation to use a comparator template, not a function pointer, without changing the implementation itself. It would be interesting to investigate at least the following:\n\n1. Investigate different values of INS_SORT_LIMIT. I observed that setting INS_SORT_LIMIT to 3 instead of the current 4 made the sort to run up to 10% in few samples. But this requires broader testing.\n\n2. Investigate dynamic INS_SORT_LIMIT to eliminate the need for the final copy as suggested in bug 701560 comment 2.\n\n3. Investigate another suggestion from the bug 701560 comment 2 of using a binary merge when the second array run is much smaller than the first one.\n\n4. Consider decreasing the scratch space length requirement to nelems/2 via using in place merge when the smaller run to merge is copied first to the scratch space.", "time": "2011-11-18T00:53:37Z", "tags": []}, {"creator": "emanuel.hoogeveen@protonmail.com", "author": "emanuel.hoogeveen@protonmail.com", "text": "It would be interesting to see how time spent in the current sorting function breaks down in terms of\n1) comparisons (calling into js, long strings etc.)\n2) moves (large objects, deep copying)\n3) sorting function overhead (complexity, bad code)\n\nFor instance if comparisons are a big bottleneck and the number of objects to sort is not extremely large (merge sort is very comparison-efficient when the two arrays to merge are large), one could consider combining Ford-Johnson sort (optimal binary insertion) with optimal merging (a la Christen, 1978).\n\nIf on the other hand moves or sorting function overhead play a big role, then Ford-Johnson sort (which has O(n\u00b2) moves and fairly high complexity) is probably not worth trying.\n\nWill the sorting function be used for many different kinds of lists or is its application limited to a few well known types of objects?", "count": 1, "bug_id": 703446, "id": 5859976, "creation_time": "2011-11-19T04:21:56Z", "is_private": false, "time": "2011-11-19T04:21:56Z", "attachment_id": null, "raw_text": "It would be interesting to see how time spent in the current sorting function breaks down in terms of\n1) comparisons (calling into js, long strings etc.)\n2) moves (large objects, deep copying)\n3) sorting function overhead (complexity, bad code)\n\nFor instance if comparisons are a big bottleneck and the number of objects to sort is not extremely large (merge sort is very comparison-efficient when the two arrays to merge are large), one could consider combining Ford-Johnson sort (optimal binary insertion) with optimal merging (a la Christen, 1978).\n\nIf on the other hand moves or sorting function overhead play a big role, then Ford-Johnson sort (which has O(n\u00b2) moves and fairly high complexity) is probably not worth trying.\n\nWill the sorting function be used for many different kinds of lists or is its application limited to a few well known types of objects?", "tags": []}]}}}