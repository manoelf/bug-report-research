{"comments": {}, "bugs": {"697151": {"comments": [{"text": "Created attachment 569403\nCode sample\n\nUser Agent: Mozilla/5.0 (Windows NT 6.1; rv:7.0.1) Gecko/20100101 Firefox/7.0.1\nBuild ID: 20110928134238\n\nSteps to reproduce:\n\nSend an asyncronous AJAX, wait 1 second, then send a syncronous AJAX.\nThe server waits 2 seconds before reply.\n\n\nActual results:\n\nThe asyncronous response fired while I was waiting for the response of the syncronous request.\n\n\nExpected results:\n\nWait for the syncronous response, then receive the asynchron response.\n\nIn other browsers (IE9, Opera11, Chrome 14, Safari 5.1) it is:\nasync ---> (0 sec)\nSYNC ----> (1 sec)\n<---- SYNC (3 sec)\n<--- async (3 sec)\n\nBut in XULRunner and Firefox it is:\nasync ---> (0 sec)\nSYNC ----> (1 sec)\n<--- async (2 sec)\n<---- SYNC (3 sec)\n\nI think, it breaks the JavaScript philosophy.", "count": 0, "author": "fmate144@gmail.com", "id": 5803492, "bug_id": 697151, "time": "2011-10-25T16:47:05Z", "raw_text": "User Agent: Mozilla/5.0 (Windows NT 6.1; rv:7.0.1) Gecko/20100101 Firefox/7.0.1\nBuild ID: 20110928134238\n\nSteps to reproduce:\n\nSend an asyncronous AJAX, wait 1 second, then send a syncronous AJAX.\nThe server waits 2 seconds before reply.\n\n\nActual results:\n\nThe asyncronous response fired while I was waiting for the response of the syncronous request.\n\n\nExpected results:\n\nWait for the syncronous response, then receive the asynchron response.\n\nIn other browsers (IE9, Opera11, Chrome 14, Safari 5.1) it is:\nasync ---> (0 sec)\nSYNC ----> (1 sec)\n<---- SYNC (3 sec)\n<--- async (3 sec)\n\nBut in XULRunner and Firefox it is:\nasync ---> (0 sec)\nSYNC ----> (1 sec)\n<--- async (2 sec)\n<---- SYNC (3 sec)\n\nI think, it breaks the JavaScript philosophy.", "creator": "fmate144@gmail.com", "creation_time": "2011-10-25T16:47:05Z", "is_private": false, "attachment_id": 569403, "tags": []}, {"author": "fmate144@gmail.com", "text": "Created attachment 569404\nServer side sample", "count": 1, "bug_id": 697151, "id": 5803496, "raw_text": "", "time": "2011-10-25T16:48:28Z", "creator": "fmate144@gmail.com", "creation_time": "2011-10-25T16:48:28Z", "is_private": false, "attachment_id": 569404, "tags": []}, {"creation_time": "2011-10-25T17:17:49Z", "is_private": false, "id": 5803579, "bug_id": 697151, "count": 2, "text": "This has nothing to do with JavaScript.\n\n\"Synchronous\" XHR is not actually a blocking synchronous call: it spins the event loop before it returns (you can tell because the page doesn't stop painting, videos keep playing, the page can be scrolled, etc; not spinning the event loop would break the web).  So the only question is which events delivery is suppressed for....", "author": "bzbarsky@mit.edu", "creator": "bzbarsky@mit.edu", "tags": [], "raw_text": "This has nothing to do with JavaScript.\n\n\"Synchronous\" XHR is not actually a blocking synchronous call: it spins the event loop before it returns (you can tell because the page doesn't stop painting, videos keep playing, the page can be scrolled, etc; not spinning the event loop would break the web).  So the only question is which events delivery is suppressed for....", "attachment_id": null, "time": "2011-10-25T17:17:49Z"}, {"tags": [], "attachment_id": null, "is_private": false, "creation_time": "2011-10-25T17:42:46Z", "creator": "fmate144@gmail.com", "time": "2011-10-25T17:42:46Z", "raw_text": "(In reply to Boris Zbarsky (:bz) from comment #2)\n> This has nothing to do with JavaScript.\nWe use XULRunner, and we got an event from our components while we were waiting for a synchronous XHR response.\n\nJavaScript runs in only one thread. Which means if I run a function, there will be no \"context-switch\". But with syncronous XHR my function go sleep and an another \"thread\" wakes up. When that dies, my original function comes, and when it finishes it's work, it returns.\n\nBut because JS is single threaded, I think, when I go into a function there will be nothing else until I came out from it. Am I wrong?\n\nSorry my english.", "bug_id": 697151, "id": 5803686, "count": 3, "text": "(In reply to Boris Zbarsky (:bz) from comment #2)\n> This has nothing to do with JavaScript.\nWe use XULRunner, and we got an event from our components while we were waiting for a synchronous XHR response.\n\nJavaScript runs in only one thread. Which means if I run a function, there will be no \"context-switch\". But with syncronous XHR my function go sleep and an another \"thread\" wakes up. When that dies, my original function comes, and when it finishes it's work, it returns.\n\nBut because JS is single threaded, I think, when I go into a function there will be nothing else until I came out from it. Am I wrong?\n\nSorry my english.", "author": "fmate144@gmail.com"}, {"is_private": false, "creation_time": "2011-10-25T17:56:45Z", "id": 5803736, "bug_id": 697151, "author": "bzbarsky@mit.edu", "count": 4, "text": "There is only one thread.  That thread spins the event loop while waiting on the sync XHR.  That has nothing to do with JS the language, which doesn't even have a concept of event loop.  It's a pure browser construct.", "creator": "bzbarsky@mit.edu", "tags": [], "attachment_id": null, "raw_text": "There is only one thread.  That thread spins the event loop while waiting on the sync XHR.  That has nothing to do with JS the language, which doesn't even have a concept of event loop.  It's a pure browser construct.", "time": "2011-10-25T17:56:45Z"}, {"raw_text": "I have the same problem\n\ntest case:\n\n(function () {\n  var s = [];\n  var url = \"#\";\n\n  setTimeout(function () {\n    s.push('? - setTimeout');\n  }, 0);\n\n  window.addEventListener(\"message\", function (event) {\n    s.push('? - postMessage');\n  });\n\n  s.push(1);\n  window.postMessage(\"\", \"*\");\n  s.push(2);\n\n  var x = new XMLHttpRequest();\n  x.open(\"GET\", url, true);\n  x.onreadystatechange = function () {\n    if (x.readyState===4) {\n      s.push('? - XMLHttpRequest');\n    }\n  };\n  x.send(null);\n  s.push(3);\n\n  var x1 = new XMLHttpRequest();\n  x1.open(\"GET\", url, false);\n  x1.onreadystatechange = function () {\n    if (x1.readyState===4) {\n      s.push(4);\n    }\n  };\n  x1.send(null);\n  s.push(5);\n  setTimeout(function () {\n    console.log(s.join(\", \"));\n  }, 500);\n}());\n\nin Chrome, Opera, IE 9+ console.log will output:\n\n1, 2, 3, 4, 5, ? - postMessage, ? - setTimeout, ? - XMLHttpRequest \n\nin Firefox:\n\n1, 2, 3, ? - postMessage, ? - XMLHttpRequest, 4, 5, ? - setTimeout\n\nit is surprising, that async callbacks are executed before the script finished", "time": "2012-11-23T02:37:35Z", "count": 5, "text": "I have the same problem\n\ntest case:\n\n(function () {\n  var s = [];\n  var url = \"#\";\n\n  setTimeout(function () {\n    s.push('? - setTimeout');\n  }, 0);\n\n  window.addEventListener(\"message\", function (event) {\n    s.push('? - postMessage');\n  });\n\n  s.push(1);\n  window.postMessage(\"\", \"*\");\n  s.push(2);\n\n  var x = new XMLHttpRequest();\n  x.open(\"GET\", url, true);\n  x.onreadystatechange = function () {\n    if (x.readyState===4) {\n      s.push('? - XMLHttpRequest');\n    }\n  };\n  x.send(null);\n  s.push(3);\n\n  var x1 = new XMLHttpRequest();\n  x1.open(\"GET\", url, false);\n  x1.onreadystatechange = function () {\n    if (x1.readyState===4) {\n      s.push(4);\n    }\n  };\n  x1.send(null);\n  s.push(5);\n  setTimeout(function () {\n    console.log(s.join(\", \"));\n  }, 500);\n}());\n\nin Chrome, Opera, IE 9+ console.log will output:\n\n1, 2, 3, 4, 5, ? - postMessage, ? - setTimeout, ? - XMLHttpRequest \n\nin Firefox:\n\n1, 2, 3, ? - postMessage, ? - XMLHttpRequest, 4, 5, ? - setTimeout\n\nit is surprising, that async callbacks are executed before the script finished", "author": "vic99999@yandex.ru", "id": 6846840, "bug_id": 697151, "attachment_id": null, "tags": [], "creator": "vic99999@yandex.ru", "creation_time": "2012-11-23T02:37:35Z", "is_private": false}, {"time": "2014-03-03T14:50:58Z", "raw_text": "", "id": 8483020, "bug_id": 697151, "author": "bzbarsky@mit.edu", "text": "*** Bug 976562 has been marked as a duplicate of this bug. ***", "count": 6, "tags": [], "attachment_id": null, "is_private": false, "creation_time": "2014-03-03T14:50:58Z", "creator": "bzbarsky@mit.edu"}, {"text": "Oh my. I had no idea authors would rely on something like that :-o\nThis needs a test in the W3C suite.. Adding now as XMLHttpRequest/send-sync-blocks-async.htm", "count": 7, "author": "hsteen@mozilla.com", "creator": "hsteen@mozilla.com", "creation_time": "2014-05-07T10:13:50Z", "is_private": false, "id": 8761264, "bug_id": 697151, "raw_text": "Oh my. I had no idea authors would rely on something like that :-o\nThis needs a test in the W3C suite.. Adding now as XMLHttpRequest/send-sync-blocks-async.htm", "attachment_id": null, "time": "2014-05-07T10:13:50Z", "tags": []}, {"bug_id": 697151, "id": 11540610, "is_private": false, "creation_time": "2016-07-12T05:39:09Z", "creator": "wisniewskit@gmail.com", "text": "Created attachment 8769993\n697151-suspend-sync-xhrs-loadgroup-while-it-runs.diff\n\nThe sync XHR code currently does suppress timeouts as well as its related document's event handling (while the XHR runs). But of course events still get queued up in the wrong order that way, and so when event handling resumes they still don't match the desired output.\n\nHere's a patch that instead suspends the rest of the sync XHR's load group until it completes. This passes the web platform test, though it still doesn't match what Chrome outputs for the code in comment 5:\n  1, 2, 3, ? - postMessage, 4, 5, ? - setTimeout, ? - XMLHttpRequest\n\nIt appears that's because postMessage needs to also be suspended somehow, but before I investigate that I thought I'd check whether this patch is even close to a desirable fix.", "count": 8, "author": "wisniewskit@gmail.com", "tags": [], "time": "2016-07-12T05:39:09Z", "raw_text": "The sync XHR code currently does suppress timeouts as well as its related document's event handling (while the XHR runs). But of course events still get queued up in the wrong order that way, and so when event handling resumes they still don't match the desired output.\n\nHere's a patch that instead suspends the rest of the sync XHR's load group until it completes. This passes the web platform test, though it still doesn't match what Chrome outputs for the code in comment 5:\n  1, 2, 3, ? - postMessage, 4, 5, ? - setTimeout, ? - XMLHttpRequest\n\nIt appears that's because postMessage needs to also be suspended somehow, but before I investigate that I thought I'd check whether this patch is even close to a desirable fix.", "attachment_id": 8769993}, {"tags": [], "time": "2016-07-12T16:58:37Z", "attachment_id": null, "raw_text": "The right \"real\" fix here is to do khuey's event queue split and shut down all events except the ones for the sync XHR.\n\nThat _might_ require keeping all necko events going in general, though, so the \"suspend all but this thing\" bit on the loadgroup might still make sense.  But even then, we'd want to do that for all loadgroups in the sync-reachable set of documents, not just the one loadgroup for the one document.\n\nIn any case, the first step here is doing the event queue split.  That's planned to be done in the next few months; I'm not sure it's worth doing bandaids in the meantime.", "id": 11542414, "bug_id": 697151, "creation_time": "2016-07-12T16:58:37Z", "is_private": false, "creator": "bzbarsky@mit.edu", "author": "bzbarsky@mit.edu", "count": 9, "text": "The right \"real\" fix here is to do khuey's event queue split and shut down all events except the ones for the sync XHR.\n\nThat _might_ require keeping all necko events going in general, though, so the \"suspend all but this thing\" bit on the loadgroup might still make sense.  But even then, we'd want to do that for all loadgroups in the sync-reachable set of documents, not just the one loadgroup for the one document.\n\nIn any case, the first step here is doing the event queue split.  That's planned to be done in the next few months; I'm not sure it's worth doing bandaids in the meantime."}, {"time": "2016-07-12T18:46:36Z", "raw_text": "Sure, I see no reason to rush on this.", "text": "Sure, I see no reason to rush on this.", "count": 10, "author": "wisniewskit@gmail.com", "bug_id": 697151, "id": 11542741, "attachment_id": null, "tags": [], "creator": "wisniewskit@gmail.com", "is_private": false, "creation_time": "2016-07-12T18:46:36Z"}, {"time": "2017-02-21T13:15:05Z", "raw_text": "", "author": "annevk@annevk.nl", "text": "*** Bug 521894 has been marked as a duplicate of this bug. ***", "count": 11, "id": 12084440, "bug_id": 697151, "attachment_id": null, "tags": [], "creator": "annevk@annevk.nl", "is_private": false, "creation_time": "2017-02-21T13:15:05Z"}, {"tags": [], "attachment_id": null, "raw_text": "As there seems to be no reason to rush on making Firefox compliant to the XHR spec and compatible with the rest of the browsers after 7 years - wait that is just the age of this bug report, as far I remember it has always been like this in Firefox, so more than 14 years - here is a little \"polyfix\", which delays execution of promises, timeouts and async XHR callbacks and solved all execution order problems we had with Firefox synchronous XHR:\n\nhttps://github.com/SAP/openui5/blob/master/src/sap.ui.core/src/sap/ui/base/syncXHRFix.js\n\nPlease be aware that this is not complete - there are still some other events that may cause JS execution while waiting for responses of synchronous requests, they just were not relevant for our use case.", "time": "2018-06-25T06:27:00Z", "is_private": false, "creation_time": "2018-06-25T06:27:00Z", "id": 13423746, "bug_id": 697151, "author": "ich@malte.de", "text": "As there seems to be no reason to rush on making Firefox compliant to the XHR spec and compatible with the rest of the browsers after 7 years - wait that is just the age of this bug report, as far I remember it has always been like this in Firefox, so more than 14 years - here is a little \"polyfix\", which delays execution of promises, timeouts and async XHR callbacks and solved all execution order problems we had with Firefox synchronous XHR:\n\nhttps://github.com/SAP/openui5/blob/master/src/sap.ui.core/src/sap/ui/base/syncXHRFix.js\n\nPlease be aware that this is not complete - there are still some other events that may cause JS execution while waiting for responses of synchronous requests, they just were not relevant for our use case.", "count": 12, "creator": "ich@malte.de"}, {"tags": [], "time": "2018-07-20T00:54:19Z", "raw_text": "This is also causing breakage at www.chicme.com (I've added a see-also link to the relevant webcompat.com issue where I diagnosed this).\n\nThe polyfix in comment 12 seems to fix the problem there; thanks for that!\n\nI've conjured up a feature-detection function to see if the polyfix is necessary, in case anyone else wants to copy-paste it until this bug is fixed:\n\n>function needSyncXHRFix() {\n>  var async = new XMLHttpRequest();\n>  var sync = new XMLHttpRequest();\n>  async.open(\"get\", \"data:text/html,\");\n>  sync.open(\"get\", \"data:text/html,\", false);\n>  async.onloadend = function() {\n>    hackNeeded = true;\n>  }\n>  var hackNeeded = false;\n>  async.send();\n>  sync.send();\n>  return hackNeeded;\n>}\n\nThis will return false in Safari, Chrome and Edge, but true in Firefox (and should return false in Firefox as well once this bug is fixed).", "attachment_id": null, "bug_id": 697151, "id": 13484050, "is_private": false, "creation_time": "2018-07-20T00:54:19Z", "creator": "twisniewski@mozilla.com", "text": "This is also causing breakage at www.chicme.com (I've added a see-also link to the relevant webcompat.com issue where I diagnosed this).\n\nThe polyfix in comment 12 seems to fix the problem there; thanks for that!\n\nI've conjured up a feature-detection function to see if the polyfix is necessary, in case anyone else wants to copy-paste it until this bug is fixed:\n\n>function needSyncXHRFix() {\n>  var async = new XMLHttpRequest();\n>  var sync = new XMLHttpRequest();\n>  async.open(\"get\", \"data:text/html,\");\n>  sync.open(\"get\", \"data:text/html,\", false);\n>  async.onloadend = function() {\n>    hackNeeded = true;\n>  }\n>  var hackNeeded = false;\n>  async.send();\n>  sync.send();\n>  return hackNeeded;\n>}\n\nThis will return false in Safari, Chrome and Edge, but true in Firefox (and should return false in Firefox as well once this bug is fixed).", "count": 13, "author": "twisniewski@mozilla.com"}, {"creation_time": "2018-07-23T14:49:52Z", "is_private": false, "bug_id": 697151, "id": 13490329, "count": 14, "text": "Just a quick update for anyone considering using a polyfix here, I've created a simplified drop-in polyfix here with feature detection included: https://github.com/wisniewskit/FirefoxSynchronousXHRPolyfix\n\nI've confirmed that it works with IE11, Edge, Chrome, Safari and Firefox, and fixes the postMessage ordering issue mentioned above as well.", "author": "twisniewski@mozilla.com", "creator": "twisniewski@mozilla.com", "tags": [], "raw_text": "Just a quick update for anyone considering using a polyfix here, I've created a simplified drop-in polyfix here with feature detection included: https://github.com/wisniewskit/FirefoxSynchronousXHRPolyfix\n\nI've confirmed that it works with IE11, Edge, Chrome, Safari and Firefox, and fixes the postMessage ordering issue mentioned above as well.", "attachment_id": null, "time": "2018-07-23T14:49:52Z"}, {"raw_text": "bz, what's the status of khuey's event queue split that you mention here in comment #9? Is there another way forward here at this stage?", "attachment_id": null, "time": "2018-07-30T21:25:56Z", "tags": [], "text": "bz, what's the status of khuey's event queue split that you mention here in comment #9? Is there another way forward here at this stage?", "count": 15, "author": "twisniewski@mozilla.com", "creator": "twisniewski@mozilla.com", "is_private": false, "creation_time": "2018-07-30T21:25:56Z", "bug_id": 697151, "id": 13511526}, {"creation_time": "2018-08-03T04:23:20Z", "is_private": false, "id": 13520436, "bug_id": 697151, "text": "I don't know that there's any work on that happening right now.  Chances are, there won't be work along those lines until Fission is done....", "count": 16, "author": "bzbarsky@mit.edu", "creator": "bzbarsky@mit.edu", "tags": [], "raw_text": "I don't know that there's any work on that happening right now.  Chances are, there won't be work along those lines until Fission is done....", "attachment_id": null, "time": "2018-08-03T04:23:20Z"}, {"creator": "twisniewski@mozilla.com", "author": "twisniewski@mozilla.com", "text": "Then do you feel it be worth doing something here before that stage? This is causing real compat issues, and people are investigating polyfixes as workarounds, so I think a bandaid may actually be appropriate.", "count": 17, "id": 13521423, "bug_id": 697151, "is_private": false, "creation_time": "2018-08-03T14:32:20Z", "time": "2018-08-03T14:32:20Z", "attachment_id": null, "raw_text": "Then do you feel it be worth doing something here before that stage? This is causing real compat issues, and people are investigating polyfixes as workarounds, so I think a bandaid may actually be appropriate.", "tags": []}, {"creator": "bzbarsky@mit.edu", "creation_time": "2018-08-03T15:42:12Z", "is_private": false, "attachment_id": null, "tags": [], "author": "bzbarsky@mit.edu", "text": "The problem is that it's not clear what the \"something\" would be.  Is there a concrete proposal?", "count": 18, "id": 13521597, "bug_id": 697151, "time": "2018-08-03T15:42:12Z", "raw_text": "The problem is that it's not clear what the \"something\" would be.  Is there a concrete proposal?"}, {"tags": [], "time": "2018-08-03T22:57:35Z", "attachment_id": 8997608, "raw_text": "For the live issue I've seen, it would be enough to just pass the expectation of the WPT xhr/send-sync-blocks-async.htm, which this new patch does (in an obviously incorrect way, but just as a quick example). Essentially we would:\n\n- capture all sync and async XHR events on the same window while a sync XHR is going on.\n- also record any interesting bits like the readyState at the time, so when we finally fire them, we can have the XHR to reflect what they were supposed to be.\n- only fire the events after-the-fact (sync first, then async), while overriding the readyState/etc as appropriate during that event.\n\nOf course, it would not be good enough for sites expecting other event types to be similarly blocked (like window.postMessage). I fully expect that I'm also missing other details. But it could at least bring us closer to interop. Thoughts?", "bug_id": 697151, "id": 13522619, "is_private": false, "creation_time": "2018-08-03T22:57:35Z", "creator": "twisniewski@mozilla.com", "author": "twisniewski@mozilla.com", "text": "Created attachment 8997608\n697151-wip.diff\n\nFor the live issue I've seen, it would be enough to just pass the expectation of the WPT xhr/send-sync-blocks-async.htm, which this new patch does (in an obviously incorrect way, but just as a quick example). Essentially we would:\n\n- capture all sync and async XHR events on the same window while a sync XHR is going on.\n- also record any interesting bits like the readyState at the time, so when we finally fire them, we can have the XHR to reflect what they were supposed to be.\n- only fire the events after-the-fact (sync first, then async), while overriding the readyState/etc as appropriate during that event.\n\nOf course, it would not be good enough for sites expecting other event types to be similarly blocked (like window.postMessage). I fully expect that I'm also missing other details. But it could at least bring us closer to interop. Thoughts?", "count": 19}, {"tags": [], "attachment_id": null, "is_private": false, "creation_time": "2018-08-04T16:34:52Z", "creator": "twisniewski@mozilla.com", "time": "2018-08-04T16:34:52Z", "raw_text": "", "bug_id": 697151, "id": 13523139, "count": 20, "text": "*** Bug 1366979 has been marked as a duplicate of this bug. ***", "author": "twisniewski@mozilla.com"}, {"bug_id": 697151, "id": 13525863, "creation_time": "2018-08-06T21:35:48Z", "is_private": false, "creator": "bzbarsky@mit.edu", "author": "bzbarsky@mit.edu", "count": 21, "text": "> - capture all sync and async XHR events on the same window while a sync XHR is going on.\n\nSo \"events\" here is notifications the XHR sends to script, not the notifications it receives from necko, right?\n\n> also record any interesting bits like the readyState at the time, so when we finally fire them,\n> we can have the XHR to reflect what they were supposed to be.\n\nUnfortunately, just faking the readyState is not good enough.\n\nFor example, say I have an async XHR that plans to call overrideMimeType() when the readyState ends up HEADERS_RECEIVED.  If we just queue up the readystatechange event dispatch but go ahead and process the data with the wrong MIME type, what effect, exactly will the overrideMimeType call have?\n\nIt seems like it would \"fix\" run-to-completion for sync XHR (except for workers, perhaps, though maybe those already manage through the use of control runnables?), at the cost of the pending async XHRs misbehaving in weird ways like the overrideMimeType example above.  I'm not sure that's the right tradeoff...\n\nWhat we _could_ do is queue up the actual necko notifications (OnStartRequest, OnDataAvailable, OnStopRequest, progress notifications, etc) in some form and re-deliver them once the sync XHR finishes.  As long as XHRs don't expect to mess with necko channels in OnStartRequest this would more or less work, I suspect.  As you say, other event sources would not be blocked by the sync XHR, but the interaction with async XHR would be fixed.", "tags": [], "time": "2018-08-06T21:35:48Z", "attachment_id": null, "raw_text": "> - capture all sync and async XHR events on the same window while a sync XHR is going on.\n\nSo \"events\" here is notifications the XHR sends to script, not the notifications it receives from necko, right?\n\n> also record any interesting bits like the readyState at the time, so when we finally fire them,\n> we can have the XHR to reflect what they were supposed to be.\n\nUnfortunately, just faking the readyState is not good enough.\n\nFor example, say I have an async XHR that plans to call overrideMimeType() when the readyState ends up HEADERS_RECEIVED.  If we just queue up the readystatechange event dispatch but go ahead and process the data with the wrong MIME type, what effect, exactly will the overrideMimeType call have?\n\nIt seems like it would \"fix\" run-to-completion for sync XHR (except for workers, perhaps, though maybe those already manage through the use of control runnables?), at the cost of the pending async XHRs misbehaving in weird ways like the overrideMimeType example above.  I'm not sure that's the right tradeoff...\n\nWhat we _could_ do is queue up the actual necko notifications (OnStartRequest, OnDataAvailable, OnStopRequest, progress notifications, etc) in some form and re-deliver them once the sync XHR finishes.  As long as XHRs don't expect to mess with necko channels in OnStartRequest this would more or less work, I suspect.  As you say, other event sources would not be blocked by the sync XHR, but the interaction with async XHR would be fixed."}, {"creator": "twisniewski@mozilla.com", "text": ">So \"events\" here is notifications the XHR sends to script, not the notifications it receives from necko, right?\n\nYes, just the Progress Events and ReadyStateChanges for \"blocked\" async XHRs.\n\n>Unfortunately, just faking the readyState is not good enough.\n\nAgreed, but I was hoping we could \"fake\" any other properties we might need to. You're probably correct that it's more trouble than just queueing up the necko notifications, however. In fact that's what my previous patch was doing (or so I presume) with loadGroup->BlockAllBut(mChannel). However, that doesn't seem to exist anymore, so how would we go about doing that now?", "count": 22, "author": "twisniewski@mozilla.com", "bug_id": 697151, "id": 13525971, "is_private": false, "creation_time": "2018-08-06T22:20:15Z", "time": "2018-08-06T22:20:15Z", "raw_text": ">So \"events\" here is notifications the XHR sends to script, not the notifications it receives from necko, right?\n\nYes, just the Progress Events and ReadyStateChanges for \"blocked\" async XHRs.\n\n>Unfortunately, just faking the readyState is not good enough.\n\nAgreed, but I was hoping we could \"fake\" any other properties we might need to. You're probably correct that it's more trouble than just queueing up the necko notifications, however. In fact that's what my previous patch was doing (or so I presume) with loadGroup->BlockAllBut(mChannel). However, that doesn't seem to exist anymore, so how would we go about doing that now?", "attachment_id": null, "tags": []}, {"creation_time": "2018-08-06T22:22:32Z", "is_private": false, "bug_id": 697151, "id": 13525975, "count": 23, "text": "Worth checking with the necko people, but the other option would be to just queue them up in the relevant XHR object by snapshotting whatever data is needed to \"replay\" the notifications.", "author": "bzbarsky@mit.edu", "creator": "bzbarsky@mit.edu", "tags": [], "raw_text": "Worth checking with the necko people, but the other option would be to just queue them up in the relevant XHR object by snapshotting whatever data is needed to \"replay\" the notifications.", "attachment_id": null, "time": "2018-08-06T22:22:32Z"}, {"bug_id": 697151, "id": 14021087, "creation_time": "2019-03-30T02:26:19Z", "is_private": false, "creator": "twisniewski@mozilla.com", "text": "Dragana, do you have and insights which could help here? It would be nice if sync XHRs could simply tell the window to queue up Necko notifications for other XHRs that are currently running in the same window, as per comment 21. Is there a reasonable way to do that already, or would it be necessary for the XHR code to queue up the events itself?", "count": 24, "author": "twisniewski@mozilla.com", "tags": [], "time": "2019-03-30T02:26:19Z", "raw_text": "Dragana, do you have and insights which could help here? It would be nice if sync XHRs could simply tell the window to queue up Necko notifications for other XHRs that are currently running in the same window, as per comment 21. Is there a reasonable way to do that already, or would it be necessary for the XHR code to queue up the events itself?", "attachment_id": null}, {"id": 14085416, "bug_id": 697151, "author": "bug-husbandry-bot@mozilla.bugs", "text": "Migrating Webcompat whiteboard priorities to project flags. See bug 1547409.", "count": 25, "raw_text": "Migrating Webcompat whiteboard priorities to project flags. See bug 1547409.", "time": "2019-04-30T01:17:04Z", "is_private": false, "creation_time": "2019-04-30T01:17:04Z", "creator": "bug-husbandry-bot@mozilla.bugs", "tags": [], "attachment_id": null}, {"time": "2019-04-30T01:19:18Z", "raw_text": "See bug 1547409. Migrating whiteboard priority tags to program flags.", "text": "See bug 1547409. Migrating whiteboard priority tags to program flags.", "count": 26, "author": "bug-husbandry-bot@mozilla.bugs", "bug_id": 697151, "id": 14085735, "attachment_id": null, "tags": [], "creator": "bug-husbandry-bot@mozilla.bugs", "creation_time": "2019-04-30T01:19:18Z", "is_private": false}, {"tags": [], "raw_text": "> Dragana, do you have and insights which could help here? It would be nice if sync XHRs could simply tell the window to queue up Necko notifications for other XHRs that are currently running in the same window, as per comment 21. Is there a reasonable way to do that already, or would it be necessary for the XHR code to queue up the events itself?\n\nwouls suspending all other httpChannels work?", "attachment_id": null, "time": "2020-02-12T15:34:18Z", "creation_time": "2020-02-12T15:34:18Z", "is_private": false, "id": 14636928, "bug_id": 697151, "count": 27, "text": "> Dragana, do you have and insights which could help here? It would be nice if sync XHRs could simply tell the window to queue up Necko notifications for other XHRs that are currently running in the same window, as per comment 21. Is there a reasonable way to do that already, or would it be necessary for the XHR code to queue up the events itself?\n\nwouls suspending all other httpChannels work?", "author": "dd.mozilla@gmail.com", "creator": "dd.mozilla@gmail.com"}, {"id": 14636967, "bug_id": 697151, "is_private": false, "creation_time": "2020-02-12T15:50:40Z", "creator": "twisniewski@mozilla.com", "author": "twisniewski@mozilla.com", "count": 28, "text": "Would that actually suspend the network fetches for those requests, or just the resulting notifications? I don't believe that other engines block the actual fetches, they just don't process their related notifications/events until after the sync XHR completes.", "tags": [], "time": "2020-02-12T15:50:40Z", "attachment_id": null, "raw_text": "Would that actually suspend the network fetches for those requests, or just the resulting notifications? I don't believe that other engines block the actual fetches, they just don't process their related notifications/events until after the sync XHR completes."}, {"creation_time": "2020-02-14T12:20:18Z", "is_private": false, "creator": "dd.mozilla@gmail.com", "tags": [], "attachment_id": null, "bug_id": 697151, "id": 14641302, "text": "(In reply to Thomas Wisniewski [:twisniewski] from comment #28)\n> Would that actually suspend the network fetches for those requests, or just the resulting notifications? I don't believe that other engines block the actual fetches, they just don't process their related notifications/events until after the sync XHR completes.\n\nthis will not suspend actual network fetch. Data will be collected in a stream listener of the socket or in tcp layer. Probably it is not ideal.", "count": 29, "author": "dd.mozilla@gmail.com", "time": "2020-02-14T12:20:18Z", "raw_text": "(In reply to Thomas Wisniewski [:twisniewski] from comment #28)\n> Would that actually suspend the network fetches for those requests, or just the resulting notifications? I don't believe that other engines block the actual fetches, they just don't process their related notifications/events until after the sync XHR completes.\n\nthis will not suspend actual network fetch. Data will be collected in a stream listener of the socket or in tcp layer. Probably it is not ideal."}]}}}