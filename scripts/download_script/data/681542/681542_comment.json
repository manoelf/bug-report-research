{"comments": {}, "bugs": {"681542": {"comments": [{"bug_id": 681542, "id": 5673751, "count": 0, "is_private": false, "tags": [], "attachment_id": null, "time": "2011-08-24T01:19:21Z", "text": "Large JS files are being used these days, whose parse/initial run times can be significant. For example, ammo.js is 1.1MB and takes 2-3 seconds to be prepared before it is actually used. This is very noticeable in demos like\n\nhttp://syntensity.com/static/ammo.html\n\nPerhaps we can start to work on the JavaScript as it is being downloaded, in a streaming manner? Parsing seems more feasible, since running would be in danger of things like\n\n  f(x);\n  [..much later..]\n  function f() { .. }\n\nbut perhaps something can be done even there?", "creation_time": "2011-08-24T01:19:21Z", "raw_text": "Large JS files are being used these days, whose parse/initial run times can be significant. For example, ammo.js is 1.1MB and takes 2-3 seconds to be prepared before it is actually used. This is very noticeable in demos like\n\nhttp://syntensity.com/static/ammo.html\n\nPerhaps we can start to work on the JavaScript as it is being downloaded, in a streaming manner? Parsing seems more feasible, since running would be in danger of things like\n\n  f(x);\n  [..much later..]\n  function f() { .. }\n\nbut perhaps something can be done even there?", "author": "azakai@mozilla.com", "creator": "azakai@mozilla.com"}, {"creator": "brendan@mozilla.org", "author": "brendan@mozilla.org", "tags": [], "count": 1, "is_private": false, "id": 5673791, "bug_id": 681542, "raw_text": "Parsing is the only issue. We cannot execute at all for the reason you show, and more: var as well as function is hoisted in JS. But lexing and parsing is enough.\n\n/be", "creation_time": "2011-08-24T01:43:48Z", "text": "Parsing is the only issue. We cannot execute at all for the reason you show, and more: var as well as function is hoisted in JS. But lexing and parsing is enough.\n\n/be", "time": "2011-08-24T01:43:48Z", "attachment_id": null}, {"id": 5673845, "count": 2, "is_private": false, "tags": [], "bug_id": 681542, "creation_time": "2011-08-24T02:12:47Z", "raw_text": "The JS parser is a pretty well tuned (thanks in modern days to cdleary, njn, and others) recursive descent parser.\n\nThe problem is if we receive TCP segments full of JS, the top-level functions and statements will span segment boundaries.\n\nSo we will need either an explicit-state parser, which is ugly and (this may have been tried and measured in SpiderMonkey) often slower than implicit(-stack)-state.\n\nOr else we would need a thread in which to parse, so the OS can keep the implicit state on the thread stack in between parsing turns.\n\nPutting JS parsing in a thread should remind us of speculative <script src=...> prefetching, which uses a thread to parse ahead and try to fire early requests to load the ... URL.\n\nWe're already using threads. So a JS parsing thread seems both easiest and even most efficient (probably we won't measure, since we'd have to do the work of mangling the current parser to use explicit state). I say full speed ahead with a thread!\n\nWho will take this.\n\n/be", "attachment_id": null, "time": "2011-08-24T02:12:47Z", "text": "The JS parser is a pretty well tuned (thanks in modern days to cdleary, njn, and others) recursive descent parser.\n\nThe problem is if we receive TCP segments full of JS, the top-level functions and statements will span segment boundaries.\n\nSo we will need either an explicit-state parser, which is ugly and (this may have been tried and measured in SpiderMonkey) often slower than implicit(-stack)-state.\n\nOr else we would need a thread in which to parse, so the OS can keep the implicit state on the thread stack in between parsing turns.\n\nPutting JS parsing in a thread should remind us of speculative <script src=...> prefetching, which uses a thread to parse ahead and try to fire early requests to load the ... URL.\n\nWe're already using threads. So a JS parsing thread seems both easiest and even most efficient (probably we won't measure, since we'd have to do the work of mangling the current parser to use explicit state). I say full speed ahead with a thread!\n\nWho will take this.\n\n/be", "author": "brendan@mozilla.org", "creator": "brendan@mozilla.org"}, {"bug_id": 681542, "id": 5673855, "is_private": false, "count": 3, "tags": [], "time": "2011-08-24T02:19:23Z", "attachment_id": null, "text": "So from the browser end of this....  Right now we very explicitly wait until we have all the data before calling into JS, obviously.  We could sort of change that, but I thought that removing the streaming parse mode from the JS parser was a significant perf win.  And the TCP segment issue is somewhat worse than Brendan says because individual characters can span segment boundaries.\n\nIn any case, what sort of API would jseng expose here?  A series of calls each of which takes a jschar* + length as the data becomes available?  Trying to think about how to implement this on the browser side.", "raw_text": "So from the browser end of this....  Right now we very explicitly wait until we have all the data before calling into JS, obviously.  We could sort of change that, but I thought that removing the streaming parse mode from the JS parser was a significant perf win.  And the TCP segment issue is somewhat worse than Brendan says because individual characters can span segment boundaries.\n\nIn any case, what sort of API would jseng expose here?  A series of calls each of which takes a jschar* + length as the data becomes available?  Trying to think about how to implement this on the browser side.", "creation_time": "2011-08-24T02:19:23Z", "author": "bzbarsky@mit.edu", "creator": "bzbarsky@mit.edu"}, {"time": "2011-08-24T04:42:30Z", "attachment_id": null, "author": "mail@lukewagner.name", "text": "Compiling functions lazily (as proposed in bug 678037) should allow the initial parsing/compilation to complete much faster.", "creator": "mail@lukewagner.name", "creation_time": "2011-08-24T04:42:30Z", "raw_text": "Compiling functions lazily (as proposed in bug 678037) should allow the initial parsing/compilation to complete much faster.", "bug_id": 681542, "id": 5674050, "is_private": false, "count": 4, "tags": []}, {"author": "brendan@mozilla.org", "creator": "brendan@mozilla.org", "attachment_id": null, "time": "2011-08-24T23:27:11Z", "text": "Boris: we never had a streaming parse mode in JS.\n\nAny larger-than-byte lexical or grammatical unit can span a segment boundary, of course. That's not the issue so much as how to save state when suspending waiting for more data.\n\nThe thread idea would want our script loader code to pass segment payloads of <script src=> content to the parsing thread, and be prepared to execute the script when a message from the thread comes back indicated successful compilation. So a message-passing API.\n\nLuke: good point. Oliver Hunt has implemented lazy function compilation in JSC (I think in the straightforward way, which has exponential complexity in the worst case of nesting).\n\nBut whatever our initial lex/parse costs loading JS (you have to parse to lex JS, note well -- consider /), the idea of moving that parser to a thread to which one can hand off buffers as they come in from the net, and get back a script to execute later, seems like it could win. We could prefetch and interleave lexing and parsing with other work.\n\nOf course we could not run any later scripts or lay out the content beyond the script (in case of document.write, assuming the script lacks the async attribute).\n\n/be", "raw_text": "Boris: we never had a streaming parse mode in JS.\n\nAny larger-than-byte lexical or grammatical unit can span a segment boundary, of course. That's not the issue so much as how to save state when suspending waiting for more data.\n\nThe thread idea would want our script loader code to pass segment payloads of <script src=> content to the parsing thread, and be prepared to execute the script when a message from the thread comes back indicated successful compilation. So a message-passing API.\n\nLuke: good point. Oliver Hunt has implemented lazy function compilation in JSC (I think in the straightforward way, which has exponential complexity in the worst case of nesting).\n\nBut whatever our initial lex/parse costs loading JS (you have to parse to lex JS, note well -- consider /), the idea of moving that parser to a thread to which one can hand off buffers as they come in from the net, and get back a script to execute later, seems like it could win. We could prefetch and interleave lexing and parsing with other work.\n\nOf course we could not run any later scripts or lay out the content beyond the script (in case of document.write, assuming the script lacks the async attribute).\n\n/be", "creation_time": "2011-08-24T23:27:11Z", "bug_id": 681542, "id": 5676474, "count": 5, "is_private": false, "tags": []}, {"creation_time": "2011-08-24T23:59:24Z", "raw_text": "(In reply to Brendan Eich [:brendan] from comment #5)\n> \n> Any larger-than-byte lexical or grammatical unit can span a segment\n> boundary, of course.\n\nAnd that's a *huge* pain to handle.  Pretty much the first step in my epic scanner reworking was to remove the need for the parsing mode where the input is broken into segments, by ensuring the full input was in a single block in memory before starting.  (We already always had the input in a single block in the browser, the segmented case was only used in the JS shell.)  This permitted just about every follow-on simplification and speed-up.  I *really* don't want segments to be re-introduced :(", "text": "(In reply to Brendan Eich [:brendan] from comment #5)\n> \n> Any larger-than-byte lexical or grammatical unit can span a segment\n> boundary, of course.\n\nAnd that's a *huge* pain to handle.  Pretty much the first step in my epic scanner reworking was to remove the need for the parsing mode where the input is broken into segments, by ensuring the full input was in a single block in memory before starting.  (We already always had the input in a single block in the browser, the segmented case was only used in the JS shell.)  This permitted just about every follow-on simplification and speed-up.  I *really* don't want segments to be re-introduced :(", "attachment_id": null, "time": "2011-08-24T23:59:24Z", "is_private": false, "count": 6, "tags": [], "id": 5676570, "bug_id": 681542, "creator": "n.nethercote@gmail.com", "author": "n.nethercote@gmail.com"}]}}}