{"comments": {}, "bugs": {"688797": {"comments": [{"id": 5733956, "is_private": false, "count": 0, "tags": [], "bug_id": 688797, "raw_text": "Currently malloc-allocated data from external functions need to be explicitly managed by JavaScript code. Since this is alien to the typical JavaScript programmer's mindset, I expect it to be a fair source of leaks. It would be useful if we were able to set a bit on these objects so that their memory was managed in the same way as JS-allocated CTypes objects. And, in particular, it would be useful to be able to set a bit on types so that any CData objects returned or manipulated by function calls had this bit set automatically.\n\n   let libc = ctypes.open(\"libc.so.6\");\n\n   let malloc = libc.declare(\"malloc\", ctypes.default_abi, ctypes.voidptr_t, ctypes.size_t);\n   let ptr = malloc(2048);\n   ptr = ptr.autofree(); // ptr is memory managed\n\n   let malloc_af = libc.declare(\"malloc\", ctypes.default_abi, ctypes.voidptr_t.autofree(), ctypes.size_t);\n   let ptr = malloc_af(2048); // ptr is memory managed\n\n   // This may not be feasible:\n   let create_thing = library.declare(\"create_thing\", ctypes.default_abi, ctypes.void_t, ctypes.voidptr_t.autofree().ptr());\n   let thing = ctypes.voidptr_t();\n   create_thing(thing.address()); // thing is most likely not memory managed, but it would be nice if it were.", "creation_time": "2011-09-23T17:25:36Z", "attachment_id": null, "time": "2011-09-23T17:25:36Z", "author": "kmaglione+bmo@mozilla.com", "text": "Currently malloc-allocated data from external functions need to be explicitly managed by JavaScript code. Since this is alien to the typical JavaScript programmer's mindset, I expect it to be a fair source of leaks. It would be useful if we were able to set a bit on these objects so that their memory was managed in the same way as JS-allocated CTypes objects. And, in particular, it would be useful to be able to set a bit on types so that any CData objects returned or manipulated by function calls had this bit set automatically.\n\n   let libc = ctypes.open(\"libc.so.6\");\n\n   let malloc = libc.declare(\"malloc\", ctypes.default_abi, ctypes.voidptr_t, ctypes.size_t);\n   let ptr = malloc(2048);\n   ptr = ptr.autofree(); // ptr is memory managed\n\n   let malloc_af = libc.declare(\"malloc\", ctypes.default_abi, ctypes.voidptr_t.autofree(), ctypes.size_t);\n   let ptr = malloc_af(2048); // ptr is memory managed\n\n   // This may not be feasible:\n   let create_thing = library.declare(\"create_thing\", ctypes.default_abi, ctypes.void_t, ctypes.voidptr_t.autofree().ptr());\n   let thing = ctypes.voidptr_t();\n   create_thing(thing.address()); // thing is most likely not memory managed, but it would be nice if it were.", "creator": "kmaglione+bmo@mozilla.com"}, {"attachment_id": null, "time": "2012-01-24T20:04:04Z", "text": "Bug 720771 should address this need.\n\nI initially wanted to do it using types, something like what you propose here, but taras suggested something that is less integrated with CTypes and I think it's better.", "creation_time": "2012-01-24T20:04:04Z", "raw_text": "Bug 720771 should address this need.\n\nI initially wanted to do it using types, something like what you propose here, but taras suggested something that is less integrated with CTypes and I think it's better.", "bug_id": 688797, "id": 6005097, "count": 1, "is_private": false, "tags": [], "author": "jorendorff@mozilla.com", "creator": "jorendorff@mozilla.com"}, {"bug_id": 688797, "id": 6005099, "tags": [], "count": 2, "is_private": false, "author": "jorendorff@mozilla.com", "attachment_id": null, "time": "2012-01-24T20:04:36Z", "text": "By the way - you should rarely need to call malloc or free from ctypes, because CTypes are JS constructors. So you can write:\n\n    let buffer_t = ctypes.uint8_t.array();\n    let buf = new buffer_t(2048);   // new array of 2048 bytes\n    let ptr = buf.address();\n\nThe buffer is automatically freed when buf is collected.\n\nOr if you just need enough memory for a particular struct, you don't even have to specify the size:\n\n    let mystruct_t = ctypes.StructType(......);\n    let buf = new mystruct_t;\n    let ptr = buf.address();", "creator": "jorendorff@mozilla.com", "creation_time": "2012-01-24T20:04:36Z", "raw_text": "By the way - you should rarely need to call malloc or free from ctypes, because CTypes are JS constructors. So you can write:\n\n    let buffer_t = ctypes.uint8_t.array();\n    let buf = new buffer_t(2048);   // new array of 2048 bytes\n    let ptr = buf.address();\n\nThe buffer is automatically freed when buf is collected.\n\nOr if you just need enough memory for a particular struct, you don't even have to specify the size:\n\n    let mystruct_t = ctypes.StructType(......);\n    let buf = new mystruct_t;\n    let ptr = buf.address();"}]}}}