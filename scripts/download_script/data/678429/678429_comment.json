{"bugs": {"678429": {"comments": [{"time": "2011-08-12T02:44:00Z", "attachment_id": null, "raw_text": "We shouldn't keep accessible alive when it's about to go away. This is good alternative to IsDefunct and more memory friendly.\n\nIt should be used for\n# accessible events\n# single accessible iterator\n# XPCOM objects", "tags": [], "creator": "surkov.alexander@gmail.com", "author": "surkov.alexander@gmail.com", "count": 0, "text": "We shouldn't keep accessible alive when it's about to go away. This is good alternative to IsDefunct and more memory friendly.\n\nIt should be used for\n# accessible events\n# single accessible iterator\n# XPCOM objects", "bug_id": 678429, "id": 5649242, "creation_time": "2011-08-12T02:44:00Z", "is_private": false}, {"tags": [], "attachment_id": null, "is_private": false, "creation_time": "2011-08-12T03:05:59Z", "creator": "surkov.alexander@gmail.com", "time": "2011-08-12T03:05:59Z", "raw_text": "(In reply to alexander surkov from comment #0)\n\n> # XPCOM objects\n\nApproach for XPCOM objects is to keep own hash to get XPCOM object by given accessible object so it can be sort of own weak reference implementation, i.e. when accessible goes away then it's removed from hash and accessible pointer in XPCOM object is null out.\n\nHaving said this approach can be used as a base for common weak reference implementation, i.e. use hash to get weak reference list by accessible object.\n\nFor that nsDocAccessible::mAccessibleCache can provide values:\nstruct\n{\n  nsRefPtr<nsAccessible> mAccessible; // manage accessible lifecycle\n  AccWeakReferenceList mWeakRefList; // list of weak references\n}\n\nMake XPCOM object inherited from weak reference class and keep as the first item of the weak reference list (downcast it to XPCOM object when requested).", "bug_id": 678429, "id": 5649261, "count": 1, "text": "(In reply to alexander surkov from comment #0)\n\n> # XPCOM objects\n\nApproach for XPCOM objects is to keep own hash to get XPCOM object by given accessible object so it can be sort of own weak reference implementation, i.e. when accessible goes away then it's removed from hash and accessible pointer in XPCOM object is null out.\n\nHaving said this approach can be used as a base for common weak reference implementation, i.e. use hash to get weak reference list by accessible object.\n\nFor that nsDocAccessible::mAccessibleCache can provide values:\nstruct\n{\n  nsRefPtr<nsAccessible> mAccessible; // manage accessible lifecycle\n  AccWeakReferenceList mWeakRefList; // list of weak references\n}\n\nMake XPCOM object inherited from weak reference class and keep as the first item of the weak reference list (downcast it to XPCOM object when requested).", "author": "surkov.alexander@gmail.com"}, {"tags": [], "raw_text": "> # accessible events\n\nas an alternative here what if when we shutdown an accessible we run through the event queue and drop all but a hide event for the accessible on the floor.  since by the time we say this accessibles state changed we'll also say this accessible is dead.\n\n> # single accessible iterator\n\ndo we want to weak ref this or just say it can only be used in place where tree is not allowed to change (so probably just getting relations)?\n\n> For that nsDocAccessible::mAccessibleCache can provide values:\n> struct\n> {\n>   nsRefPtr<nsAccessible> mAccessible; // manage accessible lifecycle\n\nIt'd be nice if the parent did this, or just the doc itself.\n\n>   AccWeakReferenceList mWeakRefList; // list of weak references\n> }\n> \n> Make XPCOM object inherited from weak reference class and keep as the first\n> item of the weak reference list (downcast it to XPCOM object when requested).\n\nhow is  invalidation going to work? virtual function? (simple but not very nice)?\nother than the downcasting for xpcom object we could store member pointers I suppose.", "attachment_id": null, "time": "2012-04-04T22:22:26Z", "is_private": false, "creation_time": "2012-04-04T22:22:26Z", "bug_id": 678429, "id": 6198703, "text": "> # accessible events\n\nas an alternative here what if when we shutdown an accessible we run through the event queue and drop all but a hide event for the accessible on the floor.  since by the time we say this accessibles state changed we'll also say this accessible is dead.\n\n> # single accessible iterator\n\ndo we want to weak ref this or just say it can only be used in place where tree is not allowed to change (so probably just getting relations)?\n\n> For that nsDocAccessible::mAccessibleCache can provide values:\n> struct\n> {\n>   nsRefPtr<nsAccessible> mAccessible; // manage accessible lifecycle\n\nIt'd be nice if the parent did this, or just the doc itself.\n\n>   AccWeakReferenceList mWeakRefList; // list of weak references\n> }\n> \n> Make XPCOM object inherited from weak reference class and keep as the first\n> item of the weak reference list (downcast it to XPCOM object when requested).\n\nhow is  invalidation going to work? virtual function? (simple but not very nice)?\nother than the downcasting for xpcom object we could store member pointers I suppose.", "count": 2, "author": "tbsaunde+mozbugs@tbsaunde.org", "creator": "tbsaunde+mozbugs@tbsaunde.org"}, {"time": "2012-04-05T01:31:27Z", "attachment_id": null, "raw_text": "I'm not sure I have the whole picture yet (or I've forgotten). Are we talking about have an nsWeakAccessible? (similar to the nsWeakFrame setup)", "tags": [], "creator": "dbolter@mozilla.com", "author": "dbolter@mozilla.com", "text": "I'm not sure I have the whole picture yet (or I've forgotten). Are we talking about have an nsWeakAccessible? (similar to the nsWeakFrame setup)", "count": 3, "bug_id": 678429, "id": 6199216, "is_private": false, "creation_time": "2012-04-05T01:31:27Z"}, {"author": "surkov.alexander@gmail.com", "text": "(In reply to Trevor Saunders (:tbsaunde) from comment #2)\n> > # accessible events\n> \n> as an alternative here what if when we shutdown an accessible we run through\n> the event queue and drop all but a hide event for the accessible on the\n> floor.  since by the time we say this accessibles state changed we'll also\n> say this accessible is dead.\n\nhide events are not exception but anyway when you shutdown the accessible tree of m objects and has n events in the queue, that's it's n*m. Proposed weak reference approach is faster since it takes n.\n\n> > # single accessible iterator\n> \n> do we want to weak ref this or just say it can only be used in place where\n> tree is not allowed to change (so probably just getting relations)?\n\nI'm not sure what you mean by \"where tree is not allowed to change\". Currently iterators are not a problem but new IA2 probably make us to expose this object externally. So we don't control its life cycle and don't want to keep defunct accessible alive.\n\n> > For that nsDocAccessible::mAccessibleCache can provide values:\n> > struct\n> > {\n> >   nsRefPtr<nsAccessible> mAccessible; // manage accessible lifecycle\n> \n> It'd be nice if the parent did this, or just the doc itself.\n\nparent probably no because I don't see anything bad in parent but its children recreation. Document yes, and that's what I proposed actually (since mAccessibleCache is managed by document).\n\n> >   AccWeakReferenceList mWeakRefList; // list of weak references\n> > }\n> > \n> > Make XPCOM object inherited from weak reference class and keep as the first\n> > item of the weak reference list (downcast it to XPCOM object when requested).\n> \n> how is  invalidation going to work? virtual function? (simple but not very\n> nice)?\n\nweak reference keeps a raw pointer to accessible object, when accessible goes away then raw point is nulled out. That's it if I don't miss anything.\n\n> other than the downcasting for xpcom object we could store member pointers I\n> suppose.\n\nthat'd be nice. Anyway let's introduce weak reference here and deal with XPCOM stuffs later.\n\n(In reply to David Bolter [:davidb] from comment #3)\n> I'm not sure I have the whole picture yet (or I've forgotten). Are we\n> talking about have an nsWeakAccessible? (similar to the nsWeakFrame setup)\n\nyes, about weak reference implementation for accessible objects (see bug summary? ;) ) Note, implementation is different from nsWeakFrame, our implementation is going to be performant so we can use weakrefs really wide.", "count": 4, "creator": "surkov.alexander@gmail.com", "creation_time": "2012-04-05T03:42:33Z", "is_private": false, "id": 6199369, "bug_id": 678429, "attachment_id": null, "raw_text": "(In reply to Trevor Saunders (:tbsaunde) from comment #2)\n> > # accessible events\n> \n> as an alternative here what if when we shutdown an accessible we run through\n> the event queue and drop all but a hide event for the accessible on the\n> floor.  since by the time we say this accessibles state changed we'll also\n> say this accessible is dead.\n\nhide events are not exception but anyway when you shutdown the accessible tree of m objects and has n events in the queue, that's it's n*m. Proposed weak reference approach is faster since it takes n.\n\n> > # single accessible iterator\n> \n> do we want to weak ref this or just say it can only be used in place where\n> tree is not allowed to change (so probably just getting relations)?\n\nI'm not sure what you mean by \"where tree is not allowed to change\". Currently iterators are not a problem but new IA2 probably make us to expose this object externally. So we don't control its life cycle and don't want to keep defunct accessible alive.\n\n> > For that nsDocAccessible::mAccessibleCache can provide values:\n> > struct\n> > {\n> >   nsRefPtr<nsAccessible> mAccessible; // manage accessible lifecycle\n> \n> It'd be nice if the parent did this, or just the doc itself.\n\nparent probably no because I don't see anything bad in parent but its children recreation. Document yes, and that's what I proposed actually (since mAccessibleCache is managed by document).\n\n> >   AccWeakReferenceList mWeakRefList; // list of weak references\n> > }\n> > \n> > Make XPCOM object inherited from weak reference class and keep as the first\n> > item of the weak reference list (downcast it to XPCOM object when requested).\n> \n> how is  invalidation going to work? virtual function? (simple but not very\n> nice)?\n\nweak reference keeps a raw pointer to accessible object, when accessible goes away then raw point is nulled out. That's it if I don't miss anything.\n\n> other than the downcasting for xpcom object we could store member pointers I\n> suppose.\n\nthat'd be nice. Anyway let's introduce weak reference here and deal with XPCOM stuffs later.\n\n(In reply to David Bolter [:davidb] from comment #3)\n> I'm not sure I have the whole picture yet (or I've forgotten). Are we\n> talking about have an nsWeakAccessible? (similar to the nsWeakFrame setup)\n\nyes, about weak reference implementation for accessible objects (see bug summary? ;) ) Note, implementation is different from nsWeakFrame, our implementation is going to be performant so we can use weakrefs really wide.", "time": "2012-04-05T03:42:33Z", "tags": []}, {"author": "tbsaunde+mozbugs@tbsaunde.org", "text": "(In reply to alexander :surkov from comment #4)\n> (In reply to Trevor Saunders (:tbsaunde) from comment #2)\n> > > # accessible events\n> > \n> > as an alternative here what if when we shutdown an accessible we run through\n> > the event queue and drop all but a hide event for the accessible on the\n> > floor.  since by the time we say this accessibles state changed we'll also\n> > say this accessible is dead.\n> \n> hide events are not exception but anyway when you shutdown the accessible\n\nbut why can't they be?  if something happens and then we kill the object but don't tell anybody about the first thing until after we killed the object whose to say the first change ever took place?\n\n> tree of m objects and has n events in the queue, that's it's n*m. Proposed\n> weak reference approach is faster since it takes n.\n\nwouldn't that be m * number of refs to each?\nAlso if in a sain world dropping an event on the floor would mean making the queue shorter and so coalescing would be faster.\nWhat I mean is the complexity is a little more tricky than that.\n\n> > > # single accessible iterator\n> > \n> > do we want to weak ref this or just say it can only be used in place where\n> > tree is not allowed to change (so probably just getting relations)?\n> \n> I'm not sure what you mean by \"where tree is not allowed to change\".\n\nsame sort of thing as with IDRefsIterator now where you can't have one across DOM tree mutations or the weak ref to a content node might become invalid (thinking about what you did in bug 421242).\n\n> Currently iterators are not a problem but new IA2 probably make us to expose\n> this object externally. So we don't control its life cycle and don't want to\n> keep defunct accessible alive.\n\nok, if that happens they yeah we definitely need this.  You'll have to fix IDRefsIteraotr as I say though.\n\n> > > For that nsDocAccessible::mAccessibleCache can provide values:\n> > > struct\n> > > {\n> > >   nsRefPtr<nsAccessible> mAccessible; // manage accessible lifecycle\n> > \n> > It'd be nice if the parent did this, or just the doc itself.\n> \n> parent probably no because I don't see anything bad in parent but its\n> children recreation. Document yes, and that's what I proposed actually\n> (since mAccessibleCache is managed by document).\n\nyeah, not completely sure what I was thinking, other than it would be nice if doing this allowed us to stop refcounting accessibles, which is a little weird if the doc and the parent possily both want to own accessibles.\n\n> > >   AccWeakReferenceList mWeakRefList; // list of weak references\n> > > }\n> > > \n> > > Make XPCOM object inherited from weak reference class and keep as the first\n> > > item of the weak reference list (downcast it to XPCOM object when requested).\n> > \n> > how is  invalidation going to work? virtual function? (simple but not very\n> > nice)?\n> \n> weak reference keeps a raw pointer to accessible object, when accessible\n> goes away then raw point is nulled out. That's it if I don't miss anything.\n\nyeah, that's fine if you just want weak refs, but I'm not sure if it works with the xpcom objects part of what you said.\n\n> > other than the downcasting for xpcom object we could store member pointers I\n> > suppose.\n> \n> that'd be nice. Anyway let's introduce weak reference here and deal with\n> XPCOM stuffs later.\n\nWell, I'd prefer to avoid adding machinary when simpler things will do, but maybe we really do need this machinary.", "count": 5, "creator": "tbsaunde+mozbugs@tbsaunde.org", "is_private": false, "creation_time": "2012-04-05T04:49:33Z", "bug_id": 678429, "id": 6199460, "attachment_id": null, "raw_text": "(In reply to alexander :surkov from comment #4)\n> (In reply to Trevor Saunders (:tbsaunde) from comment #2)\n> > > # accessible events\n> > \n> > as an alternative here what if when we shutdown an accessible we run through\n> > the event queue and drop all but a hide event for the accessible on the\n> > floor.  since by the time we say this accessibles state changed we'll also\n> > say this accessible is dead.\n> \n> hide events are not exception but anyway when you shutdown the accessible\n\nbut why can't they be?  if something happens and then we kill the object but don't tell anybody about the first thing until after we killed the object whose to say the first change ever took place?\n\n> tree of m objects and has n events in the queue, that's it's n*m. Proposed\n> weak reference approach is faster since it takes n.\n\nwouldn't that be m * number of refs to each?\nAlso if in a sain world dropping an event on the floor would mean making the queue shorter and so coalescing would be faster.\nWhat I mean is the complexity is a little more tricky than that.\n\n> > > # single accessible iterator\n> > \n> > do we want to weak ref this or just say it can only be used in place where\n> > tree is not allowed to change (so probably just getting relations)?\n> \n> I'm not sure what you mean by \"where tree is not allowed to change\".\n\nsame sort of thing as with IDRefsIterator now where you can't have one across DOM tree mutations or the weak ref to a content node might become invalid (thinking about what you did in bug 421242).\n\n> Currently iterators are not a problem but new IA2 probably make us to expose\n> this object externally. So we don't control its life cycle and don't want to\n> keep defunct accessible alive.\n\nok, if that happens they yeah we definitely need this.  You'll have to fix IDRefsIteraotr as I say though.\n\n> > > For that nsDocAccessible::mAccessibleCache can provide values:\n> > > struct\n> > > {\n> > >   nsRefPtr<nsAccessible> mAccessible; // manage accessible lifecycle\n> > \n> > It'd be nice if the parent did this, or just the doc itself.\n> \n> parent probably no because I don't see anything bad in parent but its\n> children recreation. Document yes, and that's what I proposed actually\n> (since mAccessibleCache is managed by document).\n\nyeah, not completely sure what I was thinking, other than it would be nice if doing this allowed us to stop refcounting accessibles, which is a little weird if the doc and the parent possily both want to own accessibles.\n\n> > >   AccWeakReferenceList mWeakRefList; // list of weak references\n> > > }\n> > > \n> > > Make XPCOM object inherited from weak reference class and keep as the first\n> > > item of the weak reference list (downcast it to XPCOM object when requested).\n> > \n> > how is  invalidation going to work? virtual function? (simple but not very\n> > nice)?\n> \n> weak reference keeps a raw pointer to accessible object, when accessible\n> goes away then raw point is nulled out. That's it if I don't miss anything.\n\nyeah, that's fine if you just want weak refs, but I'm not sure if it works with the xpcom objects part of what you said.\n\n> > other than the downcasting for xpcom object we could store member pointers I\n> > suppose.\n> \n> that'd be nice. Anyway let's introduce weak reference here and deal with\n> XPCOM stuffs later.\n\nWell, I'd prefer to avoid adding machinary when simpler things will do, but maybe we really do need this machinary.", "time": "2012-04-05T04:49:33Z", "tags": []}, {"is_private": false, "creation_time": "2012-04-05T05:20:32Z", "creator": "surkov.alexander@gmail.com", "tags": [], "attachment_id": null, "bug_id": 678429, "id": 6199511, "author": "surkov.alexander@gmail.com", "text": "(In reply to Trevor Saunders (:tbsaunde) from comment #5)\n> > hide events are not exception but anyway when you shutdown the accessible\n> \n> but why can't they be?  if something happens and then we kill the object but\n> don't tell anybody about the first thing until after we killed the object\n> whose to say the first change ever took place?\n\nif hide event target is defunct then it means it was coalesced by other hide event.\n\n> > tree of m objects and has n events in the queue, that's it's n*m. Proposed\n> > weak reference approach is faster since it takes n.\n> \n> wouldn't that be m * number of refs to each?\n\nno, we have an event for root of subtree and therefore a weak ref for it, all children may not have weak refs.\n\n> Also if in a sain world dropping an event on the floor would mean making the\n> queue shorter and so coalescing would be faster.\n\nwhile we keep them in array then it doesn't sound like a good approach\n\n> What I mean is the complexity is a little more tricky than that.\n\nAnyway I think I prefer to have unified approach rather than handling the same problem in different ways.\n\n> > > > # single accessible iterator\n> > > \n> > > do we want to weak ref this or just say it can only be used in place where\n> > > tree is not allowed to change (so probably just getting relations)?\n> > \n> > I'm not sure what you mean by \"where tree is not allowed to change\".\n> \n> same sort of thing as with IDRefsIterator now where you can't have one\n> across DOM tree mutations or the weak ref to a content node might become\n> invalid (thinking about what you did in bug 421242).\n\nwell, I didn't think about correctness of iterators, I just wanted to make sure they don't keep an accessible alive when it should go away.\n\n> \n> > Currently iterators are not a problem but new IA2 probably make us to expose\n> > this object externally. So we don't control its life cycle and don't want to\n> > keep defunct accessible alive.\n> \n> ok, if that happens they yeah we definitely need this.  You'll have to fix\n> IDRefsIteraotr as I say though.\n\nI'm still not sure what you keep in mind. So, let's file a new bug if it's big enough or fix it here if it's small.\n\n> > parent probably no because I don't see anything bad in parent but its\n> > children recreation. Document yes, and that's what I proposed actually\n> > (since mAccessibleCache is managed by document).\n> \n> yeah, not completely sure what I was thinking, other than it would be nice\n> if doing this allowed us to stop refcounting accessibles, which is a little\n> weird if the doc and the parent possily both want to own accessibles.\n\nyeah, that's what I want to do one day. As follow up of this bug we can switch to weak refs in parent-child relations of nsAccessible object, no strong refs, no cycle collection is needed. Next step would be get rid weak refs for those when we get tree update correct always.\n\n> > > >   AccWeakReferenceList mWeakRefList; // list of weak references\n> > > > }\n> > > > \n> > > > Make XPCOM object inherited from weak reference class and keep as the first\n> > > > item of the weak reference list (downcast it to XPCOM object when requested).\n> > > \n> > > how is  invalidation going to work? virtual function? (simple but not very\n> > > nice)?\n> > \n> > weak reference keeps a raw pointer to accessible object, when accessible\n> > goes away then raw point is nulled out. That's it if I don't miss anything.\n> \n> yeah, that's fine if you just want weak refs, but I'm not sure if it works\n> with the xpcom objects part of what you said.\n\nso if you inherited xpcom object from weak ref then xpcom object has, say, mWeakRef to nsAccessbile. For each method it check if mWeakRef value is not null.\n\n> > > other than the downcasting for xpcom object we could store member pointers I\n> > > suppose.\n> > \n> > that'd be nice. Anyway let's introduce weak reference here and deal with\n> > XPCOM stuffs later.\n> \n> Well, I'd prefer to avoid adding machinary when simpler things will do, but\n> maybe we really do need this machinary.\n\ndo you concern XPCOM part implementation or general concern?", "count": 6, "raw_text": "(In reply to Trevor Saunders (:tbsaunde) from comment #5)\n> > hide events are not exception but anyway when you shutdown the accessible\n> \n> but why can't they be?  if something happens and then we kill the object but\n> don't tell anybody about the first thing until after we killed the object\n> whose to say the first change ever took place?\n\nif hide event target is defunct then it means it was coalesced by other hide event.\n\n> > tree of m objects and has n events in the queue, that's it's n*m. Proposed\n> > weak reference approach is faster since it takes n.\n> \n> wouldn't that be m * number of refs to each?\n\nno, we have an event for root of subtree and therefore a weak ref for it, all children may not have weak refs.\n\n> Also if in a sain world dropping an event on the floor would mean making the\n> queue shorter and so coalescing would be faster.\n\nwhile we keep them in array then it doesn't sound like a good approach\n\n> What I mean is the complexity is a little more tricky than that.\n\nAnyway I think I prefer to have unified approach rather than handling the same problem in different ways.\n\n> > > > # single accessible iterator\n> > > \n> > > do we want to weak ref this or just say it can only be used in place where\n> > > tree is not allowed to change (so probably just getting relations)?\n> > \n> > I'm not sure what you mean by \"where tree is not allowed to change\".\n> \n> same sort of thing as with IDRefsIterator now where you can't have one\n> across DOM tree mutations or the weak ref to a content node might become\n> invalid (thinking about what you did in bug 421242).\n\nwell, I didn't think about correctness of iterators, I just wanted to make sure they don't keep an accessible alive when it should go away.\n\n> \n> > Currently iterators are not a problem but new IA2 probably make us to expose\n> > this object externally. So we don't control its life cycle and don't want to\n> > keep defunct accessible alive.\n> \n> ok, if that happens they yeah we definitely need this.  You'll have to fix\n> IDRefsIteraotr as I say though.\n\nI'm still not sure what you keep in mind. So, let's file a new bug if it's big enough or fix it here if it's small.\n\n> > parent probably no because I don't see anything bad in parent but its\n> > children recreation. Document yes, and that's what I proposed actually\n> > (since mAccessibleCache is managed by document).\n> \n> yeah, not completely sure what I was thinking, other than it would be nice\n> if doing this allowed us to stop refcounting accessibles, which is a little\n> weird if the doc and the parent possily both want to own accessibles.\n\nyeah, that's what I want to do one day. As follow up of this bug we can switch to weak refs in parent-child relations of nsAccessible object, no strong refs, no cycle collection is needed. Next step would be get rid weak refs for those when we get tree update correct always.\n\n> > > >   AccWeakReferenceList mWeakRefList; // list of weak references\n> > > > }\n> > > > \n> > > > Make XPCOM object inherited from weak reference class and keep as the first\n> > > > item of the weak reference list (downcast it to XPCOM object when requested).\n> > > \n> > > how is  invalidation going to work? virtual function? (simple but not very\n> > > nice)?\n> > \n> > weak reference keeps a raw pointer to accessible object, when accessible\n> > goes away then raw point is nulled out. That's it if I don't miss anything.\n> \n> yeah, that's fine if you just want weak refs, but I'm not sure if it works\n> with the xpcom objects part of what you said.\n\nso if you inherited xpcom object from weak ref then xpcom object has, say, mWeakRef to nsAccessbile. For each method it check if mWeakRef value is not null.\n\n> > > other than the downcasting for xpcom object we could store member pointers I\n> > > suppose.\n> > \n> > that'd be nice. Anyway let's introduce weak reference here and deal with\n> > XPCOM stuffs later.\n> \n> Well, I'd prefer to avoid adding machinary when simpler things will do, but\n> maybe we really do need this machinary.\n\ndo you concern XPCOM part implementation or general concern?", "time": "2012-04-05T05:20:32Z"}, {"attachment_id": null, "tags": [], "creator": "tbsaunde+mozbugs@tbsaunde.org", "is_private": false, "creation_time": "2012-04-05T10:40:33Z", "raw_text": "> > > tree of m objects and has n events in the queue, that's it's n*m. Proposed\n> > > weak reference approach is faster since it takes n.\n> > \n> > wouldn't that be m * number of refs to each?\n> \n> no, we have an event for root of subtree and therefore a weak ref for it,\n> all children may not have weak refs.\n\nhow are you not going to have a weak ref wherever you need to point to an accessible from an event?\n\n> > Also if in a sain world dropping an event on the floor would mean making the\n> > queue shorter and so coalescing would be faster.\n> \n> while we keep them in array then it doesn't sound like a good approach\n\nyeah, but as far as I can see the one big array approach isn't particularly sain.\n\n> > What I mean is the complexity is a little more tricky than that.\n> \n> Anyway I think I prefer to have unified approach rather than handling the\n> same problem in different ways.\n\nTo me it would depend a lot on the complexity of the generic approach.  If we can simply take are of all the cases without a big generic thing why not on the other hand if we need 10 tricky things then maybe generic approach makes sense.\n\n> > > > > # single accessible iterator\n> > > > \n> > > > do we want to weak ref this or just say it can only be used in place where\n> > > > tree is not allowed to change (so probably just getting relations)?\n> > > \n> > > I'm not sure what you mean by \"where tree is not allowed to change\".\n> > \n> > same sort of thing as with IDRefsIterator now where you can't have one\n> > across DOM tree mutations or the weak ref to a content node might become\n> > invalid (thinking about what you did in bug 421242).\n> \n> well, I didn't think about correctness of iterators, I just wanted to make\n> sure they don't keep an accessible alive when it should go away.\n\nsure, but other than for ia2 you could just say that accessible must not go defunct while iterator points at it, and change the RefPtr in SingleAccIterator to a raw pointer and call it a day.\n\n> > \n> > > Currently iterators are not a problem but new IA2 probably make us to expose\n> > > this object externally. So we don't control its life cycle and don't want to\n> > > keep defunct accessible alive.\n> > \n> > ok, if that happens they yeah we definitely need this.  You'll have to fix\n> > IDRefsIteraotr as I say though.\n> \n> I'm still not sure what you keep in mind. So, let's file a new bug if it's\n> big enough or fix it here if it's small.\n\nits completely different issue, but IDRefsIterator has member\n\nnsIContent* mContent;\n\nThen if I can hold an IDRefsIterator accross DOM mutation we have a problem, and either need to be very clever, or make that reference strong.\n\n> > > parent probably no because I don't see anything bad in parent but its\n> > > children recreation. Document yes, and that's what I proposed actually\n> > > (since mAccessibleCache is managed by document).\n> > \n> > yeah, not completely sure what I was thinking, other than it would be nice\n> > if doing this allowed us to stop refcounting accessibles, which is a little\n> > weird if the doc and the parent possily both want to own accessibles.\n> \n> yeah, that's what I want to do one day. As follow up of this bug we can\n> switch to weak refs in parent-child relations of nsAccessible object, no\n> strong refs, no cycle collection is needed. Next step would be get rid weak\n> refs for those when we get tree update correct always.\n\nI'm not sure what allways means, I suspect there will always be atleast one bug somewhere.\n\nmy thoughts had been to just go ahead make the parent pointer raw, and have the document stop holding owning references to accessibles other than direct kids, using the requirement that it must be notified when a accessible is removed from the doc.\n\n> > > > other than the downcasting for xpcom object we could store member pointers I\n> > > > suppose.\n> > > \n> > > that'd be nice. Anyway let's introduce weak reference here and deal with\n> > > XPCOM stuffs later.\n> > \n> > Well, I'd prefer to avoid adding machinary when simpler things will do, but\n> > maybe we really do need this machinary.\n> \n> do you concern XPCOM part implementation or general concern?\n\nits a general thing.", "time": "2012-04-05T10:40:33Z", "author": "tbsaunde+mozbugs@tbsaunde.org", "count": 7, "text": "> > > tree of m objects and has n events in the queue, that's it's n*m. Proposed\n> > > weak reference approach is faster since it takes n.\n> > \n> > wouldn't that be m * number of refs to each?\n> \n> no, we have an event for root of subtree and therefore a weak ref for it,\n> all children may not have weak refs.\n\nhow are you not going to have a weak ref wherever you need to point to an accessible from an event?\n\n> > Also if in a sain world dropping an event on the floor would mean making the\n> > queue shorter and so coalescing would be faster.\n> \n> while we keep them in array then it doesn't sound like a good approach\n\nyeah, but as far as I can see the one big array approach isn't particularly sain.\n\n> > What I mean is the complexity is a little more tricky than that.\n> \n> Anyway I think I prefer to have unified approach rather than handling the\n> same problem in different ways.\n\nTo me it would depend a lot on the complexity of the generic approach.  If we can simply take are of all the cases without a big generic thing why not on the other hand if we need 10 tricky things then maybe generic approach makes sense.\n\n> > > > > # single accessible iterator\n> > > > \n> > > > do we want to weak ref this or just say it can only be used in place where\n> > > > tree is not allowed to change (so probably just getting relations)?\n> > > \n> > > I'm not sure what you mean by \"where tree is not allowed to change\".\n> > \n> > same sort of thing as with IDRefsIterator now where you can't have one\n> > across DOM tree mutations or the weak ref to a content node might become\n> > invalid (thinking about what you did in bug 421242).\n> \n> well, I didn't think about correctness of iterators, I just wanted to make\n> sure they don't keep an accessible alive when it should go away.\n\nsure, but other than for ia2 you could just say that accessible must not go defunct while iterator points at it, and change the RefPtr in SingleAccIterator to a raw pointer and call it a day.\n\n> > \n> > > Currently iterators are not a problem but new IA2 probably make us to expose\n> > > this object externally. So we don't control its life cycle and don't want to\n> > > keep defunct accessible alive.\n> > \n> > ok, if that happens they yeah we definitely need this.  You'll have to fix\n> > IDRefsIteraotr as I say though.\n> \n> I'm still not sure what you keep in mind. So, let's file a new bug if it's\n> big enough or fix it here if it's small.\n\nits completely different issue, but IDRefsIterator has member\n\nnsIContent* mContent;\n\nThen if I can hold an IDRefsIterator accross DOM mutation we have a problem, and either need to be very clever, or make that reference strong.\n\n> > > parent probably no because I don't see anything bad in parent but its\n> > > children recreation. Document yes, and that's what I proposed actually\n> > > (since mAccessibleCache is managed by document).\n> > \n> > yeah, not completely sure what I was thinking, other than it would be nice\n> > if doing this allowed us to stop refcounting accessibles, which is a little\n> > weird if the doc and the parent possily both want to own accessibles.\n> \n> yeah, that's what I want to do one day. As follow up of this bug we can\n> switch to weak refs in parent-child relations of nsAccessible object, no\n> strong refs, no cycle collection is needed. Next step would be get rid weak\n> refs for those when we get tree update correct always.\n\nI'm not sure what allways means, I suspect there will always be atleast one bug somewhere.\n\nmy thoughts had been to just go ahead make the parent pointer raw, and have the document stop holding owning references to accessibles other than direct kids, using the requirement that it must be notified when a accessible is removed from the doc.\n\n> > > > other than the downcasting for xpcom object we could store member pointers I\n> > > > suppose.\n> > > \n> > > that'd be nice. Anyway let's introduce weak reference here and deal with\n> > > XPCOM stuffs later.\n> > \n> > Well, I'd prefer to avoid adding machinary when simpler things will do, but\n> > maybe we really do need this machinary.\n> \n> do you concern XPCOM part implementation or general concern?\n\nits a general thing.", "bug_id": 678429, "id": 6199955}, {"raw_text": "(In reply to Trevor Saunders (:tbsaunde) from comment #7)\n> > > > tree of m objects and has n events in the queue, that's it's n*m. Proposed\n> > > > weak reference approach is faster since it takes n.\n> > > \n> > > wouldn't that be m * number of refs to each?\n> > \n> > no, we have an event for root of subtree and therefore a weak ref for it,\n> > all children may not have weak refs.\n> \n> how are you not going to have a weak ref wherever you need to point to an\n> accessible from an event?\n\nI think you misunderstood me. Let's you have a tree of m elements you're going to destroy, let's you have events queue of n events so you should run through events queue for each element from tree tree, at least until we do perfect coalition.\n\n> > > What I mean is the complexity is a little more tricky than that.\n> > \n> > Anyway I think I prefer to have unified approach rather than handling the\n> > same problem in different ways.\n> \n> To me it would depend a lot on the complexity of the generic approach.  If\n> we can simply take are of all the cases without a big generic thing why not\n> on the other hand if we need 10 tricky things then maybe generic approach\n> makes sense.\n\ni'm up for general approach because this approach is fast and let us to not thing about all different cases in invalidation.\n\n> sure, but other than for ia2 you could just say that accessible must not go\n> defunct while iterator points at it, and change the RefPtr in\n> SingleAccIterator to a raw pointer and call it a day.\n\nyes, other than ia2 case\n\n> its completely different issue, but IDRefsIterator has member\n> \n> nsIContent* mContent;\n> \n> Then if I can hold an IDRefsIterator accross DOM mutation we have a problem,\n> and either need to be very clever, or make that reference strong.\n\nI see, we need to keep this in mind if IA2 is changed\n\n> my thoughts had been to just go ahead make the parent pointer raw, and have\n> the document stop holding owning references to accessibles other than direct\n> kids, using the requirement that it must be notified when a accessible is\n> removed from the doc.\n\nok, this approach makes hard to keep the case when parent is recreated but its children not. I think making a document to manage the lifecycle of accessible object is correct, at least it's responsible for tree invalidation what means we keep the logic in the same place.", "attachment_id": null, "time": "2012-04-05T11:20:32Z", "tags": [], "text": "(In reply to Trevor Saunders (:tbsaunde) from comment #7)\n> > > > tree of m objects and has n events in the queue, that's it's n*m. Proposed\n> > > > weak reference approach is faster since it takes n.\n> > > \n> > > wouldn't that be m * number of refs to each?\n> > \n> > no, we have an event for root of subtree and therefore a weak ref for it,\n> > all children may not have weak refs.\n> \n> how are you not going to have a weak ref wherever you need to point to an\n> accessible from an event?\n\nI think you misunderstood me. Let's you have a tree of m elements you're going to destroy, let's you have events queue of n events so you should run through events queue for each element from tree tree, at least until we do perfect coalition.\n\n> > > What I mean is the complexity is a little more tricky than that.\n> > \n> > Anyway I think I prefer to have unified approach rather than handling the\n> > same problem in different ways.\n> \n> To me it would depend a lot on the complexity of the generic approach.  If\n> we can simply take are of all the cases without a big generic thing why not\n> on the other hand if we need 10 tricky things then maybe generic approach\n> makes sense.\n\ni'm up for general approach because this approach is fast and let us to not thing about all different cases in invalidation.\n\n> sure, but other than for ia2 you could just say that accessible must not go\n> defunct while iterator points at it, and change the RefPtr in\n> SingleAccIterator to a raw pointer and call it a day.\n\nyes, other than ia2 case\n\n> its completely different issue, but IDRefsIterator has member\n> \n> nsIContent* mContent;\n> \n> Then if I can hold an IDRefsIterator accross DOM mutation we have a problem,\n> and either need to be very clever, or make that reference strong.\n\nI see, we need to keep this in mind if IA2 is changed\n\n> my thoughts had been to just go ahead make the parent pointer raw, and have\n> the document stop holding owning references to accessibles other than direct\n> kids, using the requirement that it must be notified when a accessible is\n> removed from the doc.\n\nok, this approach makes hard to keep the case when parent is recreated but its children not. I think making a document to manage the lifecycle of accessible object is correct, at least it's responsible for tree invalidation what means we keep the logic in the same place.", "count": 8, "author": "surkov.alexander@gmail.com", "creator": "surkov.alexander@gmail.com", "is_private": false, "creation_time": "2012-04-05T11:20:32Z", "id": 6200004, "bug_id": 678429}, {"time": "2012-04-06T00:18:20Z", "raw_text": "(In reply to alexander :surkov from comment #8)\n> (In reply to Trevor Saunders (:tbsaunde) from comment #7)\n> > > > > tree of m objects and has n events in the queue, that's it's n*m. Proposed\n> > > > > weak reference approach is faster since it takes n.\n> > > > \n> > > > wouldn't that be m * number of refs to each?\n> > > \n> > > no, we have an event for root of subtree and therefore a weak ref for it,\n> > > all children may not have weak refs.\n> > \n> > how are you not going to have a weak ref wherever you need to point to an\n> > accessible from an event?\n> \n> I think you misunderstood me. Let's you have a tree of m elements you're\n> going to destroy, let's you have events queue of n events so you should run\n> through events queue for each element from tree tree, at least until we do\n> perfect coalition.\n\nok, I think we may have talked passed each other some.  What you say is true, but I'm not sure I agree its fair to say weak refs is linear in number of accessibles.\n\nlets say you have n accessibles to shutdown which have x1, x2, .... xn weak refs each in the event queue.  I'd say the correct run time of this is \\sigma_{i=1}^n x_i\n\n> > > > What I mean is the complexity is a little more tricky than that.\n> > > \n> > > Anyway I think I prefer to have unified approach rather than handling the\n> > > same problem in different ways.\n> > \n> > To me it would depend a lot on the complexity of the generic approach.  If\n> > we can simply take are of all the cases without a big generic thing why not\n> > on the other hand if we need 10 tricky things then maybe generic approach\n> > makes sense.\n> \n> i'm up for general approach because this approach is fast and let us to not\n> thing about all different cases in invalidation.\n\nI'm honestly not sure what I think, if we had something that clearerly neededweak refs now I'd say absolutely, but for now I'm sort of in middle.\n\n> > sure, but other than for ia2 you could just say that accessible must not go\n> > defunct while iterator points at it, and change the RefPtr in\n> > SingleAccIterator to a raw pointer and call it a day.\n> \n> yes, other than ia2 case\n\nwhich is a issue we don't handle currently.  So do we\n* fix the other obviously places this possible ia2 issue could come up\n* ignore this possible future issue and just keep raw pointer and say it must need be held across tree mutation\n* use weak ref here and leave other case is so some iterators work in ia2 case but not others, and we take small perf hit to have some iterators possibly already working when ia2 actually does this.\n\nI'd probably say just use raw pointer and restrict usage for now since it shouldn't be hard to make this work later if ia2 does start requiring us to hold one across tree mutation.\n\n> > my thoughts had been to just go ahead make the parent pointer raw, and have\n> > the document stop holding owning references to accessibles other than direct\n> > kids, using the requirement that it must be notified when a accessible is\n> > removed from the doc.\n> \n> ok, this approach makes hard to keep the case when parent is recreated but\n> its children not. I think making a document to manage the lifecycle of\n> accessible object is correct, at least it's responsible for tree\n> invalidation what means we keep the logic in the same place.\n\nyeah, I guess this part is fine by me if it allows us to make document sole owner of the accessible.  I'd been thinking of having the parent be the owner since afaik that's more standard, but the doc does seem to make more sense.", "attachment_id": null, "tags": [], "creator": "tbsaunde+mozbugs@tbsaunde.org", "text": "(In reply to alexander :surkov from comment #8)\n> (In reply to Trevor Saunders (:tbsaunde) from comment #7)\n> > > > > tree of m objects and has n events in the queue, that's it's n*m. Proposed\n> > > > > weak reference approach is faster since it takes n.\n> > > > \n> > > > wouldn't that be m * number of refs to each?\n> > > \n> > > no, we have an event for root of subtree and therefore a weak ref for it,\n> > > all children may not have weak refs.\n> > \n> > how are you not going to have a weak ref wherever you need to point to an\n> > accessible from an event?\n> \n> I think you misunderstood me. Let's you have a tree of m elements you're\n> going to destroy, let's you have events queue of n events so you should run\n> through events queue for each element from tree tree, at least until we do\n> perfect coalition.\n\nok, I think we may have talked passed each other some.  What you say is true, but I'm not sure I agree its fair to say weak refs is linear in number of accessibles.\n\nlets say you have n accessibles to shutdown which have x1, x2, .... xn weak refs each in the event queue.  I'd say the correct run time of this is \\sigma_{i=1}^n x_i\n\n> > > > What I mean is the complexity is a little more tricky than that.\n> > > \n> > > Anyway I think I prefer to have unified approach rather than handling the\n> > > same problem in different ways.\n> > \n> > To me it would depend a lot on the complexity of the generic approach.  If\n> > we can simply take are of all the cases without a big generic thing why not\n> > on the other hand if we need 10 tricky things then maybe generic approach\n> > makes sense.\n> \n> i'm up for general approach because this approach is fast and let us to not\n> thing about all different cases in invalidation.\n\nI'm honestly not sure what I think, if we had something that clearerly neededweak refs now I'd say absolutely, but for now I'm sort of in middle.\n\n> > sure, but other than for ia2 you could just say that accessible must not go\n> > defunct while iterator points at it, and change the RefPtr in\n> > SingleAccIterator to a raw pointer and call it a day.\n> \n> yes, other than ia2 case\n\nwhich is a issue we don't handle currently.  So do we\n* fix the other obviously places this possible ia2 issue could come up\n* ignore this possible future issue and just keep raw pointer and say it must need be held across tree mutation\n* use weak ref here and leave other case is so some iterators work in ia2 case but not others, and we take small perf hit to have some iterators possibly already working when ia2 actually does this.\n\nI'd probably say just use raw pointer and restrict usage for now since it shouldn't be hard to make this work later if ia2 does start requiring us to hold one across tree mutation.\n\n> > my thoughts had been to just go ahead make the parent pointer raw, and have\n> > the document stop holding owning references to accessibles other than direct\n> > kids, using the requirement that it must be notified when a accessible is\n> > removed from the doc.\n> \n> ok, this approach makes hard to keep the case when parent is recreated but\n> its children not. I think making a document to manage the lifecycle of\n> accessible object is correct, at least it's responsible for tree\n> invalidation what means we keep the logic in the same place.\n\nyeah, I guess this part is fine by me if it allows us to make document sole owner of the accessible.  I'd been thinking of having the parent be the owner since afaik that's more standard, but the doc does seem to make more sense.", "count": 9, "author": "tbsaunde+mozbugs@tbsaunde.org", "id": 6202552, "bug_id": 678429, "creation_time": "2012-04-06T00:18:20Z", "is_private": false}, {"tags": [], "attachment_id": null, "creation_time": "2012-04-06T00:33:32Z", "is_private": false, "creator": "tbsaunde+mozbugs@tbsaunde.org", "raw_text": "(In reply to alexander :surkov from comment #1)\n> (In reply to alexander surkov from comment #0)\n> \n> > # XPCOM objects\n> \n> Approach for XPCOM objects is to keep own hash to get XPCOM object by given\n> accessible object so it can be sort of own weak reference implementation,\n> i.e. when accessible goes away then it's removed from hash and accessible\n> pointer in XPCOM object is null out.\n> \n> Having said this approach can be used as a base for common weak reference\n> implementation, i.e. use hash to get weak reference list by accessible\n> object.\n> \n> For that nsDocAccessible::mAccessibleCache can provide > struct\n> {\n>   nsRefPtr<nsAccessible> mAccessible; // manage accessible lifecycle\n\nthat seems kind of wasteful, if we really want to use a ref pointer it seems like sticking it in the mNodeToAccessibleMap would be better, or we could just manually AddRef / Release the accessible when we bind / unbind it.\n\n>   AccWeakReferenceList mWeakRefList; // list of weak references\n\ncan't that just be nsTArray<nsAccessible**> although if you like a typedef ok.", "time": "2012-04-06T00:33:32Z", "bug_id": 678429, "id": 6202590, "text": "(In reply to alexander :surkov from comment #1)\n> (In reply to alexander surkov from comment #0)\n> \n> > # XPCOM objects\n> \n> Approach for XPCOM objects is to keep own hash to get XPCOM object by given\n> accessible object so it can be sort of own weak reference implementation,\n> i.e. when accessible goes away then it's removed from hash and accessible\n> pointer in XPCOM object is null out.\n> \n> Having said this approach can be used as a base for common weak reference\n> implementation, i.e. use hash to get weak reference list by accessible\n> object.\n> \n> For that nsDocAccessible::mAccessibleCache can provide > struct\n> {\n>   nsRefPtr<nsAccessible> mAccessible; // manage accessible lifecycle\n\nthat seems kind of wasteful, if we really want to use a ref pointer it seems like sticking it in the mNodeToAccessibleMap would be better, or we could just manually AddRef / Release the accessible when we bind / unbind it.\n\n>   AccWeakReferenceList mWeakRefList; // list of weak references\n\ncan't that just be nsTArray<nsAccessible**> although if you like a typedef ok.", "count": 10, "author": "tbsaunde+mozbugs@tbsaunde.org"}, {"tags": [], "attachment_id": null, "raw_text": "(In reply to Trevor Saunders (:tbsaunde) from comment #9)\n> > I think you misunderstood me. Let's you have a tree of m elements you're\n> > going to destroy, let's you have events queue of n events so you should run\n> > through events queue for each element from tree tree, at least until we do\n> > perfect coalition.\n> \n> ok, I think we may have talked passed each other some.  What you say is\n> true, but I'm not sure I agree its fair to say weak refs is linear in number\n> of accessibles.\n> \n> lets say you have n accessibles to shutdown which have x1, x2, .... xn weak\n> refs each in the event queue.  I'd say the correct run time of this is\n> \\sigma_{i=1}^n x_i\n\nanyway, if weakrefs are used in events only then it's lesser than m*n. if weakrefs are used outside events then it could be > m*n but in this case we need to do invalidation of these other places.\n\n> > i'm up for general approach because this approach is fast and let us to not\n> > thing about all different cases in invalidation.\n> \n> I'm honestly not sure what I think, if we had something that clearerly\n> neededweak refs now I'd say absolutely, but for now I'm sort of in middle.\n\nother point of weak refs was keep a weak ref to internal object in MSAA objects.\n\n(In reply to Trevor Saunders (:tbsaunde) from comment #10)\n> > For that nsDocAccessible::mAccessibleCache can provide > struct\n> > {\n> >   nsRefPtr<nsAccessible> mAccessible; // manage accessible lifecycle\n> \n> that seems kind of wasteful, if we really want to use a ref pointer it seems\n> like sticking it in the mNodeToAccessibleMap would be better, or we could\n> just manually AddRef / Release the accessible when we bind / unbind it.\n\nnot sure I follow, why manual AddRef/Release are prefered and why mNodeToAccessibleMap is better?\n\n> >   AccWeakReferenceList mWeakRefList; // list of weak references\n> \n> can't that just be nsTArray<nsAccessible**> although if you like a typedef\n> ok.\n\nsure, it was an illustration :)", "time": "2012-04-06T02:50:18Z", "creation_time": "2012-04-06T02:50:18Z", "is_private": false, "bug_id": 678429, "id": 6202816, "author": "surkov.alexander@gmail.com", "text": "(In reply to Trevor Saunders (:tbsaunde) from comment #9)\n> > I think you misunderstood me. Let's you have a tree of m elements you're\n> > going to destroy, let's you have events queue of n events so you should run\n> > through events queue for each element from tree tree, at least until we do\n> > perfect coalition.\n> \n> ok, I think we may have talked passed each other some.  What you say is\n> true, but I'm not sure I agree its fair to say weak refs is linear in number\n> of accessibles.\n> \n> lets say you have n accessibles to shutdown which have x1, x2, .... xn weak\n> refs each in the event queue.  I'd say the correct run time of this is\n> \\sigma_{i=1}^n x_i\n\nanyway, if weakrefs are used in events only then it's lesser than m*n. if weakrefs are used outside events then it could be > m*n but in this case we need to do invalidation of these other places.\n\n> > i'm up for general approach because this approach is fast and let us to not\n> > thing about all different cases in invalidation.\n> \n> I'm honestly not sure what I think, if we had something that clearerly\n> neededweak refs now I'd say absolutely, but for now I'm sort of in middle.\n\nother point of weak refs was keep a weak ref to internal object in MSAA objects.\n\n(In reply to Trevor Saunders (:tbsaunde) from comment #10)\n> > For that nsDocAccessible::mAccessibleCache can provide > struct\n> > {\n> >   nsRefPtr<nsAccessible> mAccessible; // manage accessible lifecycle\n> \n> that seems kind of wasteful, if we really want to use a ref pointer it seems\n> like sticking it in the mNodeToAccessibleMap would be better, or we could\n> just manually AddRef / Release the accessible when we bind / unbind it.\n\nnot sure I follow, why manual AddRef/Release are prefered and why mNodeToAccessibleMap is better?\n\n> >   AccWeakReferenceList mWeakRefList; // list of weak references\n> \n> can't that just be nsTArray<nsAccessible**> although if you like a typedef\n> ok.\n\nsure, it was an illustration :)", "count": 11, "creator": "surkov.alexander@gmail.com"}, {"creator": "tbsaunde+mozbugs@tbsaunde.org", "text": "> > > i'm up for general approach because this approach is fast and let us to not\n> > > thing about all different cases in invalidation.\n> > \n> > I'm honestly not sure what I think, if we had something that clearerly\n> > neededweak refs now I'd say absolutely, but for now I'm sort of in middle.\n> \n> other point of weak refs was keep a weak ref to internal object in MSAA\n> objects.\n\nyeah, but we don't really need this to do that easily, we could just do the same thing we do in atk nsAccessibleWrap and implement Shutdown() to kill the pointer in the wrapper object.  That doesn't really work if we get rid of nsAccessibleWrap, but if we do that we need to more generally rethink how wrapper object tree is updated etc.\n\n> (In reply to Trevor Saunders (:tbsaunde) from comment #10)\n> > > For that nsDocAccessible::mAccessibleCache can provide > struct\n> > > {\n> > >   nsRefPtr<nsAccessible> mAccessible; // manage accessible lifecycle\n> > \n> > that seems kind of wasteful, if we really want to use a ref pointer it seems\n> > like sticking it in the mNodeToAccessibleMap would be better, or we could\n> > just manually AddRef / Release the accessible when we bind / unbind it.\n> \n> not sure I follow, why manual AddRef/Release are prefered and why\n> mNodeToAccessibleMap is better?\n\nI was mostly trying to not need more hash tables, but I'm not sure I actually think they are, sort of just putting out ideas in the hope some of them will end up making sense or giving someone else a good idea.\n\n> > >   AccWeakReferenceList mWeakRefList; // list of weak references\n> > \n> > can't that just be nsTArray<nsAccessible**> although if you like a typedef\n> > ok.\n> \n> sure, it was an illustration :)\n\nok, sounds good.", "count": 12, "author": "tbsaunde+mozbugs@tbsaunde.org", "bug_id": 678429, "id": 6202836, "creation_time": "2012-04-06T03:06:02Z", "is_private": false, "time": "2012-04-06T03:06:02Z", "raw_text": "> > > i'm up for general approach because this approach is fast and let us to not\n> > > thing about all different cases in invalidation.\n> > \n> > I'm honestly not sure what I think, if we had something that clearerly\n> > neededweak refs now I'd say absolutely, but for now I'm sort of in middle.\n> \n> other point of weak refs was keep a weak ref to internal object in MSAA\n> objects.\n\nyeah, but we don't really need this to do that easily, we could just do the same thing we do in atk nsAccessibleWrap and implement Shutdown() to kill the pointer in the wrapper object.  That doesn't really work if we get rid of nsAccessibleWrap, but if we do that we need to more generally rethink how wrapper object tree is updated etc.\n\n> (In reply to Trevor Saunders (:tbsaunde) from comment #10)\n> > > For that nsDocAccessible::mAccessibleCache can provide > struct\n> > > {\n> > >   nsRefPtr<nsAccessible> mAccessible; // manage accessible lifecycle\n> > \n> > that seems kind of wasteful, if we really want to use a ref pointer it seems\n> > like sticking it in the mNodeToAccessibleMap would be better, or we could\n> > just manually AddRef / Release the accessible when we bind / unbind it.\n> \n> not sure I follow, why manual AddRef/Release are prefered and why\n> mNodeToAccessibleMap is better?\n\nI was mostly trying to not need more hash tables, but I'm not sure I actually think they are, sort of just putting out ideas in the hope some of them will end up making sense or giving someone else a good idea.\n\n> > >   AccWeakReferenceList mWeakRefList; // list of weak references\n> > \n> > can't that just be nsTArray<nsAccessible**> although if you like a typedef\n> > ok.\n> \n> sure, it was an illustration :)\n\nok, sounds good.", "attachment_id": null, "tags": []}, {"tags": [], "time": "2012-04-06T03:15:25Z", "raw_text": "(In reply to Trevor Saunders (:tbsaunde) from comment #12)\n\n> > other point of weak refs was keep a weak ref to internal object in MSAA\n> > objects.\n> \n> yeah, but we don't really need this to do that easily, we could just do the\n> same thing we do in atk nsAccessibleWrap and implement Shutdown() to kill\n> the pointer in the wrapper object.  That doesn't really work if we get rid\n> of nsAccessibleWrap, but if we do that we need to more generally rethink how\n> wrapper object tree is updated etc.\n\nthat means nsAccessibleWrap should keep a pointer to MSAA object (if we start to use tear offs for MSAA then things get more tricky)\n\nIt seems to be we battle over having a general approach vs handling each case separately.\n\n> > (In reply to Trevor Saunders (:tbsaunde) from comment #10)\n> > > > For that nsDocAccessible::mAccessibleCache can provide > struct\n> > > > {\n> > > >   nsRefPtr<nsAccessible> mAccessible; // manage accessible lifecycle\n> > > \n> > > that seems kind of wasteful, if we really want to use a ref pointer it seems\n> > > like sticking it in the mNodeToAccessibleMap would be better, or we could\n> > > just manually AddRef / Release the accessible when we bind / unbind it.\n> > \n> > not sure I follow, why manual AddRef/Release are prefered and why\n> > mNodeToAccessibleMap is better?\n> \n> I was mostly trying to not need more hash tables, but I'm not sure I\n> actually think they are, sort of just putting out ideas in the hope some of\n> them will end up making sense or giving someone else a good idea.\n\nwe just reuse existing hashtable", "attachment_id": null, "bug_id": 678429, "id": 6202844, "is_private": false, "creation_time": "2012-04-06T03:15:25Z", "creator": "surkov.alexander@gmail.com", "text": "(In reply to Trevor Saunders (:tbsaunde) from comment #12)\n\n> > other point of weak refs was keep a weak ref to internal object in MSAA\n> > objects.\n> \n> yeah, but we don't really need this to do that easily, we could just do the\n> same thing we do in atk nsAccessibleWrap and implement Shutdown() to kill\n> the pointer in the wrapper object.  That doesn't really work if we get rid\n> of nsAccessibleWrap, but if we do that we need to more generally rethink how\n> wrapper object tree is updated etc.\n\nthat means nsAccessibleWrap should keep a pointer to MSAA object (if we start to use tear offs for MSAA then things get more tricky)\n\nIt seems to be we battle over having a general approach vs handling each case separately.\n\n> > (In reply to Trevor Saunders (:tbsaunde) from comment #10)\n> > > > For that nsDocAccessible::mAccessibleCache can provide > struct\n> > > > {\n> > > >   nsRefPtr<nsAccessible> mAccessible; // manage accessible lifecycle\n> > > \n> > > that seems kind of wasteful, if we really want to use a ref pointer it seems\n> > > like sticking it in the mNodeToAccessibleMap would be better, or we could\n> > > just manually AddRef / Release the accessible when we bind / unbind it.\n> > \n> > not sure I follow, why manual AddRef/Release are prefered and why\n> > mNodeToAccessibleMap is better?\n> \n> I was mostly trying to not need more hash tables, but I'm not sure I\n> actually think they are, sort of just putting out ideas in the hope some of\n> them will end up making sense or giving someone else a good idea.\n\nwe just reuse existing hashtable", "count": 13, "author": "surkov.alexander@gmail.com"}, {"is_private": false, "creation_time": "2012-04-06T10:52:40Z", "creator": "tbsaunde+mozbugs@tbsaunde.org", "tags": [], "attachment_id": null, "id": 6203322, "bug_id": 678429, "text": "(In reply to alexander :surkov from comment #13)\n> (In reply to Trevor Saunders (:tbsaunde) from comment #12)\n> \n> > > other point of weak refs was keep a weak ref to internal object in MSAA\n> > > objects.\n> > \n> > yeah, but we don't really need this to do that easily, we could just do the\n> > same thing we do in atk nsAccessibleWrap and implement Shutdown() to kill\n> > the pointer in the wrapper object.  That doesn't really work if we get rid\n> > of nsAccessibleWrap, but if we do that we need to more generally rethink how\n> > wrapper object tree is updated etc.\n> \n> that means nsAccessibleWrap should keep a pointer to MSAA object (if we\n> start to use tear offs for MSAA then things get more tricky)\n\nI'm not sure I see what you mean here.  We're just going to have one platform object that implements all of the msaa / ia2 methods for that object no?\n\n> It seems to be we battle over having a general approach vs handling each\n> case separately.\n\nyeah, and the number of case there will be.\n\n> > > (In reply to Trevor Saunders (:tbsaunde) from comment #10)\n> > > > > For that nsDocAccessible::mAccessibleCache can provide > struct\n> > > > > {\n> > > > >   nsRefPtr<nsAccessible> mAccessible; // manage accessible lifecycle\n> > > > \n> > > > that seems kind of wasteful, if we really want to use a ref pointer it seems\n> > > > like sticking it in the mNodeToAccessibleMap would be better, or we could\n> > > > just manually AddRef / Release the accessible when we bind / unbind it.\n> > > \n> > > not sure I follow, why manual AddRef/Release are prefered and why\n> > > mNodeToAccessibleMap is better?\n> > \n> > I was mostly trying to not need more hash tables, but I'm not sure I\n> > actually think they are, sort of just putting out ideas in the hope some of\n> > them will end up making sense or giving someone else a good idea.\n> \n> we just reuse existing hashtable\n\nyeah, but it would be nice if we didn't have that hash table, but I guess if we have it why not use it.", "count": 14, "author": "tbsaunde+mozbugs@tbsaunde.org", "time": "2012-04-06T10:52:40Z", "raw_text": "(In reply to alexander :surkov from comment #13)\n> (In reply to Trevor Saunders (:tbsaunde) from comment #12)\n> \n> > > other point of weak refs was keep a weak ref to internal object in MSAA\n> > > objects.\n> > \n> > yeah, but we don't really need this to do that easily, we could just do the\n> > same thing we do in atk nsAccessibleWrap and implement Shutdown() to kill\n> > the pointer in the wrapper object.  That doesn't really work if we get rid\n> > of nsAccessibleWrap, but if we do that we need to more generally rethink how\n> > wrapper object tree is updated etc.\n> \n> that means nsAccessibleWrap should keep a pointer to MSAA object (if we\n> start to use tear offs for MSAA then things get more tricky)\n\nI'm not sure I see what you mean here.  We're just going to have one platform object that implements all of the msaa / ia2 methods for that object no?\n\n> It seems to be we battle over having a general approach vs handling each\n> case separately.\n\nyeah, and the number of case there will be.\n\n> > > (In reply to Trevor Saunders (:tbsaunde) from comment #10)\n> > > > > For that nsDocAccessible::mAccessibleCache can provide > struct\n> > > > > {\n> > > > >   nsRefPtr<nsAccessible> mAccessible; // manage accessible lifecycle\n> > > > \n> > > > that seems kind of wasteful, if we really want to use a ref pointer it seems\n> > > > like sticking it in the mNodeToAccessibleMap would be better, or we could\n> > > > just manually AddRef / Release the accessible when we bind / unbind it.\n> > > \n> > > not sure I follow, why manual AddRef/Release are prefered and why\n> > > mNodeToAccessibleMap is better?\n> > \n> > I was mostly trying to not need more hash tables, but I'm not sure I\n> > actually think they are, sort of just putting out ideas in the hope some of\n> > them will end up making sense or giving someone else a good idea.\n> \n> we just reuse existing hashtable\n\nyeah, but it would be nice if we didn't have that hash table, but I guess if we have it why not use it."}, {"bug_id": 678429, "id": 6203421, "is_private": false, "creation_time": "2012-04-06T12:40:23Z", "creator": "surkov.alexander@gmail.com", "text": "(In reply to Trevor Saunders (:tbsaunde) from comment #14)\n> > that means nsAccessibleWrap should keep a pointer to MSAA object (if we\n> > start to use tear offs for MSAA then things get more tricky)\n> \n> I'm not sure I see what you mean here.  We're just going to have one\n> platform object that implements all of the msaa / ia2 methods for that\n> object no?\n\nok, I thought about ISimpleDOM interfaces, but we could not use tear offs for them\n\n> > It seems to be we battle over having a general approach vs handling each\n> > case separately.\n> \n> yeah, and the number of case there will be.\n\nso candidates are:\n1) XPCOM\n2) MSAA (and other platforms)\n3) events\n4) relations if IA2 1.3 will be released ever\n5) possibly parent/child relations (replace strong ref on weak ref)\n\nwe could handle all of them via weak refs or maintain invalidation logic for each of them. I like to keep things the same way if it doesn't hit us too much.", "count": 15, "author": "surkov.alexander@gmail.com", "tags": [], "time": "2012-04-06T12:40:23Z", "raw_text": "(In reply to Trevor Saunders (:tbsaunde) from comment #14)\n> > that means nsAccessibleWrap should keep a pointer to MSAA object (if we\n> > start to use tear offs for MSAA then things get more tricky)\n> \n> I'm not sure I see what you mean here.  We're just going to have one\n> platform object that implements all of the msaa / ia2 methods for that\n> object no?\n\nok, I thought about ISimpleDOM interfaces, but we could not use tear offs for them\n\n> > It seems to be we battle over having a general approach vs handling each\n> > case separately.\n> \n> yeah, and the number of case there will be.\n\nso candidates are:\n1) XPCOM\n2) MSAA (and other platforms)\n3) events\n4) relations if IA2 1.3 will be released ever\n5) possibly parent/child relations (replace strong ref on weak ref)\n\nwe could handle all of them via weak refs or maintain invalidation logic for each of them. I like to keep things the same way if it doesn't hit us too much.", "attachment_id": null}, {"count": 16, "text": "Created attachment 742208\npatch\n\nplain and easy, it makes us dependent on caches but benefits should prevail over that", "author": "surkov.alexander@gmail.com", "id": 7358093, "bug_id": 678429, "raw_text": "plain and easy, it makes us dependent on caches but benefits should prevail over that", "time": "2013-04-26T06:29:28Z", "creator": "surkov.alexander@gmail.com", "is_private": false, "creation_time": "2013-04-26T06:29:28Z", "attachment_id": 742208, "tags": []}, {"is_private": false, "creation_time": "2013-05-07T02:23:24Z", "id": 7393835, "bug_id": 678429, "text": "Trev, I thought you commented about this bug but I didn't find where. So what do you think?", "count": 17, "author": "surkov.alexander@gmail.com", "creator": "surkov.alexander@gmail.com", "tags": [], "raw_text": "Trev, I thought you commented about this bug but I didn't find where. So what do you think?", "attachment_id": null, "time": "2013-05-07T02:23:24Z"}, {"creation_time": "2013-05-07T03:04:18Z", "is_private": false, "creator": "tbsaunde+mozbugs@tbsaunde.org", "tags": [], "attachment_id": null, "id": 7393938, "bug_id": 678429, "count": 18, "text": "(In reply to alexander :surkov from comment #17)\n> Trev, I thought you commented about this bug but I didn't find where. So\n> what do you think?\n\ndoesn't the approach suffer from the A B A problem? that is to say if I first have node with accessible at address x remove it kill the accessible then create a new node at X and it gets an accessible  any weak refs that pointed at the first accessible and are still around again refer to an accessible just a different one!", "author": "tbsaunde+mozbugs@tbsaunde.org", "time": "2013-05-07T03:04:18Z", "raw_text": "(In reply to alexander :surkov from comment #17)\n> Trev, I thought you commented about this bug but I didn't find where. So\n> what do you think?\n\ndoesn't the approach suffer from the A B A problem? that is to say if I first have node with accessible at address x remove it kill the accessible then create a new node at X and it gets an accessible  any weak refs that pointed at the first accessible and are still around again refer to an accessible just a different one!"}, {"tags": [], "time": "2013-05-07T03:28:29Z", "attachment_id": null, "raw_text": "it is, ideas to workaround it?", "id": 7393988, "bug_id": 678429, "creation_time": "2013-05-07T03:28:29Z", "is_private": false, "creator": "surkov.alexander@gmail.com", "author": "surkov.alexander@gmail.com", "text": "it is, ideas to workaround it?", "count": 19}, {"bug_id": 678429, "id": 7397431, "is_private": false, "creation_time": "2013-05-07T20:19:07Z", "creator": "tbsaunde+mozbugs@tbsaunde.org", "author": "tbsaunde+mozbugs@tbsaunde.org", "count": 20, "text": "(In reply to alexander :surkov from comment #19)\n> it is, ideas to workaround it?\n\nuse hash map from accessible to weak refs? or just not solve the problem?  (what do we need it for?)", "tags": [], "time": "2013-05-07T20:19:07Z", "attachment_id": null, "raw_text": "(In reply to alexander :surkov from comment #19)\n> it is, ideas to workaround it?\n\nuse hash map from accessible to weak refs? or just not solve the problem?  (what do we need it for?)"}, {"author": "surkov.alexander@gmail.com", "text": "(In reply to Trevor Saunders (:tbsaunde) from comment #20)\n> (In reply to alexander :surkov from comment #19)\n> > it is, ideas to workaround it?\n> \n> use hash map from accessible to weak refs?\n\n4 bytes per week ref vs keeping an accessible object in memory longer than we need. Probably a win if somebody keeps them.\n\n> or just not solve the problem? \n> (what do we need it for?)\n\nIt's tempting but imagine AT stored ISimpleDOMNode for menu accessible, it was replaced on different accessible at the same memory address but AT still operates on it like it was a menu. It could be a problem.", "count": 21, "creator": "surkov.alexander@gmail.com", "is_private": false, "creation_time": "2013-05-15T05:20:42Z", "bug_id": 678429, "id": 7424350, "attachment_id": null, "raw_text": "(In reply to Trevor Saunders (:tbsaunde) from comment #20)\n> (In reply to alexander :surkov from comment #19)\n> > it is, ideas to workaround it?\n> \n> use hash map from accessible to weak refs?\n\n4 bytes per week ref vs keeping an accessible object in memory longer than we need. Probably a win if somebody keeps them.\n\n> or just not solve the problem? \n> (what do we need it for?)\n\nIt's tempting but imagine AT stored ISimpleDOMNode for menu accessible, it was replaced on different accessible at the same memory address but AT still operates on it like it was a menu. It could be a problem.", "time": "2013-05-15T05:20:42Z", "tags": []}, {"is_private": false, "creation_time": "2013-05-15T06:06:11Z", "creator": "tbsaunde+mozbugs@tbsaunde.org", "tags": [], "attachment_id": null, "id": 7424450, "bug_id": 678429, "count": 22, "text": "(In reply to alexander :surkov from comment #21)\n> (In reply to Trevor Saunders (:tbsaunde) from comment #20)\n> > (In reply to alexander :surkov from comment #19)\n> > > it is, ideas to workaround it?\n> > \n> > use hash map from accessible to weak refs?\n> \n> 4 bytes per week ref vs keeping an accessible object in memory longer than\n> we need. Probably a win if somebody keeps them.\n\nmaybe, but its heavy weight and I'm not yet convinced we need it.\n\n> > or just not solve the problem? \n> > (what do we need it for?)\n> \n> It's tempting but imagine AT stored ISimpleDOMNode for menu accessible, it\n> was replaced on different accessible at the same memory address but AT still\n> operates on it like it was a menu. It could be a problem.\n\noh, yeah, I don't think not solvingthat problem is acceptable, I meant not supporting weak refs.", "author": "tbsaunde+mozbugs@tbsaunde.org", "raw_text": "(In reply to alexander :surkov from comment #21)\n> (In reply to Trevor Saunders (:tbsaunde) from comment #20)\n> > (In reply to alexander :surkov from comment #19)\n> > > it is, ideas to workaround it?\n> > \n> > use hash map from accessible to weak refs?\n> \n> 4 bytes per week ref vs keeping an accessible object in memory longer than\n> we need. Probably a win if somebody keeps them.\n\nmaybe, but its heavy weight and I'm not yet convinced we need it.\n\n> > or just not solve the problem? \n> > (what do we need it for?)\n> \n> It's tempting but imagine AT stored ISimpleDOMNode for menu accessible, it\n> was replaced on different accessible at the same memory address but AT still\n> operates on it like it was a menu. It could be a problem.\n\noh, yeah, I don't think not solvingthat problem is acceptable, I meant not supporting weak refs.", "time": "2013-05-15T06:06:11Z"}, {"id": 7424465, "bug_id": 678429, "is_private": false, "creation_time": "2013-05-15T06:15:08Z", "creator": "surkov.alexander@gmail.com", "text": "Comment on attachment 742208\npatch\n\nok, leaving it for now", "count": 23, "author": "surkov.alexander@gmail.com", "tags": [], "time": "2013-05-15T06:15:08Z", "raw_text": "ok, leaving it for now", "attachment_id": 742208}, {"time": "2018-10-15T08:44:38Z", "raw_text": "No assignee, updating the status.", "count": 24, "text": "No assignee, updating the status.", "author": "sledru@mozilla.com", "id": 13686295, "bug_id": 678429, "attachment_id": null, "tags": [], "creator": "sledru@mozilla.com", "is_private": false, "creation_time": "2018-10-15T08:44:38Z"}]}}, "comments": {}}