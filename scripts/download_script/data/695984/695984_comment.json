{"bugs": {"695984": {"comments": [{"is_private": false, "creator": "fryn@frankyan.com", "creation_time": "2011-10-20T05:47:40Z", "author": "fryn@frankyan.com", "text": "In Cocoa-based apps on OS X (Snow Leopard), it looks like it's standard to select the word on which the cursor was placed when opening the context menu.\n\nFor example, in Chrome, right-clicking or secondary click/tapping the word \"Firefox\" on a web page selects the word and opens a context menu with the item \"Search Google for 'Firefox'\". In Safari, the same happens, except with a menu item labelled \"Search in Google\". In TextEdit and Terminal, the same happens, except with a menu item labelled \"Search in Spotlight\".\n\nAlso, when right-clicking text inside a link, Chrome and Safari both select the link text and open a context menu with a similar searching item and also the menu item \"Copy\" to copy that link text.\n\nBoth of these are very useful, and I'd like to improve the platform integration and UI efficiency of Firefox by implementing them.", "tags": [], "time": "2011-10-20T05:47:40Z", "attachment_id": null, "raw_text": "In Cocoa-based apps on OS X (Snow Leopard), it looks like it's standard to select the word on which the cursor was placed when opening the context menu.\n\nFor example, in Chrome, right-clicking or secondary click/tapping the word \"Firefox\" on a web page selects the word and opens a context menu with the item \"Search Google for 'Firefox'\". In Safari, the same happens, except with a menu item labelled \"Search in Google\". In TextEdit and Terminal, the same happens, except with a menu item labelled \"Search in Spotlight\".\n\nAlso, when right-clicking text inside a link, Chrome and Safari both select the link text and open a context menu with a similar searching item and also the menu item \"Copy\" to copy that link text.\n\nBoth of these are very useful, and I'd like to improve the platform integration and UI efficiency of Firefox by implementing them.", "id": 5793827, "count": 0, "bug_id": 695984}, {"id": 5793834, "raw_text": "This is a hacky patch that I put together.\nIt works exactly as I would like the final patch to behave:\n- Right-clicking inside an existing selection maintains that selection.\n- Right-clicking an unselected area deselects any existing selection and does the following:\n  - If text inside a link, select all of the link text.\n  - If a word not inside a link, select the word.\n  - If two words not inside a link, select either both words or nothing.\n    (This patch selects both words, and I'm okay with that.)\n  - If an area that is not text, do not select anything.\n\nI've pushed it to the UX branch, and you can try it out in the latest UX nightlies (as of October 20, 2011):\nhttps://hg.mozilla.org/projects/ux/rev/61fd918ea50b\n\nEhsan, could you provide feedback on my patch's implementation and help with an API to select the word as if I were double-clicking on the word without having the simulate a double-mousedown (which is what the hacky patch does now)? Thank you in advance!", "attachment_id": 568317, "text": "Created attachment 568317\nhacky patch that works perfectly\n\nThis is a hacky patch that I put together.\nIt works exactly as I would like the final patch to behave:\n- Right-clicking inside an existing selection maintains that selection.\n- Right-clicking an unselected area deselects any existing selection and does the following:\n  - If text inside a link, select all of the link text.\n  - If a word not inside a link, select the word.\n  - If two words not inside a link, select either both words or nothing.\n    (This patch selects both words, and I'm okay with that.)\n  - If an area that is not text, do not select anything.\n\nI've pushed it to the UX branch, and you can try it out in the latest UX nightlies (as of October 20, 2011):\nhttps://hg.mozilla.org/projects/ux/rev/61fd918ea50b\n\nEhsan, could you provide feedback on my patch's implementation and help with an API to select the word as if I were double-clicking on the word without having the simulate a double-mousedown (which is what the hacky patch does now)? Thank you in advance!", "tags": [], "time": "2011-10-20T06:00:22Z", "bug_id": 695984, "creation_time": "2011-10-20T06:00:22Z", "author": "fryn@frankyan.com", "count": 1, "is_private": false, "creator": "fryn@frankyan.com"}, {"id": 5793854, "raw_text": "Correction:\n  - If two words not inside a link, select either both words or nothing.\nShould be:\n  - If the click is in the space between two words not inside a link, select either both words or nothing.", "attachment_id": null, "text": "Correction:\n  - If two words not inside a link, select either both words or nothing.\nShould be:\n  - If the click is in the space between two words not inside a link, select either both words or nothing.", "tags": [], "bug_id": 695984, "time": "2011-10-20T06:34:52Z", "creation_time": "2011-10-20T06:34:52Z", "author": "fryn@frankyan.com", "count": 2, "is_private": false, "creator": "fryn@frankyan.com"}, {"tags": [], "time": "2011-10-22T19:13:31Z", "text": "Comment on attachment 568317\nhacky patch that works perfectly\n\nReview of attachment 568317:\n-----------------------------------------------------------------\n\nOverall this look good.  Please see my comments inline.\n\n::: browser/base/content/nsContextMenu.js\n@@ +1468,5 @@\n>    }\n>  };\n> +\n> +#ifdef XP_MACOSX\n> +function selectContext(event) {\n\nThis method needs to be e10s aware.  :-)\n\n@@ +1475,5 @@\n> +  let x = event.screenX - box.screenX, y = event.screenY - box.screenY;\n> +  let clickIsInside = function(rect)\n> +    x >= rect.left && x <= rect.left + rect.width &&\n> +    y >= rect.top && y <= rect.top + rect.height;\n> +  let selection = document.commandDispatcher.focusedWindow.getSelection();\n\nThis will not work correctly when right-clicking on text controls, since they have their own selection objects.\n\n@@ +1483,5 @@\n> +  selection.removeAllRanges();\n> +\n> +  // If click is on text, select word(s).\n> +  let node = document.popupNode, range = document.createRange();\n> +  if (function clickIsOnText(node) {\n\nNit: please define the function before the if statement.\n\n@@ +1493,5 @@\n> +  }(node)) {\n> +    // If click is on text in link, select link contents.\n> +    do {\n> +      if (node instanceof HTMLAnchorElement && node.href) {\n> +        range.selectNodeContents(node);\n\nIf the anchor contains other things as well (for example an image) do we still want to select it?\n\n@@ +1503,5 @@\n> +      removeEventListener(\"mousedown\", suppressHandlers, true);\n> +      event.stopPropagation();\n> +    }, true);\n> +    QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils).\n> +    sendMouseEvent(\"mousedown\", event.clientX, event.clientY, 0, 2, 0);\n\nIf the element has other mousedown event handlers attached to it, will this trigger them being selected as well?\n\nMaybe it's best to implement this part on the Gecko side?", "author": "ehsan.akhgari@gmail.com", "creation_time": "2011-10-22T19:13:31Z", "creator": "ehsan.akhgari@gmail.com", "is_private": false, "id": 5798846, "raw_text": "Review of attachment 568317:\n-----------------------------------------------------------------\n\nOverall this look good.  Please see my comments inline.\n\n::: browser/base/content/nsContextMenu.js\n@@ +1468,5 @@\n>    }\n>  };\n> +\n> +#ifdef XP_MACOSX\n> +function selectContext(event) {\n\nThis method needs to be e10s aware.  :-)\n\n@@ +1475,5 @@\n> +  let x = event.screenX - box.screenX, y = event.screenY - box.screenY;\n> +  let clickIsInside = function(rect)\n> +    x >= rect.left && x <= rect.left + rect.width &&\n> +    y >= rect.top && y <= rect.top + rect.height;\n> +  let selection = document.commandDispatcher.focusedWindow.getSelection();\n\nThis will not work correctly when right-clicking on text controls, since they have their own selection objects.\n\n@@ +1483,5 @@\n> +  selection.removeAllRanges();\n> +\n> +  // If click is on text, select word(s).\n> +  let node = document.popupNode, range = document.createRange();\n> +  if (function clickIsOnText(node) {\n\nNit: please define the function before the if statement.\n\n@@ +1493,5 @@\n> +  }(node)) {\n> +    // If click is on text in link, select link contents.\n> +    do {\n> +      if (node instanceof HTMLAnchorElement && node.href) {\n> +        range.selectNodeContents(node);\n\nIf the anchor contains other things as well (for example an image) do we still want to select it?\n\n@@ +1503,5 @@\n> +      removeEventListener(\"mousedown\", suppressHandlers, true);\n> +      event.stopPropagation();\n> +    }, true);\n> +    QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils).\n> +    sendMouseEvent(\"mousedown\", event.clientX, event.clientY, 0, 2, 0);\n\nIf the element has other mousedown event handlers attached to it, will this trigger them being selected as well?\n\nMaybe it's best to implement this part on the Gecko side?", "attachment_id": 568317, "bug_id": 695984, "count": 3}, {"count": 4, "is_private": false, "creator": "ehsan.akhgari@gmail.com", "text": "See nsFrame::HandleMultiplePress <http://mxr.mozilla.org/mozilla-central/source/layout/generic/nsFrame.cpp#2497> for the code in Gecko implementing word selection.  Specifically, you can use the nsFrame::PeekBackwardAndForward API to get the word selection behavior you need.", "tags": [], "time": "2011-10-22T19:17:48Z", "bug_id": 695984, "creation_time": "2011-10-22T19:17:48Z", "author": "ehsan.akhgari@gmail.com", "raw_text": "See nsFrame::HandleMultiplePress <http://mxr.mozilla.org/mozilla-central/source/layout/generic/nsFrame.cpp#2497> for the code in Gecko implementing word selection.  Specifically, you can use the nsFrame::PeekBackwardAndForward API to get the word selection behavior you need.", "attachment_id": null, "id": 5798857}, {"bug_id": 695984, "count": 5, "id": 6078283, "raw_text": "wouldn't it make sense to have a hidden preference for this, since it might be useful for other platforms aswell?", "attachment_id": null, "time": "2012-02-21T13:19:46Z", "tags": [], "text": "wouldn't it make sense to have a hidden preference for this, since it might be useful for other platforms aswell?", "author": "mozilla@metasieben.org", "creation_time": "2012-02-21T13:19:46Z", "creator": "mozilla@metasieben.org", "is_private": false}, {"creator": "fryn@frankyan.com", "is_private": false, "count": 6, "author": "fryn@frankyan.com", "creation_time": "2012-08-17T00:31:23Z", "time": "2012-08-17T00:31:23Z", "bug_id": 695984, "tags": [], "text": "Unassigning myself, as I'm not actively working on this.", "attachment_id": null, "raw_text": "Unassigning myself, as I'm not actively working on this.", "id": 6561547}, {"text": "*** Bug 365183 has been marked as a duplicate of this bug. ***", "time": "2012-09-11T01:55:37Z", "bug_id": 695984, "tags": [], "creation_time": "2012-09-11T01:55:37Z", "author": "fryn@frankyan.com", "count": 7, "is_private": false, "creator": "fryn@frankyan.com", "id": 6624276, "raw_text": "", "attachment_id": null}, {"count": 8, "is_private": false, "creator": "fryn@frankyan.com", "text": "Created attachment 660398\nWIP v1\n\nI got this working correctly when right-clicking directly on a word.\nUnfortunately, it also selects text when right-clicking outside of text regions in the same cases that we select text when double-clicking in those locations.\nWhat is the best way to detect whether the cursor is actually inside the rects of a text region?\nIn other words, SelectByTypeAtPoint in nsFrame does not provide the behavior that is desired here.\n\nAlso, ideally, the previous selection should be deselected when right-clicking outside of the region in which dragging the cursor would have produced that selection. I am not sure how to implement this either.", "bug_id": 695984, "tags": [], "time": "2012-09-12T12:30:30Z", "creation_time": "2012-09-12T12:30:30Z", "author": "fryn@frankyan.com", "raw_text": "I got this working correctly when right-clicking directly on a word.\nUnfortunately, it also selects text when right-clicking outside of text regions in the same cases that we select text when double-clicking in those locations.\nWhat is the best way to detect whether the cursor is actually inside the rects of a text region?\nIn other words, SelectByTypeAtPoint in nsFrame does not provide the behavior that is desired here.\n\nAlso, ideally, the previous selection should be deselected when right-clicking outside of the region in which dragging the cursor would have produced that selection. I am not sure how to implement this either.", "attachment_id": 660398, "id": 6628630}, {"count": 9, "bug_id": 695984, "creator": "ehsan.akhgari@gmail.com", "is_private": false, "tags": [], "time": "2012-09-12T18:16:07Z", "text": "Do you expect to get this behavior only in inputs and textareas, or in all editable fields?", "author": "ehsan.akhgari@gmail.com", "creation_time": "2012-09-12T18:16:07Z", "raw_text": "Do you expect to get this behavior only in inputs and textareas, or in all editable fields?", "attachment_id": null, "id": 6629651}, {"attachment_id": null, "raw_text": "(Talking about contentEditable fields and documents in designMode.)", "id": 6629652, "creator": "ehsan.akhgari@gmail.com", "is_private": false, "count": 10, "author": "ehsan.akhgari@gmail.com", "creation_time": "2012-09-12T18:16:27Z", "time": "2012-09-12T18:16:27Z", "bug_id": 695984, "tags": [], "text": "(Talking about contentEditable fields and documents in designMode.)"}, {"count": 11, "creator": "fryn@frankyan.com", "is_private": false, "time": "2012-09-12T19:52:31Z", "bug_id": 695984, "tags": [], "text": "(In reply to Ehsan Akhgari [:ehsan])\n> Do you expect to get this behavior only in inputs and textareas, or in all\n> editable fields?\n> (Talking about contentEditable fields and documents in designMode.)\n\nIf by \"this behavior\" you mean \"selecting clicked word when opening context menu\", I'd like this behavior to work for any part of the web page that is selectable, including non-contentEditable text. That's how it works in almost all other Cocoa-based text fields on OS X, including in Safari and Chrome.\n\nIf by \"this behavior\" you mean \"right-clicking on a word selecting the word and right-clicking in a blank area NOT selecting the nearest word\", I'm mostly referring to non-editable fields, e.g. most body text of web pages.\n\nImplementation-wise, I'm like to do the following:\n\n1. Implement a function that returns when a mouse event was outside of the bounds of the current selection, so we can deselect the current selection on right-click if it returns true. (The \"bounds of selection\" does not always equal the union of the clientRects of the selection ranges. For example, select the second half of a paragraph by dragging beyond the last word of the paragraph. Now right-click. Even though the cursor is slightly outside of the highlighted region, in the desired behavior, we should continue to maintain the selection.)\n\n2. Implement a variant of SelectByTypeAtPoint that only selects words when clicking directly on them. I think I can do this using the target of the nsGUIEvent and then walking down into the tree to check before selecting, but it seems overly convoluted and expensive. Is there a better way?", "author": "fryn@frankyan.com", "creation_time": "2012-09-12T19:52:31Z", "raw_text": "(In reply to Ehsan Akhgari [:ehsan])\n> Do you expect to get this behavior only in inputs and textareas, or in all\n> editable fields?\n> (Talking about contentEditable fields and documents in designMode.)\n\nIf by \"this behavior\" you mean \"selecting clicked word when opening context menu\", I'd like this behavior to work for any part of the web page that is selectable, including non-contentEditable text. That's how it works in almost all other Cocoa-based text fields on OS X, including in Safari and Chrome.\n\nIf by \"this behavior\" you mean \"right-clicking on a word selecting the word and right-clicking in a blank area NOT selecting the nearest word\", I'm mostly referring to non-editable fields, e.g. most body text of web pages.\n\nImplementation-wise, I'm like to do the following:\n\n1. Implement a function that returns when a mouse event was outside of the bounds of the current selection, so we can deselect the current selection on right-click if it returns true. (The \"bounds of selection\" does not always equal the union of the clientRects of the selection ranges. For example, select the second half of a paragraph by dragging beyond the last word of the paragraph. Now right-click. Even though the cursor is slightly outside of the highlighted region, in the desired behavior, we should continue to maintain the selection.)\n\n2. Implement a variant of SelectByTypeAtPoint that only selects words when clicking directly on them. I think I can do this using the target of the nsGUIEvent and then walking down into the tree to check before selecting, but it seems overly convoluted and expensive. Is there a better way?", "attachment_id": null, "id": 6629971}, {"id": 6630098, "raw_text": "(In reply to comment #11)\n> (In reply to Ehsan Akhgari [:ehsan])\n> > Do you expect to get this behavior only in inputs and textareas, or in all\n> > editable fields?\n> > (Talking about contentEditable fields and documents in designMode.)\n> \n> If by \"this behavior\" you mean \"selecting clicked word when opening context\n> menu\", I'd like this behavior to work for any part of the web page that is\n> selectable, including non-contentEditable text. That's how it works in almost\n> all other Cocoa-based text fields on OS X, including in Safari and Chrome.\n\nYes, that is what I meant.  If you wanna do that, you should hit-test and get the frame corresponding to the event position, and call nsIFrame::IsSelectable on it.\n\n> If by \"this behavior\" you mean \"right-clicking on a word selecting the word and\n> right-clicking in a blank area NOT selecting the nearest word\", I'm mostly\n> referring to non-editable fields, e.g. most body text of web pages.\n\nNo, sorry, I was confused.  Please ignore my comment about the editability.\n\n> Implementation-wise, I'm like to do the following:\n> \n> 1. Implement a function that returns when a mouse event was outside of the\n> bounds of the current selection, so we can deselect the current selection on\n> right-click if it returns true. (The \"bounds of selection\" does not always\n> equal the union of the clientRects of the selection ranges. For example, select\n> the second half of a paragraph by dragging beyond the last word of the\n> paragraph. Now right-click. Even though the cursor is slightly outside of the\n> highlighted region, in the desired behavior, we should continue to maintain the\n> selection.)\n\nHmm, isn't this just hit-testing?\n\n> 2. Implement a variant of SelectByTypeAtPoint that only selects words when\n> clicking directly on them. I think I can do this using the target of the\n> nsGUIEvent and then walking down into the tree to check before selecting, but\n> it seems overly convoluted and expensive. Is there a better way?\n\nYou need to ask roc about that.", "attachment_id": null, "tags": [], "time": "2012-09-12T20:24:35Z", "text": "(In reply to comment #11)\n> (In reply to Ehsan Akhgari [:ehsan])\n> > Do you expect to get this behavior only in inputs and textareas, or in all\n> > editable fields?\n> > (Talking about contentEditable fields and documents in designMode.)\n> \n> If by \"this behavior\" you mean \"selecting clicked word when opening context\n> menu\", I'd like this behavior to work for any part of the web page that is\n> selectable, including non-contentEditable text. That's how it works in almost\n> all other Cocoa-based text fields on OS X, including in Safari and Chrome.\n\nYes, that is what I meant.  If you wanna do that, you should hit-test and get the frame corresponding to the event position, and call nsIFrame::IsSelectable on it.\n\n> If by \"this behavior\" you mean \"right-clicking on a word selecting the word and\n> right-clicking in a blank area NOT selecting the nearest word\", I'm mostly\n> referring to non-editable fields, e.g. most body text of web pages.\n\nNo, sorry, I was confused.  Please ignore my comment about the editability.\n\n> Implementation-wise, I'm like to do the following:\n> \n> 1. Implement a function that returns when a mouse event was outside of the\n> bounds of the current selection, so we can deselect the current selection on\n> right-click if it returns true. (The \"bounds of selection\" does not always\n> equal the union of the clientRects of the selection ranges. For example, select\n> the second half of a paragraph by dragging beyond the last word of the\n> paragraph. Now right-click. Even though the cursor is slightly outside of the\n> highlighted region, in the desired behavior, we should continue to maintain the\n> selection.)\n\nHmm, isn't this just hit-testing?\n\n> 2. Implement a variant of SelectByTypeAtPoint that only selects words when\n> clicking directly on them. I think I can do this using the target of the\n> nsGUIEvent and then walking down into the tree to check before selecting, but\n> it seems overly convoluted and expensive. Is there a better way?\n\nYou need to ask roc about that.", "author": "ehsan.akhgari@gmail.com", "creation_time": "2012-09-12T20:24:35Z", "creator": "ehsan.akhgari@gmail.com", "is_private": false, "bug_id": 695984, "count": 12}, {"creator": "fryn@frankyan.com", "is_private": false, "count": 13, "author": "fryn@frankyan.com", "creation_time": "2012-09-12T20:54:19Z", "bug_id": 695984, "tags": [], "time": "2012-09-12T20:54:19Z", "text": "(In reply to Ehsan Akhgari [:ehsan] from comment #12)\n> > 1. Implement a function that returns when a mouse event was outside of the\n> > bounds of the current selection, so we can deselect the current selection on\n> > right-click if it returns true. (The \"bounds of selection\" does not always\n> > equal the union of the clientRects of the selection ranges. For example, select\n> > the second half of a paragraph by dragging beyond the last word of the\n> > paragraph. Now right-click. Even though the cursor is slightly outside of the\n> > highlighted region, in the desired behavior, we should continue to maintain the\n> > selection.)\n> \n> Hmm, isn't this just hit-testing?\n\nYes, but I don't know how to compute the region to hit-test against. As I explained above, the union of the clientRects of the selection ranges is often smaller than the correct region.\n\n> > 2. Implement a variant of SelectByTypeAtPoint that only selects words when\n> > clicking directly on them. I think I can do this using the target of the\n> > nsGUIEvent and then walking down into the tree to check before selecting, but\n> > it seems overly convoluted and expensive. Is there a better way?\n> \n> You need to ask roc about that.\n\nRoc, could you help me with these two problems?", "attachment_id": null, "raw_text": "(In reply to Ehsan Akhgari [:ehsan] from comment #12)\n> > 1. Implement a function that returns when a mouse event was outside of the\n> > bounds of the current selection, so we can deselect the current selection on\n> > right-click if it returns true. (The \"bounds of selection\" does not always\n> > equal the union of the clientRects of the selection ranges. For example, select\n> > the second half of a paragraph by dragging beyond the last word of the\n> > paragraph. Now right-click. Even though the cursor is slightly outside of the\n> > highlighted region, in the desired behavior, we should continue to maintain the\n> > selection.)\n> \n> Hmm, isn't this just hit-testing?\n\nYes, but I don't know how to compute the region to hit-test against. As I explained above, the union of the clientRects of the selection ranges is often smaller than the correct region.\n\n> > 2. Implement a variant of SelectByTypeAtPoint that only selects words when\n> > clicking directly on them. I think I can do this using the target of the\n> > nsGUIEvent and then walking down into the tree to check before selecting, but\n> > it seems overly convoluted and expensive. Is there a better way?\n> \n> You need to ask roc about that.\n\nRoc, could you help me with these two problems?", "id": 6630194}, {"attachment_id": null, "raw_text": "(In reply to comment #13)\n> (In reply to Ehsan Akhgari [:ehsan] from comment #12)\n> > > 1. Implement a function that returns when a mouse event was outside of the\n> > > bounds of the current selection, so we can deselect the current selection on\n> > > right-click if it returns true. (The \"bounds of selection\" does not always\n> > > equal the union of the clientRects of the selection ranges. For example, select\n> > > the second half of a paragraph by dragging beyond the last word of the\n> > > paragraph. Now right-click. Even though the cursor is slightly outside of the\n> > > highlighted region, in the desired behavior, we should continue to maintain the\n> > > selection.)\n> > \n> > Hmm, isn't this just hit-testing?\n> \n> Yes, but I don't know how to compute the region to hit-test against. As I\n> explained above, the union of the clientRects of the selection ranges is often\n> smaller than the correct region.\n\nI'm not sure why you need to do that.  Unless I'm missing something, you should just get a frame from the hit-testing, and see if it's selected or not.  You don't need to worry about the client rects of the selection range at all.", "id": 6630522, "creator": "ehsan.akhgari@gmail.com", "is_private": false, "count": 14, "author": "ehsan.akhgari@gmail.com", "creation_time": "2012-09-12T22:35:06Z", "time": "2012-09-12T22:35:06Z", "tags": [], "bug_id": 695984, "text": "(In reply to comment #13)\n> (In reply to Ehsan Akhgari [:ehsan] from comment #12)\n> > > 1. Implement a function that returns when a mouse event was outside of the\n> > > bounds of the current selection, so we can deselect the current selection on\n> > > right-click if it returns true. (The \"bounds of selection\" does not always\n> > > equal the union of the clientRects of the selection ranges. For example, select\n> > > the second half of a paragraph by dragging beyond the last word of the\n> > > paragraph. Now right-click. Even though the cursor is slightly outside of the\n> > > highlighted region, in the desired behavior, we should continue to maintain the\n> > > selection.)\n> > \n> > Hmm, isn't this just hit-testing?\n> \n> Yes, but I don't know how to compute the region to hit-test against. As I\n> explained above, the union of the clientRects of the selection ranges is often\n> smaller than the correct region.\n\nI'm not sure why you need to do that.  Unless I'm missing something, you should just get a frame from the hit-testing, and see if it's selected or not.  You don't need to worry about the client rects of the selection range at all."}, {"id": 6630555, "attachment_id": null, "raw_text": "(And by that, I mean calling the nsIFrame::IsSelected() function.)", "author": "ehsan.akhgari@gmail.com", "creation_time": "2012-09-12T22:42:49Z", "tags": [], "bug_id": 695984, "time": "2012-09-12T22:42:49Z", "text": "(And by that, I mean calling the nsIFrame::IsSelected() function.)", "creator": "ehsan.akhgari@gmail.com", "is_private": false, "count": 15}, {"id": 6631224, "raw_text": "(In reply to Ehsan Akhgari [:ehsan] from comment #15)\n> (And by that, I mean calling the nsIFrame::IsSelected() function.)\n\nIf you take a look at the patch, you'll see that I'm using it already, but it's not sufficient. If this is too confusing to follow in text form, I can show you via screen sharing on Vidyo or something.", "attachment_id": null, "tags": [], "time": "2012-09-13T03:31:00Z", "text": "(In reply to Ehsan Akhgari [:ehsan] from comment #15)\n> (And by that, I mean calling the nsIFrame::IsSelected() function.)\n\nIf you take a look at the patch, you'll see that I'm using it already, but it's not sufficient. If this is too confusing to follow in text form, I can show you via screen sharing on Vidyo or something.", "author": "fryn@frankyan.com", "creation_time": "2012-09-13T03:31:00Z", "creator": "fryn@frankyan.com", "is_private": false, "bug_id": 695984, "count": 16}, {"count": 17, "bug_id": 695984, "is_private": false, "creator": "ehsan.akhgari@gmail.com", "text": "So, I'm not quite sure what you mean.  Can you please capture the bad behavior on a screencast?\n\nI also tested chrome, and it seems like their behavior is a bit more complicated than this.  For example, right clicking on multi-word links selects the entire link.\n\nPerhaps we should first get a better sense of what the desired behavior is.", "time": "2012-09-13T18:17:04Z", "tags": [], "creation_time": "2012-09-13T18:17:04Z", "author": "ehsan.akhgari@gmail.com", "raw_text": "So, I'm not quite sure what you mean.  Can you please capture the bad behavior on a screencast?\n\nI also tested chrome, and it seems like their behavior is a bit more complicated than this.  For example, right clicking on multi-word links selects the entire link.\n\nPerhaps we should first get a better sense of what the desired behavior is.", "attachment_id": null, "id": 6632913}, {"id": 6633090, "attachment_id": null, "raw_text": "(In reply to Ehsan Akhgari [:ehsan] from comment #17)\n> Perhaps we should first get a better sense of what the desired behavior is.\n\nI know exactly what the desired behavior is. It's just very difficult to recreate it, so, in the previous comments, I've been trying to break it down into pieces that we'd need to achieve it.\nI'll make a screencast of it.", "creation_time": "2012-09-13T19:14:13Z", "author": "fryn@frankyan.com", "text": "(In reply to Ehsan Akhgari [:ehsan] from comment #17)\n> Perhaps we should first get a better sense of what the desired behavior is.\n\nI know exactly what the desired behavior is. It's just very difficult to recreate it, so, in the previous comments, I've been trying to break it down into pieces that we'd need to achieve it.\nI'll make a screencast of it.", "tags": [], "bug_id": 695984, "time": "2012-09-13T19:14:13Z", "is_private": false, "creator": "fryn@frankyan.com", "count": 18}, {"is_private": false, "creator": "mozilla@metasieben.org", "count": 19, "creation_time": "2012-09-14T09:00:12Z", "author": "mozilla@metasieben.org", "text": "while platform integration is great, will it still be possible to use >View Selection Source< after this has landed? neither chrome nor safari have this VERY useful feature.\n\ncorrect me if i'm wrong, the patch that landed on the ux-branch did not allow that; it cleared the selection as soon as you right-clicked anywhere.", "time": "2012-09-14T09:00:12Z", "tags": [], "bug_id": 695984, "attachment_id": null, "raw_text": "while platform integration is great, will it still be possible to use >View Selection Source< after this has landed? neither chrome nor safari have this VERY useful feature.\n\ncorrect me if i'm wrong, the patch that landed on the ux-branch did not allow that; it cleared the selection as soon as you right-clicked anywhere.", "id": 6634820}, {"attachment_id": 660398, "raw_text": "Clearing the request for now.", "id": 6635882, "creator": "ehsan.akhgari@gmail.com", "is_private": false, "count": 20, "author": "ehsan.akhgari@gmail.com", "creation_time": "2012-09-14T17:39:40Z", "tags": [], "time": "2012-09-14T17:39:40Z", "bug_id": 695984, "text": "Comment on attachment 660398\nWIP v1\n\nClearing the request for now."}, {"raw_text": "There are complains on Facebook so I dug a bit and find this bug.\n\n(In reply to :Ehsan Akhgari from comment #4)\n> See nsFrame::HandleMultiplePress\n> <http://mxr.mozilla.org/mozilla-central/source/layout/generic/nsFrame.\n> cpp#2497> for the code in Gecko implementing word selection.  Specifically,\n> you can use the nsFrame::PeekBackwardAndForward API to get the word\n> selection behavior you need.\n\nAre these APIs scriptable? With e10s I don't think it make sense to do things as WIP does (trying to select the word from parent process through Selection API). IMHO the right place to do thing is here\n\nhttp://searchfox.org/mozilla-central/rev/03b3c20a6ec60435feb995a2a23c5926188c85a1/browser/base/content/content.js#121\n\nbut these methods has to be scriptable in order to be called here...", "attachment_id": null, "id": 11628508, "count": 21, "is_private": false, "creator": "timdream@gmail.com", "text": "There are complains on Facebook so I dug a bit and find this bug.\n\n(In reply to :Ehsan Akhgari from comment #4)\n> See nsFrame::HandleMultiplePress\n> <http://mxr.mozilla.org/mozilla-central/source/layout/generic/nsFrame.\n> cpp#2497> for the code in Gecko implementing word selection.  Specifically,\n> you can use the nsFrame::PeekBackwardAndForward API to get the word\n> selection behavior you need.\n\nAre these APIs scriptable? With e10s I don't think it make sense to do things as WIP does (trying to select the word from parent process through Selection API). IMHO the right place to do thing is here\n\nhttp://searchfox.org/mozilla-central/rev/03b3c20a6ec60435feb995a2a23c5926188c85a1/browser/base/content/content.js#121\n\nbut these methods has to be scriptable in order to be called here...", "bug_id": 695984, "time": "2016-08-16T11:18:36Z", "tags": [], "creation_time": "2016-08-16T11:18:36Z", "author": "timdream@gmail.com"}, {"id": 11631391, "attachment_id": null, "raw_text": "(In reply to Tim Guan-tin Chien [:timdream] (please needinfo) from comment #21)\n> With e10s I don't think it make sense to do\n> things as WIP does (trying to select the word from parent process through\n> Selection API). \n\nI am sorry, I didn't look at the second WIP which do stuff in nsFrame.cpp directly in the content process.", "author": "timdream@gmail.com", "creation_time": "2016-08-17T04:55:58Z", "tags": [], "bug_id": 695984, "time": "2016-08-17T04:55:58Z", "text": "(In reply to Tim Guan-tin Chien [:timdream] (please needinfo) from comment #21)\n> With e10s I don't think it make sense to do\n> things as WIP does (trying to select the word from parent process through\n> Selection API). \n\nI am sorry, I didn't look at the second WIP which do stuff in nsFrame.cpp directly in the content process.", "creator": "timdream@gmail.com", "is_private": false, "count": 22}, {"creator": "yoasif@gmail.com", "is_private": false, "tags": [], "time": "2017-12-28T16:03:28Z", "text": "This was reported on https://www.reddit.com/r/firefox/comments/7mmvl6/select_word_with_secondary_click/ -- desired behavior is shown in: https://gfycat.com/FoolishOblongCob and the Firefox behavior is shown in https://gfycat.com/SecondhandJovialLeonberger.\n\nI am also able to reproduce this behavior.", "author": "yoasif@gmail.com", "creation_time": "2017-12-28T16:03:28Z", "raw_text": "This was reported on https://www.reddit.com/r/firefox/comments/7mmvl6/select_word_with_secondary_click/ -- desired behavior is shown in: https://gfycat.com/FoolishOblongCob and the Firefox behavior is shown in https://gfycat.com/SecondhandJovialLeonberger.\n\nI am also able to reproduce this behavior.", "attachment_id": null, "id": 12937444, "count": 23, "bug_id": 695984}]}}, "comments": {}}