{"comments": {}, "bugs": {"706197": {"comments": [{"author": "sstangl@mozilla.com", "creator": "sstangl@mozilla.com", "bug_id": 706197, "id": 5879527, "count": 0, "is_private": false, "tags": [], "time": "2011-11-29T19:34:55Z", "attachment_id": null, "text": "Chris pointed out that if Ion compiles are cheap enough, and for a hopefully short-lived memory hit, OSR can be refactored to always produce graphs with a single entry-point.\n\nIn this proposed model, each IonScript would contain two primary IonCode references: one for the default method called when compiling a function, and one bound to an opcode for OSR, which is a GC candidate as soon as that Ion frame is removed.\n\nCompilation of OSR would occur completely separately from compiling for function invocation. Therefore Block 0 of the OSR method could be the OSR entry itself. If the OSR point is on a nested loop, the outer loop(s) would be unrolled.\n\nThe advantage to this approach is better optimization (for little work) and simpler optimization phases. A single entry-point would make our optimizations closer to textbook form, which would be great. They would also likely run more quickly, having less complexity to mitigate.\n\nThe disadvantage is multiple compilation, which is only possible if optimization is cheap. We would also have to examine when to compile functions for regular invocation -- the HotSpot compiler, which provides the motivation for this bug, would perform that compilation just before the separate OSR compilation.\n\nThe motivating blog entry that Chris linked me to is:\nhttp://www.azulsystems.com/blog/cliff/2011-11-22-what-the-heck-is-osr-and-why-is-it-bad-or-good/hots\n\nI am leaving this bug to be investigated in the future.", "raw_text": "Chris pointed out that if Ion compiles are cheap enough, and for a hopefully short-lived memory hit, OSR can be refactored to always produce graphs with a single entry-point.\n\nIn this proposed model, each IonScript would contain two primary IonCode references: one for the default method called when compiling a function, and one bound to an opcode for OSR, which is a GC candidate as soon as that Ion frame is removed.\n\nCompilation of OSR would occur completely separately from compiling for function invocation. Therefore Block 0 of the OSR method could be the OSR entry itself. If the OSR point is on a nested loop, the outer loop(s) would be unrolled.\n\nThe advantage to this approach is better optimization (for little work) and simpler optimization phases. A single entry-point would make our optimizations closer to textbook form, which would be great. They would also likely run more quickly, having less complexity to mitigate.\n\nThe disadvantage is multiple compilation, which is only possible if optimization is cheap. We would also have to examine when to compile functions for regular invocation -- the HotSpot compiler, which provides the motivation for this bug, would perform that compilation just before the separate OSR compilation.\n\nThe motivating blog entry that Chris linked me to is:\nhttp://www.azulsystems.com/blog/cliff/2011-11-22-what-the-heck-is-osr-and-why-is-it-bad-or-good/hots\n\nI am leaving this bug to be investigated in the future.", "creation_time": "2011-11-29T19:34:55Z"}, {"id": 7392705, "tags": [], "count": 1, "is_private": false, "bug_id": 706197, "raw_text": "(In reply to Sean Stangl [:sstangl] from comment #0)\n> Chris pointed out that if Ion compiles are cheap enough, [\u2026]\n\nShouldn't we mark this bug as invalid?", "creation_time": "2013-05-06T21:15:42Z", "author": "nicolas.b.pierron@mozilla.com", "time": "2013-05-06T21:15:42Z", "attachment_id": null, "creator": "nicolas.b.pierron@mozilla.com", "text": "(In reply to Sean Stangl [:sstangl] from comment #0)\n> Chris pointed out that if Ion compiles are cheap enough, [\u2026]\n\nShouldn't we mark this bug as invalid?"}]}}}