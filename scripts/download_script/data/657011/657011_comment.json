{"bugs": {"657011": {"comments": [{"time": "2011-05-13T20:39:05Z", "id": 5469099, "is_private": false, "raw_text": "QI is implemented pretty naively.  NS_TableDrivenQI (nsISupportsImpl.cpp) does a linear search through a table for a matching IID, and returns if none is found.  The macro-based QI implementation is similar -- it constructs a sequence of if statements checking each IID.\n\nIt's not clear to me whether this is a bottleneck, but if it is, there are many ways we might be able to do better (roughly in order of easy to hard):\n\n* Manually reorder interfaces so that the most commonly-targeted interfaces appear first in the list.\n\n* Implement IID comparisons using SIMD instructions.  (I actually don't think this is likely to help much, since the IIDs aren't particularly long and should fail to match on the first word most of the time.)\n\n* Use binary search on classes with many interfaces.\n\n* Index into a lookup table to do the QI.\n\n* Inline (many) QI calls.  If we know statically what class we're QI'ing to, the compiler should be able to get rid of the irrelevant branches.\n\nFirst step would be determining if this actually matters.", "creation_time": "2011-05-13T20:39:05Z", "bug_id": 657011, "tags": [], "author": "justin.lebar+bug@gmail.com", "text": "QI is implemented pretty naively.  NS_TableDrivenQI (nsISupportsImpl.cpp) does a linear search through a table for a matching IID, and returns if none is found.  The macro-based QI implementation is similar -- it constructs a sequence of if statements checking each IID.\n\nIt's not clear to me whether this is a bottleneck, but if it is, there are many ways we might be able to do better (roughly in order of easy to hard):\n\n* Manually reorder interfaces so that the most commonly-targeted interfaces appear first in the list.\n\n* Implement IID comparisons using SIMD instructions.  (I actually don't think this is likely to help much, since the IIDs aren't particularly long and should fail to match on the first word most of the time.)\n\n* Use binary search on classes with many interfaces.\n\n* Index into a lookup table to do the QI.\n\n* Inline (many) QI calls.  If we know statically what class we're QI'ing to, the compiler should be able to get rid of the irrelevant branches.\n\nFirst step would be determining if this actually matters.", "count": 0, "attachment_id": null, "creator": "justin.lebar+bug@gmail.com"}, {"text": "Reordering has marginal gain: in many cases, the interface 'misses' are as common as the hits (e.g. xpconnect QIed everything to nsIXPCScriptable).\n\nGoing from macro to table-driven was a noticeable improvement (bug 313309), but the benefit was mainly derived from the codesize win and improved memory locality of the really tight loop. The bug doesn't say, but I think it improved Tp times by 2-3%.\n\nWe tried to do a binary-search implementation per-class (generated from python, IIRC) which would optimize the number of comparisons and use switch statements: I can't find that bug now, but it basically caused codesize to balloon and offset the raw performance win. See bug 412320 for the gory details.\n\nIf you statically know the class you're QIing to, why are you QIing at all? Just use static-cast. But that's very unlikely to be the common case.\n\nAs of the last time we measured (a couple years ago at least), MMX instructions for nsID::Equals were actually *slower* than the four word comparisons we have now, partly because of the shortcut common-case where the first comparison misses. See bug 165975.\n\nI don't mean to be discouraging, but I think we've mined out all the useful wins here and probably should focus on other things.", "count": 1, "time": "2011-05-13T21:26:54Z", "author": "benjamin@smedbergs.us", "id": 5469221, "bug_id": 657011, "creation_time": "2011-05-13T21:26:54Z", "raw_text": "Reordering has marginal gain: in many cases, the interface 'misses' are as common as the hits (e.g. xpconnect QIed everything to nsIXPCScriptable).\n\nGoing from macro to table-driven was a noticeable improvement (bug 313309), but the benefit was mainly derived from the codesize win and improved memory locality of the really tight loop. The bug doesn't say, but I think it improved Tp times by 2-3%.\n\nWe tried to do a binary-search implementation per-class (generated from python, IIRC) which would optimize the number of comparisons and use switch statements: I can't find that bug now, but it basically caused codesize to balloon and offset the raw performance win. See bug 412320 for the gory details.\n\nIf you statically know the class you're QIing to, why are you QIing at all? Just use static-cast. But that's very unlikely to be the common case.\n\nAs of the last time we measured (a couple years ago at least), MMX instructions for nsID::Equals were actually *slower* than the four word comparisons we have now, partly because of the shortcut common-case where the first comparison misses. See bug 165975.\n\nI don't mean to be discouraging, but I think we've mined out all the useful wins here and probably should focus on other things.", "tags": [], "creator": "benjamin@smedbergs.us", "is_private": false, "attachment_id": null}, {"creator": "justin.lebar+bug@gmail.com", "attachment_id": null, "count": 2, "text": "> If you statically know the class you're QIing to, why are you QIing at all? \n> Just use static-cast. But that's very unlikely to be the common case.\n\nI should have said that you statically know the *interface* you're QI'ing to.  We currently do:\n\nQueryInterface (iid, obj):\n  if (iid == IFoo::iid)\n    return obj cast as IFoo\n  else if (iid == IBar::iid)\n    return obj cast as IBar\n  else\n    return null\n\nIf you statically know that iid == IFoo::iid, this is a lot simpler.\n\nIt seems the real trick is that you don't statically know what concrete class you're QI'ing *from*.\n\n> I don't mean to be discouraging, but I think we've mined out all the useful \n> wins here and probably should focus on other things.\n\nNot at all!  I appreciate your looking up those old bugs.", "author": "justin.lebar+bug@gmail.com", "tags": [], "raw_text": "> If you statically know the class you're QIing to, why are you QIing at all? \n> Just use static-cast. But that's very unlikely to be the common case.\n\nI should have said that you statically know the *interface* you're QI'ing to.  We currently do:\n\nQueryInterface (iid, obj):\n  if (iid == IFoo::iid)\n    return obj cast as IFoo\n  else if (iid == IBar::iid)\n    return obj cast as IBar\n  else\n    return null\n\nIf you statically know that iid == IFoo::iid, this is a lot simpler.\n\nIt seems the real trick is that you don't statically know what concrete class you're QI'ing *from*.\n\n> I don't mean to be discouraging, but I think we've mined out all the useful \n> wins here and probably should focus on other things.\n\nNot at all!  I appreciate your looking up those old bugs.", "bug_id": 657011, "creation_time": "2011-05-13T21:41:44Z", "is_private": false, "id": 5469289, "time": "2011-05-13T21:41:44Z"}, {"time": "2011-05-14T01:09:37Z", "id": 5469713, "bug_id": 657011, "creation_time": "2011-05-14T01:09:37Z", "raw_text": "> It seems the real trick is that you don't statically know what concrete class\n> you're QI'ing *from*.\n\nYes, that's why you need QI in the first place, in most cases....  The case when you don't know what interface you're getting is pretty rare.", "tags": [], "is_private": false, "text": "> It seems the real trick is that you don't statically know what concrete class\n> you're QI'ing *from*.\n\nYes, that's why you need QI in the first place, in most cases....  The case when you don't know what interface you're getting is pretty rare.", "count": 3, "author": "bzbarsky@mit.edu", "creator": "bzbarsky@mit.edu", "attachment_id": null}]}}, "comments": {}}