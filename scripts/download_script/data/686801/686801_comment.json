{"comments": {}, "bugs": {"686801": {"comments": [{"tags": [], "is_private": false, "count": 0, "id": 5717900, "bug_id": 686801, "raw_text": "PGO spits out gcov files. Those should contain enough information such that the linker[and gcc] can put active functions together in the binary to reduce the number of hard page faults on startup", "creation_time": "2011-09-14T23:26:35Z", "text": "PGO spits out gcov files. Those should contain enough information such that the linker[and gcc] can put active functions together in the binary to reduce the number of hard page faults on startup", "time": "2011-09-14T23:26:35Z", "attachment_id": null, "creator": "taras.mozilla@glek.net", "author": "taras.mozilla@glek.net"}, {"author": "froydnj+bz@gmail.com", "creator": "froydnj+bz@gmail.com", "id": 5718139, "tags": [], "count": 1, "is_private": false, "bug_id": 686801, "creation_time": "2011-09-15T05:17:58Z", "raw_text": "I was looking at the linker scripts for elf (ld/scripttempl/elf.sc) and it does group .text.hot and .text.cold.  I don't recall exactly what was said in the meeting this morning about this arrangement; it is not sufficient for our purposes because some other measure than \"we executed this code during startup and therefore it is hot\" is used?  Is that right?\n\nIs there work to be done on the GCC side (other than possibly modifying its idea of hot code as abvoe) here?  Seems like you'd just compile with -ffunction-sections and let the linker sort things out.\n\nRafael, you mentioned doing this with a linker plugin; would you mind sketching out how that would work?", "time": "2011-09-15T05:17:58Z", "attachment_id": null, "text": "I was looking at the linker scripts for elf (ld/scripttempl/elf.sc) and it does group .text.hot and .text.cold.  I don't recall exactly what was said in the meeting this morning about this arrangement; it is not sufficient for our purposes because some other measure than \"we executed this code during startup and therefore it is hot\" is used?  Is that right?\n\nIs there work to be done on the GCC side (other than possibly modifying its idea of hot code as abvoe) here?  Seems like you'd just compile with -ffunction-sections and let the linker sort things out.\n\nRafael, you mentioned doing this with a linker plugin; would you mind sketching out how that would work?"}, {"creator": "mh+mozilla@glandium.org", "author": "mh+mozilla@glandium.org", "text": "The problem with gcov output is that it is most likely not going to mark as hot a lot of stuff running during startup because it's only being run once (all the initialization stuff), but for better startup, we do need these to be grouped as well.\n\nWhen looking at the gcov generation code in gcc, I found that it should be quite easy to hook something when entering a function that would spit out the function name if it wasn't seen already, which effectively would give us the startup order.\n\nOTOH, for something completely different, I actually ended up doing something that with some more work would be able to do that as well, using -finstrument-functions.\n\nNow, something else that could be interesting is to know what we're running exactly once and will never run again. If there's a lot of that, and we group it, there is opportunity to free that memory once we're done using it.", "attachment_id": null, "time": "2011-09-15T06:07:19Z", "raw_text": "The problem with gcov output is that it is most likely not going to mark as hot a lot of stuff running during startup because it's only being run once (all the initialization stuff), but for better startup, we do need these to be grouped as well.\n\nWhen looking at the gcov generation code in gcc, I found that it should be quite easy to hook something when entering a function that would spit out the function name if it wasn't seen already, which effectively would give us the startup order.\n\nOTOH, for something completely different, I actually ended up doing something that with some more work would be able to do that as well, using -finstrument-functions.\n\nNow, something else that could be interesting is to know what we're running exactly once and will never run again. If there's a lot of that, and we group it, there is opportunity to free that memory once we're done using it.", "creation_time": "2011-09-15T06:07:19Z", "bug_id": 686801, "count": 2, "is_private": false, "tags": [], "id": 5718182}, {"tags": [], "count": 3, "is_private": false, "id": 5719076, "bug_id": 686801, "creation_time": "2011-09-15T19:38:32Z", "raw_text": "> Rafael, you mentioned doing this with a linker plugin; would you mind\n> sketching out how that would work?\n\nMy idea was reading the profile information. That way no changes to gcc (the compiler) should be necessary. We might still change the driver to make it easy to use.\n\nThe interface needed was added in http://sourceware.org/git/?p=binutils.git;a=commitdiff;h=317e1e07b77cd74c44ba866ac8a7ea0692e5bd9e;hp=89b2a2b111055f5f38a3d8efe57be59cecd229ec", "text": "> Rafael, you mentioned doing this with a linker plugin; would you mind\n> sketching out how that would work?\n\nMy idea was reading the profile information. That way no changes to gcc (the compiler) should be necessary. We might still change the driver to make it easy to use.\n\nThe interface needed was added in http://sourceware.org/git/?p=binutils.git;a=commitdiff;h=317e1e07b77cd74c44ba866ac8a7ea0692e5bd9e;hp=89b2a2b111055f5f38a3d8efe57be59cecd229ec", "time": "2011-09-15T19:38:32Z", "attachment_id": null, "creator": "respindola@unverified.tld", "author": "respindola@unverified.tld"}]}}}