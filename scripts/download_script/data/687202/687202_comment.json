{"comments": {}, "bugs": {"687202": {"comments": [{"raw_text": "To improve the visual a11y of the element, I have a patch that adds two ticks, one representing the low mark and one representing the high mark. If low==high, only one is draw and if low==min or, the low mark isn't draw. Same thing for high==max.\nThe idea is with low and high marks, the user will be able to see the limits. Where the value has to be might be understandable from the contexts: if the meter represents the number of bugs in Firefox, it will have to be low, if it represents the number of Firefox users, it will have to be high.\n\nThis patch should be nearly ready. I might have to do a bit of clean-up. Nothing important.\n\nDavid, how does it sound?", "time": "2011-09-17T01:37:52Z", "bug_id": 687202, "id": 5721123, "author": "mounir@lamouri.fr", "count": 0, "text": "Created attachment 560663\nPatch v1\n\nTo improve the visual a11y of the element, I have a patch that adds two ticks, one representing the low mark and one representing the high mark. If low==high, only one is draw and if low==min or, the low mark isn't draw. Same thing for high==max.\nThe idea is with low and high marks, the user will be able to see the limits. Where the value has to be might be understandable from the contexts: if the meter represents the number of bugs in Firefox, it will have to be low, if it represents the number of Firefox users, it will have to be high.\n\nThis patch should be nearly ready. I might have to do a bit of clean-up. Nothing important.\n\nDavid, how does it sound?", "tags": [], "attachment_id": 560663, "creation_time": "2011-09-17T01:37:52Z", "is_private": false, "creator": "mounir@lamouri.fr"}, {"attachment_id": 560663, "tags": [], "creator": "roc@ocallahan.org", "is_private": false, "creation_time": "2011-09-19T03:59:39Z", "raw_text": "Review of attachment 560663:\n-----------------------------------------------------------------\n\nSeems to me that this could paint outside the content-box or even the border-box of the meter. In that case, your nsMeterFrame::Reflow needs to add the relevant overflow area before calling FinishAndStoreOverflow --- definitely to the visual overflow area, and possibly to the scrollable overflow area, if you want to be able to scroll to see these marks. Your display item's GetBounds needs to include the overflow area too (possibly just by returning the frame's overflow area).\n\n::: layout/forms/nsMeterFrame.cpp\n@@ +302,5 @@\n> +class LimitsPainter {\n> +public:\n> +  static void\n> +  PaintLimit(nsRenderingContext* aCtx, const nsRect& aRect, float aValue,\n> +             bool aIsHorizontal, bool aIsRTL)\n\nprobably a little cleaner to pass the orientation and direction directly and test for values in the body of this method. boolean parameters aren't good.\n\n@@ +307,5 @@\n> +  {\n> +    // Points come from the coordinates on a 5X4 unit box.\n> +    static const PRInt32 arrowPolygonX[] = { -2,  2, 0 };\n> +    static const PRInt32 arrowPolygonY[] = { -4, -4, 0 };\n> +    static const PRInt32 arrowNumPoints = sizeof(arrowPolygonX) / sizeof(PRInt32);\n\nuse NS_ARRAY_LENGTH\n\n@@ +330,5 @@\n> +      } else if (!aIsRTL) {\n> +        paintPolygon[i] = nsPoint(x + nsPresContext::CSSPixelsToAppUnits(arrowPolygonY[i]),\n> +                                  y + nsPresContext::CSSPixelsToAppUnits(arrowPolygonX[i]));\n> +      } else {\n> +        paintPolygon[i] = nsPoint(x + nsPresContext::CSSPixelsToAppUnits(abs(arrowPolygonY[i])),\n\nWhy not x - nsPresContext::CSSPixelsToAppUnits(arrowPolygonY[i])?\n\n@@ +341,5 @@\n> +  static void\n> +  Paint(nsIFrame* aFrame,\n> +        nsRenderingContext* aCtx,\n> +        const nsRect& aDirtyRect,\n> +        nsPoint aPt)\n\nProbably simpler just to make Paint() and PaintLimit() static global functions.", "time": "2011-09-19T03:59:39Z", "author": "roc@ocallahan.org", "text": "Comment on attachment 560663\nPatch v1\n\nReview of attachment 560663:\n-----------------------------------------------------------------\n\nSeems to me that this could paint outside the content-box or even the border-box of the meter. In that case, your nsMeterFrame::Reflow needs to add the relevant overflow area before calling FinishAndStoreOverflow --- definitely to the visual overflow area, and possibly to the scrollable overflow area, if you want to be able to scroll to see these marks. Your display item's GetBounds needs to include the overflow area too (possibly just by returning the frame's overflow area).\n\n::: layout/forms/nsMeterFrame.cpp\n@@ +302,5 @@\n> +class LimitsPainter {\n> +public:\n> +  static void\n> +  PaintLimit(nsRenderingContext* aCtx, const nsRect& aRect, float aValue,\n> +             bool aIsHorizontal, bool aIsRTL)\n\nprobably a little cleaner to pass the orientation and direction directly and test for values in the body of this method. boolean parameters aren't good.\n\n@@ +307,5 @@\n> +  {\n> +    // Points come from the coordinates on a 5X4 unit box.\n> +    static const PRInt32 arrowPolygonX[] = { -2,  2, 0 };\n> +    static const PRInt32 arrowPolygonY[] = { -4, -4, 0 };\n> +    static const PRInt32 arrowNumPoints = sizeof(arrowPolygonX) / sizeof(PRInt32);\n\nuse NS_ARRAY_LENGTH\n\n@@ +330,5 @@\n> +      } else if (!aIsRTL) {\n> +        paintPolygon[i] = nsPoint(x + nsPresContext::CSSPixelsToAppUnits(arrowPolygonY[i]),\n> +                                  y + nsPresContext::CSSPixelsToAppUnits(arrowPolygonX[i]));\n> +      } else {\n> +        paintPolygon[i] = nsPoint(x + nsPresContext::CSSPixelsToAppUnits(abs(arrowPolygonY[i])),\n\nWhy not x - nsPresContext::CSSPixelsToAppUnits(arrowPolygonY[i])?\n\n@@ +341,5 @@\n> +  static void\n> +  Paint(nsIFrame* aFrame,\n> +        nsRenderingContext* aCtx,\n> +        const nsRect& aDirtyRect,\n> +        nsPoint aPt)\n\nProbably simpler just to make Paint() and PaintLimit() static global functions.", "count": 1, "bug_id": 687202, "id": 5722474}]}}}