{"comments": {}, "bugs": {"666088": {"comments": [{"count": 0, "id": 5547143, "is_private": false, "time": "2011-06-22T00:53:55Z", "creation_time": "2011-06-22T00:53:55Z", "creator": "azakai@mozilla.com", "author": "azakai@mozilla.com", "attachment_id": null, "raw_text": "We sometimes need aligned allocations for things like SIMD. Doing this manually in each case (that is, allocating a bit more than needed, then working on an aligned address) is possible but a helper class could make our lives easier. For example, here is how Bullet does this:\n\nhttp://www.bulletphysics.com/Bullet/BulletFull/btAlignedAllocator_8h.html\n\nBasically, a class that holds the raw result of malloc, and is templated on the alignment. Then it can return a pointer to the aligned address.\n\nAny objections?", "bug_id": 666088, "text": "We sometimes need aligned allocations for things like SIMD. Doing this manually in each case (that is, allocating a bit more than needed, then working on an aligned address) is possible but a helper class could make our lives easier. For example, here is how Bullet does this:\n\nhttp://www.bulletphysics.com/Bullet/BulletFull/btAlignedAllocator_8h.html\n\nBasically, a class that holds the raw result of malloc, and is templated on the alignment. Then it can return a pointer to the aligned address.\n\nAny objections?", "tags": []}, {"id": 5547150, "count": 1, "is_private": false, "time": "2011-06-22T00:58:21Z", "creation_time": "2011-06-22T00:58:21Z", "creator": "justin.lebar+bug@gmail.com", "author": "justin.lebar+bug@gmail.com", "attachment_id": null, "raw_text": "Isn't this what memalign is for?\n\nIt would certainly be nice if we could statically type aligned pointers so we don't have to guess their alignment.", "bug_id": 666088, "text": "Isn't this what memalign is for?\n\nIt would certainly be nice if we could statically type aligned pointers so we don't have to guess their alignment.", "tags": []}, {"time": "2011-06-22T01:04:35Z", "creation_time": "2011-06-22T01:04:35Z", "creator": "azakai@mozilla.com", "author": "azakai@mozilla.com", "count": 2, "id": 5547165, "is_private": false, "bug_id": 666088, "text": "Yes, memalign does exactly this. But just on *NIX I believe.", "tags": [], "attachment_id": null, "raw_text": "Yes, memalign does exactly this. But just on *NIX I believe."}, {"count": 3, "id": 5547170, "is_private": false, "author": "mh+mozilla@glandium.org", "time": "2011-06-22T01:09:13Z", "creation_time": "2011-06-22T01:09:13Z", "creator": "mh+mozilla@glandium.org", "raw_text": "There's _aligned_malloc on win32.", "attachment_id": null, "tags": [], "bug_id": 666088, "text": "There's _aligned_malloc on win32."}, {"bug_id": 666088, "text": "jemalloc also exports a memalign-type thing.\n\nSince we're going to have jemalloc on all tier-1 platforms RSN, I don't care if  we need extra machinery in this smart pointer to support other allocators if we can make it just as fast with jemalloc as if we didn't have the wrapper.", "tags": [], "attachment_id": null, "raw_text": "jemalloc also exports a memalign-type thing.\n\nSince we're going to have jemalloc on all tier-1 platforms RSN, I don't care if  we need extra machinery in this smart pointer to support other allocators if we can make it just as fast with jemalloc as if we didn't have the wrapper.", "creation_time": "2011-06-22T01:09:54Z", "time": "2011-06-22T01:09:54Z", "creator": "justin.lebar+bug@gmail.com", "author": "justin.lebar+bug@gmail.com", "count": 4, "id": 5547174, "is_private": false}, {"is_private": false, "count": 5, "id": 5547201, "creator": "justin.lebar+bug@gmail.com", "creation_time": "2011-06-22T01:25:49Z", "time": "2011-06-22T01:25:49Z", "author": "justin.lebar+bug@gmail.com", "attachment_id": null, "raw_text": "We discussed on IRC whether __attribute__((aligned(X))) would work, but it won't.\n\n<glandium> \"Note that normal allocators, such as malloc, C++ operator new, and the Win32 allocators return memory that will most likely not be sufficiently aligned for __declspec(align(#)) structures or arrays of structures.\"\n\nSo I think the way to do this is to have a function which delegates to memalign / jemalloc's memalign when it's available, or does what's suggested in comment 0 when it's not.\n\nThat class would return a smart pointer which knows how to free itself.  When memalign is available, it just calls free(), otherwise it does what's in comment 0.", "bug_id": 666088, "text": "We discussed on IRC whether __attribute__((aligned(X))) would work, but it won't.\n\n<glandium> \"Note that normal allocators, such as malloc, C++ operator new, and the Win32 allocators return memory that will most likely not be sufficiently aligned for __declspec(align(#)) structures or arrays of structures.\"\n\nSo I think the way to do this is to have a function which delegates to memalign / jemalloc's memalign when it's available, or does what's suggested in comment 0 when it's not.\n\nThat class would return a smart pointer which knows how to free itself.  When memalign is available, it just calls free(), otherwise it does what's in comment 0.", "tags": []}, {"creator": "azakai@mozilla.com", "creation_time": "2011-06-22T16:49:44Z", "time": "2011-06-22T16:49:44Z", "author": "azakai@mozilla.com", "is_private": false, "id": 5548522, "count": 6, "tags": [], "bug_id": 666088, "text": "memalign will always use the default malloc though, won't it? Seems like we should allow customizing that I think.", "attachment_id": null, "raw_text": "memalign will always use the default malloc though, won't it? Seems like we should allow customizing that I think."}, {"author": "justin.lebar+bug@gmail.com", "creator": "justin.lebar+bug@gmail.com", "creation_time": "2011-06-22T17:01:59Z", "time": "2011-06-22T17:01:59Z", "is_private": false, "id": 5548563, "count": 7, "tags": [], "bug_id": 666088, "text": "(In reply to comment #6)\n> memalign will always use the default malloc though, won't it? Seems like we\n> should allow customizing that I think.\n\nI guess what you're saying is that both types of smart pointers (the one which is just a wrapper around memalign/free and the one which calls malloc, or custom_malloc, and adjusts the pointer) should exist, regardless of whether we're building with jemalloc.  Then you can hook up your custom allocator to whichever type is appropriate.\n\nThat doesn't sound so bad, but I think YAGNI, and this would just make designing a fast thin aligned pointer class more difficult.  Do you have a custom allocator in mind that you want to hook up to?  I'd rather implement what we need now, rather than what we might need.", "raw_text": "(In reply to comment #6)\n> memalign will always use the default malloc though, won't it? Seems like we\n> should allow customizing that I think.\n\nI guess what you're saying is that both types of smart pointers (the one which is just a wrapper around memalign/free and the one which calls malloc, or custom_malloc, and adjusts the pointer) should exist, regardless of whether we're building with jemalloc.  Then you can hook up your custom allocator to whichever type is appropriate.\n\nThat doesn't sound so bad, but I think YAGNI, and this would just make designing a fast thin aligned pointer class more difficult.  Do you have a custom allocator in mind that you want to hook up to?  I'd rather implement what we need now, rather than what we might need.", "attachment_id": null}, {"raw_text": "I was thinking about custom allocators in the JS engine.\n\nA list of our custom allocators appears in one of the commands here:\n\nhttp://blog.mozilla.com/nnethercote/2011/01/07/memory-profiling-firefox-with-massif-part-2/", "attachment_id": null, "tags": [], "bug_id": 666088, "text": "I was thinking about custom allocators in the JS engine.\n\nA list of our custom allocators appears in one of the commands here:\n\nhttp://blog.mozilla.com/nnethercote/2011/01/07/memory-profiling-firefox-with-massif-part-2/", "is_private": false, "count": 8, "id": 5548745, "author": "azakai@mozilla.com", "creator": "azakai@mozilla.com", "time": "2011-06-22T17:53:26Z", "creation_time": "2011-06-22T17:53:26Z"}]}}}