{"bugs": {"686989": {"comments": [{"time": "2011-09-15T22:56:58Z", "attachment_id": null, "text": "When marshalling a string parameter from JS to C++, we currently just create a new nsString which makes a new copy of the chars.  Ideally, we'd just pass the JSString to C++ directly without copying.  For \"fixed\" JSStrings (flat, null-terminated, not extensible -- the \"stable\" state of a string), we have a free word in the header.  We can use this to embed a reference count that is maintained by nsAString ctor/copy/assign/dtor just like normal string buffers.  Thus, in JS GC, we'd only sweep a string if it wasn't marked AND its ref count was 0.\n\nWhen converting an nsAString to JS:\n - if the nsAString points to a (same-compartment) JSString, we can just pass that to JS\n - failing that, we create an external string; since its the same chars, we should be able to change the representation of the nsAString to reference this new external string, thereby optimizing future to-JS conversions of the same nsAString.\n\nNaively, this requires the single-threadification of C++ strings.  sicking nominates jlebar ;)\n\nbz's idea is to have a new nsAString subclass nsSingleThreadString (or something) whose constructor sets a bit in the flags \"I am only used on a single thread\".  When converting a JS string to a C++ nsAString outparam, only nsAString's with this bit set would receive the JSString, others would have to copy.  Furthermore, when copying an nsAString, if the source referenced a JSString and the destination didn't have the \"single-thread\" bit, there would be a clone.  This could be a shorter path than making C++ strings single-threaded although we'd have to be careful not to introduce cases where we do more cloning.  Also the optimization would only apply so far as we use nsSingleThreadString.", "raw_text": "When marshalling a string parameter from JS to C++, we currently just create a new nsString which makes a new copy of the chars.  Ideally, we'd just pass the JSString to C++ directly without copying.  For \"fixed\" JSStrings (flat, null-terminated, not extensible -- the \"stable\" state of a string), we have a free word in the header.  We can use this to embed a reference count that is maintained by nsAString ctor/copy/assign/dtor just like normal string buffers.  Thus, in JS GC, we'd only sweep a string if it wasn't marked AND its ref count was 0.\n\nWhen converting an nsAString to JS:\n - if the nsAString points to a (same-compartment) JSString, we can just pass that to JS\n - failing that, we create an external string; since its the same chars, we should be able to change the representation of the nsAString to reference this new external string, thereby optimizing future to-JS conversions of the same nsAString.\n\nNaively, this requires the single-threadification of C++ strings.  sicking nominates jlebar ;)\n\nbz's idea is to have a new nsAString subclass nsSingleThreadString (or something) whose constructor sets a bit in the flags \"I am only used on a single thread\".  When converting a JS string to a C++ nsAString outparam, only nsAString's with this bit set would receive the JSString, others would have to copy.  Furthermore, when copying an nsAString, if the source referenced a JSString and the destination didn't have the \"single-thread\" bit, there would be a clone.  This could be a shorter path than making C++ strings single-threaded although we'd have to be careful not to introduce cases where we do more cloning.  Also the optimization would only apply so far as we use nsSingleThreadString.", "creation_time": "2011-09-15T22:56:58Z", "bug_id": 686989, "id": 5719435, "tags": [], "is_private": false, "count": 0, "author": "mail@lukewagner.name", "creator": "mail@lukewagner.name"}, {"creator": "bzbarsky@mit.edu", "author": "bzbarsky@mit.edu", "is_private": false, "count": 1, "tags": [], "id": 5719554, "bug_id": 686989, "creation_time": "2011-09-16T00:12:50Z", "raw_text": "Hmm.  So right now all nsAStrings have a PRUnichar* mData member which points to the actual string data.  This would need to change to a union or something, right?", "text": "Hmm.  So right now all nsAStrings have a PRUnichar* mData member which points to the actual string data.  This would need to change to a union or something, right?", "attachment_id": null, "time": "2011-09-16T00:12:50Z"}, {"text": "No, we'd still have that. But we'd also have a pointer to a separately allocated object which acts as root for the JS string. This separate object is located from from a thread-specific arena of string-roots so the allocation should be fast.\n\nThis means that we either have to merge flags and length into a single word, or increase the size of nsString to 4 words.", "time": "2011-09-16T04:43:08Z", "attachment_id": null, "raw_text": "No, we'd still have that. But we'd also have a pointer to a separately allocated object which acts as root for the JS string. This separate object is located from from a thread-specific arena of string-roots so the allocation should be fast.\n\nThis means that we either have to merge flags and length into a single word, or increase the size of nsString to 4 words.", "creation_time": "2011-09-16T04:43:08Z", "bug_id": 686989, "count": 2, "is_private": false, "tags": [], "id": 5719787, "creator": "jonas@sicking.cc", "author": "jonas@sicking.cc"}, {"author": "bzbarsky@mit.edu", "creator": "bzbarsky@mit.edu", "bug_id": 686989, "id": 5719812, "tags": [], "is_private": false, "count": 3, "time": "2011-09-16T05:41:39Z", "attachment_id": null, "text": "Hmm.  On 64-bit, at least, merging would work fine.  On 32-bit, we may have to take the extra one-word hit.  :(", "raw_text": "Hmm.  On 64-bit, at least, merging would work fine.  On 32-bit, we may have to take the extra one-word hit.  :(", "creation_time": "2011-09-16T05:41:39Z"}, {"creator": "jonas@sicking.cc", "author": "jonas@sicking.cc", "text": "Though, with enough smarts we might not need to. First off, between the length member and the root pointer we have at least 3 bits free for flags. 4 if we can ensure that the root object is always located at a 2-word boundary. Second, the the root is used we shouldn't need many flags. When it isn't used we'll have plenty of bits for flags.", "time": "2011-09-16T05:54:47Z", "attachment_id": null, "creation_time": "2011-09-16T05:54:47Z", "raw_text": "Though, with enough smarts we might not need to. First off, between the length member and the root pointer we have at least 3 bits free for flags. 4 if we can ensure that the root object is always located at a 2-word boundary. Second, the the root is used we shouldn't need many flags. When it isn't used we'll have plenty of bits for flags.", "bug_id": 686989, "is_private": false, "count": 4, "tags": [], "id": 5719822}, {"author": "mail@lukewagner.name", "creator": "mail@lukewagner.name", "attachment_id": null, "time": "2011-09-16T06:45:47Z", "text": "Jonas: things have changed a bit since we last talked.  There is no root needed (nor pool to hold said roots): comment 0 proposes ref-counting the JSString header directly from the nsAString ctor/cctor/op=/dtor/etc and teaching the JS GC to respect this.\n\nIf length can be merged with flags (28 bits of length, 4 bits of flags, just like JSString :), then one word points to chars, one word points to the JSString header; that's 3 words total.", "raw_text": "Jonas: things have changed a bit since we last talked.  There is no root needed (nor pool to hold said roots): comment 0 proposes ref-counting the JSString header directly from the nsAString ctor/cctor/op=/dtor/etc and teaching the JS GC to respect this.\n\nIf length can be merged with flags (28 bits of length, 4 bits of flags, just like JSString :), then one word points to chars, one word points to the JSString header; that's 3 words total.", "creation_time": "2011-09-16T06:45:47Z", "bug_id": 686989, "id": 5719842, "tags": [], "is_private": false, "count": 5}, {"author": "jonas@sicking.cc", "creator": "jonas@sicking.cc", "attachment_id": null, "time": "2011-09-16T08:26:50Z", "text": "Oooh, I like this idea even more! Sorry for assuming that things hadn't changed since our conversation.\n\nI don't however like the idea of having a subclass of nsAString which is single-threaded. This would require knowing on a callee side if a given nsAString is single threaded or not before passing it across threads.\n\nI think we should simply make our strings single threaded instead and just have specific code to deal with passing strings across threads.", "raw_text": "Oooh, I like this idea even more! Sorry for assuming that things hadn't changed since our conversation.\n\nI don't however like the idea of having a subclass of nsAString which is single-threaded. This would require knowing on a callee side if a given nsAString is single threaded or not before passing it across threads.\n\nI think we should simply make our strings single threaded instead and just have specific code to deal with passing strings across threads.", "creation_time": "2011-09-16T08:26:50Z", "bug_id": 686989, "id": 5719919, "count": 6, "is_private": false, "tags": []}, {"author": "mail@lukewagner.name", "creator": "mail@lukewagner.name", "bug_id": 686989, "id": 5720244, "count": 7, "is_private": false, "tags": [], "time": "2011-09-16T16:09:22Z", "attachment_id": null, "text": "(In reply to Jonas Sicking (:sicking) from comment #6)\n> I think we should simply make our strings single threaded instead and just\n> have specific code to deal with passing strings across threads.\n\nMe too, just recording ideas for completeness.", "raw_text": "(In reply to Jonas Sicking (:sicking) from comment #6)\n> I think we should simply make our strings single threaded instead and just\n> have specific code to deal with passing strings across threads.\n\nMe too, just recording ideas for completeness.", "creation_time": "2011-09-16T16:09:22Z"}, {"bug_id": 686989, "id": 5818745, "tags": [], "is_private": false, "count": 8, "attachment_id": null, "time": "2011-11-01T19:30:10Z", "text": "Bobby, we're interested in knowing how much string data we're actually holding onto because of this. Could you look into instrumenting this code to add a number to about:memory for this? If we're not holding on to a huge amount of data here then I don't think we need to worry about fixing this from a memory point of view, but this might still be significant from a performance point of view.", "creation_time": "2011-11-01T19:30:10Z", "raw_text": "Bobby, we're interested in knowing how much string data we're actually holding onto because of this. Could you look into instrumenting this code to add a number to about:memory for this? If we're not holding on to a huge amount of data here then I don't think we need to worry about fixing this from a memory point of view, but this might still be significant from a performance point of view.", "author": "jstenback+bmo@gmail.com", "creator": "jstenback+bmo@gmail.com"}, {"bug_id": 686989, "is_private": false, "count": 9, "tags": [], "id": 5819479, "creator": "bholley@mozilla.com", "text": "(In reply to Johnny Stenback (:jst, jst@mozilla.com) from comment #8)\n> Bobby, we're interested in knowing how much string data we're actually\n> holding onto because of this. Could you look into instrumenting this code to\n> add a number to about:memory for this?\n\nIs this the same as what njn was asking about? As I mentioned in bug 697041 comment 3, I don't think it would be very fruitful to add memory reporters for xpconnect string data (unless we care about, and can reliable track, peak usage). The string data is very ephemeral (it has stack scope), so what we'd see would depend entirely on what was on the stack when the memory analysis was done. Again, if we're just interested in peak usage, this is a different story.\n\n> this might still be significant from a\n> performance point of view.\n\nI think this is really the main reason to do this. I can work on it (including the single-threadification of strings) if we think it's important enough.", "attachment_id": null, "time": "2011-11-01T22:53:53Z", "author": "bholley@mozilla.com", "raw_text": "(In reply to Johnny Stenback (:jst, jst@mozilla.com) from comment #8)\n> Bobby, we're interested in knowing how much string data we're actually\n> holding onto because of this. Could you look into instrumenting this code to\n> add a number to about:memory for this?\n\nIs this the same as what njn was asking about? As I mentioned in bug 697041 comment 3, I don't think it would be very fruitful to add memory reporters for xpconnect string data (unless we care about, and can reliable track, peak usage). The string data is very ephemeral (it has stack scope), so what we'd see would depend entirely on what was on the stack when the memory analysis was done. Again, if we're just interested in peak usage, this is a different story.\n\n> this might still be significant from a\n> performance point of view.\n\nI think this is really the main reason to do this. I can work on it (including the single-threadification of strings) if we think it's important enough.", "creation_time": "2011-11-01T22:53:53Z"}, {"creator": "continuation@gmail.com", "author": "continuation@gmail.com", "creation_time": "2011-11-01T23:09:16Z", "raw_text": "We're just trying to get a handle on how much of it is really ephemeral, and how ephemeral it is.  If they are all stack-scoped, and the calls are not that long, then I think that's good enough to know that we don't need to worry about this for memory usage.", "text": "We're just trying to get a handle on how much of it is really ephemeral, and how ephemeral it is.  If they are all stack-scoped, and the calls are not that long, then I think that's good enough to know that we don't need to worry about this for memory usage.", "time": "2011-11-01T23:09:16Z", "attachment_id": null, "tags": [], "count": 10, "is_private": false, "id": 5819524, "bug_id": 686989}, {"text": "(In reply to Bobby Holley (:bholley) from comment #9)\n> Is this the same as what njn was asking about? As I mentioned in bug 697041\n> comment 3, I don't think it would be very fruitful to add memory reporters\n> for xpconnect string data (unless we care about, and can reliable track,\n> peak usage). The string data is very ephemeral (it has stack scope), so what\n> we'd see would depend entirely on what was on the stack when the memory\n> analysis was done. Again, if we're just interested in peak usage, this is a\n> different story.\n\nThe interesting case here is when we're calling from JS into C++, where we can *not* share string data because we can not share the underlying string buffer past the lifetime of this call, but come to think of it, that's not something that we can actually measure in XPConnect. When we call from JS into C++, we wrap string data in dependent strings, and those strings can not share their underlying buffer, so if the called C++ needs to hold on to that string we're forced to copy at that point. But I don't think whether that happened is detectable in the XPConnect code, nor do I think a memory reporter is the right thing there.\n\nTelemetry for string usage in general could be useful, and as part of that the amount of string data that's copied due to the underlying string buffer not being sharable could be a useful piece of information to have, but that's not this bug.\n\nSo yes, this bug is purely about the performance impact of the string handling here, not the memory usage.", "attachment_id": null, "time": "2011-11-02T01:22:28Z", "creation_time": "2011-11-02T01:22:28Z", "raw_text": "(In reply to Bobby Holley (:bholley) from comment #9)\n> Is this the same as what njn was asking about? As I mentioned in bug 697041\n> comment 3, I don't think it would be very fruitful to add memory reporters\n> for xpconnect string data (unless we care about, and can reliable track,\n> peak usage). The string data is very ephemeral (it has stack scope), so what\n> we'd see would depend entirely on what was on the stack when the memory\n> analysis was done. Again, if we're just interested in peak usage, this is a\n> different story.\n\nThe interesting case here is when we're calling from JS into C++, where we can *not* share string data because we can not share the underlying string buffer past the lifetime of this call, but come to think of it, that's not something that we can actually measure in XPConnect. When we call from JS into C++, we wrap string data in dependent strings, and those strings can not share their underlying buffer, so if the called C++ needs to hold on to that string we're forced to copy at that point. But I don't think whether that happened is detectable in the XPConnect code, nor do I think a memory reporter is the right thing there.\n\nTelemetry for string usage in general could be useful, and as part of that the amount of string data that's copied due to the underlying string buffer not being sharable could be a useful piece of information to have, but that's not this bug.\n\nSo yes, this bug is purely about the performance impact of the string handling here, not the memory usage.", "bug_id": 686989, "tags": [], "is_private": false, "count": 11, "id": 5819823, "creator": "jstenback+bmo@gmail.com", "author": "jstenback+bmo@gmail.com"}, {"id": 5819895, "count": 12, "is_private": false, "tags": [], "bug_id": 686989, "creation_time": "2011-11-02T02:17:29Z", "raw_text": "A few notes:\n\n1)  There _is_ a case we can measure in xpconnect: JS strings coming in that are actually wrapping an XPCOM string buffer.  Right now we still do the non-sharing dependent thing; we could see whether sharing those would help much.\n\n2)  This is mostly about the performance impact, but there might be memory impact. Hard to say.", "time": "2011-11-02T02:17:29Z", "attachment_id": null, "text": "A few notes:\n\n1)  There _is_ a case we can measure in xpconnect: JS strings coming in that are actually wrapping an XPCOM string buffer.  Right now we still do the non-sharing dependent thing; we could see whether sharing those would help much.\n\n2)  This is mostly about the performance impact, but there might be memory impact. Hard to say.", "author": "bzbarsky@mit.edu", "creator": "bzbarsky@mit.edu"}, {"author": "bholley@mozilla.com", "creator": "bholley@mozilla.com", "bug_id": 686989, "id": 6507741, "is_private": false, "count": 13, "tags": [], "attachment_id": null, "time": "2012-07-26T14:50:33Z", "text": "This is not something I'm going to get to any time in the reasonable future.", "creation_time": "2012-07-26T14:50:33Z", "raw_text": "This is not something I'm going to get to any time in the reasonable future."}]}}, "comments": {}}