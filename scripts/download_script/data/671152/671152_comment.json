{"comments": {}, "bugs": {"671152": {"comments": [{"attachment_id": null, "raw_text": "STEPS TO REPRODUCE\n1. run mochitest editor/libeditor/html/tests/test_bug537046.html\n\nACTUAL RESULTS\n###!!! ASSERTION: selection could not be collapsed after undo of deletetext.: '(NS_SUCCEEDED(result))', file editor/libeditor/base/DeleteTextTxn.cpp, line 125\n###!!! ASSERTION: null node passed to IsTextNode(): 'Not Reached', file editor/libeditor/base/nsEditor.cpp, line 3757\n\nPLATFORMS AND BUILDS TESTED\nBug occurs in a local mozilla-central DEBUG build on Linux x86-64", "text": "STEPS TO REPRODUCE\n1. run mochitest editor/libeditor/html/tests/test_bug537046.html\n\nACTUAL RESULTS\n###!!! ASSERTION: selection could not be collapsed after undo of deletetext.: '(NS_SUCCEEDED(result))', file editor/libeditor/base/DeleteTextTxn.cpp, line 125\n###!!! ASSERTION: null node passed to IsTextNode(): 'Not Reached', file editor/libeditor/base/nsEditor.cpp, line 3757\n\nPLATFORMS AND BUILDS TESTED\nBug occurs in a local mozilla-central DEBUG build on Linux x86-64", "bug_id": 671152, "tags": [], "id": 5588113, "count": 0, "is_private": false, "time": "2011-07-13T01:06:40Z", "creation_time": "2011-07-13T01:06:40Z", "creator": "MatsPalmgren_bugz@use.startmail.com", "author": "MatsPalmgren_bugz@use.startmail.com"}, {"time": "2012-06-19T23:40:31Z", "creation_time": "2012-06-19T23:40:31Z", "creator": "jruderman@gmail.com", "author": "jruderman@gmail.com", "id": 6405384, "count": 1, "is_private": false, "text": "Still happens on mozilla-central.", "bug_id": 671152, "tags": [], "attachment_id": null, "raw_text": "Still happens on mozilla-central."}, {"text": "So the failure is because mAncestorLimiter is set, and the text node is not a descendant of it.  I *think* mAncestorLimiter is the editable div, and the text node has no parent at the time the transaction runs.  Thus the Collapse() call fails.\n\nEhsan, do you know why this is a problem?  Why can't the selection be collapsed into a detached text node?  Maybe we don't want it to be in this case, but it should be legal, no?  The node and offset are totally valid -- it's a detached Text node with offset 0.", "bug_id": 671152, "tags": [], "raw_text": "So the failure is because mAncestorLimiter is set, and the text node is not a descendant of it.  I *think* mAncestorLimiter is the editable div, and the text node has no parent at the time the transaction runs.  Thus the Collapse() call fails.\n\nEhsan, do you know why this is a problem?  Why can't the selection be collapsed into a detached text node?  Maybe we don't want it to be in this case, but it should be legal, no?  The node and offset are totally valid -- it's a detached Text node with offset 0.", "attachment_id": null, "author": "ayg@aryeh.name", "time": "2012-06-22T08:45:21Z", "creation_time": "2012-06-22T08:45:21Z", "creator": "ayg@aryeh.name", "count": 2, "id": 6413447, "is_private": false}, {"creator": "ehsan.akhgari@gmail.com", "creation_time": "2012-06-25T18:06:54Z", "time": "2012-06-25T18:06:54Z", "author": "ehsan.akhgari@gmail.com", "is_private": false, "count": 3, "id": 6420504, "text": "Hmm, how does this happen?  Selection is a property of the presshell, right?  So it wouldn't make a lot of sense for a detached node to be part of it.  Or am I missing something?", "bug_id": 671152, "tags": [], "attachment_id": null, "raw_text": "Hmm, how does this happen?  Selection is a property of the presshell, right?  So it wouldn't make a lot of sense for a detached node to be part of it.  Or am I missing something?"}, {"raw_text": "Well, we do support selections being in detached nodes:\n\ndata:text/html,<!DOCTYPE html>\n<script>\nvar text = document.createTextNode(\"abc\");\ngetSelection().collapse(text, 0);\ndocument.documentElement.textContent =\ngetSelection().anchorNode + \" \" +\ngetSelection().anchorOffset;\n</script>\n\nOutputs \"[object Text] 0\" in a nightly for me.  This is per spec -- Selections can contain any Range.  IE also behaves this way, IIRC, but WebKit does not.  Of course, a Selection that's not in a visible node won't itself be visible.\n\nSo given that the test-case above works, why is this failing?  What's setting mAncestorLimiter, and why do we want it?", "attachment_id": null, "bug_id": 671152, "text": "Well, we do support selections being in detached nodes:\n\ndata:text/html,<!DOCTYPE html>\n<script>\nvar text = document.createTextNode(\"abc\");\ngetSelection().collapse(text, 0);\ndocument.documentElement.textContent =\ngetSelection().anchorNode + \" \" +\ngetSelection().anchorOffset;\n</script>\n\nOutputs \"[object Text] 0\" in a nightly for me.  This is per spec -- Selections can contain any Range.  IE also behaves this way, IIRC, but WebKit does not.  Of course, a Selection that's not in a visible node won't itself be visible.\n\nSo given that the test-case above works, why is this failing?  What's setting mAncestorLimiter, and why do we want it?", "tags": [], "count": 4, "id": 6422775, "is_private": false, "author": "ayg@aryeh.name", "time": "2012-06-26T09:36:00Z", "creation_time": "2012-06-26T09:36:00Z", "creator": "ayg@aryeh.name"}, {"id": 6427836, "count": 5, "is_private": false, "author": "ehsan.akhgari@gmail.com", "creation_time": "2012-06-27T18:03:38Z", "time": "2012-06-27T18:03:38Z", "creator": "ehsan.akhgari@gmail.com", "raw_text": "Huh!  So we basically use mAncestorLimit to determine how much of the tree to look at.  If selections behave this way, this entire infrastructure will be broken.  :(\n\nHave you looked into why the Collapse call itself fails though?", "attachment_id": null, "tags": [], "text": "Huh!  So we basically use mAncestorLimit to determine how much of the tree to look at.  If selections behave this way, this entire infrastructure will be broken.  :(\n\nHave you looked into why the Collapse call itself fails though?", "bug_id": 671152}, {"tags": [], "text": "(In reply to Ehsan Akhgari [:ehsan] from comment #5)\n> Huh!  So we basically use mAncestorLimit to determine how much of the tree\n> to look at.  If selections behave this way, this entire infrastructure will\n> be broken.  :(\n\nI'm not sure what you mean here.  Specifically, what's the difference between the selection in the test-case of comment 4 and the test-case in comment 0?  Why does the latter have an ancestor limiter, and the former not?\n\n> Have you looked into why the Collapse call itself fails though?\n\nIt checks IsValidSelectionPoint, which verifies that the node is a descendant of aFrameSel->GetAncestorLimiter() if that's set.  So it returns NS_ERROR_FAILURE.  At least that's what it looks like from code inspection.", "bug_id": 671152, "raw_text": "(In reply to Ehsan Akhgari [:ehsan] from comment #5)\n> Huh!  So we basically use mAncestorLimit to determine how much of the tree\n> to look at.  If selections behave this way, this entire infrastructure will\n> be broken.  :(\n\nI'm not sure what you mean here.  Specifically, what's the difference between the selection in the test-case of comment 4 and the test-case in comment 0?  Why does the latter have an ancestor limiter, and the former not?\n\n> Have you looked into why the Collapse call itself fails though?\n\nIt checks IsValidSelectionPoint, which verifies that the node is a descendant of aFrameSel->GetAncestorLimiter() if that's set.  So it returns NS_ERROR_FAILURE.  At least that's what it looks like from code inspection.", "attachment_id": null, "author": "ayg@aryeh.name", "time": "2012-07-02T11:04:05Z", "creation_time": "2012-07-02T11:04:05Z", "creator": "ayg@aryeh.name", "count": 6, "id": 6437915, "is_private": false}, {"raw_text": "(In reply to :Aryeh Gregor from comment #6)\n> (In reply to Ehsan Akhgari [:ehsan] from comment #5)\n> > Huh!  So we basically use mAncestorLimit to determine how much of the tree\n> > to look at.  If selections behave this way, this entire infrastructure will\n> > be broken.  :(\n> \n> I'm not sure what you mean here.  Specifically, what's the difference\n> between the selection in the test-case of comment 4 and the test-case in\n> comment 0?  Why does the latter have an ancestor limiter, and the former not?\n\nBecause the editor is not involved in the former?\n\nWhat do we expect to happen with the test case in comment 4 though?  We seem to be the only browser which allows the selection to be collapsed to a node that is not in the document...\n\n> > Have you looked into why the Collapse call itself fails though?\n> \n> It checks IsValidSelectionPoint, which verifies that the node is a\n> descendant of aFrameSel->GetAncestorLimiter() if that's set.  So it returns\n> NS_ERROR_FAILURE.  At least that's what it looks like from code inspection.\n\nIn that case, the caller of Collapse should be able to handle it failing, and should not assert.... :/", "attachment_id": null, "text": "(In reply to :Aryeh Gregor from comment #6)\n> (In reply to Ehsan Akhgari [:ehsan] from comment #5)\n> > Huh!  So we basically use mAncestorLimit to determine how much of the tree\n> > to look at.  If selections behave this way, this entire infrastructure will\n> > be broken.  :(\n> \n> I'm not sure what you mean here.  Specifically, what's the difference\n> between the selection in the test-case of comment 4 and the test-case in\n> comment 0?  Why does the latter have an ancestor limiter, and the former not?\n\nBecause the editor is not involved in the former?\n\nWhat do we expect to happen with the test case in comment 4 though?  We seem to be the only browser which allows the selection to be collapsed to a node that is not in the document...\n\n> > Have you looked into why the Collapse call itself fails though?\n> \n> It checks IsValidSelectionPoint, which verifies that the node is a\n> descendant of aFrameSel->GetAncestorLimiter() if that's set.  So it returns\n> NS_ERROR_FAILURE.  At least that's what it looks like from code inspection.\n\nIn that case, the caller of Collapse should be able to handle it failing, and should not assert.... :/", "bug_id": 671152, "tags": [], "id": 6442972, "count": 7, "is_private": false, "author": "ehsan.akhgari@gmail.com", "creation_time": "2012-07-03T21:25:14Z", "time": "2012-07-03T21:25:14Z", "creator": "ehsan.akhgari@gmail.com"}, {"creator": "ayg@aryeh.name", "creation_time": "2012-07-05T12:55:25Z", "time": "2012-07-05T12:55:25Z", "author": "ayg@aryeh.name", "is_private": false, "id": 6446430, "count": 8, "tags": [], "text": "(In reply to Ehsan Akhgari [:ehsan] from comment #7)\n> Because the editor is not involved in the former?\n\nWell, yes, but why should that make a difference?  Either we support such selections or we don't.  Why should we suddenly not support them when the editor is involved, when we otherwise do?\n\n> What do we expect to happen with the test case in comment 4 though?  We seem\n> to be the only browser which allows the selection to be collapsed to a node\n> that is not in the document...\n\nOkay, so should we change that?  Obviously it's pretty useless.  Do we want to limit a window's selection to only be in (inclusive) descendants of that window's document?\n\n> In that case, the caller of Collapse should be able to handle it failing,\n> and should not assert.... :/\n\nThis is another case where the assertion is sane but mutation events make it incorrect.  I'd really hate to lose sanity checks like this for common cases just because mutation events are broken.", "bug_id": 671152, "attachment_id": null, "raw_text": "(In reply to Ehsan Akhgari [:ehsan] from comment #7)\n> Because the editor is not involved in the former?\n\nWell, yes, but why should that make a difference?  Either we support such selections or we don't.  Why should we suddenly not support them when the editor is involved, when we otherwise do?\n\n> What do we expect to happen with the test case in comment 4 though?  We seem\n> to be the only browser which allows the selection to be collapsed to a node\n> that is not in the document...\n\nOkay, so should we change that?  Obviously it's pretty useless.  Do we want to limit a window's selection to only be in (inclusive) descendants of that window's document?\n\n> In that case, the caller of Collapse should be able to handle it failing,\n> and should not assert.... :/\n\nThis is another case where the assertion is sane but mutation events make it incorrect.  I'd really hate to lose sanity checks like this for common cases just because mutation events are broken."}, {"count": 9, "id": 6448176, "is_private": false, "author": "ehsan.akhgari@gmail.com", "creation_time": "2012-07-05T21:28:03Z", "time": "2012-07-05T21:28:03Z", "creator": "ehsan.akhgari@gmail.com", "raw_text": "(In reply to :Aryeh Gregor from comment #8)\n> (In reply to Ehsan Akhgari [:ehsan] from comment #7)\n> > Because the editor is not involved in the former?\n> \n> Well, yes, but why should that make a difference?  Either we support such\n> selections or we don't.  Why should we suddenly not support them when the\n> editor is involved, when we otherwise do?\n\nI was talking about what's different in our code, not what we should do.  Honestly I think it's pretty crazy to allow selections to be collapsed on stuff which are detached from the document.  WebKit and Opera seem to agree.  Is this spec'ed somewhere?\n\n> > What do we expect to happen with the test case in comment 4 though?  We seem\n> > to be the only browser which allows the selection to be collapsed to a node\n> > that is not in the document...\n> \n> Okay, so should we change that?  Obviously it's pretty useless.  Do we want\n> to limit a window's selection to only be in (inclusive) descendants of that\n> window's document?\n\nThat would make way more sense to me than what we currently do.  I think selection is a presentation property, and I don't even know what it means to put it on things which are by definition out of the presentation.\n\n> > In that case, the caller of Collapse should be able to handle it failing,\n> > and should not assert.... :/\n> \n> This is another case where the assertion is sane but mutation events make it\n> incorrect.  I'd really hate to lose sanity checks like this for common cases\n> just because mutation events are broken.\n\nLet's see what bz things here.", "attachment_id": null, "bug_id": 671152, "text": "(In reply to :Aryeh Gregor from comment #8)\n> (In reply to Ehsan Akhgari [:ehsan] from comment #7)\n> > Because the editor is not involved in the former?\n> \n> Well, yes, but why should that make a difference?  Either we support such\n> selections or we don't.  Why should we suddenly not support them when the\n> editor is involved, when we otherwise do?\n\nI was talking about what's different in our code, not what we should do.  Honestly I think it's pretty crazy to allow selections to be collapsed on stuff which are detached from the document.  WebKit and Opera seem to agree.  Is this spec'ed somewhere?\n\n> > What do we expect to happen with the test case in comment 4 though?  We seem\n> > to be the only browser which allows the selection to be collapsed to a node\n> > that is not in the document...\n> \n> Okay, so should we change that?  Obviously it's pretty useless.  Do we want\n> to limit a window's selection to only be in (inclusive) descendants of that\n> window's document?\n\nThat would make way more sense to me than what we currently do.  I think selection is a presentation property, and I don't even know what it means to put it on things which are by definition out of the presentation.\n\n> > In that case, the caller of Collapse should be able to handle it failing,\n> > and should not assert.... :/\n> \n> This is another case where the assertion is sane but mutation events make it\n> incorrect.  I'd really hate to lose sanity checks like this for common cases\n> just because mutation events are broken.\n\nLet's see what bz things here.", "tags": []}, {"attachment_id": null, "raw_text": "(In reply to Ehsan Akhgari [:ehsan] from comment #9)\n> I was talking about what's different in our code, not what we should do. \n> Honestly I think it's pretty crazy to allow selections to be collapsed on\n> stuff which are detached from the document.  WebKit and Opera seem to agree.\n> Is this spec'ed somewhere?\n\nYes, selection stuff is in the editing spec:\n\nhttp://dvcs.w3.org/hg/editing/raw-file/tip/editing.html#selections\n\nI went with the Gecko behavior for the spec because it was simplest, at least vis-a-vis the spec.  (Because the spec doesn't care about how it's presented!)  But if we want to change it, I'm fine with that -- I'll update the spec.  IE10 Developer Preview also doesn't allow such selections.\n\n> > Okay, so should we change that?  Obviously it's pretty useless.  Do we want\n> > to limit a window's selection to only be in (inclusive) descendants of that\n> > window's document?\n> \n> That would make way more sense to me than what we currently do.  I think\n> selection is a presentation property, and I don't even know what it means to\n> put it on things which are by definition out of the presentation.\n\nIt should be the same as putting it in display: none.  Or \"visibility: hidden; position: absolute; left: -1000000px\".  No selection is visible, but it still works programmatically.  Technically, per current spec, if you collapse() the selection into a text node that's the child of a detached element with contenteditable, typing text will insert text as usual into the text node.  This doesn't seem very useful, I grant!  (Even if computed styles worked.)\n\nI'll change the spec and file a bug to change our code.  Probably we have to silently ignore the command, not throw, for compat -- only IE throws here, AFAIK, and its implementation is very new and probably not compatible.\n\nMeanwhile, we have to fix this bug.  I think the right approach is along the lines of what we took in bug 766426 -- detect the case of mutation events and throw an exception (or otherwise fail) rather than asserting.  Actually, I think that in this case we should probably refuse to delete the node at all, because we shouldn't consider detached nodes editable, right?", "text": "(In reply to Ehsan Akhgari [:ehsan] from comment #9)\n> I was talking about what's different in our code, not what we should do. \n> Honestly I think it's pretty crazy to allow selections to be collapsed on\n> stuff which are detached from the document.  WebKit and Opera seem to agree.\n> Is this spec'ed somewhere?\n\nYes, selection stuff is in the editing spec:\n\nhttp://dvcs.w3.org/hg/editing/raw-file/tip/editing.html#selections\n\nI went with the Gecko behavior for the spec because it was simplest, at least vis-a-vis the spec.  (Because the spec doesn't care about how it's presented!)  But if we want to change it, I'm fine with that -- I'll update the spec.  IE10 Developer Preview also doesn't allow such selections.\n\n> > Okay, so should we change that?  Obviously it's pretty useless.  Do we want\n> > to limit a window's selection to only be in (inclusive) descendants of that\n> > window's document?\n> \n> That would make way more sense to me than what we currently do.  I think\n> selection is a presentation property, and I don't even know what it means to\n> put it on things which are by definition out of the presentation.\n\nIt should be the same as putting it in display: none.  Or \"visibility: hidden; position: absolute; left: -1000000px\".  No selection is visible, but it still works programmatically.  Technically, per current spec, if you collapse() the selection into a text node that's the child of a detached element with contenteditable, typing text will insert text as usual into the text node.  This doesn't seem very useful, I grant!  (Even if computed styles worked.)\n\nI'll change the spec and file a bug to change our code.  Probably we have to silently ignore the command, not throw, for compat -- only IE throws here, AFAIK, and its implementation is very new and probably not compatible.\n\nMeanwhile, we have to fix this bug.  I think the right approach is along the lines of what we took in bug 766426 -- detect the case of mutation events and throw an exception (or otherwise fail) rather than asserting.  Actually, I think that in this case we should probably refuse to delete the node at all, because we shouldn't consider detached nodes editable, right?", "bug_id": 671152, "tags": [], "count": 10, "id": 6449266, "is_private": false, "creation_time": "2012-07-06T07:02:47Z", "time": "2012-07-06T07:02:47Z", "creator": "ayg@aryeh.name", "author": "ayg@aryeh.name"}, {"time": "2012-07-06T07:04:12Z", "creation_time": "2012-07-06T07:04:12Z", "creator": "ayg@aryeh.name", "tags": [], "bug_id": 671152, "text": "(In reply to :Aryeh Gregor from comment #10)\n> Meanwhile, we have to fix this bug.  I think the right approach is along the\n> lines of what we took in bug 766426 -- detect the case of mutation events\n> and throw an exception (or otherwise fail) rather than asserting.  Actually,\n> I think that in this case we should probably refuse to delete the node at\n> all, because we shouldn't consider detached nodes editable, right?\n\nOh, wait, no -- I think the issue here is that the deletion of some text triggers the removal of the node via mutation events.  So the deletion was legit.  We just need to refuse to collapse the selection in this case.", "author": "ayg@aryeh.name", "count": 11, "id": 6449272, "is_private": false, "attachment_id": null, "raw_text": "(In reply to :Aryeh Gregor from comment #10)\n> Meanwhile, we have to fix this bug.  I think the right approach is along the\n> lines of what we took in bug 766426 -- detect the case of mutation events\n> and throw an exception (or otherwise fail) rather than asserting.  Actually,\n> I think that in this case we should probably refuse to delete the node at\n> all, because we shouldn't consider detached nodes editable, right?\n\nOh, wait, no -- I think the issue here is that the deletion of some text triggers the removal of the node via mutation events.  So the deletion was legit.  We just need to refuse to collapse the selection in this case."}, {"author": "ehsan.akhgari@gmail.com", "time": "2012-07-06T17:20:55Z", "creation_time": "2012-07-06T17:20:55Z", "creator": "ehsan.akhgari@gmail.com", "id": 6450421, "count": 12, "is_private": false, "bug_id": 671152, "text": "(In reply to comment #10)\n> (In reply to Ehsan Akhgari [:ehsan] from comment #9)\n> > I was talking about what's different in our code, not what we should do. \n> > Honestly I think it's pretty crazy to allow selections to be collapsed on\n> > stuff which are detached from the document.  WebKit and Opera seem to agree.\n> > Is this spec'ed somewhere?\n> \n> Yes, selection stuff is in the editing spec:\n> \n> http://dvcs.w3.org/hg/editing/raw-file/tip/editing.html#selections\n> \n> I went with the Gecko behavior for the spec because it was simplest, at least\n> vis-a-vis the spec.  (Because the spec doesn't care about how it's presented!) \n> But if we want to change it, I'm fine with that -- I'll update the spec.  IE10\n> Developer Preview also doesn't allow such selections.\n\nYeah, I think we should change the spec here.\n\n> > > Okay, so should we change that?  Obviously it's pretty useless.  Do we want\n> > > to limit a window's selection to only be in (inclusive) descendants of that\n> > > window's document?\n> > \n> > That would make way more sense to me than what we currently do.  I think\n> > selection is a presentation property, and I don't even know what it means to\n> > put it on things which are by definition out of the presentation.\n> \n> It should be the same as putting it in display: none.  Or \"visibility: hidden;\n> position: absolute; left: -1000000px\".  No selection is visible, but it still\n> works programmatically.  Technically, per current spec, if you collapse() the\n> selection into a text node that's the child of a detached element with\n> contenteditable, typing text will insert text as usual into the text node. \n> This doesn't seem very useful, I grant!  (Even if computed styles worked.)\n\nWell, I think this is actually harmful.  What happens if the element is removed from the document, an editing command gets invoked, and the element then gets added back?  The element has been changed by the command is not what the developer or the user would expect, I don't think!\n\n> I'll change the spec and file a bug to change our code.  Probably we have to\n> silently ignore the command, not throw, for compat -- only IE throws here,\n> AFAIK, and its implementation is very new and probably not compatible.\n\nAgreed.\n\n> Meanwhile, we have to fix this bug.  I think the right approach is along the\n> lines of what we took in bug 766426 -- detect the case of mutation events and\n> throw an exception (or otherwise fail) rather than asserting.  Actually, I\n> think that in this case we should probably refuse to delete the node at all,\n> because we shouldn't consider detached nodes editable, right?\n\nYes, I don't think the node should be removed in this case.", "tags": [], "raw_text": "(In reply to comment #10)\n> (In reply to Ehsan Akhgari [:ehsan] from comment #9)\n> > I was talking about what's different in our code, not what we should do. \n> > Honestly I think it's pretty crazy to allow selections to be collapsed on\n> > stuff which are detached from the document.  WebKit and Opera seem to agree.\n> > Is this spec'ed somewhere?\n> \n> Yes, selection stuff is in the editing spec:\n> \n> http://dvcs.w3.org/hg/editing/raw-file/tip/editing.html#selections\n> \n> I went with the Gecko behavior for the spec because it was simplest, at least\n> vis-a-vis the spec.  (Because the spec doesn't care about how it's presented!) \n> But if we want to change it, I'm fine with that -- I'll update the spec.  IE10\n> Developer Preview also doesn't allow such selections.\n\nYeah, I think we should change the spec here.\n\n> > > Okay, so should we change that?  Obviously it's pretty useless.  Do we want\n> > > to limit a window's selection to only be in (inclusive) descendants of that\n> > > window's document?\n> > \n> > That would make way more sense to me than what we currently do.  I think\n> > selection is a presentation property, and I don't even know what it means to\n> > put it on things which are by definition out of the presentation.\n> \n> It should be the same as putting it in display: none.  Or \"visibility: hidden;\n> position: absolute; left: -1000000px\".  No selection is visible, but it still\n> works programmatically.  Technically, per current spec, if you collapse() the\n> selection into a text node that's the child of a detached element with\n> contenteditable, typing text will insert text as usual into the text node. \n> This doesn't seem very useful, I grant!  (Even if computed styles worked.)\n\nWell, I think this is actually harmful.  What happens if the element is removed from the document, an editing command gets invoked, and the element then gets added back?  The element has been changed by the command is not what the developer or the user would expect, I don't think!\n\n> I'll change the spec and file a bug to change our code.  Probably we have to\n> silently ignore the command, not throw, for compat -- only IE throws here,\n> AFAIK, and its implementation is very new and probably not compatible.\n\nAgreed.\n\n> Meanwhile, we have to fix this bug.  I think the right approach is along the\n> lines of what we took in bug 766426 -- detect the case of mutation events and\n> throw an exception (or otherwise fail) rather than asserting.  Actually, I\n> think that in this case we should probably refuse to delete the node at all,\n> because we shouldn't consider detached nodes editable, right?\n\nYes, I don't think the node should be removed in this case.", "attachment_id": null}, {"time": "2012-07-06T17:22:15Z", "creation_time": "2012-07-06T17:22:15Z", "creator": "ehsan.akhgari@gmail.com", "author": "ehsan.akhgari@gmail.com", "id": 6450435, "count": 13, "is_private": false, "bug_id": 671152, "text": "(In reply to :Aryeh Gregor from comment #11)\n> (In reply to :Aryeh Gregor from comment #10)\n> > Meanwhile, we have to fix this bug.  I think the right approach is along the\n> > lines of what we took in bug 766426 -- detect the case of mutation events\n> > and throw an exception (or otherwise fail) rather than asserting.  Actually,\n> > I think that in this case we should probably refuse to delete the node at\n> > all, because we shouldn't consider detached nodes editable, right?\n> \n> Oh, wait, no -- I think the issue here is that the deletion of some text\n> triggers the removal of the node via mutation events.  So the deletion was\n> legit.  We just need to refuse to collapse the selection in this case.\n\nOh hrm, yeah you're right!", "tags": [], "attachment_id": null, "raw_text": "(In reply to :Aryeh Gregor from comment #11)\n> (In reply to :Aryeh Gregor from comment #10)\n> > Meanwhile, we have to fix this bug.  I think the right approach is along the\n> > lines of what we took in bug 766426 -- detect the case of mutation events\n> > and throw an exception (or otherwise fail) rather than asserting.  Actually,\n> > I think that in this case we should probably refuse to delete the node at\n> > all, because we shouldn't consider detached nodes editable, right?\n> \n> Oh, wait, no -- I think the issue here is that the deletion of some text\n> triggers the removal of the node via mutation events.  So the deletion was\n> legit.  We just need to refuse to collapse the selection in this case.\n\nOh hrm, yeah you're right!"}, {"tags": [], "bug_id": 671152, "text": "(In reply to Ehsan Akhgari [:ehsan] from comment #12)\n> Yeah, I think we should change the spec here.\n\nTest case, for reference:\n\ndata:text/html,<!doctype html>\n<iframe></iframe>\n<script>\nonload = function() {\nvar result = \"\";\n\ntry {\nvar div = document.createElement(\"div\");\ngetSelection().collapse(div, 0);\nresult += getSelection().anchorNode;\n} catch(e) {\nresult += e;\n}\n\ntry {\nvar text = document.createTextNode(\"abc\");\ngetSelection().collapse(text, 0);\nresult += \" \" + getSelection().anchorNode;\n} catch(e) {\nresult += e;\n}\n\ntry {\nvar iframeDoc = document.body.firstChild.contentDocument;\ngetSelection().collapse(iframeDoc.body, 0);\nresult += \" \" + getSelection().anchorNode;\n} catch(e) {\nresult += e;\n}\n\ntry {\ndocument.body.removeChild(document.body.firstChild);\ngetSelection().collapse(iframeDoc.body, 0);\nresult += \" \" + getSelection().anchorNode;\n} catch(e) {\nresult += e;\n}\n\ndocument.body.textContent = result;\n};\n</script>\n\nChrome 21 dev and Opera Next 12.00 alpha both give \"null null null null\".  IE10 Developer Preview throws in the second case (detached text node) but succeeds in all others.  (But then when I adjust the test case slightly it throws in the first case too?  Ugh.)  Firefox 16.0a1 succeeds in all cases.\n\n\nWhat should we do if a script does getSelection().getRangeAt(0).setStart(detached, 0)?  This isn't a problem for Chrome or Opera, because getRangeAt() returns a copy.  But we have to handle it somehow.  Actually, if we're going to place any restriction on what ranges can be in selections, I think we're going to have to change getRangeAt() to return a copy.  Does that make sense to you?  I've gone back and forth on it, but the spec currently matches Gecko here.  If you think getRangeAt() should return a copy instead of a reference, so scripts can't directly modify selections' ranges, I'll change the spec and write a patch for Gecko.\n\n> Well, I think this is actually harmful.  What happens if the element is\n> removed from the document, an editing command gets invoked, and the element\n> then gets added back?  The element has been changed by the command is not\n> what the developer or the user would expect, I don't think!\n\nThis is moot, but -- if the element is removed from the document, range mutation rules will mean the selection gets moved to its parent, so it's no longer selected.  The only time a detached element can be in the selection per current spec is if script puts it there.", "raw_text": "(In reply to Ehsan Akhgari [:ehsan] from comment #12)\n> Yeah, I think we should change the spec here.\n\nTest case, for reference:\n\ndata:text/html,<!doctype html>\n<iframe></iframe>\n<script>\nonload = function() {\nvar result = \"\";\n\ntry {\nvar div = document.createElement(\"div\");\ngetSelection().collapse(div, 0);\nresult += getSelection().anchorNode;\n} catch(e) {\nresult += e;\n}\n\ntry {\nvar text = document.createTextNode(\"abc\");\ngetSelection().collapse(text, 0);\nresult += \" \" + getSelection().anchorNode;\n} catch(e) {\nresult += e;\n}\n\ntry {\nvar iframeDoc = document.body.firstChild.contentDocument;\ngetSelection().collapse(iframeDoc.body, 0);\nresult += \" \" + getSelection().anchorNode;\n} catch(e) {\nresult += e;\n}\n\ntry {\ndocument.body.removeChild(document.body.firstChild);\ngetSelection().collapse(iframeDoc.body, 0);\nresult += \" \" + getSelection().anchorNode;\n} catch(e) {\nresult += e;\n}\n\ndocument.body.textContent = result;\n};\n</script>\n\nChrome 21 dev and Opera Next 12.00 alpha both give \"null null null null\".  IE10 Developer Preview throws in the second case (detached text node) but succeeds in all others.  (But then when I adjust the test case slightly it throws in the first case too?  Ugh.)  Firefox 16.0a1 succeeds in all cases.\n\n\nWhat should we do if a script does getSelection().getRangeAt(0).setStart(detached, 0)?  This isn't a problem for Chrome or Opera, because getRangeAt() returns a copy.  But we have to handle it somehow.  Actually, if we're going to place any restriction on what ranges can be in selections, I think we're going to have to change getRangeAt() to return a copy.  Does that make sense to you?  I've gone back and forth on it, but the spec currently matches Gecko here.  If you think getRangeAt() should return a copy instead of a reference, so scripts can't directly modify selections' ranges, I'll change the spec and write a patch for Gecko.\n\n> Well, I think this is actually harmful.  What happens if the element is\n> removed from the document, an editing command gets invoked, and the element\n> then gets added back?  The element has been changed by the command is not\n> what the developer or the user would expect, I don't think!\n\nThis is moot, but -- if the element is removed from the document, range mutation rules will mean the selection gets moved to its parent, so it's no longer selected.  The only time a detached element can be in the selection per current spec is if script puts it there.", "attachment_id": null, "author": "ayg@aryeh.name", "creator": "ayg@aryeh.name", "time": "2012-07-08T12:47:55Z", "creation_time": "2012-07-08T12:47:55Z", "is_private": false, "count": 14, "id": 6453384}, {"author": "ayg@aryeh.name", "time": "2012-07-08T12:50:56Z", "creation_time": "2012-07-08T12:50:56Z", "creator": "ayg@aryeh.name", "count": 15, "id": 6453386, "is_private": false, "text": "Ryosuke, you might be interested in above discussion.  I think we should change the selection spec to match WebKit a bit better -- make getRangeAt() return a copy (so modifying the result doesn't change the selection), and make addRange/collapse/extend/etc. fail silently if you try to place the selection in anything other than a descendant of window.document.  Including if you try to place the selection in an iframe.  I'm guessing you don't object, since it just makes WebKit more correct!  But I wanted to make sure you're okay with it anyway.", "bug_id": 671152, "tags": [], "raw_text": "Ryosuke, you might be interested in above discussion.  I think we should change the selection spec to match WebKit a bit better -- make getRangeAt() return a copy (so modifying the result doesn't change the selection), and make addRange/collapse/extend/etc. fail silently if you try to place the selection in anything other than a descendant of window.document.  Including if you try to place the selection in an iframe.  I'm guessing you don't object, since it just makes WebKit more correct!  But I wanted to make sure you're okay with it anyway.", "attachment_id": null}, {"attachment_id": null, "raw_text": "It sounds reasonable to me.", "bug_id": 671152, "text": "It sounds reasonable to me.", "tags": [], "count": 16, "id": 6453684, "is_private": false, "creation_time": "2012-07-08T18:16:04Z", "time": "2012-07-08T18:16:04Z", "creator": "rniwa@webkit.org", "author": "rniwa@webkit.org"}, {"count": 17, "id": 6456525, "is_private": false, "attachment_id": null, "raw_text": "(In reply to comment #14)\n> What should we do if a script does\n> getSelection().getRangeAt(0).setStart(detached, 0)?  This isn't a problem for\n> Chrome or Opera, because getRangeAt() returns a copy.  But we have to handle it\n> somehow.  Actually, if we're going to place any restriction on what ranges can\n> be in selections, I think we're going to have to change getRangeAt() to return\n> a copy.  Does that make sense to you?  I've gone back and forth on it, but the\n> spec currently matches Gecko here.  If you think getRangeAt() should return a\n> copy instead of a reference, so scripts can't directly modify selections'\n> ranges, I'll change the spec and write a patch for Gecko.\n\nYeah, returning a copy makes sense.\n\n> > Well, I think this is actually harmful.  What happens if the element is\n> > removed from the document, an editing command gets invoked, and the element\n> > then gets added back?  The element has been changed by the command is not\n> > what the developer or the user would expect, I don't think!\n> \n> This is moot, but -- if the element is removed from the document, range\n> mutation rules will mean the selection gets moved to its parent, so it's no\n> longer selected.  The only time a detached element can be in the selection per\n> current spec is if script puts it there.\n\nOK, then the above should have us covered, I think.", "time": "2012-07-09T21:41:02Z", "creation_time": "2012-07-09T21:41:02Z", "creator": "ehsan.akhgari@gmail.com", "tags": [], "text": "(In reply to comment #14)\n> What should we do if a script does\n> getSelection().getRangeAt(0).setStart(detached, 0)?  This isn't a problem for\n> Chrome or Opera, because getRangeAt() returns a copy.  But we have to handle it\n> somehow.  Actually, if we're going to place any restriction on what ranges can\n> be in selections, I think we're going to have to change getRangeAt() to return\n> a copy.  Does that make sense to you?  I've gone back and forth on it, but the\n> spec currently matches Gecko here.  If you think getRangeAt() should return a\n> copy instead of a reference, so scripts can't directly modify selections'\n> ranges, I'll change the spec and write a patch for Gecko.\n\nYeah, returning a copy makes sense.\n\n> > Well, I think this is actually harmful.  What happens if the element is\n> > removed from the document, an editing command gets invoked, and the element\n> > then gets added back?  The element has been changed by the command is not\n> > what the developer or the user would expect, I don't think!\n> \n> This is moot, but -- if the element is removed from the document, range\n> mutation rules will mean the selection gets moved to its parent, so it's no\n> longer selected.  The only time a detached element can be in the selection per\n> current spec is if script puts it there.\n\nOK, then the above should have us covered, I think.", "bug_id": 671152, "author": "ehsan.akhgari@gmail.com"}, {"is_private": false, "id": 7397464, "count": 18, "author": "bugs@pettay.fi", "creator": "bugs@pettay.fi", "creation_time": "2013-05-07T20:28:38Z", "time": "2013-05-07T20:28:38Z", "raw_text": "Any updates here?", "attachment_id": null, "tags": [], "bug_id": 671152, "text": "Any updates here?"}, {"count": 19, "id": 7397980, "is_private": false, "time": "2013-05-07T22:31:44Z", "creation_time": "2013-05-07T22:31:44Z", "creator": "ehsan.akhgari@gmail.com", "author": "ehsan.akhgari@gmail.com", "attachment_id": null, "raw_text": "(In reply to Olli Pettay [:smaug] from comment #18)\n> Any updates here?\n\nAs far as I know nobody is currently working on this bug.", "tags": [], "bug_id": 671152, "text": "(In reply to Olli Pettay [:smaug] from comment #18)\n> Any updates here?\n\nAs far as I know nobody is currently working on this bug."}, {"bug_id": 671152, "text": "> Yeah, returning a copy makes sense.\n\nNote that Chrome and Opera now counts as one implementation.\n\nIE10 returns a live range afaict.  So there are two UAs that implements\nwhat the spec says, and one that doesn't.\n\nDid we contact Webkit/Blink folks and ask if they intend to implement\nwhat the spec says?", "tags": [], "raw_text": "> Yeah, returning a copy makes sense.\n\nNote that Chrome and Opera now counts as one implementation.\n\nIE10 returns a live range afaict.  So there are two UAs that implements\nwhat the spec says, and one that doesn't.\n\nDid we contact Webkit/Blink folks and ask if they intend to implement\nwhat the spec says?", "attachment_id": null, "author": "MatsPalmgren_bugz@use.startmail.com", "creator": "MatsPalmgren_bugz@use.startmail.com", "creation_time": "2013-05-07T23:03:40Z", "time": "2013-05-07T23:03:40Z", "is_private": false, "id": 7398087, "count": 20}, {"raw_text": "(In reply to comment #20)\n> > Yeah, returning a copy makes sense.\n> \n> Note that Chrome and Opera now counts as one implementation.\n> \n> IE10 returns a live range afaict.  So there are two UAs that implements\n> what the spec says, and one that doesn't.\n\nThis doesn't really make this easier to decide. :(\n\n> Did we contact Webkit/Blink folks and ask if they intend to implement\n> what the spec says?\n\nSee comment 16.", "attachment_id": null, "text": "(In reply to comment #20)\n> > Yeah, returning a copy makes sense.\n> \n> Note that Chrome and Opera now counts as one implementation.\n> \n> IE10 returns a live range afaict.  So there are two UAs that implements\n> what the spec says, and one that doesn't.\n\nThis doesn't really make this easier to decide. :(\n\n> Did we contact Webkit/Blink folks and ask if they intend to implement\n> what the spec says?\n\nSee comment 16.", "bug_id": 671152, "tags": [], "id": 7403464, "count": 21, "is_private": false, "author": "ehsan.akhgari@gmail.com", "creation_time": "2013-05-09T03:33:21Z", "time": "2013-05-09T03:33:21Z", "creator": "ehsan.akhgari@gmail.com"}, {"count": 22, "id": 9087548, "is_private": false, "time": "2014-07-22T22:41:49Z", "creation_time": "2014-07-22T22:41:49Z", "creator": "jruderman@gmail.com", "author": "jruderman@gmail.com", "attachment_id": null, "raw_text": "The problem of detached and wrong-document selections leads to a wide variety of assertions. My DOM fuzzer currently ignores all assertions in editor, along with a few assertions in other code. I'd really appreciate a fix that prevents this situation, or at least disables execCommand() when selection endpoints aren't descendants of the document.", "text": "The problem of detached and wrong-document selections leads to a wide variety of assertions. My DOM fuzzer currently ignores all assertions in editor, along with a few assertions in other code. I'd really appreciate a fix that prevents this situation, or at least disables execCommand() when selection endpoints aren't descendants of the document.", "bug_id": 671152, "tags": []}, {"tags": [], "text": "I don't think anyone is working on Blink or WebKit to return a live Range so you might want to raise the question in public-webapps to see if Microsoft is interested in changing IE's behavior. FWIW, IE didn't have Gecko compatible API until recently so they might not have much backwards compatibility concern as much as we do.", "bug_id": 671152, "raw_text": "I don't think anyone is working on Blink or WebKit to return a live Range so you might want to raise the question in public-webapps to see if Microsoft is interested in changing IE's behavior. FWIW, IE didn't have Gecko compatible API until recently so they might not have much backwards compatibility concern as much as we do.", "attachment_id": null, "author": "rniwa@webkit.org", "creator": "rniwa@webkit.org", "creation_time": "2014-07-23T00:36:14Z", "time": "2014-07-23T00:36:14Z", "is_private": false, "count": 23, "id": 9088104}, {"creator": "jstutte@mozilla.com", "time": "2020-12-16T11:07:42Z", "creation_time": "2020-12-16T11:07:42Z", "author": "jstutte@mozilla.com", "is_private": false, "count": 24, "id": 15178182, "text": "Bulk-downgrade of unassigned, >=5 years untouched DOM/Storage bugs' priority.\n\nIf you have reason to believe this is wrong (especially for the severity), please write a comment and ni :jstutte.", "bug_id": 671152, "tags": [], "attachment_id": null, "raw_text": "Bulk-downgrade of unassigned, >=5 years untouched DOM/Storage bugs' priority.\n\nIf you have reason to believe this is wrong (especially for the severity), please write a comment and ni :jstutte."}]}}}