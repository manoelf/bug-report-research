{"comments": {}, "bugs": {"626901": {"comments": [{"tags": [], "time": "2011-01-19T01:19:14Z", "author": "wtc@google.com", "creation_time": "2011-01-19T01:19:14Z", "count": 0, "id": 5209359, "attachment_id": 504928, "creator": "wtc@google.com", "is_private": false, "bug_id": 626901, "raw_text": "Background: I recently debugged an SSL server that fails with\nSSL_ERROR_BAD_MAC_READ after decrypting the client's Finished\nmessage in ssl3_HandleRecord.  Eventually I found that the SSL\nhandshake actually failed much earlier, in\nssl3_HandleRSAClientKeyExchange.  The PK11_PubUnwrapSymKey call\nin ssl3_HandleRSAClientKeyExchange failed because the server's\nprivate key doesn't have the CKA_UNWRAP attribute.  The softoken's\nNSC_UnwrapKey failed with CKR_KEY_TYPE_INCONSISTENT, with was\nmapped to SEC_ERROR_INVALID_KEY.\n\nProblem:\n\nThe problem was that ssl3_HandleRSAClientKeyExchange generated\na bogus pre-master secret and carried on, regardless of the\nreason why PK11_PubUnwrapSymKey failed.  Eventually the client's\nFinished message was decrypted using a bogus session key and failed\nthe padding check, hence the SSL_ERROR_BAD_MAC_READ error.\n\nThe bogus PMS is intended to defend against the Bleichenbacher\nattack.  However, it should only be used when PK11_PubUnwrapSymKey\nfails because an error occurred during RSA decryption.  If\nPK11_PubUnwrapSymKey fails with a non-decryption error (for\nexample, SEC_ERROR_INVALID_KEY, which implies decryption wasn't\nperformed), we should report the actual error code to help\ndebugging.\n\nThe attached patch makes this change to\nssl3_HandleRSAClientKeyExchange.  It also sends the internal_error\nalert to the client when the server cannot use its private key.\n\nPlease review this patch carefully.  Thank you.", "text": "Created attachment 504928\nProposed patch\n\nBackground: I recently debugged an SSL server that fails with\nSSL_ERROR_BAD_MAC_READ after decrypting the client's Finished\nmessage in ssl3_HandleRecord.  Eventually I found that the SSL\nhandshake actually failed much earlier, in\nssl3_HandleRSAClientKeyExchange.  The PK11_PubUnwrapSymKey call\nin ssl3_HandleRSAClientKeyExchange failed because the server's\nprivate key doesn't have the CKA_UNWRAP attribute.  The softoken's\nNSC_UnwrapKey failed with CKR_KEY_TYPE_INCONSISTENT, with was\nmapped to SEC_ERROR_INVALID_KEY.\n\nProblem:\n\nThe problem was that ssl3_HandleRSAClientKeyExchange generated\na bogus pre-master secret and carried on, regardless of the\nreason why PK11_PubUnwrapSymKey failed.  Eventually the client's\nFinished message was decrypted using a bogus session key and failed\nthe padding check, hence the SSL_ERROR_BAD_MAC_READ error.\n\nThe bogus PMS is intended to defend against the Bleichenbacher\nattack.  However, it should only be used when PK11_PubUnwrapSymKey\nfails because an error occurred during RSA decryption.  If\nPK11_PubUnwrapSymKey fails with a non-decryption error (for\nexample, SEC_ERROR_INVALID_KEY, which implies decryption wasn't\nperformed), we should report the actual error code to help\ndebugging.\n\nThe attached patch makes this change to\nssl3_HandleRSAClientKeyExchange.  It also sends the internal_error\nalert to the client when the server cannot use its private key.\n\nPlease review this patch carefully.  Thank you."}, {"creator": "nelson@bolyard.me", "attachment_id": 504928, "id": 5239085, "text": "Comment on attachment 504928\nProposed patch\n\nWan-Teh, I have reviewed your patch and have a concern/observation/question.\n\nYour patch deals with failures of PK11_PubUnwrapSymKey.  That function is \nquite complex, having no less than 3 major distinct paths of execution, one\nof which is called \"HandUnwrap\" which is used in cases where the PMS must be\nmoved from one token to another but FIPS complicates life.  \n\nI believe your patch is correct for the very common case where NSS's own \nsoftoken is used on non-FIPS mode I wonder if failures in the other paths of \nexecution, and/or failures due to the use of some third party PKCS#11 module(s)\nmay cause OTHER error codes (than SEC_ERROR_INVALID_KEY) to be returned.  If\nthat were to happen, then this patch would, in effect, reactivate the vuln to the Bleichenbacher \"million question\" attack when used under those conditions.\n\nCan we be sure that SEC_ERROR_INVALID_KEY will be returned by PK11_PubUnwrapSymKey in ALL cases where the Bleichenbacher attach might be \noccurring?  If so, then your patch is OK (r+) with me.  But if not ... then I think that's potentially deadly risk.", "raw_text": "Wan-Teh, I have reviewed your patch and have a concern/observation/question.\n\nYour patch deals with failures of PK11_PubUnwrapSymKey.  That function is \nquite complex, having no less than 3 major distinct paths of execution, one\nof which is called \"HandUnwrap\" which is used in cases where the PMS must be\nmoved from one token to another but FIPS complicates life.  \n\nI believe your patch is correct for the very common case where NSS's own \nsoftoken is used on non-FIPS mode I wonder if failures in the other paths of \nexecution, and/or failures due to the use of some third party PKCS#11 module(s)\nmay cause OTHER error codes (than SEC_ERROR_INVALID_KEY) to be returned.  If\nthat were to happen, then this patch would, in effect, reactivate the vuln to the Bleichenbacher \"million question\" attack when used under those conditions.\n\nCan we be sure that SEC_ERROR_INVALID_KEY will be returned by PK11_PubUnwrapSymKey in ALL cases where the Bleichenbacher attach might be \noccurring?  If so, then your patch is OK (r+) with me.  But if not ... then I think that's potentially deadly risk.", "bug_id": 626901, "is_private": false, "tags": [], "count": 1, "creation_time": "2011-01-31T01:55:18Z", "author": "nelson@bolyard.me", "time": "2011-01-31T01:55:18Z"}, {"attachment_id": 504928, "id": 5239210, "creator": "wtc@google.com", "raw_text": "Nelson,\n\nThank you for the review.  I'm afraid that you read\nthe test in my patch wrong.  The test is:\n\n>+\t    errCode = PORT_GetError();\n>+\t    if (errCode != SEC_ERROR_INVALID_KEY) {\n>+\t\t/* RSA decryption was performed but failed.  Generate a bogus\n>+\t\t * PMS and carry on to defend against the Bleichenbacher\n>+\t\t * attack.\n>+\t\t */\n\nSo, it skips the attack defense only when the error is\nSEC_ERROR_INVALID_KEY.  For any other error, even\nSEC_ERROR_NO_MEMORY, we still generate a bogus PMS and\ncarry on.\n\nUnless a PKCS #11 token reports SEC_ERROR_INVALID_KEY\non RSA PKCS #1 padding errors, the test should not make\nNSS vulnerable to the attack.", "is_private": false, "bug_id": 626901, "text": "Comment on attachment 504928\nProposed patch\n\nNelson,\n\nThank you for the review.  I'm afraid that you read\nthe test in my patch wrong.  The test is:\n\n>+\t    errCode = PORT_GetError();\n>+\t    if (errCode != SEC_ERROR_INVALID_KEY) {\n>+\t\t/* RSA decryption was performed but failed.  Generate a bogus\n>+\t\t * PMS and carry on to defend against the Bleichenbacher\n>+\t\t * attack.\n>+\t\t */\n\nSo, it skips the attack defense only when the error is\nSEC_ERROR_INVALID_KEY.  For any other error, even\nSEC_ERROR_NO_MEMORY, we still generate a bogus PMS and\ncarry on.\n\nUnless a PKCS #11 token reports SEC_ERROR_INVALID_KEY\non RSA PKCS #1 padding errors, the test should not make\nNSS vulnerable to the attack.", "tags": [], "author": "wtc@google.com", "time": "2011-01-31T05:24:10Z", "count": 2, "creation_time": "2011-01-31T05:24:10Z"}, {"attachment_id": null, "id": 5239254, "creator": "nelson@bolyard.me", "raw_text": "Wan-Teh, You're right. I got the test sign backwards.  So, in light of that,\nthe question becomes, what are all the CKR_ errors that map to SEC_ERROR_INVALID_KEY and can a PKCS#11 module return any of them to \na failed RSA operations because of the result value not being as expected?", "is_private": false, "bug_id": 626901, "text": "Wan-Teh, You're right. I got the test sign backwards.  So, in light of that,\nthe question becomes, what are all the CKR_ errors that map to SEC_ERROR_INVALID_KEY and can a PKCS#11 module return any of them to \na failed RSA operations because of the result value not being as expected?", "tags": [], "author": "nelson@bolyard.me", "time": "2011-01-31T06:28:48Z", "count": 3, "creation_time": "2011-01-31T06:28:48Z"}, {"id": 5243580, "bug_id": 626901, "is_private": false, "raw_text": "That's my concern as well. I would rather log the error on the server side rather than return something to the client. If you saw in the long on the server \"PSM Unwrap failed, Invalid key\" that would go a long way to debugging the issue you ran into.\n\nbob", "time": "2011-02-01T19:28:56Z", "count": 4, "attachment_id": null, "creator": "rrelyea@redhat.com", "text": "That's my concern as well. I would rather log the error on the server side rather than return something to the client. If you saw in the long on the server \"PSM Unwrap failed, Invalid key\" that would go a long way to debugging the issue you ran into.\n\nbob", "tags": [], "author": "rrelyea@redhat.com", "creation_time": "2011-02-01T19:28:56Z"}, {"tags": [], "author": "wtc@google.com", "time": "2011-02-01T19:31:55Z", "count": 5, "creation_time": "2011-02-01T19:31:55Z", "attachment_id": null, "id": 5243596, "creator": "wtc@google.com", "raw_text": "Logging an error message on the server side is a good idea.\n\nNSS maps the following CKR_ errors to SEC_ERROR_INVALID_KEY:\nhttp://bonsai.mozilla.org/cvsblame.cgi?file=mozilla/security/nss/lib/pk11wrap/pk11err.c&rev=1.13&mark=91,99-101,125-127,132-136#75\n\n  CKR_DOMAIN_PARAMS_INVALID\n\n  CKR_KEY_HANDLE_INVALID\n  CKR_KEY_SIZE_RANGE\n  CKR_KEY_TYPE_INCONSISTENT\n\n  CKR_WRAPPED_KEY_INVALID\n  CKR_WRAPPED_KEY_LEN_RANGE\n\n  CKR_UNWRAPPING_KEY_HANDLE_INVALID\n  CKR_UNWRAPPING_KEY_SIZE_RANGE\n  CKR_UNWRAPPING_KEY_TYPE_INCONSISTENT\n\n  CKR_WRAPPING_KEY_HANDLE_INVALID\n  CKR_WRAPPING_KEY_SIZE_RANGE\n  CKR_WRAPPING_KEY_TYPE_INCONSISTENT\n\nCKR_WRAPPED_KEY_INVALID and CKR_WRAPPED_KEY_LEN_RANGE\nare problematic!\n\nThe safest solution is:\n\n1. add new NSS error codes\nSEC_ERROR_INVALID_UNWRAPPING_KEY,  \nSEC_ERROR_INVALID_WRAPPING_KEY, and\nSEC_ERROR_INVALID_WRAPPED_KEY; \n\n2. map CKR_UNWRAPPING_KEY_xxx, CKR_WRAPPING_KEY_xxx,\nand CKR_WRAPPED_KEY_xxx to the new NSS error codes;\n\n3. change my patch to test for SEC_ERROR_INVALID_UNWRAPPING_KEY.\n\nNelson, Bob, what do you think?", "bug_id": 626901, "is_private": false, "text": "Logging an error message on the server side is a good idea.\n\nNSS maps the following CKR_ errors to SEC_ERROR_INVALID_KEY:\nhttp://bonsai.mozilla.org/cvsblame.cgi?file=mozilla/security/nss/lib/pk11wrap/pk11err.c&rev=1.13&mark=91,99-101,125-127,132-136#75\n\n  CKR_DOMAIN_PARAMS_INVALID\n\n  CKR_KEY_HANDLE_INVALID\n  CKR_KEY_SIZE_RANGE\n  CKR_KEY_TYPE_INCONSISTENT\n\n  CKR_WRAPPED_KEY_INVALID\n  CKR_WRAPPED_KEY_LEN_RANGE\n\n  CKR_UNWRAPPING_KEY_HANDLE_INVALID\n  CKR_UNWRAPPING_KEY_SIZE_RANGE\n  CKR_UNWRAPPING_KEY_TYPE_INCONSISTENT\n\n  CKR_WRAPPING_KEY_HANDLE_INVALID\n  CKR_WRAPPING_KEY_SIZE_RANGE\n  CKR_WRAPPING_KEY_TYPE_INCONSISTENT\n\nCKR_WRAPPED_KEY_INVALID and CKR_WRAPPED_KEY_LEN_RANGE\nare problematic!\n\nThe safest solution is:\n\n1. add new NSS error codes\nSEC_ERROR_INVALID_UNWRAPPING_KEY,  \nSEC_ERROR_INVALID_WRAPPING_KEY, and\nSEC_ERROR_INVALID_WRAPPED_KEY; \n\n2. map CKR_UNWRAPPING_KEY_xxx, CKR_WRAPPING_KEY_xxx,\nand CKR_WRAPPED_KEY_xxx to the new NSS error codes;\n\n3. change my patch to test for SEC_ERROR_INVALID_UNWRAPPING_KEY.\n\nNelson, Bob, what do you think?"}, {"creator": "nelson@bolyard.me", "id": 5250987, "attachment_id": null, "text": "Wan-Teh, Sounds like a good plan to me.", "bug_id": 626901, "is_private": false, "raw_text": "Wan-Teh, Sounds like a good plan to me.", "tags": [], "creation_time": "2011-02-03T09:06:50Z", "count": 6, "time": "2011-02-03T09:06:50Z", "author": "nelson@bolyard.me"}, {"time": "2011-03-10T23:18:39Z", "count": 7, "id": 5337711, "raw_text": "I'm not sure I trust that the error we get back from the Unwrap operation will be CKR_WRAPPED_KEY_INVALID. It could very well be CKR_DATA_INVALID*, for instance. I would be a lot more comfortable with a patch that narrowed the cases a little, not a lot.\n\nSince we are talking about a security issue, I don't want to open things up because a PKCS #11 module is returning CKR_DEVICE_ERROR because the hardware choked on the bad DATA. I'd rather white list some of the errors that you think are more likely to be false negatives.... \n\n\n(*actually I think CKR_DATA_INVALID is the more likely error code, followed by CKR_WRAPPED_KEY_LENGTH_RANGE).\n\nWhat error cases are you running into that are false positives. That will give me a better idea about what we should see in this patch.\n\nbob", "is_private": false, "bug_id": 626901, "tags": [], "author": "rrelyea@redhat.com", "creation_time": "2011-03-10T23:18:39Z", "attachment_id": null, "creator": "rrelyea@redhat.com", "text": "I'm not sure I trust that the error we get back from the Unwrap operation will be CKR_WRAPPED_KEY_INVALID. It could very well be CKR_DATA_INVALID*, for instance. I would be a lot more comfortable with a patch that narrowed the cases a little, not a lot.\n\nSince we are talking about a security issue, I don't want to open things up because a PKCS #11 module is returning CKR_DEVICE_ERROR because the hardware choked on the bad DATA. I'd rather white list some of the errors that you think are more likely to be false negatives.... \n\n\n(*actually I think CKR_DATA_INVALID is the more likely error code, followed by CKR_WRAPPED_KEY_LENGTH_RANGE).\n\nWhat error cases are you running into that are false positives. That will give me a better idea about what we should see in this patch.\n\nbob"}, {"tags": [], "creation_time": "2011-03-10T23:21:52Z", "count": 8, "time": "2011-03-10T23:21:52Z", "author": "wtc@google.com", "creator": "wtc@google.com", "id": 5337719, "attachment_id": null, "text": "Bob: the error case was that the server's private key did not have the CKA_UNWRAP attribute.\nThe softoken's NSC_UnwrapKey failed with CKR_KEY_TYPE_INCONSISTENT.", "bug_id": 626901, "is_private": false, "raw_text": "Bob: the error case was that the server's private key did not have the CKA_UNWRAP attribute.\nThe softoken's NSC_UnwrapKey failed with CKR_KEY_TYPE_INCONSISTENT."}, {"tags": [], "author": "rrelyea@redhat.com", "time": "2011-03-11T01:15:26Z", "count": 9, "creation_time": "2011-03-11T01:15:26Z", "attachment_id": null, "id": 5338004, "creator": "rrelyea@redhat.com", "raw_text": "OK, I'd rather make a list of these kinds of things....\n\nCKR_KEY_TYPE_INCONSISTENT\nCKR_INVALID_KEY_HANDLE\nCKR_UNWRAPPING_KEY_HANDLE_INVALID\n\n\nSeem safe enough. The list could likely be bigger, but we really need to evaluate each code to determine if it's reasonable a PKCS #11 module may fail on that value. (Also note the the higher level unwrap function may do a decrypt and import, so things like CKR_TEMPLATE_INCONSISTENT and CKR_ATTRIBUTE_VALUE_INVALID are also possibilities)..\n\nI think I would be more comfortable first modifying PK11_PubUnwrap() to examine the CKR_ error codes in the context of their coming back from the token, and then setting an appropriate error code. At that point I would have more confidence in catching the right failure types when bad data was passed in (it would still have to be a broad net,  weird and unexpected error should be treated as 'failure to unwrap the key due to bad data' simply because underlying PKCS #11 engines are likely to have weird and unexpected failures when invalid RSA data is passed to them).\n\nbob", "bug_id": 626901, "is_private": false, "text": "OK, I'd rather make a list of these kinds of things....\n\nCKR_KEY_TYPE_INCONSISTENT\nCKR_INVALID_KEY_HANDLE\nCKR_UNWRAPPING_KEY_HANDLE_INVALID\n\n\nSeem safe enough. The list could likely be bigger, but we really need to evaluate each code to determine if it's reasonable a PKCS #11 module may fail on that value. (Also note the the higher level unwrap function may do a decrypt and import, so things like CKR_TEMPLATE_INCONSISTENT and CKR_ATTRIBUTE_VALUE_INVALID are also possibilities)..\n\nI think I would be more comfortable first modifying PK11_PubUnwrap() to examine the CKR_ error codes in the context of their coming back from the token, and then setting an appropriate error code. At that point I would have more confidence in catching the right failure types when bad data was passed in (it would still have to be a broad net,  weird and unexpected error should be treated as 'failure to unwrap the key due to bad data' simply because underlying PKCS #11 engines are likely to have weird and unexpected failures when invalid RSA data is passed to them).\n\nbob"}, {"raw_text": "r- As I mentioned in comment 9, we need a much narrower check here, which would mean changes to PK11_PubUnwrapSymKey as well..", "is_private": false, "bug_id": 626901, "text": "Comment on attachment 504928\nProposed patch\n\nr- As I mentioned in comment 9, we need a much narrower check here, which would mean changes to PK11_PubUnwrapSymKey as well..", "attachment_id": 504928, "id": 5487955, "creator": "rrelyea@redhat.com", "author": "rrelyea@redhat.com", "time": "2011-05-23T23:04:16Z", "count": 10, "creation_time": "2011-05-23T23:04:16Z", "tags": []}]}}}