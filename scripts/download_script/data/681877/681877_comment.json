{"bugs": {"681877": {"comments": [{"creator": "sphink@gmail.com", "author": "sphink@gmail.com", "raw_text": "I would like to turn on --enable-dtrace for all builds by default, on platforms that support dtrace (OSX + Linux). The Linux build machines already have the necessary development headers and tools installed (bug 673753). OSX includes the necessary pieces by default.\n\nI do not propose with this bug to enable dtrace in configure.in, because that would break Linux builds for developers who don't have the dtrace development headers & tools. (And Ubuntu's default kernel does not even contain the necessary support, so I'm not sure how easy it is to get the devel stuff installed there. Ubuntu can use a firefox compiled with --enable-dtrace just fine, though; it just can't make use of it.)\n\nCurrently, this only has any effect at all within SpiderMonkey. (There used to be some toplevel dtrace stuff, and you can still see vestiges in the toplevel probes/ directory, but that seems to have withered away long ago.)\n\nWithin SpiderMonkey, enabling dtrace has the effect of (1) adding in some nop instructions in a number of different places, (2) adding some additional branches (on constant zero values) and \"dead\" code to functions that were previously empty and declared to be inline, (3) computing various additional bits in those dead (but not compiled out!) code blocks, and (3) adding information to the object files that gives a map of those places. A few of those locations are in fairly hot code, so it's possible that they could cause a slowdown. (Or speedup, from changing alignment or happening to spell out the Mystical Sigil of Warterdeedoo.)\n\nTo measure the effect, I did 27 runs of the v8 test suite on a bunch of dtrace and non-dtrace builds:\n\nopt jit none 27\t4491.3\t4489.0\nopt jit dtrace 27\t4489.1\t4489.0\nopt nojit none 27\t686.3\t689.0\nopt nojit dtrace 27\t684.3\t686.0\ndebug jit none 27\t1217.9\t1225.0\ndebug jit dtrace 27\t1220.6\t1227.0\n\nFirst number is #iterations (always 27), then the mean score of those runs, then the median (higher is better.)\n\nThe quick summary is that enabling dtrace had no impact whatsoever. I have not inspected the generated code.\n\nAll of these runs are on a 64-bit Linux machine.\n\nJust to be clear, these timings are all for having dtrace compiled in but inactive. I need to generate a new set of numbers for when you actually start using these probe points, but that's for another bug. (First impressions: rare things like GC start/stop are free. Intermediate things like toplevel script execution are cheap. Hot things like function entry/exit are expensive, like a factor of 2-4 slowdown.) When you activate a probe point, nops get converted to jumps and constant tests get their constant flipped, activating the guarded code. (And then, with the systemtap implementation at least, a probe hit triggers a trap to the kernel.) But for some probes (function entry/exit, native call entry/exit), the effect is much more dramatic -- any JIT code compiled when the probe is active is majorly deoptimized. (Every function call becomes 3 separate calls, and there's more register pressure.)\n\nI am initially filing this under JS so it shows up in JS folks' bugmail, but I'll reassign when I figure out the right component.", "creation_time": "2011-08-25T06:35:10Z", "text": "I would like to turn on --enable-dtrace for all builds by default, on platforms that support dtrace (OSX + Linux). The Linux build machines already have the necessary development headers and tools installed (bug 673753). OSX includes the necessary pieces by default.\n\nI do not propose with this bug to enable dtrace in configure.in, because that would break Linux builds for developers who don't have the dtrace development headers & tools. (And Ubuntu's default kernel does not even contain the necessary support, so I'm not sure how easy it is to get the devel stuff installed there. Ubuntu can use a firefox compiled with --enable-dtrace just fine, though; it just can't make use of it.)\n\nCurrently, this only has any effect at all within SpiderMonkey. (There used to be some toplevel dtrace stuff, and you can still see vestiges in the toplevel probes/ directory, but that seems to have withered away long ago.)\n\nWithin SpiderMonkey, enabling dtrace has the effect of (1) adding in some nop instructions in a number of different places, (2) adding some additional branches (on constant zero values) and \"dead\" code to functions that were previously empty and declared to be inline, (3) computing various additional bits in those dead (but not compiled out!) code blocks, and (3) adding information to the object files that gives a map of those places. A few of those locations are in fairly hot code, so it's possible that they could cause a slowdown. (Or speedup, from changing alignment or happening to spell out the Mystical Sigil of Warterdeedoo.)\n\nTo measure the effect, I did 27 runs of the v8 test suite on a bunch of dtrace and non-dtrace builds:\n\nopt jit none 27\t4491.3\t4489.0\nopt jit dtrace 27\t4489.1\t4489.0\nopt nojit none 27\t686.3\t689.0\nopt nojit dtrace 27\t684.3\t686.0\ndebug jit none 27\t1217.9\t1225.0\ndebug jit dtrace 27\t1220.6\t1227.0\n\nFirst number is #iterations (always 27), then the mean score of those runs, then the median (higher is better.)\n\nThe quick summary is that enabling dtrace had no impact whatsoever. I have not inspected the generated code.\n\nAll of these runs are on a 64-bit Linux machine.\n\nJust to be clear, these timings are all for having dtrace compiled in but inactive. I need to generate a new set of numbers for when you actually start using these probe points, but that's for another bug. (First impressions: rare things like GC start/stop are free. Intermediate things like toplevel script execution are cheap. Hot things like function entry/exit are expensive, like a factor of 2-4 slowdown.) When you activate a probe point, nops get converted to jumps and constant tests get their constant flipped, activating the guarded code. (And then, with the systemtap implementation at least, a probe hit triggers a trap to the kernel.) But for some probes (function entry/exit, native call entry/exit), the effect is much more dramatic -- any JIT code compiled when the probe is active is majorly deoptimized. (Every function call becomes 3 separate calls, and there's more register pressure.)\n\nI am initially filing this under JS so it shows up in JS folks' bugmail, but I'll reassign when I figure out the right component.", "time": "2011-08-25T06:35:10Z", "attachment_id": null, "is_private": false, "count": 0, "tags": [], "id": 5677098, "bug_id": 681877}, {"creator": "dmandelin@mozilla.com", "author": "dmandelin@mozilla.com", "text": "What does it do on 64-bit Mac? What about SunSpider and Kraken?", "time": "2011-08-25T19:55:25Z", "attachment_id": null, "creation_time": "2011-08-25T19:55:25Z", "raw_text": "What does it do on 64-bit Mac? What about SunSpider and Kraken?", "bug_id": 681877, "tags": [], "is_private": false, "count": 1, "id": 5678593}]}}, "comments": {}}