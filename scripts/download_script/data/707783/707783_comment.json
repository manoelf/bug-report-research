{"bugs": {"707783": {"comments": [{"raw_text": "Bug 676349 comment 56 (Jeff Muizelaar):\n\n> We should be able to use something like the following to detect situations\n> where QPC is going to work reliably:\n> \n> #include <intrin.h>\n> \n> static bool\n> has_stable_tsc()\n> {\n>         int regs[4];\n> \n>         // detect if the Advanced Power Management feature is supported\n>         __cpuid(regs, 0x80000000);\n>         if (regs[0] < 0x80000007)\n>                 return false;\n> \n>         __cpuid(regs, 0x80000007);\n>         // if bit 8 is set than TSC will run at a constant rate\n>         // in all ACPI P-state, C-states and T-states\n>         return regs[4] & (1 << 8);\n> }\n> \n> It would be nice to use this to avoid the overhead of having to do both QPC\n> and GTC for ever TimeStamp::Now()\n\n\n\nI personally don't think this is useful for using QueryPerformanceCounter.  QPC function should do these checks for the programmer it self.  I don't think using RDTSC instruction directly is what we want to use at all and this code seems to be related only to direct use of that instruction.\n\nBut this is still worth to investigate on.", "attachment_id": null, "id": 5893490, "count": 0, "creator": "honzab.moz@firemni.cz", "is_private": false, "bug_id": 707783, "tags": [], "time": "2011-12-05T20:27:22Z", "text": "Bug 676349 comment 56 (Jeff Muizelaar):\n\n> We should be able to use something like the following to detect situations\n> where QPC is going to work reliably:\n> \n> #include <intrin.h>\n> \n> static bool\n> has_stable_tsc()\n> {\n>         int regs[4];\n> \n>         // detect if the Advanced Power Management feature is supported\n>         __cpuid(regs, 0x80000000);\n>         if (regs[0] < 0x80000007)\n>                 return false;\n> \n>         __cpuid(regs, 0x80000007);\n>         // if bit 8 is set than TSC will run at a constant rate\n>         // in all ACPI P-state, C-states and T-states\n>         return regs[4] & (1 << 8);\n> }\n> \n> It would be nice to use this to avoid the overhead of having to do both QPC\n> and GTC for ever TimeStamp::Now()\n\n\n\nI personally don't think this is useful for using QueryPerformanceCounter.  QPC function should do these checks for the programmer it self.  I don't think using RDTSC instruction directly is what we want to use at all and this code seems to be related only to direct use of that instruction.\n\nBut this is still worth to investigate on.", "author": "honzab.moz@firemni.cz", "creation_time": "2011-12-05T20:27:22Z"}, {"attachment_id": null, "raw_text": "Well, I suppose the question is whether Windows (XP, Vista, 7, 8) makes use of rdtsc if invariant TSC is available. If it does, then the calibration code can safely be disabled on processors that support invariant TSC - otherwise, I guess the code could fairly easily use rdtsc manually, but like you said we may not want that.", "id": 5893671, "creator": "emanuel.hoogeveen@protonmail.com", "is_private": false, "author": "emanuel.hoogeveen@protonmail.com", "creation_time": "2011-12-05T21:32:11Z", "tags": [], "time": "2011-12-05T21:32:11Z", "text": "Well, I suppose the question is whether Windows (XP, Vista, 7, 8) makes use of rdtsc if invariant TSC is available. If it does, then the calibration code can safely be disabled on processors that support invariant TSC - otherwise, I guess the code could fairly easily use rdtsc manually, but like you said we may not want that.", "count": 1, "bug_id": 707783}, {"bug_id": 707783, "count": 2, "text": "(In reply to Honza Bambas (:mayhemer) from comment #0)\n> Bug 676349 comment 56 (Jeff Muizelaar):\n> \n> > We should be able to use something like the following to detect situations\n> > where QPC is going to work reliably:\n> > \n> > #include <intrin.h>\n> > \n> > static bool\n> > has_stable_tsc()\n> > {\n> >         int regs[4];\n> > \n> >         // detect if the Advanced Power Management feature is supported\n> >         __cpuid(regs, 0x80000000);\n> >         if (regs[0] < 0x80000007)\n> >                 return false;\n> > \n> >         __cpuid(regs, 0x80000007);\n> >         // if bit 8 is set than TSC will run at a constant rate\n> >         // in all ACPI P-state, C-states and T-states\n> >         return regs[4] & (1 << 8);\n> > }\n> > \n> > It would be nice to use this to avoid the overhead of having to do both QPC\n> > and GTC for ever TimeStamp::Now()\n> \n> \n> \n> I personally don't think this is useful for using QueryPerformanceCounter. \n> QPC function should do these checks for the programmer it self.  I don't\n> think using RDTSC instruction directly is what we want to use at all and\n> this code seems to be related only to direct use of that instruction.\n> \n> But this is still worth to investigate on.\n\nQPC uses RDTSC on Windows 7. If we have a constant rate tsc then we now that we can trust the results of QPC (at least on a single processor machine) which should improve the TimeStamp::Now() performance closer to the other platforms for a large chunk of users.", "tags": [], "time": "2011-12-08T02:31:55Z", "creation_time": "2011-12-08T02:31:55Z", "author": "jmuizelaar@mozilla.com", "is_private": false, "creator": "jmuizelaar@mozilla.com", "id": 5899479, "raw_text": "(In reply to Honza Bambas (:mayhemer) from comment #0)\n> Bug 676349 comment 56 (Jeff Muizelaar):\n> \n> > We should be able to use something like the following to detect situations\n> > where QPC is going to work reliably:\n> > \n> > #include <intrin.h>\n> > \n> > static bool\n> > has_stable_tsc()\n> > {\n> >         int regs[4];\n> > \n> >         // detect if the Advanced Power Management feature is supported\n> >         __cpuid(regs, 0x80000000);\n> >         if (regs[0] < 0x80000007)\n> >                 return false;\n> > \n> >         __cpuid(regs, 0x80000007);\n> >         // if bit 8 is set than TSC will run at a constant rate\n> >         // in all ACPI P-state, C-states and T-states\n> >         return regs[4] & (1 << 8);\n> > }\n> > \n> > It would be nice to use this to avoid the overhead of having to do both QPC\n> > and GTC for ever TimeStamp::Now()\n> \n> \n> \n> I personally don't think this is useful for using QueryPerformanceCounter. \n> QPC function should do these checks for the programmer it self.  I don't\n> think using RDTSC instruction directly is what we want to use at all and\n> this code seems to be related only to direct use of that instruction.\n> \n> But this is still worth to investigate on.\n\nQPC uses RDTSC on Windows 7. If we have a constant rate tsc then we now that we can trust the results of QPC (at least on a single processor machine) which should improve the TimeStamp::Now() performance closer to the other platforms for a large chunk of users.", "attachment_id": null}, {"count": 3, "bug_id": 707783, "creator": "jmuizelaar@mozilla.com", "is_private": false, "author": "jmuizelaar@mozilla.com", "creation_time": "2012-01-12T16:38:25Z", "time": "2012-01-12T16:38:25Z", "tags": [], "text": "It looks like Intel machines with CONSTANT_TSC have a synchronized clock across all sockets:\n\nhttp://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=blob;f=arch/x86/kernel/tsc.c;h=c0dd5b603749057db73420caacc321d5d714338f;hb=HEAD#l822'", "attachment_id": null, "raw_text": "It looks like Intel machines with CONSTANT_TSC have a synchronized clock across all sockets:\n\nhttp://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=blob;f=arch/x86/kernel/tsc.c;h=c0dd5b603749057db73420caacc321d5d714338f;hb=HEAD#l822'", "id": 5975504}]}}, "comments": {}}