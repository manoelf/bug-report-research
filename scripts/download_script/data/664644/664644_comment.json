{"bugs": {"664644": {"comments": [{"id": 5535821, "count": 0, "is_private": false, "author": "bent.mozilla@gmail.com", "creation_time": "2011-06-16T02:20:03Z", "time": "2011-06-16T02:20:03Z", "creator": "bent.mozilla@gmail.com", "raw_text": "Our nsISupports macros log reference counts (which is great!) but we don't get automatic help for non-nsISupports classes. Those have to be added manually, and people easily forget. I'd like an analysis to ensure that every class and struct either a) implements nsISupports, or b) uses MOZ_COUNT_CTOR/DTOR. Then we can stop hunting phantom leaks (e.g. \"leaked 1 Mutex (ah geez, thanks!)\") and figure out what we're dealing with sooner.\n\nIs this possible? Complications that I'm missing?", "attachment_id": null, "tags": [], "bug_id": 664644, "text": "Our nsISupports macros log reference counts (which is great!) but we don't get automatic help for non-nsISupports classes. Those have to be added manually, and people easily forget. I'd like an analysis to ensure that every class and struct either a) implements nsISupports, or b) uses MOZ_COUNT_CTOR/DTOR. Then we can stop hunting phantom leaks (e.g. \"leaked 1 Mutex (ah geez, thanks!)\") and figure out what we're dealing with sooner.\n\nIs this possible? Complications that I'm missing?"}, {"author": "continuation@gmail.com", "creation_time": "2011-06-16T02:36:25Z", "time": "2011-06-16T02:36:25Z", "creator": "continuation@gmail.com", "id": 5535847, "count": 1, "is_private": false, "bug_id": 664644, "text": "Sounds simple enough, depending on how many weird exceptional cases there are (that is the main problem that makes analyzing cycle collector difficult).  What do you mean by \"implements nsISupports\"?  Is a subtype of nsISupports?  Has one of the NS_DECL_CYCLE_ISUPPORTS things in it?", "tags": [], "raw_text": "Sounds simple enough, depending on how many weird exceptional cases there are (that is the main problem that makes analyzing cycle collector difficult).  What do you mean by \"implements nsISupports\"?  Is a subtype of nsISupports?  Has one of the NS_DECL_CYCLE_ISUPPORTS things in it?", "attachment_id": null}, {"tags": [], "bug_id": 664644, "text": "(In reply to comment #1)\n> What do you mean by \"implements nsISupports\"?\n\nWell, it's technically the use of the NS_IMPL_ISUPPORTS_foo macros (the *implementation* macros, not the declaration macros) that logs the addref/release calls, not simply inheriting nsISupports. Most nsISupports classes use the macros, though, so I think it's useful to simply assume that inheriting nsISupports is sufficient.", "raw_text": "(In reply to comment #1)\n> What do you mean by \"implements nsISupports\"?\n\nWell, it's technically the use of the NS_IMPL_ISUPPORTS_foo macros (the *implementation* macros, not the declaration macros) that logs the addref/release calls, not simply inheriting nsISupports. Most nsISupports classes use the macros, though, so I think it's useful to simply assume that inheriting nsISupports is sufficient.", "attachment_id": null, "author": "bent.mozilla@gmail.com", "creator": "bent.mozilla@gmail.com", "time": "2011-06-16T02:53:23Z", "creation_time": "2011-06-16T02:53:23Z", "is_private": false, "id": 5535858, "count": 2}, {"creator": "continuation@gmail.com", "creation_time": "2011-06-16T18:29:18Z", "time": "2011-06-16T18:29:18Z", "author": "continuation@gmail.com", "is_private": false, "count": 3, "id": 5537194, "tags": [], "text": "I'm hacking on this a little.  I haven't done any analysis of function bodies before, but it doesn't seem too bad.  One issue I am having here is that classes can be visible (via headers), but their constructors (which are where the MOZ_COUNT_CTOR seems to be located) may be defined in another file.\n\nI can try checking to see if a class has a constructor.  If it doesn't, issue an error, because there's no way MOZ_COUNT_CTOR could be located in its constructor, then.  Otherwise, only complain about classes for which we can see the constructor body.\n\nAnother fun exception I had to add was filtering out classes declared in /usr/include/, as I assume those are never going to have MOZ_COUNT_CTOR given that they are outside of the Mozilla code base...", "bug_id": 664644, "attachment_id": null, "raw_text": "I'm hacking on this a little.  I haven't done any analysis of function bodies before, but it doesn't seem too bad.  One issue I am having here is that classes can be visible (via headers), but their constructors (which are where the MOZ_COUNT_CTOR seems to be located) may be defined in another file.\n\nI can try checking to see if a class has a constructor.  If it doesn't, issue an error, because there's no way MOZ_COUNT_CTOR could be located in its constructor, then.  Otherwise, only complain about classes for which we can see the constructor body.\n\nAnother fun exception I had to add was filtering out classes declared in /usr/include/, as I assume those are never going to have MOZ_COUNT_CTOR given that they are outside of the Mozilla code base..."}, {"creation_time": "2011-06-16T22:44:25Z", "time": "2011-06-16T22:44:25Z", "creator": "continuation@gmail.com", "author": "continuation@gmail.com", "id": 5538041, "count": 4, "is_private": false, "bug_id": 664644, "text": "Created attachment 539911\nlook for non-nsISupports classes that don't declare MOZ_COUNT_CTOR in their constructor\n\nThis script seems to work reasonably well at what you want.  You have to compile with DEBUG, or there's nothing for the script to detect for MOZ_COUNT_CTOR.  I'll upload an example of the output next.  Note that there are a huge number of (presumably false) positives.  There are a ton of classes that either don't have constructors or don't declare MOZ_COUNT_CTOR, including a huge number of string classes.  I'm not sure how to be more clever about accepting these, though perhaps the entire string directory could be whitelisted.", "tags": [], "attachment_id": 539911, "raw_text": "This script seems to work reasonably well at what you want.  You have to compile with DEBUG, or there's nothing for the script to detect for MOZ_COUNT_CTOR.  I'll upload an example of the output next.  Note that there are a huge number of (presumably false) positives.  There are a ton of classes that either don't have constructors or don't declare MOZ_COUNT_CTOR, including a huge number of string classes.  I'm not sure how to be more clever about accepting these, though perhaps the entire string directory could be whitelisted."}, {"author": "continuation@gmail.com", "creator": "continuation@gmail.com", "creation_time": "2011-06-16T22:46:34Z", "time": "2011-06-16T22:46:34Z", "is_private": false, "count": 5, "id": 5538049, "tags": [], "bug_id": 664644, "text": "Created attachment 539913\nthe result of running the script on xpcom/ds/nsHashtable.cpp\n\nThis is the result of running the script on xpcom/ds/nsHashtable.cpp.  It finds 177 problems, though each individual constructor is listed, so there are less classes than that that are problematic according to this analysis.  I looked at a few of these, and I didn't see any obvious way to prune them out.", "raw_text": "This is the result of running the script on xpcom/ds/nsHashtable.cpp.  It finds 177 problems, though each individual constructor is listed, so there are less classes than that that are problematic according to this analysis.  I looked at a few of these, and I didn't see any obvious way to prune them out.", "attachment_id": 539913}, {"tags": [], "text": "Hmmm...\n\nMost of these classes like nsTArrayFallibleAllocator and COMTypeInfo are never actually instantiated, they're just there to have static members/functions that can be called in templatey code... I'm betting that the analysis can't possibly know that, though, right? If not I guess we just need a big whitelist or some kind of code annotation.", "bug_id": 664644, "raw_text": "Hmmm...\n\nMost of these classes like nsTArrayFallibleAllocator and COMTypeInfo are never actually instantiated, they're just there to have static members/functions that can be called in templatey code... I'm betting that the analysis can't possibly know that, though, right? If not I guess we just need a big whitelist or some kind of code annotation.", "attachment_id": null, "author": "bent.mozilla@gmail.com", "time": "2011-06-17T17:05:40Z", "creation_time": "2011-06-17T17:05:40Z", "creator": "bent.mozilla@gmail.com", "id": 5539336, "count": 6, "is_private": false}, {"raw_text": "Suggestions:\n1. Anything declared as struct Foo or union Foo shouldn't be considered necessary for refcounting\n2. If a type isn't used as a pointer, it should be unnecessary\n3. NS_STACK_CLASS should almost certainly be excluded.", "attachment_id": null, "tags": [], "text": "Suggestions:\n1. Anything declared as struct Foo or union Foo shouldn't be considered necessary for refcounting\n2. If a type isn't used as a pointer, it should be unnecessary\n3. NS_STACK_CLASS should almost certainly be excluded.", "bug_id": 664644, "id": 5539362, "count": 7, "is_private": false, "author": "Pidgeot18@gmail.com", "time": "2011-06-17T17:13:02Z", "creation_time": "2011-06-17T17:13:02Z", "creator": "Pidgeot18@gmail.com"}, {"is_private": false, "count": 8, "id": 5539368, "creator": "bent.mozilla@gmail.com", "creation_time": "2011-06-17T17:15:10Z", "time": "2011-06-17T17:15:10Z", "author": "bent.mozilla@gmail.com", "attachment_id": null, "raw_text": "(In reply to comment #7)\n> 1. Anything declared as struct Foo\n\nWhy not? People can use struct/class interchangeably.", "bug_id": 664644, "text": "(In reply to comment #7)\n> 1. Anything declared as struct Foo\n\nWhy not? People can use struct/class interchangeably.", "tags": []}, {"is_private": false, "count": 9, "id": 5539376, "author": "Pidgeot18@gmail.com", "creator": "Pidgeot18@gmail.com", "creation_time": "2011-06-17T17:19:39Z", "time": "2011-06-17T17:19:39Z", "raw_text": "(In reply to comment #8)\n> (In reply to comment #7)\n> > 1. Anything declared as struct Foo\n> \n> Why not? People can use struct/class interchangeably.\n\nSure, but most instances of \"struct\" are (probably) people just bundling data together for passing as a void* to a callback. I think the number of valid cases being masked by this rule is going to be very low, and it will effectively whitelist a very large portion of cases where it doesn't matter.", "attachment_id": null, "tags": [], "bug_id": 664644, "text": "(In reply to comment #8)\n> (In reply to comment #7)\n> > 1. Anything declared as struct Foo\n> \n> Why not? People can use struct/class interchangeably.\n\nSure, but most instances of \"struct\" are (probably) people just bundling data together for passing as a void* to a callback. I think the number of valid cases being masked by this rule is going to be very low, and it will effectively whitelist a very large portion of cases where it doesn't matter."}, {"author": "continuation@gmail.com", "creation_time": "2011-06-17T17:30:32Z", "time": "2011-06-17T17:30:32Z", "creator": "continuation@gmail.com", "id": 5539409, "count": 10, "is_private": false, "bug_id": 664644, "text": "Another thing I should add is excluding any class that contains a pure virtual method, as they cannot be instantiated.\n\nI'm already excluding unions.  Good point about NS_STACK_CLASS.  I don't know what that actually is implemented as, but I can look into it.\n\nThings like \"never used as a pointer\" and \"never instantiated\" can be checked, but that would basically be a new analysis.\n\nIs there any way to statically enforce that a class should never be instantiated that doesn't have any runtime overhead (like pure virtual methods)?  Maybe something like a protected constructor?  I could check that for a class there is at least one constructor, but no public ones.", "tags": [], "raw_text": "Another thing I should add is excluding any class that contains a pure virtual method, as they cannot be instantiated.\n\nI'm already excluding unions.  Good point about NS_STACK_CLASS.  I don't know what that actually is implemented as, but I can look into it.\n\nThings like \"never used as a pointer\" and \"never instantiated\" can be checked, but that would basically be a new analysis.\n\nIs there any way to statically enforce that a class should never be instantiated that doesn't have any runtime overhead (like pure virtual methods)?  Maybe something like a protected constructor?  I could check that for a class there is at least one constructor, but no public ones.", "attachment_id": null}, {"author": "benjamin@smedbergs.us", "creator": "benjamin@smedbergs.us", "time": "2011-06-17T17:56:13Z", "creation_time": "2011-06-17T17:56:13Z", "is_private": false, "id": 5539494, "count": 11, "tags": [], "bug_id": 664644, "text": "NS_STACK_CLASS is implemented in dehydra via this analysis: http://mxr.mozilla.org/mozilla-central/source/xpcom/analysis/stack.js", "raw_text": "NS_STACK_CLASS is implemented in dehydra via this analysis: http://mxr.mozilla.org/mozilla-central/source/xpcom/analysis/stack.js", "attachment_id": null}]}}, "comments": {}}