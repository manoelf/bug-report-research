{"bugs": {"650585": {"comments": [{"id": 5414238, "author": "ehsan.akhgari@gmail.com", "is_private": false, "bug_id": 650585, "creation_time": "2011-04-17T04:32:58Z", "tags": [], "attachment_id": null, "time": "2011-04-17T04:32:58Z", "count": 0, "text": "In preparation for bug 649012, I'm removing all of the flaky setTimeout's from the accessibility tests.", "raw_text": "In preparation for bug 649012, I'm removing all of the flaky setTimeout's from the accessibility tests.", "creator": "ehsan.akhgari@gmail.com"}, {"creation_time": "2011-04-17T04:33:55Z", "tags": [], "attachment_id": 526555, "bug_id": 650585, "author": "ehsan.akhgari@gmail.com", "is_private": false, "id": 5414239, "raw_text": "", "creator": "ehsan.akhgari@gmail.com", "text": "Created attachment 526555\nPatch (v1)", "time": "2011-04-17T04:33:55Z", "count": 1}, {"raw_text": "\n>       menu1.open = true;\n> \n>-      window.setTimeout(function() {\n>+      menu1.addEventListener(\"popupshown\", function() {\n>         var menu2 = document.getElementById(\"menu_item2\");\n>         menu2.open = true;\n> \n>-        window.setTimeout(function() {\n>+        menu2.addEventListener(\"popupshown\", function() {\n>           testGroupAttrs(\"menu_item1.1\", 1, 1);\n>           testGroupAttrs(\"menu_item1.2\", 1, 3);\n>           testGroupAttrs(\"menu_item1.4\", 2, 3);\n>           testGroupAttrs(\"menu_item2\", 3, 3);\n>           testGroupAttrs(\"menu_item2.1\", 1, 2, 1);\n>           testGroupAttrs(\"menu_item2.2\", 2, 2, 1);\n> \n>+          menu1.open = false;\n>+          menu2.open = false;\n>+\n\njust curious, why you need to close them?\n\n>+++ b/accessible/tests/mochitest/common.js\n\n>         if (state.value & STATE_BUSY)\n>           return waitForDocLoad();\n> \n>-        window.setTimeout(aFunc, 150);\n>+        window.setTimeout(aFunc, 0);\n\nnice, I wanted to do that for times :)\n\n>+++ b/accessible/tests/mochitest/events.js\n>@@ -299,17 +299,17 @@ function eventQueue(aEventType)\n>     if (!aUncondProcess && this.areAllEventsExpected()) {\n>       // We need delay to avoid events coalesce from different invokers.\n>       var queue = this;\n>       SimpleTest.executeSoon(function() { queue.processNextInvoker(); });\n>       return;\n>     }\n> \n>     // Check in timeout invoker didn't fire registered events.\n>-    window.setTimeout(function(aQueue) { aQueue.processNextInvoker(); }, 500,\n>+    window.setTimeout(function(aQueue) { aQueue.processNextInvoker(); }, 0,\n>                       this);\n\nnope, we need non zero timeout to ensure there's no unexpected events, zero timeout doesn't always work.\n\n\n>-      // SimpleTest.executeSoon() doesn't help here: use setTimeout() with a little delay.\n>-      setTimeout(test_txc7, 25);\n>+      setTimeout(test_txc7, 0);\n\niirc, 0 timeout resulted in random failures, ideally this test should be changed to use accessible events instead timeouts.\n\nr=me with events.js timeout fixed.", "creator": "surkov.alexander@gmail.com", "text": "Comment on attachment 526555\nPatch (v1)\n\n\n>       menu1.open = true;\n> \n>-      window.setTimeout(function() {\n>+      menu1.addEventListener(\"popupshown\", function() {\n>         var menu2 = document.getElementById(\"menu_item2\");\n>         menu2.open = true;\n> \n>-        window.setTimeout(function() {\n>+        menu2.addEventListener(\"popupshown\", function() {\n>           testGroupAttrs(\"menu_item1.1\", 1, 1);\n>           testGroupAttrs(\"menu_item1.2\", 1, 3);\n>           testGroupAttrs(\"menu_item1.4\", 2, 3);\n>           testGroupAttrs(\"menu_item2\", 3, 3);\n>           testGroupAttrs(\"menu_item2.1\", 1, 2, 1);\n>           testGroupAttrs(\"menu_item2.2\", 2, 2, 1);\n> \n>+          menu1.open = false;\n>+          menu2.open = false;\n>+\n\njust curious, why you need to close them?\n\n>+++ b/accessible/tests/mochitest/common.js\n\n>         if (state.value & STATE_BUSY)\n>           return waitForDocLoad();\n> \n>-        window.setTimeout(aFunc, 150);\n>+        window.setTimeout(aFunc, 0);\n\nnice, I wanted to do that for times :)\n\n>+++ b/accessible/tests/mochitest/events.js\n>@@ -299,17 +299,17 @@ function eventQueue(aEventType)\n>     if (!aUncondProcess && this.areAllEventsExpected()) {\n>       // We need delay to avoid events coalesce from different invokers.\n>       var queue = this;\n>       SimpleTest.executeSoon(function() { queue.processNextInvoker(); });\n>       return;\n>     }\n> \n>     // Check in timeout invoker didn't fire registered events.\n>-    window.setTimeout(function(aQueue) { aQueue.processNextInvoker(); }, 500,\n>+    window.setTimeout(function(aQueue) { aQueue.processNextInvoker(); }, 0,\n>                       this);\n\nnope, we need non zero timeout to ensure there's no unexpected events, zero timeout doesn't always work.\n\n\n>-      // SimpleTest.executeSoon() doesn't help here: use setTimeout() with a little delay.\n>-      setTimeout(test_txc7, 25);\n>+      setTimeout(test_txc7, 0);\n\niirc, 0 timeout resulted in random failures, ideally this test should be changed to use accessible events instead timeouts.\n\nr=me with events.js timeout fixed.", "time": "2011-04-18T12:56:01Z", "count": 2, "tags": [], "creation_time": "2011-04-18T12:56:01Z", "attachment_id": 526555, "bug_id": 650585, "is_private": false, "author": "surkov.alexander@gmail.com", "id": 5415480}, {"id": 5415650, "is_private": false, "count": 3, "time": "2011-04-18T14:43:51Z", "author": "ehsan.akhgari@gmail.com", "bug_id": 650585, "text": "(In reply to comment #2)\n> Comment on attachment 526555 [details]\n> Patch (v1)\n> \n> \n> >       menu1.open = true;\n> > \n> >-      window.setTimeout(function() {\n> >+      menu1.addEventListener(\"popupshown\", function() {\n> >         var menu2 = document.getElementById(\"menu_item2\");\n> >         menu2.open = true;\n> > \n> >-        window.setTimeout(function() {\n> >+        menu2.addEventListener(\"popupshown\", function() {\n> >           testGroupAttrs(\"menu_item1.1\", 1, 1);\n> >           testGroupAttrs(\"menu_item1.2\", 1, 3);\n> >           testGroupAttrs(\"menu_item1.4\", 2, 3);\n> >           testGroupAttrs(\"menu_item2\", 3, 3);\n> >           testGroupAttrs(\"menu_item2.1\", 1, 2, 1);\n> >           testGroupAttrs(\"menu_item2.2\", 2, 2, 1);\n> > \n> >+          menu1.open = false;\n> >+          menu2.open = false;\n> >+\n> \n> just curious, why you need to close them?\n\nNo special reason, seemed cleaner this way.\n\n> >+++ b/accessible/tests/mochitest/events.js\n> >@@ -299,17 +299,17 @@ function eventQueue(aEventType)\n> >     if (!aUncondProcess && this.areAllEventsExpected()) {\n> >       // We need delay to avoid events coalesce from different invokers.\n> >       var queue = this;\n> >       SimpleTest.executeSoon(function() { queue.processNextInvoker(); });\n> >       return;\n> >     }\n> > \n> >     // Check in timeout invoker didn't fire registered events.\n> >-    window.setTimeout(function(aQueue) { aQueue.processNextInvoker(); }, 500,\n> >+    window.setTimeout(function(aQueue) { aQueue.processNextInvoker(); }, 0,\n> >                       this);\n> \n> nope, we need non zero timeout to ensure there's no unexpected events, zero\n> timeout doesn't always work.\n\nHow do accessibility events work?  Are they handled off of the usual event queue?  If yes, then we should just be able to hit the event queue a few times to make sure that such unexpected events do not happen.\n\nIn general, waiting a magical number of milliseconds to see that something does not occur in the event queue is a bad idea.\n\n> >-      // SimpleTest.executeSoon() doesn't help here: use setTimeout() with a little delay.\n> >-      setTimeout(test_txc7, 25);\n> >+      setTimeout(test_txc7, 0);\n> \n> iirc, 0 timeout resulted in random failures, ideally this test should be\n> changed to use accessible events instead timeouts.\n\nIf using a timeout used to result in random failures, using a larger timeout will also result in a similar random failure, just less frequently.\n\nIf this is a concern, the test should be rewritten as you suggest, but I don't know how it's supposed to work, so I don't think that I can do that myself.", "attachment_id": null, "tags": [], "creation_time": "2011-04-18T14:43:51Z", "creator": "ehsan.akhgari@gmail.com", "raw_text": "(In reply to comment #2)\n> Comment on attachment 526555 [details]\n> Patch (v1)\n> \n> \n> >       menu1.open = true;\n> > \n> >-      window.setTimeout(function() {\n> >+      menu1.addEventListener(\"popupshown\", function() {\n> >         var menu2 = document.getElementById(\"menu_item2\");\n> >         menu2.open = true;\n> > \n> >-        window.setTimeout(function() {\n> >+        menu2.addEventListener(\"popupshown\", function() {\n> >           testGroupAttrs(\"menu_item1.1\", 1, 1);\n> >           testGroupAttrs(\"menu_item1.2\", 1, 3);\n> >           testGroupAttrs(\"menu_item1.4\", 2, 3);\n> >           testGroupAttrs(\"menu_item2\", 3, 3);\n> >           testGroupAttrs(\"menu_item2.1\", 1, 2, 1);\n> >           testGroupAttrs(\"menu_item2.2\", 2, 2, 1);\n> > \n> >+          menu1.open = false;\n> >+          menu2.open = false;\n> >+\n> \n> just curious, why you need to close them?\n\nNo special reason, seemed cleaner this way.\n\n> >+++ b/accessible/tests/mochitest/events.js\n> >@@ -299,17 +299,17 @@ function eventQueue(aEventType)\n> >     if (!aUncondProcess && this.areAllEventsExpected()) {\n> >       // We need delay to avoid events coalesce from different invokers.\n> >       var queue = this;\n> >       SimpleTest.executeSoon(function() { queue.processNextInvoker(); });\n> >       return;\n> >     }\n> > \n> >     // Check in timeout invoker didn't fire registered events.\n> >-    window.setTimeout(function(aQueue) { aQueue.processNextInvoker(); }, 500,\n> >+    window.setTimeout(function(aQueue) { aQueue.processNextInvoker(); }, 0,\n> >                       this);\n> \n> nope, we need non zero timeout to ensure there's no unexpected events, zero\n> timeout doesn't always work.\n\nHow do accessibility events work?  Are they handled off of the usual event queue?  If yes, then we should just be able to hit the event queue a few times to make sure that such unexpected events do not happen.\n\nIn general, waiting a magical number of milliseconds to see that something does not occur in the event queue is a bad idea.\n\n> >-      // SimpleTest.executeSoon() doesn't help here: use setTimeout() with a little delay.\n> >-      setTimeout(test_txc7, 25);\n> >+      setTimeout(test_txc7, 0);\n> \n> iirc, 0 timeout resulted in random failures, ideally this test should be\n> changed to use accessible events instead timeouts.\n\nIf using a timeout used to result in random failures, using a larger timeout will also result in a similar random failure, just less frequently.\n\nIf this is a concern, the test should be rewritten as you suggest, but I don't know how it's supposed to work, so I don't think that I can do that myself."}, {"author": "surkov.alexander@gmail.com", "is_private": false, "id": 5417650, "creation_time": "2011-04-19T02:53:06Z", "tags": [], "attachment_id": null, "bug_id": 650585, "time": "2011-04-19T02:53:06Z", "count": 4, "raw_text": "(In reply to comment #3)\n\n> How do accessibility events work?  Are they handled off of the usual event\n> queue?\n\nusually a11y events are fired when refresh driver triggers us. So it may happen after zero timeout.\n\n>  If yes, then we should just be able to hit the event queue a few times\n> to make sure that such unexpected events do not happen.\n\nI don't get technical side.\n\n> In general, waiting a magical number of milliseconds to see that something does\n> not occur in the event queue is a bad idea.\n\nnot nice, and doesn't us guarantee that it works 100%. Anything in replacement?\n\n> If this is a concern, the test should be rewritten as you suggest, but I don't\n> know how it's supposed to work, so I don't think that I can do that myself.\n\nI'll try to come with something.", "creator": "surkov.alexander@gmail.com", "text": "(In reply to comment #3)\n\n> How do accessibility events work?  Are they handled off of the usual event\n> queue?\n\nusually a11y events are fired when refresh driver triggers us. So it may happen after zero timeout.\n\n>  If yes, then we should just be able to hit the event queue a few times\n> to make sure that such unexpected events do not happen.\n\nI don't get technical side.\n\n> In general, waiting a magical number of milliseconds to see that something does\n> not occur in the event queue is a bad idea.\n\nnot nice, and doesn't us guarantee that it works 100%. Anything in replacement?\n\n> If this is a concern, the test should be rewritten as you suggest, but I don't\n> know how it's supposed to work, so I don't think that I can do that myself.\n\nI'll try to come with something."}, {"id": 5417750, "count": 5, "time": "2011-04-19T04:03:04Z", "author": "ehsan.akhgari@gmail.com", "is_private": false, "text": "The refresh driver is run off of the OS event queue, which basically the main point of entry to Firefox from the OS once there is a window open.\n\nsetTimeout(f, 0) will post an event to this queue, which is triggered at least 4ms after the call, so I think if accessibility events are raised off of the refresh driver, then setTimeout(f, 0) should be enough to make sure that they're fired (since the refresh driver gets a chance to run *at least* once before \"f\" is executed.\n\nTo support this idea, I've pushed this patch to the try server, and the mochitest-a11y suite has been green...", "bug_id": 650585, "creator": "ehsan.akhgari@gmail.com", "raw_text": "The refresh driver is run off of the OS event queue, which basically the main point of entry to Firefox from the OS once there is a window open.\n\nsetTimeout(f, 0) will post an event to this queue, which is triggered at least 4ms after the call, so I think if accessibility events are raised off of the refresh driver, then setTimeout(f, 0) should be enough to make sure that they're fired (since the refresh driver gets a chance to run *at least* once before \"f\" is executed.\n\nTo support this idea, I've pushed this patch to the try server, and the mochitest-a11y suite has been green...", "attachment_id": null, "tags": [], "creation_time": "2011-04-19T04:03:04Z"}, {"attachment_id": 535034, "creation_time": "2011-05-25T11:43:31Z", "tags": [], "bug_id": 650585, "is_private": false, "author": "surkov.alexander@gmail.com", "id": 5491942, "creator": "surkov.alexander@gmail.com", "raw_text": "1) I fixed test_txtctrl.xul to not use setTimeout\n\n2) Get back 500 ms timeout for waiting to make sure there's no event.\n\nI'm not sure how to change it. Also I wouldn't go with 0 timeout since I think it may not cover some cases we need to care about. The case I try to handle here is the same a11y event can be fired on different notifications from gecko (for example, a11y focus event can be fired on DOM focus event or RadioStateChange event). Gecko can call into a11y from various places, depending on accessible tree state, these notifications may be deferred (or processed immediately), after processing a11y events may be deferred or fired immediately. The logic is not clear is some parts are really messy. Therefore I don't want to change to 0 timeout.", "text": "Created attachment 535034\npatch v2\n\n1) I fixed test_txtctrl.xul to not use setTimeout\n\n2) Get back 500 ms timeout for waiting to make sure there's no event.\n\nI'm not sure how to change it. Also I wouldn't go with 0 timeout since I think it may not cover some cases we need to care about. The case I try to handle here is the same a11y event can be fired on different notifications from gecko (for example, a11y focus event can be fired on DOM focus event or RadioStateChange event). Gecko can call into a11y from various places, depending on accessible tree state, these notifications may be deferred (or processed immediately), after processing a11y events may be deferred or fired immediately. The logic is not clear is some parts are really messy. Therefore I don't want to change to 0 timeout.", "count": 6, "time": "2011-05-25T11:43:31Z"}, {"text": "(In reply to comment #6)\n> 2) Get back 500 ms timeout for waiting to make sure there's no event.\n> \n> I'm not sure how to change it. Also I wouldn't go with 0 timeout since I\n> think it may not cover some cases we need to care about. The case I try to\n> handle here is the same a11y event can be fired on different notifications\n> from gecko (for example, a11y focus event can be fired on DOM focus event or\n> RadioStateChange event). Gecko can call into a11y from various places,\n> depending on accessible tree state, these notifications may be deferred (or\n> processed immediately), after processing a11y events may be deferred or\n> fired immediately. The logic is not clear is some parts are really messy.\n> Therefore I don't want to change to 0 timeout.\n\nWhat if we hit the event loop a number of times, let's say, 100 times?  Does that sound like a way to deal with this problem?", "bug_id": 650585, "creator": "ehsan.akhgari@gmail.com", "raw_text": "(In reply to comment #6)\n> 2) Get back 500 ms timeout for waiting to make sure there's no event.\n> \n> I'm not sure how to change it. Also I wouldn't go with 0 timeout since I\n> think it may not cover some cases we need to care about. The case I try to\n> handle here is the same a11y event can be fired on different notifications\n> from gecko (for example, a11y focus event can be fired on DOM focus event or\n> RadioStateChange event). Gecko can call into a11y from various places,\n> depending on accessible tree state, these notifications may be deferred (or\n> processed immediately), after processing a11y events may be deferred or\n> fired immediately. The logic is not clear is some parts are really messy.\n> Therefore I don't want to change to 0 timeout.\n\nWhat if we hit the event loop a number of times, let's say, 100 times?  Does that sound like a way to deal with this problem?", "attachment_id": null, "tags": [], "creation_time": "2011-05-26T19:49:18Z", "id": 5495953, "count": 7, "author": "ehsan.akhgari@gmail.com", "time": "2011-05-26T19:49:18Z", "is_private": false}, {"count": 8, "time": "2011-05-27T03:02:43Z", "text": "(In reply to comment #7)\n\n> What if we hit the event loop a number of times, let's say, 100 times?  Does\n> that sound like a way to deal with this problem?\n\nIt's a problem, theoretically, but that doesn't happen currently, no helper function that can add some unexpected events unexplicitly. If you feel like that's quite necessary then the check can be added to make sure the number of unexpected events doesn't exceed the certain limit.", "creator": "surkov.alexander@gmail.com", "raw_text": "(In reply to comment #7)\n\n> What if we hit the event loop a number of times, let's say, 100 times?  Does\n> that sound like a way to deal with this problem?\n\nIt's a problem, theoretically, but that doesn't happen currently, no helper function that can add some unexpected events unexplicitly. If you feel like that's quite necessary then the check can be added to make sure the number of unexpected events doesn't exceed the certain limit.", "id": 5496868, "author": "surkov.alexander@gmail.com", "is_private": false, "bug_id": 650585, "attachment_id": null, "creation_time": "2011-05-27T03:02:43Z", "tags": []}, {"text": "I landed what we have - http://hg.mozilla.org/mozilla-central/rev/bbceb00866f0\n\nlet's figure out what we can do with 500ms timeout for unexpected events check.", "raw_text": "I landed what we have - http://hg.mozilla.org/mozilla-central/rev/bbceb00866f0\n\nlet's figure out what we can do with 500ms timeout for unexpected events check.", "creator": "surkov.alexander@gmail.com", "time": "2011-05-27T03:45:49Z", "count": 9, "bug_id": 650585, "tags": [], "creation_time": "2011-05-27T03:45:49Z", "attachment_id": null, "id": 5496928, "is_private": false, "author": "surkov.alexander@gmail.com"}, {"count": 10, "time": "2011-05-27T14:40:29Z", "text": "(In reply to comment #8)\n> (In reply to comment #7)\n> \n> > What if we hit the event loop a number of times, let's say, 100 times?  Does\n> > that sound like a way to deal with this problem?\n> \n> It's a problem, theoretically, but that doesn't happen currently, no helper\n> function that can add some unexpected events unexplicitly. If you feel like\n> that's quite necessary then the check can be added to make sure the number\n> of unexpected events doesn't exceed the certain limit.\n\nOh, no, that's not what I meant.  You have an event and you want to make sure that it doesn't happen, right?  So, what if you install an event handler, and do something like |ok(false, \"Should not have happened\");| inside it.  Then, in order to give the event a chance to be fired (if something is broken for example), you spin the event loop 100 times.  If there's a bug which causes the event to be fired, the event handler you've installed would get called, and the test would fail.  Otherwise, you can be relatively sure that the event doesn't get fired, and everything is OK.\n\nWe use this technique in a bunch of places in our tests for making sure an event does not happen.  See <http://mxr.mozilla.org/mozilla-central/source/editor/libeditor/text/tests/test_bug527935.html?force=1#64> for an example.", "creator": "ehsan.akhgari@gmail.com", "raw_text": "(In reply to comment #8)\n> (In reply to comment #7)\n> \n> > What if we hit the event loop a number of times, let's say, 100 times?  Does\n> > that sound like a way to deal with this problem?\n> \n> It's a problem, theoretically, but that doesn't happen currently, no helper\n> function that can add some unexpected events unexplicitly. If you feel like\n> that's quite necessary then the check can be added to make sure the number\n> of unexpected events doesn't exceed the certain limit.\n\nOh, no, that's not what I meant.  You have an event and you want to make sure that it doesn't happen, right?  So, what if you install an event handler, and do something like |ok(false, \"Should not have happened\");| inside it.  Then, in order to give the event a chance to be fired (if something is broken for example), you spin the event loop 100 times.  If there's a bug which causes the event to be fired, the event handler you've installed would get called, and the test would fail.  Otherwise, you can be relatively sure that the event doesn't get fired, and everything is OK.\n\nWe use this technique in a bunch of places in our tests for making sure an event does not happen.  See <http://mxr.mozilla.org/mozilla-central/source/editor/libeditor/text/tests/test_bug527935.html?force=1#64> for an example.", "id": 5497757, "is_private": false, "author": "ehsan.akhgari@gmail.com", "bug_id": 650585, "attachment_id": null, "tags": [], "creation_time": "2011-05-27T14:40:29Z"}, {"attachment_id": null, "tags": [], "creation_time": "2014-05-14T18:50:34Z", "bug_id": 650585, "author": "surkov.alexander@gmail.com", "is_private": false, "id": 8793582, "creator": "surkov.alexander@gmail.com", "raw_text": "(missed your answer, thanks davidb for pointing out, needinfo usually works better than summary change:) ) What do you mean by event loop 100 times? I can see setTimeout in test you gave as example, basically that's what we do, no?", "text": "(missed your answer, thanks davidb for pointing out, needinfo usually works better than summary change:) ) What do you mean by event loop 100 times? I can see setTimeout in test you gave as example, basically that's what we do, no?", "count": 11, "time": "2014-05-14T18:50:34Z"}, {"id": 8799030, "count": 12, "time": "2014-05-15T19:51:51Z", "author": "ehsan.akhgari@gmail.com", "is_private": false, "text": "Sorry, I've paged this bug out of my memory, and won't be updating the patch myself...  I'll be happy to try to page this stuff back in once someone starts owning bug 649012.  Clearing the ni? until then.", "bug_id": 650585, "creator": "ehsan.akhgari@gmail.com", "raw_text": "Sorry, I've paged this bug out of my memory, and won't be updating the patch myself...  I'll be happy to try to page this stuff back in once someone starts owning bug 649012.  Clearing the ni? until then.", "attachment_id": null, "tags": [], "creation_time": "2014-05-15T19:51:51Z"}, {"raw_text": "No assignee, updating the status.", "creator": "sledru@mozilla.com", "creation_time": "2018-10-15T08:37:07Z", "tags": [], "attachment_id": null, "text": "No assignee, updating the status.", "bug_id": 650585, "time": "2018-10-15T08:37:07Z", "author": "sledru@mozilla.com", "count": 13, "is_private": false, "id": 13685295}, {"bug_id": 650585, "text": "No assignee, updating the status.", "attachment_id": null, "tags": [], "creation_time": "2018-10-15T08:44:19Z", "creator": "sledru@mozilla.com", "raw_text": "No assignee, updating the status.", "id": 13686196, "is_private": false, "count": 14, "author": "sledru@mozilla.com", "time": "2018-10-15T08:44:19Z"}, {"id": 14627044, "is_private": false, "count": 15, "author": "eitan@monotonous.org", "time": "2020-02-06T18:16:12Z", "bug_id": 650585, "text": "We mostly moved away from timeouts except for the unexpected event tests. So this bug should really be about that.\n\nhttps://searchfox.org/mozilla-central/rev/3811b11b5773c1dccfe8228bfc7143b10a9a2a99/accessible/tests/mochitest/events.js#519", "attachment_id": null, "creation_time": "2020-02-06T18:16:12Z", "tags": [], "creator": "eitan@monotonous.org", "raw_text": "We mostly moved away from timeouts except for the unexpected event tests. So this bug should really be about that.\n\nhttps://searchfox.org/mozilla-central/rev/3811b11b5773c1dccfe8228bfc7143b10a9a2a99/accessible/tests/mochitest/events.js#519"}]}}, "comments": {}}