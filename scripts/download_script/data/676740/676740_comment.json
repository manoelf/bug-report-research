{"comments": {}, "bugs": {"676740": {"comments": [{"raw_text": "If an X(HT)ML file includes a document-internal Processing Instruction to a style element in the head; as recommended per http://www.w3.org/TR/2002/REC-xhtml1-20020801/#C_14\n\nE.g.\n<?xml-stylesheet href=\"#example\" media=\"all\" type=\"text/css\"?>\n\nThis will trigger a new HTTP request for the original resource.\n\nThe content of style element (with the id \"example\" in this case) of the current page should be what was referenced; and in any case it should not result in another HTTP request.\n\nI've tested recent releases of Chrome, Opera and Safari; they do not do this.\nI'm fed up testing Internet Explorer for bugs; I don't know or care how it behaves.\n\nIt is highly unlikely to be a security issue; but, technically, it could be. When the file is requested, the HTTP Accept header requests the original resource with the media type text/css; for most resources, this would never happen. This at least leaks information about the browser which could improve web-tracking - such as during Safe Browsing - and Content-Negotiation could be used to supply different content to a Firefox browser specifically.\n\nBecause Firefox processes the document style element regardless of the processing instruction, the style in the page will still be applied no matter what happens with the request (assuming that the style element in question actually exists). However, Firefox will nevertheless process the returned file, and if it is CSS, it will be applied against the page like any other CSS resource - even if the CSS is different from the contents of the style element. Furthermore, because the new request is for the same URL as the page itself, whatever the returned document is will replace the original document in the cache; so, for example, view-source for the page will show the result of the request for the CSS document, and not the page; and when you go offline and refresh the page, you see the result of the request for the CSS document, instead of the page, etc.", "attachment_id": null, "tags": [], "bug_id": 676740, "text": "If an X(HT)ML file includes a document-internal Processing Instruction to a style element in the head; as recommended per http://www.w3.org/TR/2002/REC-xhtml1-20020801/#C_14\n\nE.g.\n<?xml-stylesheet href=\"#example\" media=\"all\" type=\"text/css\"?>\n\nThis will trigger a new HTTP request for the original resource.\n\nThe content of style element (with the id \"example\" in this case) of the current page should be what was referenced; and in any case it should not result in another HTTP request.\n\nI've tested recent releases of Chrome, Opera and Safari; they do not do this.\nI'm fed up testing Internet Explorer for bugs; I don't know or care how it behaves.\n\nIt is highly unlikely to be a security issue; but, technically, it could be. When the file is requested, the HTTP Accept header requests the original resource with the media type text/css; for most resources, this would never happen. This at least leaks information about the browser which could improve web-tracking - such as during Safe Browsing - and Content-Negotiation could be used to supply different content to a Firefox browser specifically.\n\nBecause Firefox processes the document style element regardless of the processing instruction, the style in the page will still be applied no matter what happens with the request (assuming that the style element in question actually exists). However, Firefox will nevertheless process the returned file, and if it is CSS, it will be applied against the page like any other CSS resource - even if the CSS is different from the contents of the style element. Furthermore, because the new request is for the same URL as the page itself, whatever the returned document is will replace the original document in the cache; so, for example, view-source for the page will show the result of the request for the CSS document, and not the page; and when you go offline and refresh the page, you see the result of the request for the CSS document, instead of the page, etc.", "id": 5634993, "count": 0, "is_private": false, "author": "theimp@iinet.net.au", "time": "2011-08-05T02:23:32Z", "creation_time": "2011-08-05T02:23:32Z", "creator": "theimp@iinet.net.au"}, {"raw_text": "Assuming the page is served as text/xml or some such, isn't making\na new request asking for text/css the correct behavior?", "attachment_id": null, "tags": [], "bug_id": 676740, "text": "Assuming the page is served as text/xml or some such, isn't making\na new request asking for text/css the correct behavior?", "count": 1, "id": 5635777, "is_private": false, "author": "MatsPalmgren_bugz@use.startmail.com", "time": "2011-08-05T14:45:36Z", "creation_time": "2011-08-05T14:45:36Z", "creator": "MatsPalmgren_bugz@use.startmail.com"}, {"author": "bzbarsky@mit.edu", "creation_time": "2011-08-05T15:02:12Z", "time": "2011-08-05T15:02:12Z", "creator": "bzbarsky@mit.edu", "count": 2, "id": 5635804, "is_private": false, "tags": [], "text": "That use of fragment identifiers in xml-stylesheet is a fiction.  No UA actually does that.\n\n  <?xml-stylesheet href=\"#internalStyle\" type=\"text/css\"?>\n\nMeans \"load base URL and treat it all as a stylesheet\".  Which is what we do.  And yes, C.14 is just wrong.", "bug_id": 676740, "raw_text": "That use of fragment identifiers in xml-stylesheet is a fiction.  No UA actually does that.\n\n  <?xml-stylesheet href=\"#internalStyle\" type=\"text/css\"?>\n\nMeans \"load base URL and treat it all as a stylesheet\".  Which is what we do.  And yes, C.14 is just wrong.", "attachment_id": null}, {"is_private": false, "id": 5637230, "count": 3, "author": "theimp@iinet.net.au", "creator": "theimp@iinet.net.au", "creation_time": "2011-08-06T02:05:51Z", "time": "2011-08-06T02:05:51Z", "raw_text": "But should it result in another HTTP request?\n\nRFC3986 (4.4)\nsays that:\n\n   When a same-document reference is dereferenced for a retrieval\n   action, the target of that reference is defined to be within the same\n   entity (representation, document, or message) as the reference;\n   therefore, a dereference should not result in a new retrieval action.\n\nEven if the Content-Type is considered a new representation, if the Vary: Accept header is not sent on the original, shouldn't Firefox pull it from the cache? Or does Firefox cache only by URI (and if so, should it)?\n\n> That use of fragment identifiers in xml-stylesheet is a fiction.\n\nSection C of XHTML spec. is informative, but Section 4 of\nAssociating Style Sheets with XML documents 1.0 Recommendation\nis normative and says the same thing.\n\n> Means \"load base URL and treat it all as a stylesheet\".\n\nMaybe load, but not request from the network.\n\nBecause Firefox already processes the stylesheet within the document (because it's in the style element and Firefox processes those specially), it has satisfied the \"pass through to the application\" part and should then ignore the processing instruction to stop messing things up.\n\nBesides, it's actually impossible for the server to handle this case in general. The fragment is not sent with the request, so if the document has more than one style element with an id that is referenced by a processing instruction, the author has no idea which one to send. This is a deliberate feature of the fragment identifier - it's specifically not intended that servers can send different content based upon the fragment requested.\n\nOn that matter, if there is more than one processing instruction referencing more than one internal style; say:\n\n<?xml-stylesheet href=\"#example1\" media=\"all\" type=\"text/css\"?>\n<?xml-stylesheet href=\"#example2\" media=\"all\" type=\"text/css\"?>\n<?xml-stylesheet href=\"#example3\" media=\"all\" type=\"text/css\"?>\n\nthe document is re-requested an additional three times! This is positively incorrect. It must *at least* be dereferenced back to a single URI.\n\n> No UA actually does that.\n\nI don't know how those other user-agents handle the case internally (as I said, the style element is handled specially regardless), but I know that they don't request the document from the server again.", "attachment_id": null, "tags": [], "bug_id": 676740, "text": "But should it result in another HTTP request?\n\nRFC3986 (4.4)\nsays that:\n\n   When a same-document reference is dereferenced for a retrieval\n   action, the target of that reference is defined to be within the same\n   entity (representation, document, or message) as the reference;\n   therefore, a dereference should not result in a new retrieval action.\n\nEven if the Content-Type is considered a new representation, if the Vary: Accept header is not sent on the original, shouldn't Firefox pull it from the cache? Or does Firefox cache only by URI (and if so, should it)?\n\n> That use of fragment identifiers in xml-stylesheet is a fiction.\n\nSection C of XHTML spec. is informative, but Section 4 of\nAssociating Style Sheets with XML documents 1.0 Recommendation\nis normative and says the same thing.\n\n> Means \"load base URL and treat it all as a stylesheet\".\n\nMaybe load, but not request from the network.\n\nBecause Firefox already processes the stylesheet within the document (because it's in the style element and Firefox processes those specially), it has satisfied the \"pass through to the application\" part and should then ignore the processing instruction to stop messing things up.\n\nBesides, it's actually impossible for the server to handle this case in general. The fragment is not sent with the request, so if the document has more than one style element with an id that is referenced by a processing instruction, the author has no idea which one to send. This is a deliberate feature of the fragment identifier - it's specifically not intended that servers can send different content based upon the fragment requested.\n\nOn that matter, if there is more than one processing instruction referencing more than one internal style; say:\n\n<?xml-stylesheet href=\"#example1\" media=\"all\" type=\"text/css\"?>\n<?xml-stylesheet href=\"#example2\" media=\"all\" type=\"text/css\"?>\n<?xml-stylesheet href=\"#example3\" media=\"all\" type=\"text/css\"?>\n\nthe document is re-requested an additional three times! This is positively incorrect. It must *at least* be dereferenced back to a single URI.\n\n> No UA actually does that.\n\nI don't know how those other user-agents handle the case internally (as I said, the style element is handled specially regardless), but I know that they don't request the document from the server again."}, {"id": 5637231, "count": 4, "is_private": false, "creation_time": "2011-08-06T02:14:51Z", "time": "2011-08-06T02:14:51Z", "creator": "bzbarsky@mit.edu", "author": "bzbarsky@mit.edu", "attachment_id": null, "raw_text": "> if the Vary: Accept header is not sent on the original, shouldn't Firefox pull\n> it from the cache? \n\nYes, if our cache allowed reading data that's still being written to the cache.  But it doesn't, so since the load happens before the page is done being written it can't be read from the cache.  There are existing bugs on that.  But in general, the spec can't require any particular caching policy (more precisely, it can require that things NOT be cached, but it can't require that they be cached).\n\n> Section 4 of Associating Style Sheets with XML document\n\nYes, I'm very familiar with that spec.  Like I said, it's a fiction.  No one actually implements it, or has any plans to.\n\n> RFC3986\n\nWe don't implement that yet (because it's not actually web-compatible).  But in any case, this is not a \"retrieval action\" in our terms (that would be something like an <a href>).\n\n> and should then ignore the processing instruction\n\nThe problem is that this involves knowing something about this processing instruction that we don't know at the point when we start the load from it...  this is the fundamental problem with the xml-stylesheet spec, and the reason no one implements it.\n\n> Besides, it's actually impossible for the server to handle this case in\n> general.\n\nSure it is.  Don't put in the xml-stylesheet PI, since no one supports it anyway.\n\nOr put another way, if you replace the <style> element with a <div> but then point the xml-stylesheet PI at it, do any UAs apply the styles?  I'll bet not (modulo whatever happens with error recovery if the load the whole document as a stylesheet).", "bug_id": 676740, "text": "> if the Vary: Accept header is not sent on the original, shouldn't Firefox pull\n> it from the cache? \n\nYes, if our cache allowed reading data that's still being written to the cache.  But it doesn't, so since the load happens before the page is done being written it can't be read from the cache.  There are existing bugs on that.  But in general, the spec can't require any particular caching policy (more precisely, it can require that things NOT be cached, but it can't require that they be cached).\n\n> Section 4 of Associating Style Sheets with XML document\n\nYes, I'm very familiar with that spec.  Like I said, it's a fiction.  No one actually implements it, or has any plans to.\n\n> RFC3986\n\nWe don't implement that yet (because it's not actually web-compatible).  But in any case, this is not a \"retrieval action\" in our terms (that would be something like an <a href>).\n\n> and should then ignore the processing instruction\n\nThe problem is that this involves knowing something about this processing instruction that we don't know at the point when we start the load from it...  this is the fundamental problem with the xml-stylesheet spec, and the reason no one implements it.\n\n> Besides, it's actually impossible for the server to handle this case in\n> general.\n\nSure it is.  Don't put in the xml-stylesheet PI, since no one supports it anyway.\n\nOr put another way, if you replace the <style> element with a <div> but then point the xml-stylesheet PI at it, do any UAs apply the styles?  I'll bet not (modulo whatever happens with error recovery if the load the whole document as a stylesheet).", "tags": []}, {"creator": "theimp@iinet.net.au", "time": "2011-08-06T06:33:52Z", "creation_time": "2011-08-06T06:33:52Z", "author": "theimp@iinet.net.au", "is_private": false, "id": 5637373, "count": 5, "tags": [], "text": "> But in general, the spec can't require any particular caching policy\n\nPersonally, I'm less concerned by the ultimate state of the document/cache (although it did made debugging very annoying) and more by the additional network activity. They're intertwined, unfortunately.\n\nIf I have a link like:\n\n<a href=\"#example\" type=\"text/css\">example</a>\n\nIt will not send another request to the server when activated, even though the content-type doesn't match, and even if the document is still loading when it is activated.\n\n> Yes, I'm very familiar with that spec.\n\nI don't doubt that :-)\n\n> Like I said, it's a fiction.  No one actually implements it, or has any plans to.\n\nThen, why does it get processed; that is, why does Firefox look at the href and say, \"I'll retrieve that, and apply it *as if I supported it*\"? I did a test, and if the document does send valid css on the second request, it will be applied. If it's not implemented, shouldn't it do nothing?\n\nOr do you only mean that this clause of the spec, and not the whole spec, is unimplemented?\n\nI guess that's what you mean.\n\n> The problem is that this involves knowing something about this processing instruction that we don't know at the point when we start the load from it\n\nWhat do you need to know? You know that the resource URI is within the current document, and this should not result in another network request.\n\n> Or put another way, if you replace the <style> element with a <div> but then point the xml-stylesheet PI at it, do any UAs apply the styles?\n\nI actually thought about that too, and tested it. No, no-one implements this.\n\nBut no-one else makes another request, either.\n\n\n***\n\n\nOkay, more testing has unearthed the real problem, and I've updated the bug description to reflect this.\n\nThe Link header and the link element is processed the same way as the XML Processing Instruction; so, if you have:\n\nLink: <#example1>; rel=\"stylesheet\",\n      <#example2>; rel=\"stylesheet\",\n      <#example3>; rel=\"stylesheet\"\n\nYou'll get identical (network) behavior, i.e. multiple requests for the same resource.\n\nThe Link header and the link element were never intended to reference stylesheets within elements in the way that XML Processing Instructions apparently are; however, they have always been intended to be able to reference elements within documents generally, and these should not (and do not) result in additional requests.\n\nIt is the specific case of references to stylesheets and the retrieval of stylesheets that are fragments of source documents, that is the problem here.\n\nFirefox does partially dereference the URL; so, the following does not result in two requests:\n\n<link href=\"#example\" rel=\"stylesheet\" />\n<link href=\"#example\" rel=\"stylesheet\" />\n\nAnd, assuming a parent path of /index.html then neither does the following:\n\n<link href=\"#example\" rel=\"stylesheet\" />\n<link href=\"/index.html#example\" rel=\"stylesheet\" />\n\nBut the following does result in two additional requests:\n\n<link href=\"#example1\" rel=\"stylesheet\" />\n<link href=\"#example2\" rel=\"stylesheet\" />\n\nI ran some test, and the documents that differ only by fragment will be loaded individually:\n\n1. Even if the parent document is completely loaded (say, it is already in the cache and the page is being refreshed)\n\n2. Even if the type attribute is the same as the parent e.g.\n\n<link href=\"#example\" type=\"application/xhtml+xml\" rel=\"stylesheet\" />\n\nSo, this is not a cache issue.\n\n***\n\n\nAfter further research, this might be a mutant case of bug 275689; but I'm not sure.", "bug_id": 676740, "attachment_id": null, "raw_text": "> But in general, the spec can't require any particular caching policy\n\nPersonally, I'm less concerned by the ultimate state of the document/cache (although it did made debugging very annoying) and more by the additional network activity. They're intertwined, unfortunately.\n\nIf I have a link like:\n\n<a href=\"#example\" type=\"text/css\">example</a>\n\nIt will not send another request to the server when activated, even though the content-type doesn't match, and even if the document is still loading when it is activated.\n\n> Yes, I'm very familiar with that spec.\n\nI don't doubt that :-)\n\n> Like I said, it's a fiction.  No one actually implements it, or has any plans to.\n\nThen, why does it get processed; that is, why does Firefox look at the href and say, \"I'll retrieve that, and apply it *as if I supported it*\"? I did a test, and if the document does send valid css on the second request, it will be applied. If it's not implemented, shouldn't it do nothing?\n\nOr do you only mean that this clause of the spec, and not the whole spec, is unimplemented?\n\nI guess that's what you mean.\n\n> The problem is that this involves knowing something about this processing instruction that we don't know at the point when we start the load from it\n\nWhat do you need to know? You know that the resource URI is within the current document, and this should not result in another network request.\n\n> Or put another way, if you replace the <style> element with a <div> but then point the xml-stylesheet PI at it, do any UAs apply the styles?\n\nI actually thought about that too, and tested it. No, no-one implements this.\n\nBut no-one else makes another request, either.\n\n\n***\n\n\nOkay, more testing has unearthed the real problem, and I've updated the bug description to reflect this.\n\nThe Link header and the link element is processed the same way as the XML Processing Instruction; so, if you have:\n\nLink: <#example1>; rel=\"stylesheet\",\n      <#example2>; rel=\"stylesheet\",\n      <#example3>; rel=\"stylesheet\"\n\nYou'll get identical (network) behavior, i.e. multiple requests for the same resource.\n\nThe Link header and the link element were never intended to reference stylesheets within elements in the way that XML Processing Instructions apparently are; however, they have always been intended to be able to reference elements within documents generally, and these should not (and do not) result in additional requests.\n\nIt is the specific case of references to stylesheets and the retrieval of stylesheets that are fragments of source documents, that is the problem here.\n\nFirefox does partially dereference the URL; so, the following does not result in two requests:\n\n<link href=\"#example\" rel=\"stylesheet\" />\n<link href=\"#example\" rel=\"stylesheet\" />\n\nAnd, assuming a parent path of /index.html then neither does the following:\n\n<link href=\"#example\" rel=\"stylesheet\" />\n<link href=\"/index.html#example\" rel=\"stylesheet\" />\n\nBut the following does result in two additional requests:\n\n<link href=\"#example1\" rel=\"stylesheet\" />\n<link href=\"#example2\" rel=\"stylesheet\" />\n\nI ran some test, and the documents that differ only by fragment will be loaded individually:\n\n1. Even if the parent document is completely loaded (say, it is already in the cache and the page is being refreshed)\n\n2. Even if the type attribute is the same as the parent e.g.\n\n<link href=\"#example\" type=\"application/xhtml+xml\" rel=\"stylesheet\" />\n\nSo, this is not a cache issue.\n\n***\n\n\nAfter further research, this might be a mutant case of bug 275689; but I'm not sure."}, {"text": "> If I have a link like:\n\nAs I said, that's one of the few cases where UAs treat something as a same-document reference and actually operate entirely on the DOM level.\n\n> Or do you only mean that this clause of the spec, and not the whole spec, is\n> unimplemented?\n\nYes, exactly.\n\n> You know that the resource URI is within the current document\n\nYou actually don't; whether it is depends on the base URI of the document (again, not what RFC 3986 says, but what UAs implement, as you can test trivially with <a>), which is not known at that point.\n\n> But no-one else makes another request, either.\n\nSure; the only reason there's a request in our case is because our HTTP cache is suboptimal.\n\nThat said, it looks like at least WebKit does something bizarre where it only loads certain URIs for xml-stylesheet.  Try this test document:\n\n  <?xml-stylesheet href=\"#foo\" type=\"text/css\"?>\n  <html xmlns=\"http://www.w3.org/1999/xhtml\">\n    foo {}\n    html { color: green; }\n  </html>\n\nI don't think we want to do that sort of special-casing, in general.\n\n> The Link header and the link element is processed the same way as the XML\n> Processing Instruction\n\nYes, it's the same code.  Note that WebKit is inconsistent here, by the way; if I replace the PI in my snippet above with:\n\n  <link rel=\"stylesheet\" href=\"#foo\" type=\"text/css\"/>\n\nthen it loads the document as a stylesheet.  Again, I don't think we want the inconsistency.\n\n> The Link header and the link element were never intended\n\nQuite honestly, they're generally not used or implemented as intended.  At this point those intentions are more or less irrelevant, because trying to implement them in general is not web-compatible...\n\n> the following does not result in two requests\n\nThat's just because we aggressively coalesce stylesheet loads with each other.  That includes @import loads (if you had tested those) too.\n\n> But the following does result in two additional requests:\n\nI can see the argument for ignoring the fragment identifier when performing the coalescing; right now it's just a straight URI equality check.  But since it's just an optimization, not a correctness issue, and the situation of having two stylesheet loads that only differ by fragment is very rare that's somewhat of a low priority.\n\n> Even if the parent document is completely loaded (say, it is already in the\n> cache and the page is being refreshed)\n\nThe cache doesn't support multiple readers at once either, so if the document is loading from it the stylesheet can't be, in general.\n\nThat said, I thought it would just block on the cache entry.  It's odd that you're not getting it from the cache in that case.  Can you point me to a testcase?\n\n> So, this is not a cache issue.\n\nIt really is.  All the CSS loader does is kick off a load, since it has no concept of doing anything else with URIs; whether it hits the network is entirely up to the HTTP implementation.\n\n> this might be a mutant case of bug 275689\n\nThat bug is not going to get fixed; the RFC 3986 behavior is not web-compatible and the behavior of \"same-document references\" in many places where URIs are allowed makes no sense....  This case is one where it sort of does, maybe, except that no one does it, and I don't think anyone is likely to start.", "bug_id": 676740, "tags": [], "raw_text": "> If I have a link like:\n\nAs I said, that's one of the few cases where UAs treat something as a same-document reference and actually operate entirely on the DOM level.\n\n> Or do you only mean that this clause of the spec, and not the whole spec, is\n> unimplemented?\n\nYes, exactly.\n\n> You know that the resource URI is within the current document\n\nYou actually don't; whether it is depends on the base URI of the document (again, not what RFC 3986 says, but what UAs implement, as you can test trivially with <a>), which is not known at that point.\n\n> But no-one else makes another request, either.\n\nSure; the only reason there's a request in our case is because our HTTP cache is suboptimal.\n\nThat said, it looks like at least WebKit does something bizarre where it only loads certain URIs for xml-stylesheet.  Try this test document:\n\n  <?xml-stylesheet href=\"#foo\" type=\"text/css\"?>\n  <html xmlns=\"http://www.w3.org/1999/xhtml\">\n    foo {}\n    html { color: green; }\n  </html>\n\nI don't think we want to do that sort of special-casing, in general.\n\n> The Link header and the link element is processed the same way as the XML\n> Processing Instruction\n\nYes, it's the same code.  Note that WebKit is inconsistent here, by the way; if I replace the PI in my snippet above with:\n\n  <link rel=\"stylesheet\" href=\"#foo\" type=\"text/css\"/>\n\nthen it loads the document as a stylesheet.  Again, I don't think we want the inconsistency.\n\n> The Link header and the link element were never intended\n\nQuite honestly, they're generally not used or implemented as intended.  At this point those intentions are more or less irrelevant, because trying to implement them in general is not web-compatible...\n\n> the following does not result in two requests\n\nThat's just because we aggressively coalesce stylesheet loads with each other.  That includes @import loads (if you had tested those) too.\n\n> But the following does result in two additional requests:\n\nI can see the argument for ignoring the fragment identifier when performing the coalescing; right now it's just a straight URI equality check.  But since it's just an optimization, not a correctness issue, and the situation of having two stylesheet loads that only differ by fragment is very rare that's somewhat of a low priority.\n\n> Even if the parent document is completely loaded (say, it is already in the\n> cache and the page is being refreshed)\n\nThe cache doesn't support multiple readers at once either, so if the document is loading from it the stylesheet can't be, in general.\n\nThat said, I thought it would just block on the cache entry.  It's odd that you're not getting it from the cache in that case.  Can you point me to a testcase?\n\n> So, this is not a cache issue.\n\nIt really is.  All the CSS loader does is kick off a load, since it has no concept of doing anything else with URIs; whether it hits the network is entirely up to the HTTP implementation.\n\n> this might be a mutant case of bug 275689\n\nThat bug is not going to get fixed; the RFC 3986 behavior is not web-compatible and the behavior of \"same-document references\" in many places where URIs are allowed makes no sense....  This case is one where it sort of does, maybe, except that no one does it, and I don't think anyone is likely to start.", "attachment_id": null, "author": "bzbarsky@mit.edu", "creation_time": "2011-08-06T17:43:47Z", "time": "2011-08-06T17:43:47Z", "creator": "bzbarsky@mit.edu", "count": 6, "id": 5637654, "is_private": false}, {"raw_text": "> But since it's just an optimization, not a correctness issue, and the situation of having two stylesheet loads that only differ by fragment is very rare that's somewhat of a low priority.\n\nFair enough.\n\n> The cache doesn't support multiple readers at once either, so if the document is loading from it the stylesheet can't be, in general.\n\n> That said, I thought it would just block on the cache entry.  It's odd that you're not getting it from the cache in that case.  Can you point me to a testcase?\n\nBasically, any page that's small enough to fit into a single TCP/IP frame should do the trick.\n\nThis is enough; both the Web Console and WireShark show that it is fully supplied hundreds of milliseconds before the next request, so unless it takes a ridiculously long time for Firefox to commit it to the cache, it's pretty obvious that the page is in the cache.\n\nIn the attached example, I delay loading by including two absurd 50MB CSS files (not included) containing nothing but whitespace; example1 and example2.\n\nI also set:\nnetwork.http.max-connections = 1\nnetwork.http.max-persistent-connections-per-server = 1\nnetwork.http.pipelining = false\n\nYou'll see the inline style make the body red, and then much later see the body turn blue.\n\nHey... that's weird.\n\nWhen I choke the server bandwidth low enough that I can see about:cache between each of the loads in the above file:\n\nexample.html shows that it has been accessed from the cache 3 times, but only the initial request has hit the network so far, and the CSS at the top sure hasn't been processed.\n\nBut, sure enough, example.html is requested twice again... after BOTH of the other files are requested - not just example1 (Web Console shows them requested in the source order). This takes tens of seconds, and I'm using memory cache only (the server is choked to 10,000b/s and the CSS files are now 1MB).\n\nError messages in the Web Console seem to indicate that the CSS files are at least parsed in request order (as opposed to source order). But this makes the cache request count even stranger.\n\n> That bug is not going to get fixed;\n\nI understand that; I've read the bug, and can see your point(s). I was agreeing with you :-)", "attachment_id": null, "tags": [], "bug_id": 676740, "text": "> But since it's just an optimization, not a correctness issue, and the situation of having two stylesheet loads that only differ by fragment is very rare that's somewhat of a low priority.\n\nFair enough.\n\n> The cache doesn't support multiple readers at once either, so if the document is loading from it the stylesheet can't be, in general.\n\n> That said, I thought it would just block on the cache entry.  It's odd that you're not getting it from the cache in that case.  Can you point me to a testcase?\n\nBasically, any page that's small enough to fit into a single TCP/IP frame should do the trick.\n\nThis is enough; both the Web Console and WireShark show that it is fully supplied hundreds of milliseconds before the next request, so unless it takes a ridiculously long time for Firefox to commit it to the cache, it's pretty obvious that the page is in the cache.\n\nIn the attached example, I delay loading by including two absurd 50MB CSS files (not included) containing nothing but whitespace; example1 and example2.\n\nI also set:\nnetwork.http.max-connections = 1\nnetwork.http.max-persistent-connections-per-server = 1\nnetwork.http.pipelining = false\n\nYou'll see the inline style make the body red, and then much later see the body turn blue.\n\nHey... that's weird.\n\nWhen I choke the server bandwidth low enough that I can see about:cache between each of the loads in the above file:\n\nexample.html shows that it has been accessed from the cache 3 times, but only the initial request has hit the network so far, and the CSS at the top sure hasn't been processed.\n\nBut, sure enough, example.html is requested twice again... after BOTH of the other files are requested - not just example1 (Web Console shows them requested in the source order). This takes tens of seconds, and I'm using memory cache only (the server is choked to 10,000b/s and the CSS files are now 1MB).\n\nError messages in the Web Console seem to indicate that the CSS files are at least parsed in request order (as opposed to source order). But this makes the cache request count even stranger.\n\n> That bug is not going to get fixed;\n\nI understand that; I've read the bug, and can see your point(s). I was agreeing with you :-)", "is_private": false, "id": 5638086, "count": 7, "author": "theimp@iinet.net.au", "creator": "theimp@iinet.net.au", "creation_time": "2011-08-07T03:22:00Z", "time": "2011-08-07T03:22:00Z"}, {"attachment_id": 551301, "raw_text": "", "tags": [], "bug_id": 676740, "text": "Created attachment 551301\nPage showing CSS request for itself that ignores the cache", "is_private": false, "count": 8, "id": 5638087, "creator": "theimp@iinet.net.au", "time": "2011-08-07T03:23:50Z", "creation_time": "2011-08-07T03:23:50Z", "author": "theimp@iinet.net.au"}, {"is_private": false, "id": 5638265, "count": 9, "creator": "bzbarsky@mit.edu", "time": "2011-08-07T15:30:59Z", "creation_time": "2011-08-07T15:30:59Z", "author": "bzbarsky@mit.edu", "attachment_id": null, "raw_text": "The cache entry gets closed at some point toward the end of the document load, iirc, not when we're done getting data from the network, since the document can change the cache metadata.  So doing network timings is not useful for determining what's going on with the cache.\n\nWhat would be useful is either a live testcase I can try myself or a log created following the directions at https://developer.mozilla.org/en/HTTP_Logging", "tags": [], "bug_id": 676740, "text": "The cache entry gets closed at some point toward the end of the document load, iirc, not when we're done getting data from the network, since the document can change the cache metadata.  So doing network timings is not useful for determining what's going on with the cache.\n\nWhat would be useful is either a live testcase I can try myself or a log created following the directions at https://developer.mozilla.org/en/HTTP_Logging"}, {"text": "First, I apologize for wasting everyone's time.\n\n> The cache entry gets closed at some point toward the end of the document load, iirc, not when we're done getting data from the network\n\nYes, it seems you're right; if I try to view a cache entry, it says that \"The cache entry you selected is not available.\"\n\n> That said, I thought it would just block on the cache entry.\n\nD'oh! It does. See below\u2026\n\n> What would be useful is [\u2026] a live testcase I can try myself\n\nI was building one for you, and that's where I've realized my mistake:\n\nI was sending a \"Vary: Accept\" header sometimes, or no Expires header other times, while trying to isolate the problem. The correct combination (no Vary header, Expires in the future) results in correct behavior (no additional network access).\n\nWhere I originally discovered the problem, I performed content-negotiation in order to serve text/html to primitive browsers and application/xhtml+xml to advanced browsers, and gave a Vary: Accept header so that caches could cache the correct type. That gave Firefox the idea that if it doesn't find the content-type it wants in its own cache, it should try asking for what it wants again from the server. Correct behavior, of course :-(\n\n\n***\n\n\nThis does give webmasters a reliable way of breaking (deliberately or accidentally) the Work Offline functionality, along with the view-source functionality. Not priorities, though, I understand.\n\nMaybe what is really needed is headers like Advise-Accept, Advise-Accept-Encoding, etc., which a server can use to give to clients a list of content-types or whatever that they can expect to ask for and receive for a particular resource.\n\n\n***\n\nI've updated the bug to the only outstanding issue, and changed it to enhancement.", "bug_id": 676740, "tags": [], "attachment_id": null, "raw_text": "First, I apologize for wasting everyone's time.\n\n> The cache entry gets closed at some point toward the end of the document load, iirc, not when we're done getting data from the network\n\nYes, it seems you're right; if I try to view a cache entry, it says that \"The cache entry you selected is not available.\"\n\n> That said, I thought it would just block on the cache entry.\n\nD'oh! It does. See below\u2026\n\n> What would be useful is [\u2026] a live testcase I can try myself\n\nI was building one for you, and that's where I've realized my mistake:\n\nI was sending a \"Vary: Accept\" header sometimes, or no Expires header other times, while trying to isolate the problem. The correct combination (no Vary header, Expires in the future) results in correct behavior (no additional network access).\n\nWhere I originally discovered the problem, I performed content-negotiation in order to serve text/html to primitive browsers and application/xhtml+xml to advanced browsers, and gave a Vary: Accept header so that caches could cache the correct type. That gave Firefox the idea that if it doesn't find the content-type it wants in its own cache, it should try asking for what it wants again from the server. Correct behavior, of course :-(\n\n\n***\n\n\nThis does give webmasters a reliable way of breaking (deliberately or accidentally) the Work Offline functionality, along with the view-source functionality. Not priorities, though, I understand.\n\nMaybe what is really needed is headers like Advise-Accept, Advise-Accept-Encoding, etc., which a server can use to give to clients a list of content-types or whatever that they can expect to ask for and receive for a particular resource.\n\n\n***\n\nI've updated the bug to the only outstanding issue, and changed it to enhancement.", "creator": "theimp@iinet.net.au", "creation_time": "2011-08-08T04:00:32Z", "time": "2011-08-08T04:00:32Z", "author": "theimp@iinet.net.au", "is_private": false, "count": 10, "id": 5638765}, {"id": 5639604, "count": 11, "is_private": false, "author": "bzbarsky@mit.edu", "time": "2011-08-08T15:52:09Z", "creation_time": "2011-08-08T15:52:09Z", "creator": "bzbarsky@mit.edu", "raw_text": "Thanks for double-checking all that!\n\nIgnoring the fragment identifier for the coalescing definitely makes sense.  It should be pretty trivial once bug 677260 is fixed.", "attachment_id": null, "tags": [], "text": "Thanks for double-checking all that!\n\nIgnoring the fragment identifier for the coalescing definitely makes sense.  It should be pretty trivial once bug 677260 is fixed.", "bug_id": 676740}]}}}