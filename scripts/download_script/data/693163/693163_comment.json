{"comments": {}, "bugs": {"693163": {"comments": [{"count": 0, "is_private": false, "creator": "netzen@gmail.com", "text": "While doing the fix in bug 635691 I noticed that GetTopLevelHWND's aStopOnDialogOrPopup flag didn't actually do what it said.  \n\nAll old code using GetTopLevelHWND was left with the same net logic as before, but we should investigate if the original intent was correct or not.  \n\nIn particular GetParent would only return the owner if the passed in windows had WS_POPUP style.", "tags": [], "time": "2011-10-09T14:14:39Z", "bug_id": 693163, "creation_time": "2011-10-09T14:14:39Z", "author": "netzen@gmail.com", "raw_text": "While doing the fix in bug 635691 I noticed that GetTopLevelHWND's aStopOnDialogOrPopup flag didn't actually do what it said.  \n\nAll old code using GetTopLevelHWND was left with the same net logic as before, but we should investigate if the original intent was correct or not.  \n\nIn particular GetParent would only return the owner if the passed in windows had WS_POPUP style.", "attachment_id": null, "id": 5769983}, {"is_private": false, "creator": "neil@httl.net", "count": 1, "creation_time": "2011-10-09T15:12:57Z", "author": "neil@httl.net", "text": "To avoid confusion, I shall use the following terms:\nChild window: a window with the WS_CHILD style\nTop level window: a window without the WS_CHILD style\nOwning ancestor: a window without a parent or owner, which usually means it has an entry in the taskbar.\n\nAs of bug 635691, GetTopLevelHWND has three uses: 1) with arguments of PR_TRUE and PR_FALSE, to get the owning ancestor 2) with an argument of PR_TRUE, to get the top level window only 3) with zero arguments, to get a backward-compatible behaviour, which looks as if it is the same as 2) possibly due to a bug, in that we don't actually use the WS_POPUP style, so that we always stop on a top-level window.\n\nThe following caller currently uses, and wants, behaviour 1:\nnsWindow::GetAttention\n\nThe following callers currently use, and want, behaviour 2:\nnsIMM32Handler::IsTopLevelWindowOfComposition\nnsWindow::BeginResizeDrag\nnsWindow::HideWindowChrome\nnsWindow::OnDefaultButtonLoaded\nnsWindow::SetWindowTranslucencyInner\nnsWindow::UpdateTranslucentWindow\n\nThe following callers currently use behaviour 3:\nnsWindow::SetFocus calls GetTopLevelHWND in a special debugging code block. It doesn't pass PR_TRUE, but only uses it to check whether it's a top or a child window, so it doesn't care which behaviour it gets.\nnsWindow::SetFocus calls GetTopLevelHWND to uniconify the window that it's focusing. It's not clear what should happen in the case of a dependent window, since either it or its owner could be minimised.\nnsWindow::DispatchPendingEvents calls GetTopLevelHWND to pass to EnumChildWindows. Since the latter does not include dependent windows or popups, it seems that it really wants behaviour 2.\nnsWindow::IsTopLevelMouseExit calls GetTopLevelHWND to compare with the result of WindowFromPoint, which suggests that it really wants behaviour 2.\nnsWindow::OnWindowPosChanged has the same debugging block that nsWindow::SetFocus does.\n\nI therefore claim that all callers prior to bug 635691 really only want the top level window rather than the owning ancestor, and therefore the aStopIfNotChild parameter should default to true, and the aStopIfNotPopup parameter becomes unnecessary.\n\nIt may help to rework the logic somewhat, as per the following pseudocode:\n\nwhile (IsAChildWindow(hWnd))\n  hWnd = GetParent(hWnd);\nif (wantsAncestor)\n  while (GetOwner(hWnd))\n    hWnd = GetOwner(hWnd);", "tags": [], "time": "2011-10-09T15:12:57Z", "bug_id": 693163, "attachment_id": null, "raw_text": "To avoid confusion, I shall use the following terms:\nChild window: a window with the WS_CHILD style\nTop level window: a window without the WS_CHILD style\nOwning ancestor: a window without a parent or owner, which usually means it has an entry in the taskbar.\n\nAs of bug 635691, GetTopLevelHWND has three uses: 1) with arguments of PR_TRUE and PR_FALSE, to get the owning ancestor 2) with an argument of PR_TRUE, to get the top level window only 3) with zero arguments, to get a backward-compatible behaviour, which looks as if it is the same as 2) possibly due to a bug, in that we don't actually use the WS_POPUP style, so that we always stop on a top-level window.\n\nThe following caller currently uses, and wants, behaviour 1:\nnsWindow::GetAttention\n\nThe following callers currently use, and want, behaviour 2:\nnsIMM32Handler::IsTopLevelWindowOfComposition\nnsWindow::BeginResizeDrag\nnsWindow::HideWindowChrome\nnsWindow::OnDefaultButtonLoaded\nnsWindow::SetWindowTranslucencyInner\nnsWindow::UpdateTranslucentWindow\n\nThe following callers currently use behaviour 3:\nnsWindow::SetFocus calls GetTopLevelHWND in a special debugging code block. It doesn't pass PR_TRUE, but only uses it to check whether it's a top or a child window, so it doesn't care which behaviour it gets.\nnsWindow::SetFocus calls GetTopLevelHWND to uniconify the window that it's focusing. It's not clear what should happen in the case of a dependent window, since either it or its owner could be minimised.\nnsWindow::DispatchPendingEvents calls GetTopLevelHWND to pass to EnumChildWindows. Since the latter does not include dependent windows or popups, it seems that it really wants behaviour 2.\nnsWindow::IsTopLevelMouseExit calls GetTopLevelHWND to compare with the result of WindowFromPoint, which suggests that it really wants behaviour 2.\nnsWindow::OnWindowPosChanged has the same debugging block that nsWindow::SetFocus does.\n\nI therefore claim that all callers prior to bug 635691 really only want the top level window rather than the owning ancestor, and therefore the aStopIfNotChild parameter should default to true, and the aStopIfNotPopup parameter becomes unnecessary.\n\nIt may help to rework the logic somewhat, as per the following pseudocode:\n\nwhile (IsAChildWindow(hWnd))\n  hWnd = GetParent(hWnd);\nif (wantsAncestor)\n  while (GetOwner(hWnd))\n    hWnd = GetOwner(hWnd);", "id": 5770045}]}}}