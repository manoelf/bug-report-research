{"comments": {}, "bugs": {"680289": {"comments": [{"author": "jonas@sicking.cc", "count": 0, "text": "Once we have basic joystick support, we should add support for vibrator control.\n\nI propose that we do this by adding the two properties, .hasVibrator and .vibratorStrength, to the joystick object introduced in bug 604039.\n\nBy adding the properties on the Joystick object, it ensures that pages don't get access to them unless the user has interacted with the joystick on the page. This should remove concerns about fingerprinting using the .hasVibrator property.\n\nThe main risk that I can see is that if the user accidentally uses the joystick while viewing a website, the website can annoy the user by turning on the vibrator. However I think this is an acceptable risk, and the user can fix it by either leaving the page or reloading it.\n\nAs for .vibratorStrength. I don't know if joysticks usually support a sliding scale, or a set number of distinct levels? Would simply making the strength be a number between 0 and 1 work? And if the joystick only supports distinct levels, this would turn on the lowest level that is at least as strong as the selected value.\n\nOr should .hasVibrator return a number indicating the number of levels available?", "bug_id": 680289, "id": 5664096, "time": "2011-08-18T23:33:11Z", "raw_text": "Once we have basic joystick support, we should add support for vibrator control.\n\nI propose that we do this by adding the two properties, .hasVibrator and .vibratorStrength, to the joystick object introduced in bug 604039.\n\nBy adding the properties on the Joystick object, it ensures that pages don't get access to them unless the user has interacted with the joystick on the page. This should remove concerns about fingerprinting using the .hasVibrator property.\n\nThe main risk that I can see is that if the user accidentally uses the joystick while viewing a website, the website can annoy the user by turning on the vibrator. However I think this is an acceptable risk, and the user can fix it by either leaving the page or reloading it.\n\nAs for .vibratorStrength. I don't know if joysticks usually support a sliding scale, or a set number of distinct levels? Would simply making the strength be a number between 0 and 1 work? And if the joystick only supports distinct levels, this would turn on the lowest level that is at least as strong as the selected value.\n\nOr should .hasVibrator return a number indicating the number of levels available?", "creator": "jonas@sicking.cc", "is_private": false, "creation_time": "2011-08-18T23:33:11Z", "attachment_id": null, "tags": []}, {"tags": [], "attachment_id": null, "raw_text": "It's also commonly referred to as \"rumble\" support. Note that some controllers have more than one motor, and you can control them independently. The XBox 360 controller has two motors, for example:\nhttp://msdn.microsoft.com/en-us/library/microsoft.directx_sdk.reference.xinput_vibration%28v=vs.85%29.aspx\n\nOne is low-frequency, and one is high-frequency. (Unfortunately those APIs are only available via XInput, and my Win32 backend uses DirectInput currently.)", "time": "2011-08-18T23:37:57Z", "creation_time": "2011-08-18T23:37:57Z", "is_private": false, "bug_id": 680289, "id": 5664113, "author": "ted@mielczarek.org", "text": "It's also commonly referred to as \"rumble\" support. Note that some controllers have more than one motor, and you can control them independently. The XBox 360 controller has two motors, for example:\nhttp://msdn.microsoft.com/en-us/library/microsoft.directx_sdk.reference.xinput_vibration%28v=vs.85%29.aspx\n\nOne is low-frequency, and one is high-frequency. (Unfortunately those APIs are only available via XInput, and my Win32 backend uses DirectInput currently.)", "count": 1, "creator": "ted@mielczarek.org"}, {"author": "john@nextraweb.com", "text": "I commented on Bug 679966 about rumble support for the device, what if I don\u2019t have a joystick but do have rumble, where does the vibration interface get parented? See Xperia Play and PSVita for the direction mobiles will go.", "count": 2, "creator": "john@nextraweb.com", "creation_time": "2011-08-23T15:18:38Z", "is_private": false, "id": 5672067, "bug_id": 680289, "attachment_id": null, "raw_text": "I commented on Bug 679966 about rumble support for the device, what if I don\u2019t have a joystick but do have rumble, where does the vibration interface get parented? See Xperia Play and PSVita for the direction mobiles will go.", "time": "2011-08-23T15:18:38Z", "tags": []}, {"creator": "bobby@mozillafoundation.org", "is_private": false, "creation_time": "2011-12-09T16:02:36Z", "attachment_id": 580418, "tags": [], "author": "bobby@mozillafoundation.org", "count": 3, "text": "Created attachment 580418\nPatch for applying gamepad vibration to gamepad API patchset\n\nI have put a preliminary patch together to get this working in Linux. I built it last night, and I'm trying it again on another Linux machine as I write this.\n\nIt builds on bug #604039, including its patchset, so make sure you're basing off of that if you build this.\n\nI have a reliable git branch here: https://github.com/secretrobotron/mozilla-central/tree/gamepad-api-vibration\n\nNote: There is a bug which will probably screw up >1 controllers plugged in, but I know where it is, and it's gonna get axed today.", "bug_id": 680289, "id": 5904347, "time": "2011-12-09T16:02:36Z", "raw_text": "I have put a preliminary patch together to get this working in Linux. I built it last night, and I'm trying it again on another Linux machine as I write this.\n\nIt builds on bug #604039, including its patchset, so make sure you're basing off of that if you build this.\n\nI have a reliable git branch here: https://github.com/secretrobotron/mozilla-central/tree/gamepad-api-vibration\n\nNote: There is a bug which will probably screw up >1 controllers plugged in, but I know where it is, and it's gonna get axed today."}, {"raw_text": "Cool! I only skimmed the patch, but this is the interface on the gamepad, right?\n\n    void setVibration(in unsigned long duration, in unsigned long strongMagnitude, in unsigned long weakMagnitude);\n\nwhere it oscillates between the two magnitudes? That seems a bit over-specialized to the linux ff interface and rumble to me. Could it be simplified to just:\n\nvoid vibrate(in unsigned long motor, in float normalizedMagnitude);\n\n? (or setVibration, don't care) That's the interface I was thinking of hacking in myself. I guess gamepad objects would also need a numMotors added.\n\nI'd also drop getVibration(). Seems like extra stuff that might be hard to query some places, unless it's really important for something.\n\nhttp://www.w3.org/TR/2011/WD-vibration-20111117/ is, uh, there too. I don't know how important/useful it really is to try to make phone vibration and gamepad vibration the same.", "attachment_id": null, "time": "2011-12-10T04:33:05Z", "tags": [], "text": "Cool! I only skimmed the patch, but this is the interface on the gamepad, right?\n\n    void setVibration(in unsigned long duration, in unsigned long strongMagnitude, in unsigned long weakMagnitude);\n\nwhere it oscillates between the two magnitudes? That seems a bit over-specialized to the linux ff interface and rumble to me. Could it be simplified to just:\n\nvoid vibrate(in unsigned long motor, in float normalizedMagnitude);\n\n? (or setVibration, don't care) That's the interface I was thinking of hacking in myself. I guess gamepad objects would also need a numMotors added.\n\nI'd also drop getVibration(). Seems like extra stuff that might be hard to query some places, unless it's really important for something.\n\nhttp://www.w3.org/TR/2011/WD-vibration-20111117/ is, uh, there too. I don't know how important/useful it really is to try to make phone vibration and gamepad vibration the same.", "count": 4, "author": "scott.mozilla@h4ck3r.net", "creator": "scott.mozilla@h4ck3r.net", "creation_time": "2011-12-10T04:33:05Z", "is_private": false, "id": 5906018, "bug_id": 680289}, {"raw_text": "To expand/clarify, I was thinking that doing the equivalent of the current patch would then look like:\n\n    pad.vibrate(0, strong_mag);\n    pad.vibrate(1, weak_mag);\n\n    // after duration ...\n\n    var off = 0.0;\n    pad.vibrate(0, off);\n    pad.vibrate(1, off);", "attachment_id": null, "time": "2011-12-10T05:35:16Z", "tags": [], "text": "To expand/clarify, I was thinking that doing the equivalent of the current patch would then look like:\n\n    pad.vibrate(0, strong_mag);\n    pad.vibrate(1, weak_mag);\n\n    // after duration ...\n\n    var off = 0.0;\n    pad.vibrate(0, off);\n    pad.vibrate(1, off);", "count": 5, "author": "scott.mozilla@h4ck3r.net", "creator": "scott.mozilla@h4ck3r.net", "is_private": false, "creation_time": "2011-12-10T05:35:16Z", "bug_id": 680289, "id": 5906049}, {"bug_id": 680289, "id": 5907227, "is_private": false, "creation_time": "2011-12-11T16:16:20Z", "creator": "bobby@mozillafoundation.org", "author": "bobby@mozillafoundation.org", "text": "> where it oscillates between the two magnitudes?\nNot really. There are two motors in most XInput-ish gamepads now. FF on linux supports it by default with FF_RUMBLE. All the other kinds of FF actually seem more complex.\n\n> That seems a bit over-specialized to the linux ff interface and rumble to me.\n\nI wasn't really sure how to generalize this properly until I did a bit of searching. I still don't really have a good idea other than to just steal XInput's since it's used a lot now, and there's really not a lot wrong with it: http://msdn.microsoft.com/en-us/library/windows/desktop/ee417001(v=vs.85).aspx#setting_vibration\n\nOn my blog, I wrote about why I did what if you're interested: http://robothaus.org/blog/blog/2011/12/09/gamepad-vibration-zero-to-hero/\n\nVery happy to have some feedback though. Nobody seems to know how to tackle this in a general way yet.\n\n> http://www.w3.org/TR/2011/WD-vibration-20111117/ is, uh, there too. I don't know how important/useful it really is to try to make phone vibration and gamepad vibration the same.\n\nI was actually considering this too. There's a WebVibrator bug (679966) that is attempting to deal with it already. There's no reason why we can't push this closer to that.\n\n> I'd also drop getVibration(). Seems like extra stuff that might be hard to query some places, unless it's really important for something.\n\nYou're probably right, especially considering the push, on-demand nature of vibration. Keeps the DOM impl simpler too. I can pretty much scrap nsDOMGamepadEffect. I hesitate a bit though, because it might actually be useful in the future if we intend to support more effects, and not just simple rumbling. Might be overkill for this though.", "count": 6, "tags": [], "time": "2011-12-11T16:16:20Z", "attachment_id": null, "raw_text": "> where it oscillates between the two magnitudes?\nNot really. There are two motors in most XInput-ish gamepads now. FF on linux supports it by default with FF_RUMBLE. All the other kinds of FF actually seem more complex.\n\n> That seems a bit over-specialized to the linux ff interface and rumble to me.\n\nI wasn't really sure how to generalize this properly until I did a bit of searching. I still don't really have a good idea other than to just steal XInput's since it's used a lot now, and there's really not a lot wrong with it: http://msdn.microsoft.com/en-us/library/windows/desktop/ee417001(v=vs.85).aspx#setting_vibration\n\nOn my blog, I wrote about why I did what if you're interested: http://robothaus.org/blog/blog/2011/12/09/gamepad-vibration-zero-to-hero/\n\nVery happy to have some feedback though. Nobody seems to know how to tackle this in a general way yet.\n\n> http://www.w3.org/TR/2011/WD-vibration-20111117/ is, uh, there too. I don't know how important/useful it really is to try to make phone vibration and gamepad vibration the same.\n\nI was actually considering this too. There's a WebVibrator bug (679966) that is attempting to deal with it already. There's no reason why we can't push this closer to that.\n\n> I'd also drop getVibration(). Seems like extra stuff that might be hard to query some places, unless it's really important for something.\n\nYou're probably right, especially considering the push, on-demand nature of vibration. Keeps the DOM impl simpler too. I can pretty much scrap nsDOMGamepadEffect. I hesitate a bit though, because it might actually be useful in the future if we intend to support more effects, and not just simple rumbling. Might be overkill for this though."}, {"id": 5907230, "bug_id": 680289, "is_private": false, "creation_time": "2011-12-11T16:21:02Z", "creator": "bobby@mozillafoundation.org", "count": 7, "text": "I should also expand on the \"two motors\" thing: in no way am I attached to always supporting two motors.\n\nvoid vibrate( unsigned long duration, unsigned long strength );\n\nactually looks perfect.\n\nI was intending to finish the implementation for optional args here though, so...\n\nvoid vibrate( unsigned long duration, unsigned long strength, unsigned long otherStrength = 0 );\n\nThen, if there is another motor, we can use that other arg, but it's not required.", "author": "bobby@mozillafoundation.org", "tags": [], "time": "2011-12-11T16:21:02Z", "raw_text": "I should also expand on the \"two motors\" thing: in no way am I attached to always supporting two motors.\n\nvoid vibrate( unsigned long duration, unsigned long strength );\n\nactually looks perfect.\n\nI was intending to finish the implementation for optional args here though, so...\n\nvoid vibrate( unsigned long duration, unsigned long strength, unsigned long otherStrength = 0 );\n\nThen, if there is another motor, we can use that other arg, but it's not required.", "attachment_id": null}, {"author": "ted@mielczarek.org", "text": "You'll note that the Vibration API spec supports two methods:\n void vibrate (optional unsigned long time)\nWhich is just \"vibrate for |time| milliseconds at whatever frequency\".\n\n void vibrate (optional unsigned long[] pattern)\nWhich is \"alternate vibrating and being still for N milliseconds for N in pattern\".\n\nIt would probably be nice to be able to generalize this to >1 vibration motor, since we know most gamepads that support vibration have 2. If we can get them to work it into that spec, even better.", "count": 8, "id": 5908698, "bug_id": 680289, "time": "2011-12-12T16:01:28Z", "raw_text": "You'll note that the Vibration API spec supports two methods:\n void vibrate (optional unsigned long time)\nWhich is just \"vibrate for |time| milliseconds at whatever frequency\".\n\n void vibrate (optional unsigned long[] pattern)\nWhich is \"alternate vibrating and being still for N milliseconds for N in pattern\".\n\nIt would probably be nice to be able to generalize this to >1 vibration motor, since we know most gamepads that support vibration have 2. If we can get them to work it into that spec, even better.", "creator": "ted@mielczarek.org", "creation_time": "2011-12-12T16:01:28Z", "is_private": false, "attachment_id": null, "tags": []}, {"bug_id": 680289, "id": 5908820, "is_private": false, "creation_time": "2011-12-12T16:42:23Z", "creator": "bobby@mozillafoundation.org", "count": 9, "text": "I don't mind that, only because it doesn't really try to expose any other features of the force-feedback. i.e. it only involves time, and there is a minimal amount of code to write to support the `pattern` functionality over and above supporting gamepad FF in general.\n\nI'd like to keep our API close to something like XInput's, which is very simple. So, I definitely don't mind this:\n\nvoid vibrate(optional unsigned long[] pattern, optional unsigned long weakMagnitude, optional unsigned long strongMagnitude);", "author": "bobby@mozillafoundation.org", "tags": [], "time": "2011-12-12T16:42:23Z", "raw_text": "I don't mind that, only because it doesn't really try to expose any other features of the force-feedback. i.e. it only involves time, and there is a minimal amount of code to write to support the `pattern` functionality over and above supporting gamepad FF in general.\n\nI'd like to keep our API close to something like XInput's, which is very simple. So, I definitely don't mind this:\n\nvoid vibrate(optional unsigned long[] pattern, optional unsigned long weakMagnitude, optional unsigned long strongMagnitude);", "attachment_id": null}, {"creator": "ted@mielczarek.org", "is_private": false, "creation_time": "2011-12-12T18:22:07Z", "attachment_id": null, "tags": [], "text": "Maybe that should be:\nvoid vibrate(optional unsigned long[] pattern, optional unsigned long[] magnitudes);\n?\n\nThat way you could support an arbitrary number of motors.\n\nAlso the first method could become:\nvoid vibrate (optional unsigned long time, optional unsigned long magnitude)\n\nTo vibrate everything at a specified magnitude.", "count": 10, "author": "ted@mielczarek.org", "id": 5909230, "bug_id": 680289, "time": "2011-12-12T18:22:07Z", "raw_text": "Maybe that should be:\nvoid vibrate(optional unsigned long[] pattern, optional unsigned long[] magnitudes);\n?\n\nThat way you could support an arbitrary number of motors.\n\nAlso the first method could become:\nvoid vibrate (optional unsigned long time, optional unsigned long magnitude)\n\nTo vibrate everything at a specified magnitude."}, {"tags": [], "raw_text": "(In reply to Ted Mielczarek [:ted, :luser] from comment #10)\n> Maybe that should be:\n> void vibrate(optional unsigned long[] pattern, optional unsigned long[]\n> magnitudes);\n> ?\n\nsgtm, except I don't really like the 65536-based magnitudes. I'd prefer float (or double?) normalized magnitudes that are scaled based on the device&API when applied. Seem reasonable?", "attachment_id": null, "time": "2011-12-12T19:20:28Z", "is_private": false, "creation_time": "2011-12-12T19:20:28Z", "bug_id": 680289, "id": 5909479, "count": 11, "text": "(In reply to Ted Mielczarek [:ted, :luser] from comment #10)\n> Maybe that should be:\n> void vibrate(optional unsigned long[] pattern, optional unsigned long[]\n> magnitudes);\n> ?\n\nsgtm, except I don't really like the 65536-based magnitudes. I'd prefer float (or double?) normalized magnitudes that are scaled based on the device&API when applied. Seem reasonable?", "author": "scott.mozilla@h4ck3r.net", "creator": "scott.mozilla@h4ck3r.net"}, {"tags": [], "attachment_id": null, "is_private": false, "creation_time": "2011-12-12T19:28:13Z", "creator": "ted@mielczarek.org", "time": "2011-12-12T19:28:13Z", "raw_text": "I am completely faking it here, just trying to achieve harmony with the existing WebVibration stuff. :)", "bug_id": 680289, "id": 5909504, "author": "ted@mielczarek.org", "count": 12, "text": "I am completely faking it here, just trying to achieve harmony with the existing WebVibration stuff. :)"}, {"tags": [], "raw_text": "Can you vibrate the N motors independently?\n\nIf so, it seems like the gamepad should expose an array of objects on which you can call vibrate.", "attachment_id": null, "time": "2011-12-12T23:14:44Z", "is_private": false, "creation_time": "2011-12-12T23:14:44Z", "bug_id": 680289, "id": 5910442, "text": "Can you vibrate the N motors independently?\n\nIf so, it seems like the gamepad should expose an array of objects on which you can call vibrate.", "count": 13, "author": "justin.lebar+bug@gmail.com", "creator": "justin.lebar+bug@gmail.com"}, {"bug_id": 680289, "id": 5910474, "is_private": false, "creation_time": "2011-12-12T23:24:21Z", "creator": "bobby@mozillafoundation.org", "count": 14, "text": "> If so, it seems like the gamepad should expose an array of objects on which\n> you can call vibrate.\n\nThat's not a bad idea. It does deviate quite a bit from WebVibrator though, and adds a bunch of new code to the prototype.\n\nSimplicity might be key.", "author": "bobby@mozillafoundation.org", "tags": [], "time": "2011-12-12T23:24:21Z", "raw_text": "> If so, it seems like the gamepad should expose an array of objects on which\n> you can call vibrate.\n\nThat's not a bad idea. It does deviate quite a bit from WebVibrator though, and adds a bunch of new code to the prototype.\n\nSimplicity might be key.", "attachment_id": null}, {"attachment_id": null, "tags": [], "creator": "justin.lebar+bug@gmail.com", "creation_time": "2011-12-12T23:34:45Z", "is_private": false, "time": "2011-12-12T23:34:45Z", "raw_text": "Well, WebVibrator as spec'ed by w3c [1] is just an interface:\n\ninterface Vibration {\n    void vibrate (optional unsigned long time) raises (NotSupportedError);\n    void vibrate (optional unsigned long[] pattern) raises (NotSupportedError);\n};\n\nyou can stick that interface on whatever object you'd like.\n\nBut I guess you're right -- having multiple vibrators isn't a problem exclusively related to gamepads, so maybe we should solve it in the vibrator API itself.\n\nHow does the page know what values it can pass for magnitude[]?\n\n[1] http://dev.w3.org/2009/dap/vibration/", "text": "Well, WebVibrator as spec'ed by w3c [1] is just an interface:\n\ninterface Vibration {\n    void vibrate (optional unsigned long time) raises (NotSupportedError);\n    void vibrate (optional unsigned long[] pattern) raises (NotSupportedError);\n};\n\nyou can stick that interface on whatever object you'd like.\n\nBut I guess you're right -- having multiple vibrators isn't a problem exclusively related to gamepads, so maybe we should solve it in the vibrator API itself.\n\nHow does the page know what values it can pass for magnitude[]?\n\n[1] http://dev.w3.org/2009/dap/vibration/", "count": 15, "author": "justin.lebar+bug@gmail.com", "id": 5910515, "bug_id": 680289}, {"bug_id": 680289, "id": 7226665, "creation_time": "2013-03-20T21:15:48Z", "is_private": false, "creator": "kyle@nonpolynomial.com", "author": "kyle@nonpolynomial.com", "count": 16, "text": "Bobby: You still looking at this? If not I might be interested in taking it.", "tags": [], "time": "2013-03-20T21:15:48Z", "attachment_id": null, "raw_text": "Bobby: You still looking at this? If not I might be interested in taking it."}, {"time": "2013-03-20T21:55:10Z", "raw_text": "By all means! Unfortunately, my bandwidth for this ran out and my code is based on Ted's year-old joystick patches, so it might not be a useful starting point. Happy to help if I still can.", "attachment_id": null, "tags": [], "creator": "bobby@mozillafoundation.org", "text": "By all means! Unfortunately, my bandwidth for this ran out and my code is based on Ted's year-old joystick patches, so it might not be a useful starting point. Happy to help if I still can.", "count": 17, "author": "bobby@mozillafoundation.org", "bug_id": 680289, "id": 7226808, "is_private": false, "creation_time": "2013-03-20T21:55:10Z"}, {"creator": "kyle@nonpolynomial.com", "is_private": false, "creation_time": "2013-03-29T19:25:22Z", "attachment_id": null, "tags": [], "author": "kyle@nonpolynomial.com", "count": 18, "text": "So, in true \"taking over a bug\" style... \n\nThis is not how force feedback usually works. You don't just \"call vibrate\". I realize we'd like to keep our API \"simple\", but if we'd like to future proof this, it's not a call I feel like we get to make against the rest of gaming in general.\n\nAs Bobby outlined in his blog post, FF is usually a set of effects that are built into a struct, then uploaded to the controller, in order to reduce bandwidth and make common effects reusable. So you can upload bullet firing effects once during weapons changes, for instance, while still operating on the usual USB low-speed connection most HID devices enjoy. That's why there's things like RAM/ROM size block configuration in the PID spec, which is what most APIs are built off of, even if very few people actually use the specific PID spec anymore (see files ending with \"ff\" before the extension in the drivers/hid directory of the linux kernel to witness the vendor-specific sadness full on).\n\nNot only that, effects are considered to be force mixed across motors via the controller firmware's translation of the effects, because force feedback is about simulating feeling, not just vibrating something, and that's what the spec was designed for (which is why you can't set PID per motor, like what WebVibrate does). Between crazy polymer based tactile surface solutions and what not, we're moving towards motors not being the only actuator for joysticks, and we expect controller firmware to still handle effect translation to whatever new actuators we add to controllers. So just vibrating isn't really a solution.\n\nAssume we want to stay with the way everyone else does it, it's expected you have a struct that basically mirrors the effects laid out in the PID spec (which mirrors DirectInput, because MS and immersion wrote it), which are then sent in a platform specific way to the joystick (handled by the kernel on linux, vendor specific drivers or pid.dll on windows, magic fairy dust on OS X). The only API I know that currently handles full cross platform force feedback is libsdl 2.0. For those curious, the code is at\n\nhttp://hg.libsdl.org/SDL/file/3242aa26100f/src/haptic\n\nlibsdl 2.0 isn't in full release yet, but now it's zlib licensed instead of lgpl now. So, we could feasibly make a struct similar to their unified effects system, and possibly just use the SDL 2 layer? We could also do our own implementation, but we'd basically be reimplementing what they've done.", "id": 7258505, "bug_id": 680289, "time": "2013-03-29T19:25:22Z", "raw_text": "So, in true \"taking over a bug\" style... \n\nThis is not how force feedback usually works. You don't just \"call vibrate\". I realize we'd like to keep our API \"simple\", but if we'd like to future proof this, it's not a call I feel like we get to make against the rest of gaming in general.\n\nAs Bobby outlined in his blog post, FF is usually a set of effects that are built into a struct, then uploaded to the controller, in order to reduce bandwidth and make common effects reusable. So you can upload bullet firing effects once during weapons changes, for instance, while still operating on the usual USB low-speed connection most HID devices enjoy. That's why there's things like RAM/ROM size block configuration in the PID spec, which is what most APIs are built off of, even if very few people actually use the specific PID spec anymore (see files ending with \"ff\" before the extension in the drivers/hid directory of the linux kernel to witness the vendor-specific sadness full on).\n\nNot only that, effects are considered to be force mixed across motors via the controller firmware's translation of the effects, because force feedback is about simulating feeling, not just vibrating something, and that's what the spec was designed for (which is why you can't set PID per motor, like what WebVibrate does). Between crazy polymer based tactile surface solutions and what not, we're moving towards motors not being the only actuator for joysticks, and we expect controller firmware to still handle effect translation to whatever new actuators we add to controllers. So just vibrating isn't really a solution.\n\nAssume we want to stay with the way everyone else does it, it's expected you have a struct that basically mirrors the effects laid out in the PID spec (which mirrors DirectInput, because MS and immersion wrote it), which are then sent in a platform specific way to the joystick (handled by the kernel on linux, vendor specific drivers or pid.dll on windows, magic fairy dust on OS X). The only API I know that currently handles full cross platform force feedback is libsdl 2.0. For those curious, the code is at\n\nhttp://hg.libsdl.org/SDL/file/3242aa26100f/src/haptic\n\nlibsdl 2.0 isn't in full release yet, but now it's zlib licensed instead of lgpl now. So, we could feasibly make a struct similar to their unified effects system, and possibly just use the SDL 2 layer? We could also do our own implementation, but we'd basically be reimplementing what they've done."}, {"creation_time": "2013-03-29T20:09:07Z", "is_private": false, "bug_id": 680289, "id": 7258640, "author": "kyle@nonpolynomial.com", "count": 19, "text": "Also: This API should have nothing to do with WebVibrate in terms of similarity. They're used for far different things. \n\nThat said, we could certainly implement WebVibrate backends for desktop under an actual FF API, just by having it send effects.", "creator": "kyle@nonpolynomial.com", "tags": [], "attachment_id": null, "raw_text": "Also: This API should have nothing to do with WebVibrate in terms of similarity. They're used for far different things. \n\nThat said, we could certainly implement WebVibrate backends for desktop under an actual FF API, just by having it send effects.", "time": "2013-03-29T20:09:07Z"}, {"tags": [], "attachment_id": null, "raw_text": "We're not actually aiming to implement \"force feedback support\". Most modern gamepads simply have one or two motors whose speed you can control. This is fairly similar to WebVibrate.\n\nSee XInput, for example:\nhttp://msdn.microsoft.com/en-us/library/windows/desktop/ee417001%28v=vs.85%29.aspx#setting_vibration_effects\n\nI think something like this is what we'd spec, if anything.", "time": "2013-03-29T22:33:17Z", "creation_time": "2013-03-29T22:33:17Z", "is_private": false, "id": 7259136, "bug_id": 680289, "author": "ted@mielczarek.org", "text": "We're not actually aiming to implement \"force feedback support\". Most modern gamepads simply have one or two motors whose speed you can control. This is fairly similar to WebVibrate.\n\nSee XInput, for example:\nhttp://msdn.microsoft.com/en-us/library/windows/desktop/ee417001%28v=vs.85%29.aspx#setting_vibration_effects\n\nI think something like this is what we'd spec, if anything.", "count": 20, "creator": "ted@mielczarek.org"}, {"time": "2013-03-29T23:16:08Z", "raw_text": "Well damn. I saw XInput (missed the first msdn comment) and a linux implementation and was thinking \"Why on earth are we going after X11/xorg style input drivers? Can those even hit FF?\". Yay for overloaded terms.\n\nSeeing the XInput API from Microsoft makes this whole thing make way more sense. Also wasn't aware that MS wasn't even officially supporting DI structures for the 360 controller anymore.\n\nI will return to quietly rallying for more expressive haptics in games while also shutting up, returning the bug to rumble, and getting that implemented. :)", "author": "kyle@nonpolynomial.com", "count": 21, "text": "Well damn. I saw XInput (missed the first msdn comment) and a linux implementation and was thinking \"Why on earth are we going after X11/xorg style input drivers? Can those even hit FF?\". Yay for overloaded terms.\n\nSeeing the XInput API from Microsoft makes this whole thing make way more sense. Also wasn't aware that MS wasn't even officially supporting DI structures for the 360 controller anymore.\n\nI will return to quietly rallying for more expressive haptics in games while also shutting up, returning the bug to rumble, and getting that implemented. :)", "bug_id": 680289, "id": 7259290, "attachment_id": null, "tags": [], "creator": "kyle@nonpolynomial.com", "creation_time": "2013-03-29T23:16:08Z", "is_private": false}, {"raw_text": "So, as bug 852944 gets closer to landing, I've been considering taking this bug up again. It'd really be nice to have something in the API for controller rumble. \n\nI'm still on board for something XInput-ish versus all out force feedback (my racing wheel will have to wait for the web yet another day :c ), but it feels like this should live in the Gamepad API, not the Vibration API. The Vibration API seems solely focused at mobile device vibration, and lacks the ability to select multiple vibration devices, set vibration magnitudes, etc.\n\nTed, in terms of spec work, should this be added to the gamepad API, or do we want to start an another spec and add it as a partial interface implementation?", "attachment_id": null, "time": "2015-02-26T05:56:36Z", "tags": [], "text": "So, as bug 852944 gets closer to landing, I've been considering taking this bug up again. It'd really be nice to have something in the API for controller rumble. \n\nI'm still on board for something XInput-ish versus all out force feedback (my racing wheel will have to wait for the web yet another day :c ), but it feels like this should live in the Gamepad API, not the Vibration API. The Vibration API seems solely focused at mobile device vibration, and lacks the ability to select multiple vibration devices, set vibration magnitudes, etc.\n\nTed, in terms of spec work, should this be added to the gamepad API, or do we want to start an another spec and add it as a partial interface implementation?", "count": 22, "author": "kyle@nonpolynomial.com", "creator": "kyle@nonpolynomial.com", "is_private": false, "creation_time": "2015-02-26T05:56:36Z", "bug_id": 680289, "id": 9960360}, {"id": 9965114, "bug_id": 680289, "count": 23, "text": "I'm sorta on the fence about that. I don't want to have to innovate here if we can reuse, but at the same time the WebVibration spec doesn't seem to cover the use cases of even the XInput-style API where you have >1 vibration motor and they can be set to different magnitudes.\n\nDo the vibration motors in phones that the Vibration API is targeted to cover support changing the magnitude? If not then there's probably no point in trying to unify the APIs. If so maybe it makes sense to try to unify them and turn it into a partial interface and then we could do something like\ninterface Gamepad {\n  Vibration[] rumbleMotors;\n}", "author": "ted@mielczarek.org", "raw_text": "I'm sorta on the fence about that. I don't want to have to innovate here if we can reuse, but at the same time the WebVibration spec doesn't seem to cover the use cases of even the XInput-style API where you have >1 vibration motor and they can be set to different magnitudes.\n\nDo the vibration motors in phones that the Vibration API is targeted to cover support changing the magnitude? If not then there's probably no point in trying to unify the APIs. If so maybe it makes sense to try to unify them and turn it into a partial interface and then we could do something like\ninterface Gamepad {\n  Vibration[] rumbleMotors;\n}", "time": "2015-02-27T01:12:25Z", "creation_time": "2015-02-27T01:12:25Z", "is_private": false, "creator": "ted@mielczarek.org", "tags": [], "attachment_id": null}, {"attachment_id": null, "tags": [], "creator": "kyle@nonpolynomial.com", "is_private": false, "creation_time": "2015-02-27T01:41:48Z", "time": "2015-02-27T01:41:48Z", "raw_text": "The WebVibration API looks really similar to the Android Vibration API: \n\nhttp://developer.android.com/reference/android/os/Vibrator.html\n\nBasically, the only functionality is \"Turn the motor all the way on for a specified period of time, then all the way off for a specified period of time\". There's no variability to magnitude of the signal.\n\nWith the very, very wide range of vibration actuators that can show up in phones (super cheap phones sometimes combine their speaker and their vibrator in the same unit, for instance), not to mention power concerns related to variable pulse width, it doesn't seem like there'd be much interest in adding variable vibration to the WebVibration API. \n\nThis isn't to say you /can't/ do variable vibration on phones. For instance, Immersion has a Android library specifically for force feedback effects on phones (http://immersion.com/products/touchsense-tactile-feedback/3000-series/index.html). But as far as I'm aware, it's a JNI library, so they're doing things under the covers in C/C++, so I'm not sure that really \"counts\" for this discussion.\n\nI'm still for adding force feedback specifically for Gamepad. We can discuss it with the Vibration spec people, but I have a feeling they're going to feel similarly.", "author": "kyle@nonpolynomial.com", "text": "The WebVibration API looks really similar to the Android Vibration API: \n\nhttp://developer.android.com/reference/android/os/Vibrator.html\n\nBasically, the only functionality is \"Turn the motor all the way on for a specified period of time, then all the way off for a specified period of time\". There's no variability to magnitude of the signal.\n\nWith the very, very wide range of vibration actuators that can show up in phones (super cheap phones sometimes combine their speaker and their vibrator in the same unit, for instance), not to mention power concerns related to variable pulse width, it doesn't seem like there'd be much interest in adding variable vibration to the WebVibration API. \n\nThis isn't to say you /can't/ do variable vibration on phones. For instance, Immersion has a Android library specifically for force feedback effects on phones (http://immersion.com/products/touchsense-tactile-feedback/3000-series/index.html). But as far as I'm aware, it's a JNI library, so they're doing things under the covers in C/C++, so I'm not sure that really \"counts\" for this discussion.\n\nI'm still for adding force feedback specifically for Gamepad. We can discuss it with the Vibration spec people, but I have a feeling they're going to feel similarly.", "count": 24, "bug_id": 680289, "id": 9965188}, {"bug_id": 680289, "id": 9965772, "count": 25, "text": "I think you'll definitely need a new API for gamepad rumble. If for no other reason than that you need to specify which of the gamepads should rumble.\n\nI also don't think that we should make a gamepad rumble if navigator.vibrate() is called on a desktop which has a gamepad connected. I.e. I think navigator.vibrate() should map to vibrating the device, and the device only. (If the device doesn't have vibration capabilities, we should probably hide the naviagator.vibrate() function, which is what we do now).\n\nWhat we can reuse though is the syntax. So right now navigator.vibrate() takes an integer, or an array of integers. The same could be done for gamepad.vibrate() (or whatever the function will live).\n\nBut yeah, we'd also need to invent syntax for specifying strength. That's definitely a bummer that that can't be reused from the existing API.", "author": "jonas@sicking.cc", "raw_text": "I think you'll definitely need a new API for gamepad rumble. If for no other reason than that you need to specify which of the gamepads should rumble.\n\nI also don't think that we should make a gamepad rumble if navigator.vibrate() is called on a desktop which has a gamepad connected. I.e. I think navigator.vibrate() should map to vibrating the device, and the device only. (If the device doesn't have vibration capabilities, we should probably hide the naviagator.vibrate() function, which is what we do now).\n\nWhat we can reuse though is the syntax. So right now navigator.vibrate() takes an integer, or an array of integers. The same could be done for gamepad.vibrate() (or whatever the function will live).\n\nBut yeah, we'd also need to invent syntax for specifying strength. That's definitely a bummer that that can't be reused from the existing API.", "time": "2015-02-27T05:42:18Z", "is_private": false, "creation_time": "2015-02-27T05:42:18Z", "creator": "jonas@sicking.cc", "tags": [], "attachment_id": null}, {"author": "kyle@nonpolynomial.com", "text": "I'm not sure how much of that syntax we can reuse, actually. navigator.vibrate() takes integers because it's only dealing with milliseconds, and the vibrator is either just on or off during those times. We'll also need to specify magnitudes, which may be best scaled between 0.0 and 1.0, and mentioned earlier in this thread? So we could do something like pairs of (magnitude, time) or something.", "count": 26, "bug_id": 680289, "id": 9965885, "raw_text": "I'm not sure how much of that syntax we can reuse, actually. navigator.vibrate() takes integers because it's only dealing with milliseconds, and the vibrator is either just on or off during those times. We'll also need to specify magnitudes, which may be best scaled between 0.0 and 1.0, and mentioned earlier in this thread? So we could do something like pairs of (magnitude, time) or something.", "time": "2015-02-27T07:05:11Z", "creator": "kyle@nonpolynomial.com", "is_private": false, "creation_time": "2015-02-27T07:05:11Z", "attachment_id": null, "tags": []}, {"id": 9965943, "bug_id": 680289, "text": "Yeah, signaling one or more pairs of <time, strength> seems like the way to go. Maybe something like:\n\n.vibrate([{ time: 200, strength: 0.5 }, { time: 200, strength: 0.3 }, { time: 200, strength: 0.1 }])\n\nor\n\n.vibrate([[200, 0.5], [200, 0.3], [200, 0.1]])\n\n\nI don't have an opinion really.", "count": 27, "author": "jonas@sicking.cc", "raw_text": "Yeah, signaling one or more pairs of <time, strength> seems like the way to go. Maybe something like:\n\n.vibrate([{ time: 200, strength: 0.5 }, { time: 200, strength: 0.3 }, { time: 200, strength: 0.1 }])\n\nor\n\n.vibrate([[200, 0.5], [200, 0.3], [200, 0.1]])\n\n\nI don't have an opinion really.", "time": "2015-02-27T07:45:41Z", "creation_time": "2015-02-27T07:45:41Z", "is_private": false, "creator": "jonas@sicking.cc", "tags": [], "attachment_id": null}, {"id": 9966355, "bug_id": 680289, "count": 28, "text": "(In reply to Jonas Sicking (:sicking) from comment #25)\n> I think you'll definitely need a new API for gamepad rumble. If for no other\n> reason than that you need to specify which of the gamepads should rumble.\n\nMy intent was never to make navigator.vibrate() work for Gamepads, but to see if we could make .vibrate() into a partial interface on Navigator and then reuse it for Gamepad.vibrate(). It sounds like that's probably not useful, so I'd say invent whatever is useful here and once we have a prototype in hand we can see if there's any way to harmonize them.", "author": "ted@mielczarek.org", "raw_text": "(In reply to Jonas Sicking (:sicking) from comment #25)\n> I think you'll definitely need a new API for gamepad rumble. If for no other\n> reason than that you need to specify which of the gamepads should rumble.\n\nMy intent was never to make navigator.vibrate() work for Gamepads, but to see if we could make .vibrate() into a partial interface on Navigator and then reuse it for Gamepad.vibrate(). It sounds like that's probably not useful, so I'd say invent whatever is useful here and once we have a prototype in hand we can see if there's any way to harmonize them.", "time": "2015-02-27T12:17:40Z", "creation_time": "2015-02-27T12:17:40Z", "is_private": false, "creator": "ted@mielczarek.org", "tags": [], "attachment_id": null}, {"tags": [], "attachment_id": null, "is_private": false, "creation_time": "2016-12-13T23:00:03Z", "creator": "kyle@nonpolynomial.com", "raw_text": "Looks like there's development happening around this in WebVR that will most likely influence this and I'm quite busy on other things, so I'll let someone else take care of it.", "time": "2016-12-13T23:00:03Z", "id": 11917225, "bug_id": 680289, "author": "kyle@nonpolynomial.com", "count": 29, "text": "Looks like there's development happening around this in WebVR that will most likely influence this and I'm quite busy on other things, so I'll let someone else take care of it."}, {"creator": "kyle@nonpolynomial.com", "text": "There's discussion about this happening at https://github.com/mozilla/standards-positions/issues/49, and work happening in VR that may put this closer to happening on the regular gamepad side of things.", "count": 30, "author": "kyle@nonpolynomial.com", "bug_id": 680289, "id": 13423743, "is_private": false, "creation_time": "2018-06-25T06:18:55Z", "time": "2018-06-25T06:18:55Z", "raw_text": "There's discussion about this happening at https://github.com/mozilla/standards-positions/issues/49, and work happening in VR that may put this closer to happening on the regular gamepad side of things.", "attachment_id": null, "tags": []}, {"time": "2018-10-19T18:54:11Z", "attachment_id": null, "raw_text": "", "tags": [], "creator": "kyle@nonpolynomial.com", "author": "kyle@nonpolynomial.com", "count": 31, "text": "*** Bug 1496755 has been marked as a duplicate of this bug. ***", "id": 13699573, "bug_id": 680289, "is_private": false, "creation_time": "2018-10-19T18:54:11Z"}]}}}