{"comments": {}, "bugs": {"1633943": {"comments": [{"is_private": false, "bug_id": 1633943, "text": "`webext_storage::Store::close` landed in https://github.com/mozilla/application-services/pull/3042, let's upgrade our vendored a-s version to support that.\n\nOne thing I've been thinking about over the last couple of days is how to handle errors from `close`/`teardown`. Rusqlite connections have a [`Drop` implementation](https://github.com/rusqlite/rusqlite/blob/65ef2224b6c36ee7d298331ee45349844a8bed80/src/inner_connection.rs#L298-L311) that tries to automatically close the connection, and panic if that fails. On Desktop, this will cause a crash, since we compile with [`panic = \"abort\"`](https://searchfox.org/mozilla-central/rev/2bfe3415fb3a2fba9b1c694bc0b376365e086927/Cargo.toml#59,65).\n\nEven if we don't crash, though, dropping the last reference to a Rust `StorageSyncArea` XPCOM class without calling `teardown` will drop its `LazyStore`, which drops its `webext_storage::Store`, which drops its `rusqlite::Connection`, which drops its `InnerConnection`...which closes the connection on the main thread.\n\nWhile this isn't ideal, I think it's OK as a last resort\u2014especially since mozStorage does [something similar](https://searchfox.org/mozilla-central/rev/2bfe3415fb3a2fba9b1c694bc0b376365e086927/storage/mozStorageConnection.cpp#541-543). Consumers should always call `teardown` explicitly, and not rely on automatic cleanup by the last reference falling out of scope. As Mark points out in [this comment](https://github.com/mozilla/application-services/pull/3042#discussion_r416404414), \"the last reference falling out of scope\" is a hazy concept, because XPCOM objects in JS are GCed\u2014meaning XPConnect will release the object sometime later, not immediately.\n\nIt's also an edge case within an edge case: 1) we'll only synchronously close the connection on the main thread if a) someone is misusing a `StorageSyncArea`, which shouldn't happen given that we have our `StorageSyncService` always holding one strong reference, and that's what Sync and `ExtensionStorageSync.jsm` go through, or b) dispatching the `teardown` runnable fails, which should only happen at shutdown, and causes a leak, anyway...and 2) we'll only crash if `close` itself fails, which it shouldn't given that we serialize all operations on the task queue, and `rusqlite::Connection::close` already cleans up cached statements before trying to close the connection.\n\nThat's a really, really wordy explanation for a dozen-line change, but the two issues there are subtle, and I wanted to capture them somewhere.", "author": "lina@yakshaving.ninja", "id": 14785307, "attachment_id": null, "time": "2020-04-28T23:55:41Z", "creator": "lina@yakshaving.ninja", "tags": [], "count": 0, "creation_time": "2020-04-28T23:55:41Z", "raw_text": "`webext_storage::Store::close` landed in https://github.com/mozilla/application-services/pull/3042, let's upgrade our vendored a-s version to support that.\n\nOne thing I've been thinking about over the last couple of days is how to handle errors from `close`/`teardown`. Rusqlite connections have a [`Drop` implementation](https://github.com/rusqlite/rusqlite/blob/65ef2224b6c36ee7d298331ee45349844a8bed80/src/inner_connection.rs#L298-L311) that tries to automatically close the connection, and panic if that fails. On Desktop, this will cause a crash, since we compile with [`panic = \"abort\"`](https://searchfox.org/mozilla-central/rev/2bfe3415fb3a2fba9b1c694bc0b376365e086927/Cargo.toml#59,65).\n\nEven if we don't crash, though, dropping the last reference to a Rust `StorageSyncArea` XPCOM class without calling `teardown` will drop its `LazyStore`, which drops its `webext_storage::Store`, which drops its `rusqlite::Connection`, which drops its `InnerConnection`...which closes the connection on the main thread.\n\nWhile this isn't ideal, I think it's OK as a last resort\u2014especially since mozStorage does [something similar](https://searchfox.org/mozilla-central/rev/2bfe3415fb3a2fba9b1c694bc0b376365e086927/storage/mozStorageConnection.cpp#541-543). Consumers should always call `teardown` explicitly, and not rely on automatic cleanup by the last reference falling out of scope. As Mark points out in [this comment](https://github.com/mozilla/application-services/pull/3042#discussion_r416404414), \"the last reference falling out of scope\" is a hazy concept, because XPCOM objects in JS are GCed\u2014meaning XPConnect will release the object sometime later, not immediately.\n\nIt's also an edge case within an edge case: 1) we'll only synchronously close the connection on the main thread if a) someone is misusing a `StorageSyncArea`, which shouldn't happen given that we have our `StorageSyncService` always holding one strong reference, and that's what Sync and `ExtensionStorageSync.jsm` go through, or b) dispatching the `teardown` runnable fails, which should only happen at shutdown, and causes a leak, anyway...and 2) we'll only crash if `close` itself fails, which it shouldn't given that we serialize all operations on the task queue, and `rusqlite::Connection::close` already cleans up cached statements before trying to close the connection.\n\nThat's a really, really wordy explanation for a dozen-line change, but the two issues there are subtle, and I wanted to capture them somewhere."}, {"creation_time": "2020-04-29T01:06:28Z", "count": 1, "raw_text": "\nThis commit wires up `StorageSyncArea::teardown()` to call the new\n`webext_storage::Store::close()` method.\n\nIt also changes `teardown` to drop the `LazyStore`, and thus close its\ndatabase connection, on the main thread if dispatching to the task\nqueue fails. Dispatch should only fail at shutdown, and putting the\nowned reference back only adds indirection, since the `StorageSyncArea`\nwill still drop its `LazyStore` later in shutdown.", "time": "2020-04-29T01:06:28Z", "creator": "lina@yakshaving.ninja", "tags": [], "text": "Created attachment 9144214\nBug 1633943 - Support tearing down a Rust `StorageSyncArea`. r?markh!\n\n\nThis commit wires up `StorageSyncArea::teardown()` to call the new\n`webext_storage::Store::close()` method.\n\nIt also changes `teardown` to drop the `LazyStore`, and thus close its\ndatabase connection, on the main thread if dispatching to the task\nqueue fails. Dispatch should only fail at shutdown, and putting the\nowned reference back only adds indirection, since the `StorageSyncArea`\nwill still drop its `LazyStore` later in shutdown.", "attachment_id": 9144214, "id": 14785378, "author": "lina@yakshaving.ninja", "bug_id": 1633943, "is_private": false}, {"id": 14785436, "author": "chiovolonit@gmail.com", "raw_text": "> One thing I've been thinking about over the last couple of days is how to handle errors from close/teardown. Rusqlite connections have a Drop implementation that tries to automatically close the connection, and panic if that fails. On Desktop, this will cause a crash, since we compile with panic = \"abort\".\n\nWorth noting that this behavior is not set in stone. There's an open rusqlite bug about avoiding panics for essentially this reason: https://github.com/rusqlite/rusqlite/issues/688. The `drop` panic is one I was thinking about when I filed that issue. In all likelihood turning it to a warning is probably acceptable.\n\nThat said I don't have any objections here, the rest of your rationale is good.", "attachment_id": null, "count": 2, "text": "> One thing I've been thinking about over the last couple of days is how to handle errors from close/teardown. Rusqlite connections have a Drop implementation that tries to automatically close the connection, and panic if that fails. On Desktop, this will cause a crash, since we compile with panic = \"abort\".\n\nWorth noting that this behavior is not set in stone. There's an open rusqlite bug about avoiding panics for essentially this reason: https://github.com/rusqlite/rusqlite/issues/688. The `drop` panic is one I was thinking about when I filed that issue. In all likelihood turning it to a warning is probably acceptable.\n\nThat said I don't have any objections here, the rest of your rationale is good.", "creation_time": "2020-04-29T02:20:54Z", "is_private": false, "bug_id": 1633943, "tags": [], "creator": "chiovolonit@gmail.com", "time": "2020-04-29T02:20:54Z"}, {"tags": [], "creator": "pulsebot@bots.tld", "time": "2020-04-29T04:47:56Z", "raw_text": "Pushed by kcambridge@mozilla.com:\nhttps://hg.mozilla.org/integration/autoland/rev/cfdd3c486d42\nSupport tearing down a Rust `StorageSyncArea`. r=markh", "creation_time": "2020-04-29T04:47:56Z", "count": 3, "is_private": false, "bug_id": 1633943, "attachment_id": null, "author": "pulsebot@bots.tld", "id": 14785543, "text": "Pushed by kcambridge@mozilla.com:\nhttps://hg.mozilla.org/integration/autoland/rev/cfdd3c486d42\nSupport tearing down a Rust `StorageSyncArea`. r=markh"}, {"tags": [], "creator": "lina@yakshaving.ninja", "time": "2020-04-29T05:01:03Z", "raw_text": "Thanks, Thom, that was exactly the ticket I was looking for! \ud83d\udc9c Replacing the panics would be great to do eventually, but definitely not urgent, I know there's a pile of fixes you'd like to get in there first.\n\nI also thought about wrapping the Rusqlite connection in a `ManuallyDrop`, and having the wrapper's destructor leak it if `close()` failed, but it felt like _such_ an edge case that it didn't seem to be worth the acrobatics.", "creation_time": "2020-04-29T05:01:03Z", "count": 4, "bug_id": 1633943, "is_private": false, "attachment_id": null, "author": "lina@yakshaving.ninja", "id": 14785550, "text": "Thanks, Thom, that was exactly the ticket I was looking for! \ud83d\udc9c Replacing the panics would be great to do eventually, but definitely not urgent, I know there's a pile of fixes you'd like to get in there first.\n\nI also thought about wrapping the Rusqlite connection in a `ManuallyDrop`, and having the wrapper's destructor leak it if `close()` failed, but it felt like _such_ an edge case that it didn't seem to be worth the acrobatics."}, {"text": "https://hg.mozilla.org/mozilla-central/rev/cfdd3c486d42", "id": 14785822, "author": "csabou@mozilla.com", "attachment_id": null, "is_private": false, "bug_id": 1633943, "count": 5, "creation_time": "2020-04-29T09:56:46Z", "raw_text": "https://hg.mozilla.org/mozilla-central/rev/cfdd3c486d42", "time": "2020-04-29T09:56:46Z", "creator": "csabou@mozilla.com", "tags": ["bugherder"]}, {"raw_text": "", "attachment_id": null, "id": 14787637, "author": "lina@yakshaving.ninja", "creation_time": "2020-04-30T02:43:38Z", "count": 6, "text": "*** Bug 1633363 has been marked as a duplicate of this bug. ***", "tags": [], "bug_id": 1633943, "is_private": false, "creator": "lina@yakshaving.ninja", "time": "2020-04-30T02:43:38Z"}]}}}