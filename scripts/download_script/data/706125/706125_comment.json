{"comments": {}, "bugs": {"706125": {"comments": [{"is_private": false, "count": 0, "id": 5878969, "creator": "support@educdesign.lu", "creation_time": "2011-11-29T16:13:47Z", "time": "2011-11-29T16:13:47Z", "author": "support@educdesign.lu", "attachment_id": 577624, "raw_text": "User Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_2) AppleWebKit/534.51.22 (KHTML, like Gecko) Version/5.1.1 Safari/534.51.22\n\nSteps to reproduce:\n\nI refreshed a page with an active BOSH-XMPP session using strophe.\n\nMy detailed stackoverflow description and bughunt can be found here: http://stackoverflow.com/questions/7752475/strophe-sending-double-request-on-page-unload\n\n* To reproduce the bug *\n1) Go to the isolated test environment i have set up for you folks: http://prerelease.olefa.com/resources/test/index.html\n2) If the username field is empty, refresh the page (annoying little bug I didn't get out)\n3) Use the password MozSupp667 and click 'login'\n4) refresh the page\n\n\nActual results:\n\nThe long-polling ajax request is aborted by firefox. However, firefox starts the very same request again. Due to the specifications of XMPP (in particular regarding the rid-attribute), the chat session is terminated. As a consequence, the chat session is killed after every page reload or navigation.\n\n\nExpected results:\n\nThe second request, using the exact same rid, shouldn't have been made. This bug is particular to firefox, every other browser behaves as expected.", "bug_id": 706125, "text": "Created attachment 577624\nFirebug showing the duplicate ajax-request\n\nUser Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_2) AppleWebKit/534.51.22 (KHTML, like Gecko) Version/5.1.1 Safari/534.51.22\n\nSteps to reproduce:\n\nI refreshed a page with an active BOSH-XMPP session using strophe.\n\nMy detailed stackoverflow description and bughunt can be found here: http://stackoverflow.com/questions/7752475/strophe-sending-double-request-on-page-unload\n\n* To reproduce the bug *\n1) Go to the isolated test environment i have set up for you folks: http://prerelease.olefa.com/resources/test/index.html\n2) If the username field is empty, refresh the page (annoying little bug I didn't get out)\n3) Use the password MozSupp667 and click 'login'\n4) refresh the page\n\n\nActual results:\n\nThe long-polling ajax request is aborted by firefox. However, firefox starts the very same request again. Due to the specifications of XMPP (in particular regarding the rid-attribute), the chat session is terminated. As a consequence, the chat session is killed after every page reload or navigation.\n\n\nExpected results:\n\nThe second request, using the exact same rid, shouldn't have been made. This bug is particular to firefox, every other browser behaves as expected.", "tags": []}, {"tags": [], "text": "Also present on the nightly build, as tested by alex_mayorga on #firefox@irc.mozilla.org", "bug_id": 706125, "author": "support@educdesign.lu", "creation_time": "2011-11-29T16:39:15Z", "time": "2011-11-29T16:39:15Z", "creator": "support@educdesign.lu", "raw_text": "Also present on the nightly build, as tested by alex_mayorga on #firefox@irc.mozilla.org", "count": 1, "id": 5879056, "is_private": false, "attachment_id": null}, {"attachment_id": null, "raw_text": "How can I tell from the page whether the undesirable second request was sent?\n\nAlso, just to make sure we're testing the same thing, when you say \"refresh the page\" in step 4, are you just clicking the browser's \"reload\" button?", "bug_id": 706125, "text": "How can I tell from the page whether the undesirable second request was sent?\n\nAlso, just to make sure we're testing the same thing, when you say \"refresh the page\" in step 4, are you just clicking the browser's \"reload\" button?", "tags": [], "id": 5879619, "count": 2, "is_private": false, "time": "2011-11-29T19:59:24Z", "creation_time": "2011-11-29T19:59:24Z", "creator": "bzbarsky@mit.edu", "author": "bzbarsky@mit.edu"}, {"creation_time": "2011-11-29T20:12:17Z", "time": "2011-11-29T20:12:17Z", "creator": "bzbarsky@mit.edu", "author": "bzbarsky@mit.edu", "count": 3, "id": 5879655, "is_private": false, "tags": [], "bug_id": 706125, "text": "One interesting thing.  When I hit the reload button, the existing long-polling XHR request is canceled, of course.  This sends an onreadystatechange event, which is handled by _onRequestStateChange at http://prerelease.olefa.com/resources/test/strophe.js line 2629.  It gets down to this code:\n\n            if (!((reqStatus > 0 && reqStatus < 500) ||\n                  req.sends > 5)) {\n                this._throttledRequestHandler();\n            }\n\nin this case reqStatus is 0 (correct per http://www.w3.org/TR/XMLHttpRequest2/#the-status-attribute because there has been no server response to that request so far) and I assume req.sends <= 5.  In any case, _throttledRequestHandler gets called.  This does:\n\n        if (this._requests.length > 0) {\n            this._processRequest(0);\n        }\n\nwhich lands ends up with requestCompletedWithServerError set to true, since reqStatus is still 0.  So it abort()s the XHR, creates a new request using the data of the old one, and then sends the request.  I presume this is the request that's breaking things?\n\nAs far as I can tell, this should happen in any browser that actually follows the spec and returns a status of 0 for aborted requests...\n\nCan you put in logging on your end to see whether you hit this codepath in other browsers?", "attachment_id": null, "raw_text": "One interesting thing.  When I hit the reload button, the existing long-polling XHR request is canceled, of course.  This sends an onreadystatechange event, which is handled by _onRequestStateChange at http://prerelease.olefa.com/resources/test/strophe.js line 2629.  It gets down to this code:\n\n            if (!((reqStatus > 0 && reqStatus < 500) ||\n                  req.sends > 5)) {\n                this._throttledRequestHandler();\n            }\n\nin this case reqStatus is 0 (correct per http://www.w3.org/TR/XMLHttpRequest2/#the-status-attribute because there has been no server response to that request so far) and I assume req.sends <= 5.  In any case, _throttledRequestHandler gets called.  This does:\n\n        if (this._requests.length > 0) {\n            this._processRequest(0);\n        }\n\nwhich lands ends up with requestCompletedWithServerError set to true, since reqStatus is still 0.  So it abort()s the XHR, creates a new request using the data of the old one, and then sends the request.  I presume this is the request that's breaking things?\n\nAs far as I can tell, this should happen in any browser that actually follows the spec and returns a status of 0 for aborted requests...\n\nCan you put in logging on your end to see whether you hit this codepath in other browsers?"}, {"is_private": false, "count": 4, "id": 5881390, "creator": "support@educdesign.lu", "time": "2011-11-30T07:29:08Z", "creation_time": "2011-11-30T07:29:08Z", "author": "support@educdesign.lu", "attachment_id": null, "raw_text": "I have tried it with Google Chrome and it goes that path as well. I am currently executing the code line by line with both firefox and chrome starting on the line you have given in hope to see a difference. I'll get back to you once I found something interesting.", "tags": [], "bug_id": 706125, "text": "I have tried it with Google Chrome and it goes that path as well. I am currently executing the code line by line with both firefox and chrome starting on the line you have given in hope to see a difference. I'll get back to you once I found something interesting."}, {"bug_id": 706125, "text": "I redirected the strophe debug messages to the browser console. Something I observed was that the debug command on line 2631 gets called twice with xhr.readyState=1 almost every time (resulting in the states 1,1,2,3,4) whereas Chrome gets consecutive states (1,2,3,4).\n\nIt is also in between two xhr.readyState=1 that the duplicate ajax call gets made.\n\nI will post the a screenshot of the logged messages.", "tags": [], "attachment_id": null, "raw_text": "I redirected the strophe debug messages to the browser console. Something I observed was that the debug command on line 2631 gets called twice with xhr.readyState=1 almost every time (resulting in the states 1,1,2,3,4) whereas Chrome gets consecutive states (1,2,3,4).\n\nIt is also in between two xhr.readyState=1 that the duplicate ajax call gets made.\n\nI will post the a screenshot of the logged messages.", "creator": "support@educdesign.lu", "creation_time": "2011-11-30T09:04:56Z", "time": "2011-11-30T09:04:56Z", "author": "support@educdesign.lu", "is_private": false, "id": 5881521, "count": 5}, {"creation_time": "2011-11-30T09:10:02Z", "time": "2011-11-30T09:10:02Z", "creator": "support@educdesign.lu", "author": "support@educdesign.lu", "id": 5881525, "count": 6, "is_private": false, "tags": [], "bug_id": 706125, "text": "Created attachment 577893\nscreenshot of console where js reacts twice with xhr.readyState 1", "attachment_id": 577893, "raw_text": ""}, {"author": "support@educdesign.lu", "creator": "support@educdesign.lu", "creation_time": "2011-11-30T16:44:09Z", "time": "2011-11-30T16:44:09Z", "is_private": false, "id": 5882365, "count": 7, "tags": [], "text": "Ok,  here's what I found. The strophe library has a method named _onRequestStateChange. This is basically (from what I understand) called whenever onRequestStateChange of the XMLHTTPRequest object is called.\n\n_onRequestStateChange is called very differently on Chrome and Firefox. On Chrome, the aborted request changes its xhr-state immediately from 1 to 4. Chrome then starts a new xhr with state 1 and even tries to call the duplicate request I am having on Firefox. However, for some reason I cannot comprehend, Chrome does not send the request (I have placed a console.log('Sending stuff to server:') just before the xhr.send() method [strophe.js;line 2553]).\n\nFirefox on the other hand cycles through all states (1,2,3,4) of the aborted xhr and, like Chrome, also starts a new xhr with state 1. Unlike Chrome however, it does actually send the request which causes the initial problem.\n\nI have gained enough understanding to bypass the problem for our end-users, however the question remains if firefox is the one behaving correctly or Chrome. I will keep the test page up and running until it isn't needed anymore so you guys don't have to set up the scenario again.", "bug_id": 706125, "raw_text": "Ok,  here's what I found. The strophe library has a method named _onRequestStateChange. This is basically (from what I understand) called whenever onRequestStateChange of the XMLHTTPRequest object is called.\n\n_onRequestStateChange is called very differently on Chrome and Firefox. On Chrome, the aborted request changes its xhr-state immediately from 1 to 4. Chrome then starts a new xhr with state 1 and even tries to call the duplicate request I am having on Firefox. However, for some reason I cannot comprehend, Chrome does not send the request (I have placed a console.log('Sending stuff to server:') just before the xhr.send() method [strophe.js;line 2553]).\n\nFirefox on the other hand cycles through all states (1,2,3,4) of the aborted xhr and, like Chrome, also starts a new xhr with state 1. Unlike Chrome however, it does actually send the request which causes the initial problem.\n\nI have gained enough understanding to bypass the problem for our end-users, however the question remains if firefox is the one behaving correctly or Chrome. I will keep the test page up and running until it isn't needed anymore so you guys don't have to set up the scenario again.", "attachment_id": null}, {"attachment_id": null, "raw_text": "Thanks for digging through that and for leaving the testcase up!  That's perfect.\n\nSo two issues:\n\n1)  We should not be going through readystates 2 and 3 for a canceled request.  See\n    http://www.w3.org/TR/XMLHttpRequest2/#request-error\n2)  What should request.send() in what is basically page teardown do?  That's not clear to\n    me from the spec.  It sounds like Chrome doesn't actually send the request and we do?\n\nJonas, Olli, who knows about this stuff?", "text": "Thanks for digging through that and for leaving the testcase up!  That's perfect.\n\nSo two issues:\n\n1)  We should not be going through readystates 2 and 3 for a canceled request.  See\n    http://www.w3.org/TR/XMLHttpRequest2/#request-error\n2)  What should request.send() in what is basically page teardown do?  That's not clear to\n    me from the spec.  It sounds like Chrome doesn't actually send the request and we do?\n\nJonas, Olli, who knows about this stuff?", "bug_id": 706125, "tags": [], "is_private": false, "count": 8, "id": 5886400, "creator": "bzbarsky@mit.edu", "time": "2011-12-01T21:29:05Z", "creation_time": "2011-12-01T21:29:05Z", "author": "bzbarsky@mit.edu"}, {"raw_text": "How do you defined \"essentially page teardown\"?\n\nIf we're past the point where we've cancelled all the requests related to the page we should not allow new requests to be opened I would think.\n\nI'll definitely fix 1)", "attachment_id": null, "text": "How do you defined \"essentially page teardown\"?\n\nIf we're past the point where we've cancelled all the requests related to the page we should not allow new requests to be opened I would think.\n\nI'll definitely fix 1)", "bug_id": 706125, "tags": [], "count": 9, "id": 5886778, "is_private": false, "author": "jonas@sicking.cc", "time": "2011-12-01T23:01:27Z", "creation_time": "2011-12-01T23:01:27Z", "creator": "jonas@sicking.cc"}, {"count": 10, "id": 5886887, "is_private": false, "author": "bzbarsky@mit.edu", "time": "2011-12-01T23:34:14Z", "creation_time": "2011-12-01T23:34:14Z", "creator": "bzbarsky@mit.edu", "raw_text": "> How do you defined \"essentially page teardown\"?\n\nGood question.\n\nRequests are canceled when the navigation to the next page _starts_ iirc.  So the cancelation callback and the resulting readystate change are in fact happening before unload here, and the page may never in fact get unloaded (e.g. if the request for the next page ends up with a type that's handled by a helper app).\n\nThere is no separate cancelation when unload actualy fires, again iirc.  At least in Gecko.  What should happen per spec is an interesting question.", "attachment_id": null, "tags": [], "bug_id": 706125, "text": "> How do you defined \"essentially page teardown\"?\n\nGood question.\n\nRequests are canceled when the navigation to the next page _starts_ iirc.  So the cancelation callback and the resulting readystate change are in fact happening before unload here, and the page may never in fact get unloaded (e.g. if the request for the next page ends up with a type that's handled by a helper app).\n\nThere is no separate cancelation when unload actualy fires, again iirc.  At least in Gecko.  What should happen per spec is an interesting question."}, {"count": 11, "id": 13436822, "is_private": false, "creation_time": "2018-06-29T04:59:03Z", "time": "2018-06-29T04:59:03Z", "creator": "bug-husbandry-bot@mozilla.bugs", "author": "bug-husbandry-bot@mozilla.bugs", "attachment_id": null, "raw_text": "https://bugzilla.mozilla.org/show_bug.cgi?id=1472046\n\nMove all DOM bugs that haven\u2019t been updated in more than 3 years and has no one currently assigned to P5.\n\nIf you have questions, please contact :mdaly.", "bug_id": 706125, "text": "https://bugzilla.mozilla.org/show_bug.cgi?id=1472046\n\nMove all DOM bugs that haven\u2019t been updated in more than 3 years and has no one currently assigned to P5.\n\nIf you have questions, please contact :mdaly.", "tags": []}]}}}