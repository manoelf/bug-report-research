{"bugs": {"698822": {"comments": [{"is_private": false, "creator": "azakai@mozilla.com", "count": 0, "creation_time": "2011-11-01T18:17:36Z", "author": "azakai@mozilla.com", "text": "http://syntensity.com/static/BroadwayDemo.tar.bz2\n\nis the Broadway H264 decoder demo, with two JS files, broadway.advanced.js which is with closure compiler advanced opts, and broadway.simple.js with simple opts. (Both are pretty-printed. Changing which js file is used can be done in broadway.html.)\n\nWith advanced opts, startup is very slow for several seconds (with simple opts, startup is smooth and fast). Even after that, performance is 20% slower than simple opts (there is an All and a Steady counter for FPS. Steady ignores the first few seconds). This might be due to noticeable GC pauses that happen with advanced opts (and not simple opts). There is also a lot of analysis-temporary memory being used, I have seen 120MB at times (usually closer to startup than later), which is odd given that the code size here is not that big.\n\nIn general advanced opts leads to much faster code, due to inlining, smart variable reuse, and other things. So that it ends up 20% slower here, plus very slow startup, is surprising.\n\nIn the email discussion, it looked like advanced opts inlined a lot and created one mammoth function, which perhaps affects TI's optimizations.", "bug_id": 698822, "time": "2011-11-01T18:17:36Z", "tags": [], "attachment_id": null, "raw_text": "http://syntensity.com/static/BroadwayDemo.tar.bz2\n\nis the Broadway H264 decoder demo, with two JS files, broadway.advanced.js which is with closure compiler advanced opts, and broadway.simple.js with simple opts. (Both are pretty-printed. Changing which js file is used can be done in broadway.html.)\n\nWith advanced opts, startup is very slow for several seconds (with simple opts, startup is smooth and fast). Even after that, performance is 20% slower than simple opts (there is an All and a Steady counter for FPS. Steady ignores the first few seconds). This might be due to noticeable GC pauses that happen with advanced opts (and not simple opts). There is also a lot of analysis-temporary memory being used, I have seen 120MB at times (usually closer to startup than later), which is odd given that the code size here is not that big.\n\nIn general advanced opts leads to much faster code, due to inlining, smart variable reuse, and other things. So that it ends up 20% slower here, plus very slow startup, is surprising.\n\nIn the email discussion, it looked like advanced opts inlined a lot and created one mammoth function, which perhaps affects TI's optimizations.", "id": 5818492}, {"is_private": false, "creator": "mbebenita@gmail.com", "text": "Just a word of caution, the displayed \"Score\" is not computed correctly, it prints out the current FPS at the 60 second mark, instead of the average score. I'd just look at the All/Steady counters instead. A quick fix would be to replace the line:\n\ndocument.getElementById('score').innerHTML = fps.toFixed(2);\nwith\ndocument.getElementById('score').innerHTML = fpsSinceStart.toFixed(2);", "tags": [], "time": "2011-11-01T18:39:26Z", "creation_time": "2011-11-01T18:39:26Z", "author": "mbebenita@gmail.com", "raw_text": "Just a word of caution, the displayed \"Score\" is not computed correctly, it prints out the current FPS at the 60 second mark, instead of the average score. I'd just look at the All/Steady counters instead. A quick fix would be to replace the line:\n\ndocument.getElementById('score').innerHTML = fps.toFixed(2);\nwith\ndocument.getElementById('score').innerHTML = fpsSinceStart.toFixed(2);", "attachment_id": null, "id": 5818566, "count": 1, "bug_id": 698822}, {"attachment_id": null, "raw_text": "Inlining definitely looks like the problem here. I've been analyzing smaller benchmarks where closure advanced hurts, and forcing closure to not inline so aggressively fixes the problem. I believe I read that TI recompiles entire functions, so this makes sense.\n\nAnother observation, it looks like when closure inlines, it generates a lot of |var x = undefined| instructions. Seems like when variables are reused between a function and one inlined into it, closure assigns undefined so the variables become 'uninitialized' again. I wonder though if assigning undefined to an existing variable is costlier than just defining a new variable (without assigning to it).", "id": 5853776, "creator": "azakai@mozilla.com", "is_private": false, "count": 2, "author": "azakai@mozilla.com", "creation_time": "2011-11-16T22:46:27Z", "bug_id": 698822, "time": "2011-11-16T22:46:27Z", "tags": [], "text": "Inlining definitely looks like the problem here. I've been analyzing smaller benchmarks where closure advanced hurts, and forcing closure to not inline so aggressively fixes the problem. I believe I read that TI recompiles entire functions, so this makes sense.\n\nAnother observation, it looks like when closure inlines, it generates a lot of |var x = undefined| instructions. Seems like when variables are reused between a function and one inlined into it, closure assigns undefined so the variables become 'uninitialized' again. I wonder though if assigning undefined to an existing variable is costlier than just defining a new variable (without assigning to it)."}, {"count": 3, "bug_id": 698822, "creator": "concavelenz@gmail.com", "is_private": false, "tags": [], "time": "2011-11-17T01:57:59Z", "text": "Assignments like \"var x = undefined\" are created by Closure Compiler if a function is inlined into a loop where otherwise it might otherwise retain the value of a previous loop iteration.  A simple example:\n\nfunction b() {\n  var a;\n  alert(a);\n  a = foo();\n  alert(a);\n}\n\nwhile (1) {\n  b()\n}\n\nfunction c() {\n  var a;\n  alert(a);\n  a = foo();\n  alert(a);\n}\n\nc()\n\nproduces:\n\nfor(;;) {\n  var a = void 0;\n  alert(a);\n  a = foo();\n  alert(a)\n}\nvar b;\nalert(b);\nb = foo();\nalert(b);", "author": "concavelenz@gmail.com", "creation_time": "2011-11-17T01:57:59Z", "raw_text": "Assignments like \"var x = undefined\" are created by Closure Compiler if a function is inlined into a loop where otherwise it might otherwise retain the value of a previous loop iteration.  A simple example:\n\nfunction b() {\n  var a;\n  alert(a);\n  a = foo();\n  alert(a);\n}\n\nwhile (1) {\n  b()\n}\n\nfunction c() {\n  var a;\n  alert(a);\n  a = foo();\n  alert(a);\n}\n\nc()\n\nproduces:\n\nfor(;;) {\n  var a = void 0;\n  alert(a);\n  a = foo();\n  alert(a)\n}\nvar b;\nalert(b);\nb = foo();\nalert(b);", "attachment_id": null, "id": 5854309}, {"time": "2011-11-18T17:47:23Z", "tags": [], "bug_id": 698822, "text": "Thanks concavelenz, now it makes much more sense.", "author": "azakai@mozilla.com", "creation_time": "2011-11-18T17:47:23Z", "count": 4, "creator": "azakai@mozilla.com", "is_private": false, "id": 5858502, "raw_text": "Thanks concavelenz, now it makes much more sense.", "attachment_id": null}]}}, "comments": {}}