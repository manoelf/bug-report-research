{"comments": {}, "bugs": {"687306": {"comments": [{"time": "2011-09-18T03:59:59Z", "attachment_id": 560753, "raw_text": "User Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8) AppleWebKit/535.4+ (KHTML, like Gecko) Version/5.1 Safari/534.50\n\nSteps to reproduce:\n\nI confused js-ctypes with JS.next typed structs/arrays, I posted about js-ctypes and created a bench to realize ctypes are up to 10X slower ( or more ) than non typed JS objects, even if never used in a \"dll\" ( used only in JS )\n\nBrendan Eich asked me to point this out here ... so here I am from:\nhttp://webreflection.blogspot.com/2011/09/introduction-to-js-ctypes.html\nand the es-discuss ml\n\n\nActual results:\n\nthis happened: http://www.3site.eu/examples/ctypes.perf.html\nSave the file locally and enable the usage of js-ctypes extension in Firefox or others\n\nMost likely you will see that ctypes are on average 10 times slower than JS objects\n\n\nExpected results:\n\nafter the discussion in the ML I have no idea anymore, or better, it's the first time I write statically typed code in a dynamically interpreted programming language as JS is expecting a massive performances boost out of binary data but either I am not using binary data here or something went terribly wrong in the trace-JIT compiler since no external compiled library is used.", "tags": [], "creator": "andrea.giammarchi@gmail.com", "author": "andrea.giammarchi@gmail.com", "count": 0, "text": "Created attachment 560753\nctypes.perf.html\n\nUser Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8) AppleWebKit/535.4+ (KHTML, like Gecko) Version/5.1 Safari/534.50\n\nSteps to reproduce:\n\nI confused js-ctypes with JS.next typed structs/arrays, I posted about js-ctypes and created a bench to realize ctypes are up to 10X slower ( or more ) than non typed JS objects, even if never used in a \"dll\" ( used only in JS )\n\nBrendan Eich asked me to point this out here ... so here I am from:\nhttp://webreflection.blogspot.com/2011/09/introduction-to-js-ctypes.html\nand the es-discuss ml\n\n\nActual results:\n\nthis happened: http://www.3site.eu/examples/ctypes.perf.html\nSave the file locally and enable the usage of js-ctypes extension in Firefox or others\n\nMost likely you will see that ctypes are on average 10 times slower than JS objects\n\n\nExpected results:\n\nafter the discussion in the ML I have no idea anymore, or better, it's the first time I write statically typed code in a dynamically interpreted programming language as JS is expecting a massive performances boost out of binary data but either I am not using binary data here or something went terribly wrong in the trace-JIT compiler since no external compiled library is used.", "id": 5721862, "bug_id": 687306, "creation_time": "2011-09-18T03:59:59Z", "is_private": false}, {"raw_text": "I don't know much about trace stuff, but I'd be happy to learn. Is this straightforward to do?", "attachment_id": null, "time": "2011-09-18T07:05:18Z", "tags": [], "text": "I don't know much about trace stuff, but I'd be happy to learn. Is this straightforward to do?", "count": 1, "author": "bholley@mozilla.com", "creator": "bholley@mozilla.com", "creation_time": "2011-09-18T07:05:18Z", "is_private": false, "bug_id": 687306, "id": 5721897}, {"time": "2011-09-19T14:15:48Z", "attachment_id": null, "raw_text": "First of all, tracejit is off by default now, so I wouldn't worry about it too much.\n\nSecond, what's the issue here?  Is it that using ctypes arrays or structs is slower than native arrays, especially native typed arrays?  Isn't that more or less expected, given that the latter can be done in inline jit code while the former have to go through the whole FFI song-and-dance?", "tags": [], "creator": "bzbarsky@mit.edu", "author": "bzbarsky@mit.edu", "count": 2, "text": "First of all, tracejit is off by default now, so I wouldn't worry about it too much.\n\nSecond, what's the issue here?  Is it that using ctypes arrays or structs is slower than native arrays, especially native typed arrays?  Isn't that more or less expected, given that the latter can be done in inline jit code while the former have to go through the whole FFI song-and-dance?", "bug_id": 687306, "id": 5722928, "is_private": false, "creation_time": "2011-09-19T14:15:48Z"}, {"attachment_id": null, "tags": [], "creator": "bzbarsky@mit.edu", "creation_time": "2011-09-19T14:19:23Z", "is_private": false, "time": "2011-09-19T14:19:23Z", "raw_text": "One other note: the test is comparing apples to oranges to start with (reading one pointer from the native array, a two-integer struct from the ctypes array, creating new objects in one of the typed array cases, using dead code in the other typed array case....)", "author": "bzbarsky@mit.edu", "count": 3, "text": "One other note: the test is comparing apples to oranges to start with (reading one pointer from the native array, a two-integer struct from the ctypes array, creating new objects in one of the typed array cases, using dead code in the other typed array case....)", "bug_id": 687306, "id": 5722932}, {"time": "2011-09-19T14:29:01Z", "raw_text": "That all said, a profile of the ctypes case shows:\n\n  12% under the SetName stub, mostly calling proxy_SetProperty (because window.foo is\n      explicitly being set, not a global variable).\n  26% under JSCompartment::wrap under the JSCrossCompartmentWrapper::get call that\n      proxy_GetProperty makes under the GetElem stub.  About half of this is self time,\n      and the other half is creating the new wrapper object.\n   5% pushing dummy frames under JSCrossCompartmentWrapper::get\n  11% security checks under JSWrapper::get (for\n      xpc::FilteringWrapper<JSCrossCompartmentWrapper,xpc::ExposedPropertiesOnly>::enter).\n  22% under the actual ctypes::ArrayType::Getter; most of this is malloc and JS_NewObject\n      overhead triggered by ctypes::ConvertToJS.\n   7% overhead under js_GetProperty but outside ArrayType::Getter; mostly self time in\n      js_GetProperty and proptable searches.\n\nObvious questions: Why are we ending up with cross-compartment anything here?  And why is it so expensive?  That last does not bode well for compartment-per-global....", "bug_id": 687306, "id": 5722945, "author": "bzbarsky@mit.edu", "text": "That all said, a profile of the ctypes case shows:\n\n  12% under the SetName stub, mostly calling proxy_SetProperty (because window.foo is\n      explicitly being set, not a global variable).\n  26% under JSCompartment::wrap under the JSCrossCompartmentWrapper::get call that\n      proxy_GetProperty makes under the GetElem stub.  About half of this is self time,\n      and the other half is creating the new wrapper object.\n   5% pushing dummy frames under JSCrossCompartmentWrapper::get\n  11% security checks under JSWrapper::get (for\n      xpc::FilteringWrapper<JSCrossCompartmentWrapper,xpc::ExposedPropertiesOnly>::enter).\n  22% under the actual ctypes::ArrayType::Getter; most of this is malloc and JS_NewObject\n      overhead triggered by ctypes::ConvertToJS.\n   7% overhead under js_GetProperty but outside ArrayType::Getter; mostly self time in\n      js_GetProperty and proptable searches.\n\nObvious questions: Why are we ending up with cross-compartment anything here?  And why is it so expensive?  That last does not bode well for compartment-per-global....", "count": 4, "tags": [], "attachment_id": null, "creation_time": "2011-09-19T14:29:01Z", "is_private": false, "creator": "bzbarsky@mit.edu"}, {"time": "2011-09-19T14:36:05Z", "raw_text": "Does that .jsm access is always cross-compartment? That could be painful, and ctypes is implemented as a JSM.", "author": "benjamin@smedbergs.us", "text": "Does that .jsm access is always cross-compartment? That could be painful, and ctypes is implemented as a JSM.", "count": 5, "id": 5722964, "bug_id": 687306, "attachment_id": null, "tags": [], "creator": "benjamin@smedbergs.us", "creation_time": "2011-09-19T14:36:05Z", "is_private": false}, {"tags": [], "attachment_id": null, "is_private": false, "creation_time": "2011-09-19T14:51:31Z", "creator": "andrea.giammarchi@gmail.com", "time": "2011-09-19T14:51:31Z", "raw_text": "I just wonder if in a case where no dll/lib is imported, typed stuff has to pass through the whole song-and-dance but as I have said, not sure this is a proper issue, surely performances look poor.\n\n(In reply to Boris Zbarsky (:bz) from comment #2)\n> First of all, tracejit is off by default now, so I wouldn't worry about it\n> too much.\n> \n> Second, what's the issue here?  Is it that using ctypes arrays or structs is\n> slower than native arrays, especially native typed arrays?  Isn't that more\n> or less expected, given that the latter can be done in inline jit code while\n> the former have to go through the whole FFI song-and-dance?", "bug_id": 687306, "id": 5723005, "author": "andrea.giammarchi@gmail.com", "count": 6, "text": "I just wonder if in a case where no dll/lib is imported, typed stuff has to pass through the whole song-and-dance but as I have said, not sure this is a proper issue, surely performances look poor.\n\n(In reply to Boris Zbarsky (:bz) from comment #2)\n> First of all, tracejit is off by default now, so I wouldn't worry about it\n> too much.\n> \n> Second, what's the issue here?  Is it that using ctypes arrays or structs is\n> slower than native arrays, especially native typed arrays?  Isn't that more\n> or less expected, given that the latter can be done in inline jit code while\n> the former have to go through the whole FFI song-and-dance?"}, {"creation_time": "2011-09-19T14:53:49Z", "is_private": false, "bug_id": 687306, "id": 5723009, "count": 7, "text": "> Does that .jsm access is always cross-compartment?\n\nOh, good point.  It may not be always, but certainly in the file:// + enablePrivilege case.  Testing performance of any code the involved enablePrivilege is sort of silly, since enablePrivilege implies expensive security checks all over.\n\n> typed stuff has to pass through the whole song-and-dance\n\nYes, since you have to create the C-side structures no matter what: someone may well pass the JS reflection around to somewhere else where a DLL _is_ loaded.", "author": "bzbarsky@mit.edu", "creator": "bzbarsky@mit.edu", "tags": [], "raw_text": "> Does that .jsm access is always cross-compartment?\n\nOh, good point.  It may not be always, but certainly in the file:// + enablePrivilege case.  Testing performance of any code the involved enablePrivilege is sort of silly, since enablePrivilege implies expensive security checks all over.\n\n> typed stuff has to pass through the whole song-and-dance\n\nYes, since you have to create the C-side structures no matter what: someone may well pass the JS reflection around to somewhere else where a DLL _is_ loaded.", "attachment_id": null, "time": "2011-09-19T14:53:49Z"}, {"tags": [], "attachment_id": null, "raw_text": "We should certainly consider either unifying typed arrays or allowing them to be passed through ctypes directly in some cases, but that shouldn't be this bug, since this one already has several topics!", "time": "2011-09-19T14:54:14Z", "is_private": false, "creation_time": "2011-09-19T14:54:14Z", "bug_id": 687306, "id": 5723012, "author": "benjamin@smedbergs.us", "count": 8, "text": "We should certainly consider either unifying typed arrays or allowing them to be passed through ctypes directly in some cases, but that shouldn't be this bug, since this one already has several topics!", "creator": "benjamin@smedbergs.us"}, {"text": "The test is comparing different ways to obtain similar scenario: a statically typed collection of Point2D VS normal JS.\n\nInt32Array has two tests indeed to test access over an ArrayType, in this case the native Int32Array, and same constructor with inline object creation per each point.\n\nLatter test is to compare the difference between static typed stuff and JS in the meaning of creating in a loop each point in the loop via new Point2D({x: value, y: value});\n\nSince this would be extremely bad in therms of performances with typed Point2D, I simply add the literal object overhead to spot difference between native static and native static with typed static potential usage from web developers.\n\nNot sure I clarified or messed up more the idea behind tho ... \n\n(In reply to Boris Zbarsky (:bz) from comment #3)\n> One other note: the test is comparing apples to oranges to start with\n> (reading one pointer from the native array, a two-integer struct from the\n> ctypes array, creating new objects in one of the typed array cases, using\n> dead code in the other typed array case....)", "count": 9, "author": "andrea.giammarchi@gmail.com", "creator": "andrea.giammarchi@gmail.com", "creation_time": "2011-09-19T15:06:18Z", "is_private": false, "bug_id": 687306, "id": 5723041, "raw_text": "The test is comparing different ways to obtain similar scenario: a statically typed collection of Point2D VS normal JS.\n\nInt32Array has two tests indeed to test access over an ArrayType, in this case the native Int32Array, and same constructor with inline object creation per each point.\n\nLatter test is to compare the difference between static typed stuff and JS in the meaning of creating in a loop each point in the loop via new Point2D({x: value, y: value});\n\nSince this would be extremely bad in therms of performances with typed Point2D, I simply add the literal object overhead to spot difference between native static and native static with typed static potential usage from web developers.\n\nNot sure I clarified or messed up more the idea behind tho ... \n\n(In reply to Boris Zbarsky (:bz) from comment #3)\n> One other note: the test is comparing apples to oranges to start with\n> (reading one pointer from the native array, a two-integer struct from the\n> ctypes array, creating new objects in one of the typed array cases, using\n> dead code in the other typed array case....)", "attachment_id": null, "time": "2011-09-19T15:06:18Z", "tags": []}, {"tags": [], "raw_text": "(In reply to Boris Zbarsky (:bz) from comment #7)\n> Testing performance of any code the involved\n> enablePrivilege is sort of silly, since enablePrivilege implies expensive\n> security checks all over.\n\nI can create an add-on that does the same test if necessary ...", "attachment_id": null, "time": "2011-09-19T15:07:54Z", "is_private": false, "creation_time": "2011-09-19T15:07:54Z", "id": 5723043, "bug_id": 687306, "count": 10, "text": "(In reply to Boris Zbarsky (:bz) from comment #7)\n> Testing performance of any code the involved\n> enablePrivilege is sort of silly, since enablePrivilege implies expensive\n> security checks all over.\n\nI can create an add-on that does the same test if necessary ...", "author": "andrea.giammarchi@gmail.com", "creator": "andrea.giammarchi@gmail.com"}, {"tags": [], "time": "2011-09-19T15:10:55Z", "raw_text": "> I can create an add-on that does the same test if necessary ...\n\nThe numbers would look pretty different.\n\nBut again, you're comparing a dedicated fast-path (typed arrays) to generic access-to-C-data-structures code.  The latter will be slower.", "attachment_id": null, "id": 5723051, "bug_id": 687306, "is_private": false, "creation_time": "2011-09-19T15:10:55Z", "creator": "bzbarsky@mit.edu", "text": "> I can create an add-on that does the same test if necessary ...\n\nThe numbers would look pretty different.\n\nBut again, you're comparing a dedicated fast-path (typed arrays) to generic access-to-C-data-structures code.  The latter will be slower.", "count": 11, "author": "bzbarsky@mit.edu"}, {"time": "2011-09-19T15:20:06Z", "raw_text": "(In reply to Boris Zbarsky (:bz) from comment #11)\n> The numbers would look pretty different.\n\nI'll check then\n\n> But again, you're comparing a dedicated fast-path (typed arrays) to generic\n> access-to-C-data-structures code.  The latter will be slower.\n\nI got this, I don't get why these static data structures cannot go as fast as typed arrays if no external library is involved plus I ArrayType(ctypes.int) is a typed array, the equivalent of Int32Array, imo\n\nOnce again, I got this js-ctypes extension was not meant to speed up JS but again as JS developer I am quite confused about the meaning of typed in current JS status.\n\nFeel free to close this bug if you think everything is OK, thanks.", "count": 12, "text": "(In reply to Boris Zbarsky (:bz) from comment #11)\n> The numbers would look pretty different.\n\nI'll check then\n\n> But again, you're comparing a dedicated fast-path (typed arrays) to generic\n> access-to-C-data-structures code.  The latter will be slower.\n\nI got this, I don't get why these static data structures cannot go as fast as typed arrays if no external library is involved plus I ArrayType(ctypes.int) is a typed array, the equivalent of Int32Array, imo\n\nOnce again, I got this js-ctypes extension was not meant to speed up JS but again as JS developer I am quite confused about the meaning of typed in current JS status.\n\nFeel free to close this bug if you think everything is OK, thanks.", "author": "andrea.giammarchi@gmail.com", "bug_id": 687306, "id": 5723066, "attachment_id": null, "tags": [], "creator": "andrea.giammarchi@gmail.com", "creation_time": "2011-09-19T15:20:06Z", "is_private": false}, {"id": 5723105, "bug_id": 687306, "creation_time": "2011-09-19T15:41:14Z", "is_private": false, "creator": "mail@lukewagner.name", "text": "(In reply to Andrea Giammarchi from comment #12)\n> I got this, I don't get why these static data structures cannot go as fast\n> as typed arrays if no external library is involved plus I\n> ArrayType(ctypes.int) is a typed array, the equivalent of Int32Array, imo\n\nI agree this is initially surprising.  I think the simple answer is that there is no free lunch and, even given the extra type information, one needs to teach the jit compilers to understand and optimize based on this information and, so far, we haven't.\n\nHopefully we'll be able to kill two birds with one stone: once JS.next struct types implemented and optimized, it seems like we could rejigger js-ctypes to hit the same fast paths.", "count": 13, "author": "mail@lukewagner.name", "tags": [], "time": "2011-09-19T15:41:14Z", "raw_text": "(In reply to Andrea Giammarchi from comment #12)\n> I got this, I don't get why these static data structures cannot go as fast\n> as typed arrays if no external library is involved plus I\n> ArrayType(ctypes.int) is a typed array, the equivalent of Int32Array, imo\n\nI agree this is initially surprising.  I think the simple answer is that there is no free lunch and, even given the extra type information, one needs to teach the jit compilers to understand and optimize based on this information and, so far, we haven't.\n\nHopefully we'll be able to kill two birds with one stone: once JS.next struct types implemented and optimized, it seems like we could rejigger js-ctypes to hit the same fast paths.", "attachment_id": null}]}}}