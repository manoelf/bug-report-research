{"bugs": {"637002": {"comments": [{"attachment_id": null, "is_private": false, "time": "2011-02-26T13:31:56Z", "author": "simon@speich.net", "id": 5306170, "raw_text": "User-Agent:       Mozilla/5.0 (Windows NT 6.1; rv:2.0b12) Gecko/20100101 Firefox/4.0b12\nBuild Identifier: Mozilla/5.0 (Windows NT 6.1; rv:2.0b12) Gecko/20100101 Firefox/4.0b12\n\nWhen using the XmlHttpRequest.upload object to monitor upload progress, the ProgressEvent.load only fires, when the whole request is completed, e.g. the server has processed the request and the response is sent back. I my opinion this is wrong (and Google Chrome does it correctly). Instead the event should fire as soon as the browser has sent all the bytes (e.g.finished uploading) and it should not wait for the server's response. You would use the XmlHttpRequest.load event for that.\n\nAs a consequence the property ProgressEvent.loaded equals only ProgressEvent.total after the request is completed and not right away when all bytes are sent. This make it impossible to detect the difference. Often there is a big lag of several seconds between the browser having finished uploading (all bytes sent) and the time the server has written the file and sent the response back. In FF there is no way I can inform the user about that.\n\n\n\n\n\nReproducible: Always\n\nSteps to Reproduce:\nvar req = new XMLHttpRequest();\nreq.upload.addEventListener('progress', function(evt) {\n   if (evt.loaded == evt.total) {\n      // In Firefox this is never the case, since progress event is not called anymore when all bytes are sent !\n\n      // In Goggle Chrome this works, since it is called one last time\n\n      // Debatable which is the correct behavior, but chrome's is more usable\n   }\n}, false);\n\nreq.upload.addEventListener('load', function(evt) {\n   // In FF this event fires to late, e.g. only after the response is sent back.\n   // evt.loaded == evt.total == numberOfBytes sent\n\n   // In Chrome this event fires correctly, right after all bytes are sent, but\n   // evt.loaded == evt.total == 0 !   \n}, false);\n\nreq.addEventListener('load', function(evt) {\n   // Note: This is the load event on the req and not on the req.upload\n\n   // In FF this event is correctly called when the response is back\n\n   // Chrome fires it to early, right after all bytes are sent. \n}, false);\n\n\n\n\nThe docs at W3C on http://www.w3.org/TR/progress-events/#the-progressevent-interface below '4. Suggested ProgressEvent Types' in state, that the load event should be fired: 'After the last progress has been dispatched...'", "creation_time": "2011-02-26T13:31:56Z", "text": "User-Agent:       Mozilla/5.0 (Windows NT 6.1; rv:2.0b12) Gecko/20100101 Firefox/4.0b12\nBuild Identifier: Mozilla/5.0 (Windows NT 6.1; rv:2.0b12) Gecko/20100101 Firefox/4.0b12\n\nWhen using the XmlHttpRequest.upload object to monitor upload progress, the ProgressEvent.load only fires, when the whole request is completed, e.g. the server has processed the request and the response is sent back. I my opinion this is wrong (and Google Chrome does it correctly). Instead the event should fire as soon as the browser has sent all the bytes (e.g.finished uploading) and it should not wait for the server's response. You would use the XmlHttpRequest.load event for that.\n\nAs a consequence the property ProgressEvent.loaded equals only ProgressEvent.total after the request is completed and not right away when all bytes are sent. This make it impossible to detect the difference. Often there is a big lag of several seconds between the browser having finished uploading (all bytes sent) and the time the server has written the file and sent the response back. In FF there is no way I can inform the user about that.\n\n\n\n\n\nReproducible: Always\n\nSteps to Reproduce:\nvar req = new XMLHttpRequest();\nreq.upload.addEventListener('progress', function(evt) {\n   if (evt.loaded == evt.total) {\n      // In Firefox this is never the case, since progress event is not called anymore when all bytes are sent !\n\n      // In Goggle Chrome this works, since it is called one last time\n\n      // Debatable which is the correct behavior, but chrome's is more usable\n   }\n}, false);\n\nreq.upload.addEventListener('load', function(evt) {\n   // In FF this event fires to late, e.g. only after the response is sent back.\n   // evt.loaded == evt.total == numberOfBytes sent\n\n   // In Chrome this event fires correctly, right after all bytes are sent, but\n   // evt.loaded == evt.total == 0 !   \n}, false);\n\nreq.addEventListener('load', function(evt) {\n   // Note: This is the load event on the req and not on the req.upload\n\n   // In FF this event is correctly called when the response is back\n\n   // Chrome fires it to early, right after all bytes are sent. \n}, false);\n\n\n\n\nThe docs at W3C on http://www.w3.org/TR/progress-events/#the-progressevent-interface below '4. Suggested ProgressEvent Types' in state, that the load event should be fired: 'After the last progress has been dispatched...'", "tags": [], "creator": "simon@speich.net", "count": 0, "bug_id": 637002}, {"attachment_id": null, "is_private": false, "time": "2011-02-27T12:42:19Z", "author": "bugs@pettay.fi", "text": "(In reply to comment #0)\n> When using the XmlHttpRequest.upload object to monitor upload progress, the\n> ProgressEvent.load only fires, when the whole request is completed, e.g. the\n> server has processed the request and the response is sent back.\nWell, at the point when browser starts to get something back from server, it\nknows the data has really been sent. Otherwise the data might be just buffered\nsomewhere in the network stack.\n\n\n> Instead the event should\n> fire as soon as the browser has sent all the bytes (e.g.finished uploading) and\n> it should not wait for the server's response. You would use the\n> XmlHttpRequest.load event for that.\nupload's load fires way earlier than xhr's load.", "creation_time": "2011-02-27T12:42:19Z", "raw_text": "(In reply to comment #0)\n> When using the XmlHttpRequest.upload object to monitor upload progress, the\n> ProgressEvent.load only fires, when the whole request is completed, e.g. the\n> server has processed the request and the response is sent back.\nWell, at the point when browser starts to get something back from server, it\nknows the data has really been sent. Otherwise the data might be just buffered\nsomewhere in the network stack.\n\n\n> Instead the event should\n> fire as soon as the browser has sent all the bytes (e.g.finished uploading) and\n> it should not wait for the server's response. You would use the\n> XmlHttpRequest.load event for that.\nupload's load fires way earlier than xhr's load.", "id": 5307123, "bug_id": 637002, "tags": [], "count": 1, "creator": "bugs@pettay.fi"}, {"is_private": false, "time": "2011-02-27T13:17:53Z", "attachment_id": null, "text": "> (In reply to comment #0)\n> > Instead the event should\n> > fire as soon as the browser has sent all the bytes (e.g.finished uploading) and\n> > it should not wait for the server's response. You would use the\n> > XmlHttpRequest.load event for that.\n> upload's load fires way earlier than xhr's load.\nNo, that's exactly the problem, that it doesn't", "creation_time": "2011-02-27T13:17:53Z", "raw_text": "> (In reply to comment #0)\n> > Instead the event should\n> > fire as soon as the browser has sent all the bytes (e.g.finished uploading) and\n> > it should not wait for the server's response. You would use the\n> > XmlHttpRequest.load event for that.\n> upload's load fires way earlier than xhr's load.\nNo, that's exactly the problem, that it doesn't", "id": 5307160, "bug_id": 637002, "tags": [], "count": 2, "creator": "simon@speich.net", "author": "simon@speich.net"}, {"attachment_id": null, "time": "2011-02-27T14:16:37Z", "is_private": false, "author": "bugs@pettay.fi", "bug_id": 637002, "tags": [], "count": 3, "creator": "bugs@pettay.fi", "raw_text": "xhr's load fires after the request has been downloaded.\nupload's load fires when the downloading starts.", "id": 5307199, "text": "xhr's load fires after the request has been downloaded.\nupload's load fires when the downloading starts.", "creation_time": "2011-02-27T14:16:37Z"}, {"tags": [], "creator": "bzbarsky@mit.edu", "time": "2011-02-28T17:18:06Z", "count": 4, "bug_id": 637002, "id": 5308854, "raw_text": "Yeah, I think this is invalid.  Until we get a response from the server we don't know that that the data has actually been sent (and in fact in some cases we may have to resend it)....\n\nSimon, the upload \"load\" fires when we get the start of the server's response (the headers).  The download \"load\" fires once we get all the data.  If you're testing with tiny server responses, you could be getting both in the same packet, of course.", "is_private": false, "creation_time": "2011-02-28T17:18:06Z", "text": "Yeah, I think this is invalid.  Until we get a response from the server we don't know that that the data has actually been sent (and in fact in some cases we may have to resend it)....\n\nSimon, the upload \"load\" fires when we get the start of the server's response (the headers).  The download \"load\" fires once we get all the data.  If you're testing with tiny server responses, you could be getting both in the same packet, of course.", "attachment_id": null, "author": "bzbarsky@mit.edu"}, {"author": "simon@speich.net", "tags": [], "creator": "simon@speich.net", "count": 5, "bug_id": 637002, "id": 5310933, "raw_text": "(In reply to comment #4)\n> Yeah, I think this is invalid.  Until we get a response from the server we\n> don't know that that the data has actually been sent (and in fact in some cases\n> we may have to resend it)....\n> \nIf you leave this as invalid, would it at least be possible (or even necessary) to fire the progress event one last time (e.g. right when finished sending all bytes without waiting for the servers response) and to set evt.loaded == evt.total ?\n\n> Simon, the upload \"load\" fires when we get the start of the server's response\n> (the headers).  The download \"load\" fires once we get all the data.  If you're\n> testing with tiny server responses, you could be getting both in the same\n> packet, of course.\n\nThanks for the hint. I'm using PHP and that buffers the server's output...", "creation_time": "2011-03-01T07:39:52Z", "text": "(In reply to comment #4)\n> Yeah, I think this is invalid.  Until we get a response from the server we\n> don't know that that the data has actually been sent (and in fact in some cases\n> we may have to resend it)....\n> \nIf you leave this as invalid, would it at least be possible (or even necessary) to fire the progress event one last time (e.g. right when finished sending all bytes without waiting for the servers response) and to set evt.loaded == evt.total ?\n\n> Simon, the upload \"load\" fires when we get the start of the server's response\n> (the headers).  The download \"load\" fires once we get all the data.  If you're\n> testing with tiny server responses, you could be getting both in the same\n> packet, of course.\n\nThanks for the hint. I'm using PHP and that buffers the server's output...", "attachment_id": null, "time": "2011-03-01T07:39:52Z", "is_private": false}, {"author": "bugs@pettay.fi", "id": 5311277, "raw_text": "(In reply to comment #5)\n> If you leave this as invalid, would it at least be possible (or even necessary)\n> to fire the progress event one last time (e.g. right when finished sending all\n> bytes without waiting for the servers response) and to set evt.loaded ==\n> evt.total ?\nThat could violate XMLHttpRequest v2 spec. progress events shouldn't fire\nmore often than every 50ms.", "creation_time": "2011-03-01T12:40:27Z", "text": "(In reply to comment #5)\n> If you leave this as invalid, would it at least be possible (or even necessary)\n> to fire the progress event one last time (e.g. right when finished sending all\n> bytes without waiting for the servers response) and to set evt.loaded ==\n> evt.total ?\nThat could violate XMLHttpRequest v2 spec. progress events shouldn't fire\nmore often than every 50ms.", "tags": [], "creator": "bugs@pettay.fi", "count": 6, "bug_id": 637002, "attachment_id": null, "is_private": false, "time": "2011-03-01T12:40:27Z"}, {"bug_id": 637002, "tags": [], "creator": "bugs@pettay.fi", "time": "2011-03-10T16:01:38Z", "count": 7, "raw_text": "Btw, I just checked, Chrome does occasionally fire \"progress\" event way too\noften.", "id": 5336256, "text": "Btw, I just checked, Chrome does occasionally fire \"progress\" event way too\noften.", "creation_time": "2011-03-10T16:01:38Z", "is_private": false, "author": "bugs@pettay.fi", "attachment_id": null}, {"raw_text": "", "id": 5350799, "text": "*** Bug 642463 has been marked as a duplicate of this bug. ***", "creation_time": "2011-03-17T15:34:31Z", "bug_id": 637002, "count": 8, "creator": "bzbarsky@mit.edu", "tags": [], "author": "bzbarsky@mit.edu", "is_private": false, "time": "2011-03-17T15:34:31Z", "attachment_id": null}, {"attachment_id": null, "is_private": false, "time": "2011-03-17T15:44:38Z", "author": "bzbarsky@mit.edu", "id": 5350818, "raw_text": "For what it's worth, I posted http://lists.w3.org/Archives/Public/public-webapps/2011JanMar/0988.html about the fact that Chrome and the spec seem to disagree here.", "creation_time": "2011-03-17T15:44:38Z", "text": "For what it's worth, I posted http://lists.w3.org/Archives/Public/public-webapps/2011JanMar/0988.html about the fact that Chrome and the spec seem to disagree here.", "creator": "bzbarsky@mit.edu", "tags": [], "count": 9, "bug_id": 637002}, {"bug_id": 637002, "time": "2011-03-17T19:24:59Z", "creator": "glenn@zewt.org", "count": 10, "tags": [], "raw_text": "(In reply to comment #6)\n> (In reply to comment #5)\n> > If you leave this as invalid, would it at least be possible (or even necessary)\n> > to fire the progress event one last time (e.g. right when finished sending all\n> > bytes without waiting for the servers response) and to set evt.loaded ==\n> > evt.total ?\n> That could violate XMLHttpRequest v2 spec. progress events shouldn't fire\n> more often than every 50ms.\n\nI've posted about this issue separately.  http://lists.w3.org/Archives/Public/public-webapps/2011JanMar/0993.html", "id": 5351524, "text": "(In reply to comment #6)\n> (In reply to comment #5)\n> > If you leave this as invalid, would it at least be possible (or even necessary)\n> > to fire the progress event one last time (e.g. right when finished sending all\n> > bytes without waiting for the servers response) and to set evt.loaded ==\n> > evt.total ?\n> That could violate XMLHttpRequest v2 spec. progress events shouldn't fire\n> more often than every 50ms.\n\nI've posted about this issue separately.  http://lists.w3.org/Archives/Public/public-webapps/2011JanMar/0993.html", "creation_time": "2011-03-17T19:24:59Z", "is_private": false, "author": "glenn@zewt.org", "attachment_id": null}, {"is_private": false, "time": "2011-06-22T07:50:05Z", "attachment_id": null, "raw_text": "Does using FF5's new loadend event fix my problem?\nhttps://developer.mozilla.org/En/XMLHttpRequest/Using_XMLHttpRequest#Detecting_any_load_end_condition", "id": 5547599, "text": "Does using FF5's new loadend event fix my problem?\nhttps://developer.mozilla.org/En/XMLHttpRequest/Using_XMLHttpRequest#Detecting_any_load_end_condition", "creation_time": "2011-06-22T07:50:05Z", "bug_id": 637002, "creator": "simon@speich.net", "tags": [], "count": 11, "author": "simon@speich.net"}, {"raw_text": "", "id": 6660491, "text": "*** Bug 793679 has been marked as a duplicate of this bug. ***", "creation_time": "2012-09-24T15:22:12Z", "bug_id": 637002, "creator": "bzbarsky@mit.edu", "count": 12, "tags": [], "author": "bzbarsky@mit.edu", "is_private": false, "time": "2012-09-24T15:22:12Z", "attachment_id": null}, {"bug_id": 637002, "creator": "bzbarsky@mit.edu", "tags": [], "count": 13, "raw_text": "", "id": 6660497, "text": "*** Bug 781687 has been marked as a duplicate of this bug. ***", "creation_time": "2012-09-24T15:22:58Z", "author": "bzbarsky@mit.edu", "time": "2012-09-24T15:22:58Z", "is_private": false, "attachment_id": null}, {"id": 6660502, "raw_text": "Note that the spec discussion was ... inconclusive.\n\nIf we decide we want to change this behavior, we'll need a way for necko to tell us it's done sending the data.", "creation_time": "2012-09-24T15:24:17Z", "is_private": false, "text": "Note that the spec discussion was ... inconclusive.\n\nIf we decide we want to change this behavior, we'll need a way for necko to tell us it's done sending the data.", "time": "2012-09-24T15:24:17Z", "creator": "bzbarsky@mit.edu", "count": 14, "tags": [], "bug_id": 637002, "attachment_id": null, "author": "bzbarsky@mit.edu"}, {"time": "2014-04-03T20:33:39Z", "is_private": false, "attachment_id": null, "tags": [], "count": 15, "creator": "russell.mcclellan@gmail.com", "bug_id": 637002, "creation_time": "2014-04-03T20:33:39Z", "text": "I ran into this while developing a website.  I've read http://www.w3.org/TR/XMLHttpRequest/#make-upload-progress-notifications , and it seems unequivocal that the load event should be sent 'irrespective of whether the server has started transmitting a response or the status code of such a response'.  Reads pretty clear to me (although I don't have much training with standards-speak)", "id": 8618716, "raw_text": "I ran into this while developing a website.  I've read http://www.w3.org/TR/XMLHttpRequest/#make-upload-progress-notifications , and it seems unequivocal that the load event should be sent 'irrespective of whether the server has started transmitting a response or the status code of such a response'.  Reads pretty clear to me (although I don't have much training with standards-speak)", "author": "russell.mcclellan@gmail.com"}, {"bug_id": 637002, "tags": [], "count": 16, "creator": "bzbarsky@mit.edu", "raw_text": "We should probably reopen.\n\nI still think the spec is nonsense in the face of a retransmit, but it's hardly the first nonsensical spec out there....\n\nOver to necko for an API that will tell us when to fire this event.", "id": 8619985, "text": "We should probably reopen.\n\nI still think the spec is nonsense in the face of a retransmit, but it's hardly the first nonsensical spec out there....\n\nOver to necko for an API that will tell us when to fire this event.", "creation_time": "2014-04-04T02:36:59Z", "author": "bzbarsky@mit.edu", "time": "2014-04-04T02:36:59Z", "is_private": false, "attachment_id": null}, {"creator": "mcmanus@ducksong.com", "tags": [], "time": "2014-04-04T15:24:57Z", "count": 17, "bug_id": 637002, "creation_time": "2014-04-04T15:24:57Z", "is_private": false, "text": "we can easily enough add a notification for when necko is done sending the data.. but we can't easily figure out when the data has arrived at the server though. Basically that would require a trigger on the TCP level ack of the last data byte and that's not-worth-the-trouble for at least two reasons:\n\n1] OS Limitations don't have an event driven architecture for such a thing. To the extent its even possible (which may not be universal) we'd need to basically just continually poll the kernel asking if all the data had been acked yet. Constantly polling the kernel at mumble millisecond granularity is not a kind thing to do to your battery or the event loop.\n\n2] propogation delay of the ack means the timestamp will be off by ~1/2 rtt anyhow.\n\nBut, like I said we can certainly notify the rest of gecko when the whole upload has been passed to the next layer. Realistically documents below a certain size will be moved into bufferspace immediately in the operating system. But for large uploads flow control will indeed push back on necko and the event will occur at least in the right general area of time. Note that modern networks need large buffers to work efficiently because they are both high bandwidth and often high delay too.\n\nIf the goal is to say \"I have a server timeout of 2 seconds and I don't want the upload time of my video to count against that\" it should be sufficient.. more granular use cases probably won't work awesomely.", "id": 8621774, "raw_text": "we can easily enough add a notification for when necko is done sending the data.. but we can't easily figure out when the data has arrived at the server though. Basically that would require a trigger on the TCP level ack of the last data byte and that's not-worth-the-trouble for at least two reasons:\n\n1] OS Limitations don't have an event driven architecture for such a thing. To the extent its even possible (which may not be universal) we'd need to basically just continually poll the kernel asking if all the data had been acked yet. Constantly polling the kernel at mumble millisecond granularity is not a kind thing to do to your battery or the event loop.\n\n2] propogation delay of the ack means the timestamp will be off by ~1/2 rtt anyhow.\n\nBut, like I said we can certainly notify the rest of gecko when the whole upload has been passed to the next layer. Realistically documents below a certain size will be moved into bufferspace immediately in the operating system. But for large uploads flow control will indeed push back on necko and the event will occur at least in the right general area of time. Note that modern networks need large buffers to work efficiently because they are both high bandwidth and often high delay too.\n\nIf the goal is to say \"I have a server timeout of 2 seconds and I don't want the upload time of my video to count against that\" it should be sufficient.. more granular use cases probably won't work awesomely.", "attachment_id": null, "author": "mcmanus@ducksong.com"}, {"attachment_id": null, "is_private": false, "time": "2014-04-04T17:59:44Z", "author": "bzbarsky@mit.edu", "raw_text": "> If the goal is to say\n\nIt's not clear what the goal is.  None of the discussion on the list ever mentioned any actual use cases past presenting \"upload is done\" UI to the user, afaict.", "id": 8622502, "text": "> If the goal is to say\n\nIt's not clear what the goal is.  None of the discussion on the list ever mentioned any actual use cases past presenting \"upload is done\" UI to the user, afaict.", "creation_time": "2014-04-04T17:59:44Z", "bug_id": 637002, "count": 18, "tags": [], "creator": "bzbarsky@mit.edu"}, {"attachment_id": null, "is_private": false, "time": "2014-04-04T18:08:47Z", "author": "mcmanus@ducksong.com", "text": "this notion is pretty broken in the face of proxies as well - just another buffer.", "creation_time": "2014-04-04T18:08:47Z", "raw_text": "this notion is pretty broken in the face of proxies as well - just another buffer.", "id": 8622534, "bug_id": 637002, "count": 19, "tags": [], "creator": "mcmanus@ducksong.com"}, {"text": "Just a note.\n\nIf you send a file with XHR 2 with Chromium 33:\n- when upload is finished, the 'xhr.upload.load' event is fired\n- when processing of your file is finished on the server and the response received by the browser, the 'xhr.onreadystatechange.readyState=4' event is fired\n\nIn Firefox 28, events are fired simultaneously.\n\nWith Chromium you can write: 0%... 25%.... 50%... 75%... 100% PHP processing now... do other thing.\nWith Firefox you can only write: 0%... 25%.... 50%... 75%... do other thing.\n\n(percent < 100 are written by 'xhr.upload.progress', percent = 100 and PHP processing is written by 'xhr.upload.load', do other thing is started by 'xhr.onreadystatechange.readyState=4')\n\nSee this: http://stackoverflow.com/a/15491086/2980105", "creation_time": "2014-09-14T16:39:40Z", "raw_text": "Just a note.\n\nIf you send a file with XHR 2 with Chromium 33:\n- when upload is finished, the 'xhr.upload.load' event is fired\n- when processing of your file is finished on the server and the response received by the browser, the 'xhr.onreadystatechange.readyState=4' event is fired\n\nIn Firefox 28, events are fired simultaneously.\n\nWith Chromium you can write: 0%... 25%.... 50%... 75%... 100% PHP processing now... do other thing.\nWith Firefox you can only write: 0%... 25%.... 50%... 75%... do other thing.\n\n(percent < 100 are written by 'xhr.upload.progress', percent = 100 and PHP processing is written by 'xhr.upload.load', do other thing is started by 'xhr.onreadystatechange.readyState=4')\n\nSee this: http://stackoverflow.com/a/15491086/2980105", "id": 9308899, "bug_id": 637002, "creator": "u456582@disabled.tld", "tags": [], "count": 20, "author": "u456582@disabled.tld", "is_private": false, "time": "2014-09-14T16:39:40Z", "attachment_id": null}, {"author": "bugs@pettay.fi", "text": "(In reply to luigifab from comment #20)\n\n> With Chromium you can write: 0%... 25%.... 50%... 75%... 100% PHP processing\n> now... do other thing.\n> With Firefox you can only write: 0%... 25%.... 50%... 75%... do other thing.\n> \n> (percent < 100 are written by 'xhr.upload.progress', percent = 100 and PHP\n> processing is written by 'xhr.upload.load', do other thing is started by\n> 'xhr.onreadystatechange.readyState=4')\n> \n\nIn Chromium case nothing guarantees the data is in the php level when you get\n\"PHP processing\". It can be just buffered somewhere in the network level.", "creation_time": "2014-09-15T10:14:03Z", "raw_text": "(In reply to luigifab from comment #20)\n\n> With Chromium you can write: 0%... 25%.... 50%... 75%... 100% PHP processing\n> now... do other thing.\n> With Firefox you can only write: 0%... 25%.... 50%... 75%... do other thing.\n> \n> (percent < 100 are written by 'xhr.upload.progress', percent = 100 and PHP\n> processing is written by 'xhr.upload.load', do other thing is started by\n> 'xhr.onreadystatechange.readyState=4')\n> \n\nIn Chromium case nothing guarantees the data is in the php level when you get\n\"PHP processing\". It can be just buffered somewhere in the network level.", "id": 9310212, "bug_id": 637002, "tags": [], "count": 21, "creator": "bugs@pettay.fi", "attachment_id": null, "is_private": false, "time": "2014-09-15T10:14:03Z"}, {"bug_id": 637002, "tags": [], "time": "2014-09-15T20:22:02Z", "creator": "u456582@disabled.tld", "count": 22, "raw_text": "(In reply to Olli Pettay [:smaug] from comment #21)\n> In Chromium case nothing guarantees the data is in the php level when you get\n> \"PHP processing\". It can be just buffered somewhere in the network level.\n\nYeah, but if the upload is ended, we are waiting a response from the server, no?", "id": 9313042, "text": "(In reply to Olli Pettay [:smaug] from comment #21)\n> In Chromium case nothing guarantees the data is in the php level when you get\n> \"PHP processing\". It can be just buffered somewhere in the network level.\n\nYeah, but if the upload is ended, we are waiting a response from the server, no?", "is_private": false, "creation_time": "2014-09-15T20:22:02Z", "author": "u456582@disabled.tld", "attachment_id": null}, {"creator": "bzbarsky@mit.edu", "time": "2014-09-16T03:11:43Z", "tags": [], "count": 23, "bug_id": 637002, "id": 9314653, "raw_text": "No, we're waiting on an acknowledgement that the server has received the upload.  If that doesn't come, the upload can actually end up happening again, as I understand the situation.", "is_private": false, "creation_time": "2014-09-16T03:11:43Z", "text": "No, we're waiting on an acknowledgement that the server has received the upload.  If that doesn't come, the upload can actually end up happening again, as I understand the situation.", "attachment_id": null, "author": "bzbarsky@mit.edu"}, {"author": "u456582@disabled.tld", "bug_id": 637002, "count": 24, "tags": [], "creator": "u456582@disabled.tld", "raw_text": "Hum... so this is the web server (like lighttpd) which is not sending this acknowledgement?\n\nupload start\n- user >>>> data sending\nupload end\n- user <<<< server ack?\nfile processing by a php script\n- user <<<< php response", "id": 9318236, "text": "Hum... so this is the web server (like lighttpd) which is not sending this acknowledgement?\n\nupload start\n- user >>>> data sending\nupload end\n- user <<<< server ack?\nfile processing by a php script\n- user <<<< php response", "creation_time": "2014-09-16T17:58:56Z", "attachment_id": null, "time": "2014-09-16T17:58:56Z", "is_private": false}, {"author": "bzbarsky@mit.edu", "attachment_id": null, "text": "The problem is that the HTTP protocol does not provide a way for the HTTP server to acknowledge receipt of the request other than by starting the HTTP response.\n\nBut yes, the php script could send the response headers immediately and the data once it's done processing if it wanted to.", "creation_time": "2014-09-16T18:21:54Z", "is_private": false, "raw_text": "The problem is that the HTTP protocol does not provide a way for the HTTP server to acknowledge receipt of the request other than by starting the HTTP response.\n\nBut yes, the php script could send the response headers immediately and the data once it's done processing if it wanted to.", "id": 9318381, "bug_id": 637002, "count": 25, "time": "2014-09-16T18:21:54Z", "creator": "bzbarsky@mit.edu", "tags": []}, {"time": "2014-09-16T20:36:27Z", "is_private": false, "attachment_id": null, "bug_id": 637002, "count": 26, "creator": "u456582@disabled.tld", "tags": [], "text": "Okayyyyyyyyyy! So, it's simple.\nLet's go for a complete example...\n\n> // YOUR (SIMPLE) JAVASCRIPT FILE\n> var form = new FormData(), xhr = new XMLHttpRequest();\n> form.append('inputname', document.querySelector('input').files[0]);\n> \n> xhr.open('POST', 'http://oneserver/onephpfile', true);\n> xhr.setRequestHeader('X-CSRF-Token', 'somestring');\n> \n> xhr.onreadystatechange = function () {\n> \tif ((xhr.readyState === 4) && (xhr.status === 200))\n> \t\t// do other thing with xhr.responseText.trim()\n> };\n> \n> xhr.upload.addEventListener('loadstart', showProgressBarFunction, false);\n> xhr.upload.addEventListener('progress',  updateProgressBarFunction, false);\n> xhr.upload.addEventListener('load',      updateProgressBarFunction, false);\n> \n> xhr.send(form);\n\n> // YOUR FIRST (SIMPLE) PHP FILE\n> header('Content-Type: text/plain; charset=utf-8');\n> header('Cache-Control: no-cache, must-revalidate');\n> header('Pragma: no-cache');\n> \n> sleep(20);\n> echo 'file processing ended';\n\nWith this first PHP file, you will see: 10%... 50%... 75%... 'do other thing'\n with Firefox (4/10/28/32) and IE (10/11).\n\nBut you we will see: 10%... 50%... 75%... 100%... 'do other thing'\n with Chrome/Chromium (37/33) and Opera (24).\n\n> // YOUR SECOND (SIMPLE) PHP FILE\n> header('Content-Type: text/plain; charset=utf-8');\n> header('Cache-Control: no-cache, must-revalidate');\n> header('Pragma: no-cache');\n> \n> header('Content-Encoding: chunked', true);\n> header('Connection: Keep-Alive', true);\n> ini_set('max_execution_time', 60);\n> ini_set('output_buffering', false);\n> ini_set('implicit_flush', true);\n> ob_implicit_flush(true);\n> for ($i = 0; $i < ob_get_level(); $i++)\n> \tob_end_clean();\n> echo ' ';\n> \n> sleep(20);\n> echo 'file processing ended';\n\nWith this second PHP file, you will see: 10%... 50%... 75%... 100%... 'do other thing'\n with Chrome/Chromium (37/33), Opera (24), Firefox (4/10/28/32) and IE (10/11)!\n\nI just think that Chrome and Opera displaying 100% before Firefox and Opera, but this is not very important...", "creation_time": "2014-09-16T20:36:27Z", "raw_text": "Okayyyyyyyyyy! So, it's simple.\nLet's go for a complete example...\n\n> // YOUR (SIMPLE) JAVASCRIPT FILE\n> var form = new FormData(), xhr = new XMLHttpRequest();\n> form.append('inputname', document.querySelector('input').files[0]);\n> \n> xhr.open('POST', 'http://oneserver/onephpfile', true);\n> xhr.setRequestHeader('X-CSRF-Token', 'somestring');\n> \n> xhr.onreadystatechange = function () {\n> \tif ((xhr.readyState === 4) && (xhr.status === 200))\n> \t\t// do other thing with xhr.responseText.trim()\n> };\n> \n> xhr.upload.addEventListener('loadstart', showProgressBarFunction, false);\n> xhr.upload.addEventListener('progress',  updateProgressBarFunction, false);\n> xhr.upload.addEventListener('load',      updateProgressBarFunction, false);\n> \n> xhr.send(form);\n\n> // YOUR FIRST (SIMPLE) PHP FILE\n> header('Content-Type: text/plain; charset=utf-8');\n> header('Cache-Control: no-cache, must-revalidate');\n> header('Pragma: no-cache');\n> \n> sleep(20);\n> echo 'file processing ended';\n\nWith this first PHP file, you will see: 10%... 50%... 75%... 'do other thing'\n with Firefox (4/10/28/32) and IE (10/11).\n\nBut you we will see: 10%... 50%... 75%... 100%... 'do other thing'\n with Chrome/Chromium (37/33) and Opera (24).\n\n> // YOUR SECOND (SIMPLE) PHP FILE\n> header('Content-Type: text/plain; charset=utf-8');\n> header('Cache-Control: no-cache, must-revalidate');\n> header('Pragma: no-cache');\n> \n> header('Content-Encoding: chunked', true);\n> header('Connection: Keep-Alive', true);\n> ini_set('max_execution_time', 60);\n> ini_set('output_buffering', false);\n> ini_set('implicit_flush', true);\n> ob_implicit_flush(true);\n> for ($i = 0; $i < ob_get_level(); $i++)\n> \tob_end_clean();\n> echo ' ';\n> \n> sleep(20);\n> echo 'file processing ended';\n\nWith this second PHP file, you will see: 10%... 50%... 75%... 100%... 'do other thing'\n with Chrome/Chromium (37/33), Opera (24), Firefox (4/10/28/32) and IE (10/11)!\n\nI just think that Chrome and Opera displaying 100% before Firefox and Opera, but this is not very important...", "id": 9319267, "author": "u456582@disabled.tld"}, {"attachment_id": null, "author": "bug-husbandry-bot@mozilla.bugs", "id": 12658843, "raw_text": "Bulk change to priority: https://bugzilla.mozilla.org/show_bug.cgi?id=1399258", "is_private": false, "creation_time": "2017-09-13T18:39:44Z", "text": "Bulk change to priority: https://bugzilla.mozilla.org/show_bug.cgi?id=1399258", "tags": [], "count": 27, "creator": "bug-husbandry-bot@mozilla.bugs", "time": "2017-09-13T18:39:44Z", "bug_id": 637002}]}}, "comments": {}}