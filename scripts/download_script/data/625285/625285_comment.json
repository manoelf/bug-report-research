{"comments": {}, "bugs": {"625285": {"comments": [{"count": 0, "author": "jmuizelaar@mozilla.com", "is_private": false, "id": 5195839, "tags": [], "creator": "jmuizelaar@mozilla.com", "raw_text": "We should be able to use some of the Apple extensions to avoid an extra copy here.", "attachment_id": null, "time": "2011-01-13T04:34:09Z", "creation_time": "2011-01-13T04:34:09Z", "bug_id": 625285, "text": "We should be able to use some of the Apple extensions to avoid an extra copy here."}, {"count": 1, "author": "ajuma.bugzilla@alijuma.com", "id": 5554962, "tags": [], "is_private": false, "raw_text": "Using the Apple Client Storage extension significantly reduces copying (in my testing, I'm seeing roughly a 50% reduction in time spent in memcpy when viewing a 720p video).", "creator": "ajuma.bugzilla@alijuma.com", "attachment_id": 541784, "bug_id": 625285, "text": "Created attachment 541784\nImplementation of Apple Client Storage extension\n\nUsing the Apple Client Storage extension significantly reduces copying (in my testing, I'm seeing roughly a 50% reduction in time spent in memcpy when viewing a 720p video).", "time": "2011-06-24T20:48:32Z", "creation_time": "2011-06-24T20:48:32Z"}, {"count": 2, "author": "ajuma.bugzilla@alijuma.com", "raw_text": "I've fixed the approach I was using to make sure OpenGL is done with a client storage buffer before reusing it, and I've added a check for whether the client storage extension is supported (when it isn't, the existing code is used instead).", "creator": "ajuma.bugzilla@alijuma.com", "attachment_id": 542452, "id": 5561511, "bug_id": 625285, "tags": [], "text": "Created attachment 542452\nImplementation of Apple Client Storage extension\n\nI've fixed the approach I was using to make sure OpenGL is done with a client storage buffer before reusing it, and I've added a check for whether the client storage extension is supported (when it isn't, the existing code is used instead).", "is_private": false, "time": "2011-06-28T13:57:22Z", "creation_time": "2011-06-28T13:57:22Z"}, {"text": "Comment on attachment 542452\nImplementation of Apple Client Storage extension\n\nReview of attachment 542452:\n-----------------------------------------------------------------\n\nThis looks really good, improved video performance is great :)\n\nJust a few comments, mainly regarding code duplication (especially when we extent this for other Layer types).\n\n::: gfx/layers/opengl/ImageLayerOGL.cpp\n@@ +130,5 @@\n> +/**\n> + * This is an event used to unref a GLContext on the main thread and\n> + * delete textures associated with that context.\n> + */\n> +class ClientStorageDeleter : public nsRunnable {\n\nAgain (if splinter gets my comments in the right order), we already have this code for the TextureDeleter, I would be very happy if we could re-use it :)\n\n@@ +338,5 @@\n> +                           LOCAL_GL_UNSIGNED_BYTE,\n> +                           mData.mCrChannel);\n> +\n> +  mContext->fBindTexture(LOCAL_GL_TEXTURE_2D, 0);\n> +  mContext->fPixelStorei(LOCAL_GL_UNPACK_CLIENT_STORAGE_APPLE, LOCAL_GL_FALSE);\n\nI'm assuming that calling glTexSubImage2D forces the pipeline to finish all current rendering operations with this texture? A comment detailing this would be nice.\n\n@@ +385,5 @@\n> +  if (mRecycledClientStorages.IsEmpty() || \n> +      mRecycledClientStorageSize.mYSize != aData.mYSize ||\n> +      mRecycledClientStorageSize.mCbCrSize != aData.mCbCrSize ||\n> +      mRecycledClientStorageSize.mYStride != aData.mYStride ||\n> +      mRecycledClientStorageSize.mCbCrStride != aData.mCbCrStride) {\n\nIs there any reason we only check the top of the stored list to see if the size is correct? (I realize the other RecycleBin implementations do the same).\n\nIt seems like if we have multiple videos playing then this will always have to allocate new images unnecessarily.\n\n@@ +403,5 @@\n> +\n> +  if (mDirtyClientStorages.Length() > 0) {\n> +    GLClientStorage* cs = mDirtyClientStorages[0].forget();\n> +    cs->CleanTextures();\n> +    mRecycledClientStorages.AppendElement(cs);\n\nDo we need to set mRecycledClientStorageSize here?\n\n@@ +680,5 @@\n> +      if (!yuvImage->mClientStorage->AreTexturesAllocated()) {\n> +        yuvImage->mClientStorage->AllocateTextures(gl());\n> +      }\n> +      // This call has to be made by the main thread, so we make it here.\n> +      yuvImage->mRecycleBin->CleanClientStorages();\n\nRather than doing this here, could we delay until the end of the painting cycle (when we call Flush/SwapBuffers), and then move everything from the dirty list into the clean list?\n\n::: gfx/layers/opengl/ImageLayerOGL.h\n@@ +101,5 @@\n> + * on the main thread.\n> + *\n> + * Initially the buffer is allocated but the textures are not.\n> + */\n> +class GLClientStorage {\n\nIf we're planning on using GLClientStorage for ThebesLayerOGL as well, then we probably should make a shared based class that wraps a single client storage-backed texture and use 3 of them here (possibly within a thin YCbCrImage wrapper).\n\nThe current interface for this class looks very similar to GLTexture, could we implement this code as a sub-class of that and have the client storage specific stuff be an implementation detail?\n\nRecycleBin could then make a platform-specific decision as to which class to instantiate based on extension availability.\n\nWe'd need to move the GLTexture/RecycleBin code into a shared location.", "bug_id": 625285, "creation_time": "2011-07-06T14:53:41Z", "time": "2011-07-06T14:53:41Z", "attachment_id": 542452, "creator": "matt.woodrow@gmail.com", "raw_text": "Review of attachment 542452:\n-----------------------------------------------------------------\n\nThis looks really good, improved video performance is great :)\n\nJust a few comments, mainly regarding code duplication (especially when we extent this for other Layer types).\n\n::: gfx/layers/opengl/ImageLayerOGL.cpp\n@@ +130,5 @@\n> +/**\n> + * This is an event used to unref a GLContext on the main thread and\n> + * delete textures associated with that context.\n> + */\n> +class ClientStorageDeleter : public nsRunnable {\n\nAgain (if splinter gets my comments in the right order), we already have this code for the TextureDeleter, I would be very happy if we could re-use it :)\n\n@@ +338,5 @@\n> +                           LOCAL_GL_UNSIGNED_BYTE,\n> +                           mData.mCrChannel);\n> +\n> +  mContext->fBindTexture(LOCAL_GL_TEXTURE_2D, 0);\n> +  mContext->fPixelStorei(LOCAL_GL_UNPACK_CLIENT_STORAGE_APPLE, LOCAL_GL_FALSE);\n\nI'm assuming that calling glTexSubImage2D forces the pipeline to finish all current rendering operations with this texture? A comment detailing this would be nice.\n\n@@ +385,5 @@\n> +  if (mRecycledClientStorages.IsEmpty() || \n> +      mRecycledClientStorageSize.mYSize != aData.mYSize ||\n> +      mRecycledClientStorageSize.mCbCrSize != aData.mCbCrSize ||\n> +      mRecycledClientStorageSize.mYStride != aData.mYStride ||\n> +      mRecycledClientStorageSize.mCbCrStride != aData.mCbCrStride) {\n\nIs there any reason we only check the top of the stored list to see if the size is correct? (I realize the other RecycleBin implementations do the same).\n\nIt seems like if we have multiple videos playing then this will always have to allocate new images unnecessarily.\n\n@@ +403,5 @@\n> +\n> +  if (mDirtyClientStorages.Length() > 0) {\n> +    GLClientStorage* cs = mDirtyClientStorages[0].forget();\n> +    cs->CleanTextures();\n> +    mRecycledClientStorages.AppendElement(cs);\n\nDo we need to set mRecycledClientStorageSize here?\n\n@@ +680,5 @@\n> +      if (!yuvImage->mClientStorage->AreTexturesAllocated()) {\n> +        yuvImage->mClientStorage->AllocateTextures(gl());\n> +      }\n> +      // This call has to be made by the main thread, so we make it here.\n> +      yuvImage->mRecycleBin->CleanClientStorages();\n\nRather than doing this here, could we delay until the end of the painting cycle (when we call Flush/SwapBuffers), and then move everything from the dirty list into the clean list?\n\n::: gfx/layers/opengl/ImageLayerOGL.h\n@@ +101,5 @@\n> + * on the main thread.\n> + *\n> + * Initially the buffer is allocated but the textures are not.\n> + */\n> +class GLClientStorage {\n\nIf we're planning on using GLClientStorage for ThebesLayerOGL as well, then we probably should make a shared based class that wraps a single client storage-backed texture and use 3 of them here (possibly within a thin YCbCrImage wrapper).\n\nThe current interface for this class looks very similar to GLTexture, could we implement this code as a sub-class of that and have the client storage specific stuff be an implementation detail?\n\nRecycleBin could then make a platform-specific decision as to which class to instantiate based on extension availability.\n\nWe'd need to move the GLTexture/RecycleBin code into a shared location.", "tags": [], "id": 5576349, "is_private": false, "author": "matt.woodrow@gmail.com", "count": 3}, {"time": "2011-07-06T14:55:01Z", "creation_time": "2011-07-06T14:55:01Z", "bug_id": 625285, "text": "Indeed splinter did not arrange my comments in order :)\n\nRead the ImageLayerOGL.h comments before the .cpp ones!", "creator": "matt.woodrow@gmail.com", "raw_text": "Indeed splinter did not arrange my comments in order :)\n\nRead the ImageLayerOGL.h comments before the .cpp ones!", "attachment_id": null, "is_private": false, "id": 5576354, "tags": [], "count": 4, "author": "matt.woodrow@gmail.com"}, {"author": "matt.woodrow@gmail.com", "count": 5, "raw_text": "Looking at this again, I'm not sure if we ever want to use this with other layer types.\n\nWe tried using this for ThebesLayers (bug 575521), and it ended up being a regression (bug 611564). It appeared that the only solution (other than switching to PBO's) was to use glTextureRangeAPPLE which is a huge undertaking.", "creator": "matt.woodrow@gmail.com", "attachment_id": null, "tags": [], "text": "Looking at this again, I'm not sure if we ever want to use this with other layer types.\n\nWe tried using this for ThebesLayers (bug 575521), and it ended up being a regression (bug 611564). It appeared that the only solution (other than switching to PBO's) was to use glTextureRangeAPPLE which is a huge undertaking.", "id": 5875097, "bug_id": 625285, "creation_time": "2011-11-28T09:19:19Z", "time": "2011-11-28T09:19:19Z", "is_private": false}, {"raw_text": "It might still be worth another try. The approach in Bug 575521 doesn't appear to permanently associate textures and corresponding client storage buffers; instead, each upload involves using glTexImage2D to create a new association. I wonder if using (and recycling) texture objects that are permanently backed by a client storage buffer will give better performance.", "creator": "ajuma.bugzilla@alijuma.com", "attachment_id": null, "author": "ajuma.bugzilla@alijuma.com", "count": 6, "creation_time": "2011-11-28T14:31:10Z", "time": "2011-11-28T14:31:10Z", "is_private": false, "tags": [], "text": "It might still be worth another try. The approach in Bug 575521 doesn't appear to permanently associate textures and corresponding client storage buffers; instead, each upload involves using glTexImage2D to create a new association. I wonder if using (and recycling) texture objects that are permanently backed by a client storage buffer will give better performance.", "id": 5875479, "bug_id": 625285}, {"is_private": false, "time": "2011-12-13T19:41:49Z", "creation_time": "2011-12-13T19:41:49Z", "bug_id": 625285, "id": 5912963, "text": "(In reply to Matt Woodrow (:mattwoodrow) from comment #3)\n\n> @@ +385,5 @@\n> > +  if (mRecycledClientStorages.IsEmpty() || \n> > +      mRecycledClientStorageSize.mYSize != aData.mYSize ||\n> > +      mRecycledClientStorageSize.mCbCrSize != aData.mCbCrSize ||\n> > +      mRecycledClientStorageSize.mYStride != aData.mYStride ||\n> > +      mRecycledClientStorageSize.mCbCrStride != aData.mCbCrStride) {\n> \n> Is there any reason we only check the top of the stored list to see if the\n> size is correct? (I realize the other RecycleBin implementations do the\n> same).\n> \n> It seems like if we have multiple videos playing then this will always have\n> to allocate new images unnecessarily.\n\nAs far as I can tell, when we have multiple videos playing, each will have its own ImageContainer and hence its own RecycleBin. So I think it's reasonable for a RecycleBin to restrict itself to a single size.", "tags": [], "attachment_id": null, "creator": "ajuma.bugzilla@alijuma.com", "raw_text": "(In reply to Matt Woodrow (:mattwoodrow) from comment #3)\n\n> @@ +385,5 @@\n> > +  if (mRecycledClientStorages.IsEmpty() || \n> > +      mRecycledClientStorageSize.mYSize != aData.mYSize ||\n> > +      mRecycledClientStorageSize.mCbCrSize != aData.mCbCrSize ||\n> > +      mRecycledClientStorageSize.mYStride != aData.mYStride ||\n> > +      mRecycledClientStorageSize.mCbCrStride != aData.mCbCrStride) {\n> \n> Is there any reason we only check the top of the stored list to see if the\n> size is correct? (I realize the other RecycleBin implementations do the\n> same).\n> \n> It seems like if we have multiple videos playing then this will always have\n> to allocate new images unnecessarily.\n\nAs far as I can tell, when we have multiple videos playing, each will have its own ImageContainer and hence its own RecycleBin. So I think it's reasonable for a RecycleBin to restrict itself to a single size.", "count": 7, "author": "ajuma.bugzilla@alijuma.com"}]}}}