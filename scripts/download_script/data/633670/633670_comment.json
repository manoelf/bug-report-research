{"comments": {}, "bugs": {"633670": {"comments": [{"count": 0, "text": "Lately we've taken more notice of \"leaks\", where we hold on to an object longer than we should (but not past shutdown).  I was thinking about ways to write tests for these kinds of bugs since our traditional tests won't catch these and came up with the following.\n\nProvide two new global functions (on SpecialPowers?  as an xpcom object?):\n\nregisterObject: takes an object that supports weak references (which includes the big ones, documents and windows), stores a weak ref, and hands back some sort of identifier.\nisObjectDead: takes the identifier mentioned above, looks up the weak reference, forces a GC/CC, and then sees if the object is still alive via the weakref.\n\nThis won't let us test everything, but it would get the big objects.  Jesse, would this help you fuzz for this kind of stuff?\n\nThoughts, comments?", "time": "2011-02-12T01:26:37Z", "author": "khuey@kylehuey.com", "id": 5274284, "creation_time": "2011-02-12T01:26:37Z", "bug_id": 633670, "raw_text": "Lately we've taken more notice of \"leaks\", where we hold on to an object longer than we should (but not past shutdown).  I was thinking about ways to write tests for these kinds of bugs since our traditional tests won't catch these and came up with the following.\n\nProvide two new global functions (on SpecialPowers?  as an xpcom object?):\n\nregisterObject: takes an object that supports weak references (which includes the big ones, documents and windows), stores a weak ref, and hands back some sort of identifier.\nisObjectDead: takes the identifier mentioned above, looks up the weak reference, forces a GC/CC, and then sees if the object is still alive via the weakref.\n\nThis won't let us test everything, but it would get the big objects.  Jesse, would this help you fuzz for this kind of stuff?\n\nThoughts, comments?", "tags": [], "creator": "khuey@kylehuey.com", "attachment_id": null, "is_private": false}, {"id": 5275211, "time": "2011-02-12T22:34:27Z", "tags": [], "raw_text": "For regression tests, this sounds excellent.  It could be used to construct an automated test for bug 610956, for example.\n\nI'd keep the GC/CC calls separate from isObjectDead.  It can be too much, if you're hoping to check isObjectDead for a bunch of objects at once, and want it to be fast.  It can be too little, if collecting an object requires multiple CCs or a return to the event loop between CCs (e.g. bug 610166).\n\nYou might want to provide an async GC/CC API to guarantee that conservative stack scanning won't incorrectly keep things alive.\n\nFor fuzzing, I'm not sure this would be useful.  With all the crazy stuff going on, there's no obvious point at which a given {frame, tab, browser window, page in session history} \"should be dead\".  I can close all browser windows (or navigate away from the main fuzz page with bfcache disabled? - see bug 630072 comment 53), but then I'm happier counting the remaining windows and documents than asking whether specific windows and documents are alive.", "bug_id": 633670, "creation_time": "2011-02-12T22:34:27Z", "is_private": false, "count": 1, "text": "For regression tests, this sounds excellent.  It could be used to construct an automated test for bug 610956, for example.\n\nI'd keep the GC/CC calls separate from isObjectDead.  It can be too much, if you're hoping to check isObjectDead for a bunch of objects at once, and want it to be fast.  It can be too little, if collecting an object requires multiple CCs or a return to the event loop between CCs (e.g. bug 610166).\n\nYou might want to provide an async GC/CC API to guarantee that conservative stack scanning won't incorrectly keep things alive.\n\nFor fuzzing, I'm not sure this would be useful.  With all the crazy stuff going on, there's no obvious point at which a given {frame, tab, browser window, page in session history} \"should be dead\".  I can close all browser windows (or navigate away from the main fuzz page with bfcache disabled? - see bug 630072 comment 53), but then I'm happier counting the remaining windows and documents than asking whether specific windows and documents are alive.", "author": "jruderman@gmail.com", "creator": "jruderman@gmail.com", "attachment_id": null}, {"attachment_id": null, "is_private": false, "creator": "continuation@gmail.com", "tags": [], "raw_text": "This sounds very similar in philosophy to David Baron's (I think) ExplainLiveExpectedGarbage for the CC.  I'm not sure exactly how that works, or how effective he found it to be.", "creation_time": "2011-06-15T00:22:20Z", "bug_id": 633670, "id": 5532914, "author": "continuation@gmail.com", "time": "2011-06-15T00:22:20Z", "text": "This sounds very similar in philosophy to David Baron's (I think) ExplainLiveExpectedGarbage for the CC.  I'm not sure exactly how that works, or how effective he found it to be.", "count": 2}, {"author": "jruderman@gmail.com", "count": 3, "text": "> You might want to provide an async GC/CC API to guarantee that conservative\n> stack scanning won't incorrectly keep things alive.\n\njdm added such an API in bug 661927 :)", "attachment_id": null, "creator": "jruderman@gmail.com", "time": "2011-07-03T18:15:35Z", "id": 5571883, "is_private": false, "bug_id": 633670, "creation_time": "2011-07-03T18:15:35Z", "raw_text": "> You might want to provide an async GC/CC API to guarantee that conservative\n> stack scanning won't incorrectly keep things alive.\n\njdm added such an API in bug 661927 :)", "tags": []}, {"is_private": false, "creation_time": "2011-08-29T00:45:08Z", "bug_id": 633670, "raw_text": "What's the status of this?", "tags": [], "time": "2011-08-29T00:45:08Z", "id": 5683914, "attachment_id": null, "creator": "n.nethercote@gmail.com", "author": "n.nethercote@gmail.com", "count": 4, "text": "What's the status of this?"}, {"time": "2011-08-29T15:54:33Z", "id": 5685025, "is_private": false, "creation_time": "2011-08-29T15:54:33Z", "bug_id": 633670, "raw_text": "I have a patch in my queue but ran into a bug that was hard to track down and then got whisked away to other things.  I'll see if I can figure it out soon.", "tags": [], "author": "khuey@kylehuey.com", "text": "I have a patch in my queue but ran into a bug that was hard to track down and then got whisked away to other things.  I'll see if I can figure it out soon.", "count": 5, "attachment_id": null, "creator": "khuey@kylehuey.com"}, {"time": "2011-08-29T16:11:54Z", "id": 5685060, "creation_time": "2011-08-29T16:11:54Z", "bug_id": 633670, "raw_text": "Heh, and with a few weeks distance it was pretty easy to find the bug.", "tags": [], "is_private": false, "text": "Created attachment 556571\nPatch\n\nHeh, and with a few weeks distance it was pretty easy to find the bug.", "count": 6, "author": "khuey@kylehuey.com", "creator": "khuey@kylehuey.com", "attachment_id": 556571}, {"is_private": false, "attachment_id": 556571, "creation_time": "2011-09-06T23:27:04Z", "bug_id": 633670, "raw_text": ">+already_AddRefed<mozILifetimeTester>\n>+GetLifetimeTester()\n>+{\n>+  if (!sLifetimeTester) {\n>+    // The service manager will hold us alive until shutdown.\n>+    sLifetimeTester = new mozLifetimeTester();\n>+    bool inited = sLifetimeTester->Init();\n>+    NS_ENSURE_TRUE(inited, nsnull);\n>+  }\n\nI'm not a fan of this function, for a few reasons:\n - it holds the object without adding a reference until near the end\n - it has an unnecessary QI\n - if Init() ever does fail, this'll return null the first time and\n   then non-null the rest (since you'll never actually call the destructor,\n   because of the first problem)\n\nDo you really need a moz prefix on a class inside mozilla::testing::?\nThat's not the convention we've been using.  (And I'm not crazy about\nmoz prefixes in general; I'd rather just stick with ns.)\n\nAlso, could you make ~mozLifetimeTester() explicitly private rather\nthan relying on the default?\n\nIn RegisterObject, why is it an error to register the same object\ntwice.  That seems like unnecessary pain -- why not just return the\nID?\n\nUsing the pointer as the ID doesn't seem valid -- it's subject to\npointer replay (though if you hit it you'll hit the NS_ERROR_UNEXPECTED\nyou currently have, but I think that's a bad idea -- could still lead to\nrandom test failures).  I think you need to generate and track your own\nIDs.  (In that case, RegisterObject could just always give out a new ID\neven if the object is already registered.) If you do that you could even\nuse an array rather than a hashtable.\n\nIn the IDL, don't have an empty comment.  Either have none or say\nsomething.  Preferably say something useful.\n\n\n\nYou should ask bsmedberg, as xpcom owner, if he's ok with the file\nlocation and the mozilla::testing:: namespace, at the very least.\n\nreview- because of the pointer replay issues", "tags": [], "creator": "dbaron@dbaron.org", "time": "2011-09-06T23:27:04Z", "author": "dbaron@dbaron.org", "id": 5703493, "count": 7, "text": "Comment on attachment 556571\nPatch\n\n>+already_AddRefed<mozILifetimeTester>\n>+GetLifetimeTester()\n>+{\n>+  if (!sLifetimeTester) {\n>+    // The service manager will hold us alive until shutdown.\n>+    sLifetimeTester = new mozLifetimeTester();\n>+    bool inited = sLifetimeTester->Init();\n>+    NS_ENSURE_TRUE(inited, nsnull);\n>+  }\n\nI'm not a fan of this function, for a few reasons:\n - it holds the object without adding a reference until near the end\n - it has an unnecessary QI\n - if Init() ever does fail, this'll return null the first time and\n   then non-null the rest (since you'll never actually call the destructor,\n   because of the first problem)\n\nDo you really need a moz prefix on a class inside mozilla::testing::?\nThat's not the convention we've been using.  (And I'm not crazy about\nmoz prefixes in general; I'd rather just stick with ns.)\n\nAlso, could you make ~mozLifetimeTester() explicitly private rather\nthan relying on the default?\n\nIn RegisterObject, why is it an error to register the same object\ntwice.  That seems like unnecessary pain -- why not just return the\nID?\n\nUsing the pointer as the ID doesn't seem valid -- it's subject to\npointer replay (though if you hit it you'll hit the NS_ERROR_UNEXPECTED\nyou currently have, but I think that's a bad idea -- could still lead to\nrandom test failures).  I think you need to generate and track your own\nIDs.  (In that case, RegisterObject could just always give out a new ID\neven if the object is already registered.) If you do that you could even\nuse an array rather than a hashtable.\n\nIn the IDL, don't have an empty comment.  Either have none or say\nsomething.  Preferably say something useful.\n\n\n\nYou should ask bsmedberg, as xpcom owner, if he's ok with the file\nlocation and the mozilla::testing:: namespace, at the very least.\n\nreview- because of the pointer replay issues"}]}}}