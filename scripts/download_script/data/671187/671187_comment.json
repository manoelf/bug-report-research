{"bugs": {"671187": {"comments": [{"count": 0, "creator": "masayuki@d-toybox.com", "is_private": false, "time": "2011-07-13T06:07:35Z", "bug_id": 671187, "tags": [], "text": "1. Open the URL in smaller window (i.e., need to resize if you don't see body's scrollbar).\n2. Mousedown on \"aaaaa\".\n3. Mousemove to bottom edge of the parent's body.\n\nThe iframe cannot be scrolled because its bottom edge is clipped by parent's body.\n\nI'm looking for the simple fix...", "author": "masayuki@d-toybox.com", "creation_time": "2011-07-13T06:07:35Z", "raw_text": "1. Open the URL in smaller window (i.e., need to resize if you don't see body's scrollbar).\n2. Mousedown on \"aaaaa\".\n3. Mousemove to bottom edge of the parent's body.\n\nThe iframe cannot be scrolled because its bottom edge is clipped by parent's body.\n\nI'm looking for the simple fix...", "attachment_id": null, "id": 5588370}, {"time": "2011-07-27T08:15:07Z", "bug_id": 671187, "tags": [], "text": "Created attachment 548711\nPatch part.1 Make inline methods to check reason of mouse event\n\nI'll add new synthesized event reason for auto scrolling. This patch sorts out the related code by the new inline functions.", "author": "masayuki@d-toybox.com", "creation_time": "2011-07-27T08:15:07Z", "count": 1, "creator": "masayuki@d-toybox.com", "is_private": false, "id": 5615988, "raw_text": "I'll add new synthesized event reason for auto scrolling. This patch sorts out the related code by the new inline functions.", "attachment_id": 548711}, {"time": "2011-07-27T08:21:45Z", "bug_id": 671187, "tags": [], "text": "Created attachment 548713\nPatch part.2 Make a new mouse event reason for scrolling by drag\n\nThis patch adds a new synthesized mouse reason and changes nsIPresShell::SynthesizeMouseMove() for it can dispatch the new reason.\n\nAnd PresShell::HandleEventInternal() calls nsIFrame::HandleSynthesizedMouseEvent() since the synthesized events don't cause DOM events.", "author": "masayuki@d-toybox.com", "creation_time": "2011-07-27T08:21:45Z", "count": 2, "creator": "masayuki@d-toybox.com", "is_private": false, "id": 5615997, "raw_text": "This patch adds a new synthesized mouse reason and changes nsIPresShell::SynthesizeMouseMove() for it can dispatch the new reason.\n\nAnd PresShell::HandleEventInternal() calls nsIFrame::HandleSynthesizedMouseEvent() since the synthesized events don't cause DOM events.", "attachment_id": 548713}, {"count": 3, "creator": "masayuki@d-toybox.com", "is_private": false, "time": "2011-07-27T08:38:38Z", "bug_id": 671187, "tags": [], "text": "Created attachment 548715\nPatch part.3 Use synthesized mousemove event for auto scroll at dragging\n\nThis is first patch witch changes the behavior actually.\n\nFirst, nsTypedSelection::DoAutoScroll() is moved to nsFrame::DoAutoScroll().\n\nSecond, the auto scroll timer fires the new synthesized mouse move event.\n\nAnd nsFrame handles the new mouse move event as real mouse move event for repeating to scroll.\n\nBy this change, nsFrame can always choose a scroll target which is under mouse cursor. This provides better behavior with part.5.\n\nAnd also, PresShell has a bug, this patch also fixes it too. When NS_MOUSE_EXIT is handling, root PresShell forgets the last mouse cursor position even when mouse events are captured.  This bug causes stopping this new auto scrolling unexpectedly if mouse cursor is moved outside of the window.\n\nThis patch makes the root PresShell not forget the mouse cursor position if mouse events are captured.  And when mouse capture is released, it forgets the cursor position.\n\nEven if capturing content is replaced with another content, the PresShell forgets the cursor position. This isn't the best behavior. However, another window might be topmost under the cursor. So, we need to wait next real mouse move event for knowing correct position.", "author": "masayuki@d-toybox.com", "creation_time": "2011-07-27T08:38:38Z", "raw_text": "This is first patch witch changes the behavior actually.\n\nFirst, nsTypedSelection::DoAutoScroll() is moved to nsFrame::DoAutoScroll().\n\nSecond, the auto scroll timer fires the new synthesized mouse move event.\n\nAnd nsFrame handles the new mouse move event as real mouse move event for repeating to scroll.\n\nBy this change, nsFrame can always choose a scroll target which is under mouse cursor. This provides better behavior with part.5.\n\nAnd also, PresShell has a bug, this patch also fixes it too. When NS_MOUSE_EXIT is handling, root PresShell forgets the last mouse cursor position even when mouse events are captured.  This bug causes stopping this new auto scrolling unexpectedly if mouse cursor is moved outside of the window.\n\nThis patch makes the root PresShell not forget the mouse cursor position if mouse events are captured.  And when mouse capture is released, it forgets the cursor position.\n\nEven if capturing content is replaced with another content, the PresShell forgets the cursor position. This isn't the best behavior. However, another window might be topmost under the cursor. So, we need to wait next real mouse move event for knowing correct position.", "attachment_id": 548715, "id": 5616020}, {"bug_id": 671187, "count": 4, "creation_time": "2011-07-27T08:44:01Z", "author": "masayuki@d-toybox.com", "text": "Created attachment 548716\nPatch part.4 Sort out drag handling code of nsFrame\n\nThis patch sorts out the drag handling code in nsFrame.cpp. This doesn't change behavior.\n\nSee each static method's comment for the detail of each of them.\n\nnsFrame::IsOnScrollableFrameEdge() is added new parameter aCursorPosInScrollableFrame. It doesn't make sense in this patch. But this would help next patch's performance. We can reduce the count of calling nsLayoutUtils::GetEventCoordinatesRelativeTo().", "tags": [], "time": "2011-07-27T08:44:01Z", "is_private": false, "creator": "masayuki@d-toybox.com", "id": 5616031, "attachment_id": 548716, "raw_text": "This patch sorts out the drag handling code in nsFrame.cpp. This doesn't change behavior.\n\nSee each static method's comment for the detail of each of them.\n\nnsFrame::IsOnScrollableFrameEdge() is added new parameter aCursorPosInScrollableFrame. It doesn't make sense in this patch. But this would help next patch's performance. We can reduce the count of calling nsLayoutUtils::GetEventCoordinatesRelativeTo()."}, {"attachment_id": 548718, "raw_text": "This patch is the main patch of this bug fix.\n\nWhen mouse cursor isn't on any scrollable edge inside selection root element, nsFrame tries to find an ancestor scrollable frame which clips selection root element. If mouse cursor is *in* selection root frame and mouse cursor is on an ancestor's edge or outside of it, that means the selection root frame is clipped by the found ancestor.  Then, this scrolls the ancestor.\n\nNote that if mouse cursor is outside of the selection root frame, this patch doesn't change the behavior. So, this is a little bit safer than its look.\n\nBy this change, user becomes possible to scroll to every point under selection root by dragging. Therefore, now, we can limit the selection target by nsIPresShell::SCROLL_NO_PARENT_FRAMES. This makes easily understandable behavior when there are complex scrollable elements are nested.", "id": 5616042, "is_private": false, "creator": "masayuki@d-toybox.com", "count": 5, "creation_time": "2011-07-27T08:55:51Z", "author": "masayuki@d-toybox.com", "text": "Created attachment 548718\nPatch part.5 Ancestor scrollable elements of selection root element should be scrollable by on-edge-scrolling\n\nThis patch is the main patch of this bug fix.\n\nWhen mouse cursor isn't on any scrollable edge inside selection root element, nsFrame tries to find an ancestor scrollable frame which clips selection root element. If mouse cursor is *in* selection root frame and mouse cursor is on an ancestor's edge or outside of it, that means the selection root frame is clipped by the found ancestor.  Then, this scrolls the ancestor.\n\nNote that if mouse cursor is outside of the selection root frame, this patch doesn't change the behavior. So, this is a little bit safer than its look.\n\nBy this change, user becomes possible to scroll to every point under selection root by dragging. Therefore, now, we can limit the selection target by nsIPresShell::SCROLL_NO_PARENT_FRAMES. This makes easily understandable behavior when there are complex scrollable elements are nested.", "bug_id": 671187, "time": "2011-07-27T08:55:51Z", "tags": []}, {"text": "Comment on attachment 548718\nPatch part.5 Ancestor scrollable elements of selection root element should be scrollable by on-edge-scrolling\n\nAnd this patch should be also needs ui-review. faaborg, see also comment 5.\n\nThis patch adds a special case only when mouse cursor is in selection root element rect but actually on another element, i.e., selection root element is clipped by its ancestor.\n\nSo, this makes user can scroll only ancestor scrollable elements, i.e., not all scrollable elements under sibling elements of ancestors.", "tags": [], "bug_id": 671187, "time": "2011-07-27T09:16:39Z", "creation_time": "2011-07-27T09:16:39Z", "author": "masayuki@d-toybox.com", "count": 6, "is_private": false, "creator": "masayuki@d-toybox.com", "id": 5616065, "raw_text": "And this patch should be also needs ui-review. faaborg, see also comment 5.\n\nThis patch adds a special case only when mouse cursor is in selection root element rect but actually on another element, i.e., selection root element is clipped by its ancestor.\n\nSo, this makes user can scroll only ancestor scrollable elements, i.e., not all scrollable elements under sibling elements of ancestors.", "attachment_id": 548718}, {"creator": "masayuki@d-toybox.com", "is_private": false, "count": 7, "author": "masayuki@d-toybox.com", "creation_time": "2011-07-27T09:34:33Z", "time": "2011-07-27T09:34:33Z", "tags": [], "bug_id": 671187, "text": "Smaug:\n\nThere is another reason to change the scroll timer behavior (part.3).\n\nThat is for bug 672181. I think that the bug can be fixed easily if we don't start auto scroll by real mouse move event.  I.e., nsFrame should scroll only by the new synthesized mouse move event. It means that continuous real mouse move events can prevent auto scrolling even if dragging on scrollable edges. I believe that this delay to scroll approach is correct because the main purpose of dragging is expanding selection, not scroll in most cases. Therefore, I think we should give the operation -- expanding selection -- higher priority.", "attachment_id": null, "raw_text": "Smaug:\n\nThere is another reason to change the scroll timer behavior (part.3).\n\nThat is for bug 672181. I think that the bug can be fixed easily if we don't start auto scroll by real mouse move event.  I.e., nsFrame should scroll only by the new synthesized mouse move event. It means that continuous real mouse move events can prevent auto scrolling even if dragging on scrollable edges. I believe that this delay to scroll approach is correct because the main purpose of dragging is expanding selection, not scroll in most cases. Therefore, I think we should give the operation -- expanding selection -- higher priority.", "id": 5616082}, {"text": "Comment on attachment 548718\nPatch part.5 Ancestor scrollable elements of selection root element should be scrollable by on-edge-scrolling\n\nI have to admit my understanding of what this patch does based on the description might not be fully accurate since I read through this pretty quickly, but I agree that we should give priority to expanding the selection.", "time": "2011-07-28T21:38:51Z", "tags": [], "bug_id": 671187, "creation_time": "2011-07-28T21:38:51Z", "author": "faaborg@gmail.com", "count": 8, "is_private": false, "creator": "faaborg@gmail.com", "id": 5620576, "raw_text": "I have to admit my understanding of what this patch does based on the description might not be fully accurate since I read through this pretty quickly, but I agree that we should give priority to expanding the selection.", "attachment_id": 548718}, {"raw_text": "this certainly needs a layout peer review.", "attachment_id": 548716, "id": 5625538, "count": 9, "is_private": false, "creator": "bugs@pettay.fi", "text": "Comment on attachment 548716\nPatch part.4 Sort out drag handling code of nsFrame\n\nthis certainly needs a layout peer review.", "time": "2011-08-01T17:02:19Z", "tags": [], "bug_id": 671187, "creation_time": "2011-08-01T17:02:19Z", "author": "bugs@pettay.fi"}, {"author": "masayuki@d-toybox.com", "creation_time": "2011-08-01T17:12:25Z", "bug_id": 671187, "time": "2011-08-01T17:12:25Z", "tags": [], "text": "Comment on attachment 548716\nPatch part.4 Sort out drag handling code of nsFrame\n\nSure. I think that roc is best person.\n\nRoc, see comment 4 about the detail of this patch.", "creator": "masayuki@d-toybox.com", "is_private": false, "count": 10, "id": 5625573, "attachment_id": 548716, "raw_text": "Sure. I think that roc is best person.\n\nRoc, see comment 4 about the detail of this patch."}, {"author": "masayuki@d-toybox.com", "creation_time": "2011-08-01T17:14:15Z", "time": "2011-08-01T17:14:15Z", "bug_id": 671187, "tags": [], "text": "Comment on attachment 548713\nPatch part.2 Make a new mouse event reason for scrolling by drag\n\nneeds sr due to nsIPresShell change.", "creator": "masayuki@d-toybox.com", "is_private": false, "count": 11, "id": 5625578, "attachment_id": 548713, "raw_text": "needs sr due to nsIPresShell change."}, {"text": "Btw, since this is making rather major changes late in this cycle, I wonder\nif we should backout bug 552707 from m-c and try to re-land it after\nnext Aurora.", "tags": [], "time": "2011-08-01T18:42:47Z", "creation_time": "2011-08-01T18:42:47Z", "author": "bugs@pettay.fi", "is_private": false, "creator": "bugs@pettay.fi", "id": 5625842, "raw_text": "Btw, since this is making rather major changes late in this cycle, I wonder\nif we should backout bug 552707 from m-c and try to re-land it after\nnext Aurora.", "attachment_id": null, "bug_id": 671187, "count": 12}, {"attachment_id": 548716, "raw_text": "Review of attachment 548716:\n-----------------------------------------------------------------\n\n::: layout/generic/nsFrame.cpp\n@@ +2210,5 @@\n> + *              aScrollableFrame scroll port.\n> + *              One or two flags of CURSOR_ON_*_EDGE if cursor is on the edge\n> + *              of the scroll port.\n> + *              Otherwise, i.e., if cursor is outside the scroll port,\n> + *              one ore two flags of CURSOR_OUTSIDE_*.\n\nThis comment makes it sound like INSIDE takes priority over OUTSIDE. But actually OUTSIDE takes priority over INSIDE.\n\nBut it might be simpler to just let ComputeCursorLocatedInScrollPort return all relevant bits and let the caller be responsible for choosing priorities.\n\n@@ +2258,5 @@\n> +  } else if (scrollPortRect.x + edgeH > aCursorPosInScrollableFrame.x) {\n> +    result |= CURSOR_ON_LEFT_EDGE;\n> +  } else if (scrollPortRect.XMost() < aCursorPosInScrollableFrame.x) {\n> +    result |= CURSOR_OUTSIDE_RIGHT;\n> +  } else if (scrollPortRect.XMost() - edgeH < aCursorPosInScrollableFrame.x) {\n\nWhy are these all \"else\" clauses? Shouldn't you set all the relevant bits?\n\n@@ +2271,5 @@\n> +    result |= CURSOR_ON_TOP_EDGE;\n> +  } else if (frameRect.YMost() < aCursorPosInScrollableFrame.y) {\n> +    result |= CURSOR_OUTSIDE_BOTTOM;\n> +  } else if (frameRect.YMost() - edgeV <\n> +               aCursorPosInScrollableFrame.y) {\n\nAgain, why are these all \"else\" clauses?", "id": 5626629, "creator": "roc@ocallahan.org", "is_private": false, "count": 13, "author": "roc@ocallahan.org", "creation_time": "2011-08-01T23:31:40Z", "time": "2011-08-01T23:31:40Z", "tags": [], "bug_id": 671187, "text": "Comment on attachment 548716\nPatch part.4 Sort out drag handling code of nsFrame\n\nReview of attachment 548716:\n-----------------------------------------------------------------\n\n::: layout/generic/nsFrame.cpp\n@@ +2210,5 @@\n> + *              aScrollableFrame scroll port.\n> + *              One or two flags of CURSOR_ON_*_EDGE if cursor is on the edge\n> + *              of the scroll port.\n> + *              Otherwise, i.e., if cursor is outside the scroll port,\n> + *              one ore two flags of CURSOR_OUTSIDE_*.\n\nThis comment makes it sound like INSIDE takes priority over OUTSIDE. But actually OUTSIDE takes priority over INSIDE.\n\nBut it might be simpler to just let ComputeCursorLocatedInScrollPort return all relevant bits and let the caller be responsible for choosing priorities.\n\n@@ +2258,5 @@\n> +  } else if (scrollPortRect.x + edgeH > aCursorPosInScrollableFrame.x) {\n> +    result |= CURSOR_ON_LEFT_EDGE;\n> +  } else if (scrollPortRect.XMost() < aCursorPosInScrollableFrame.x) {\n> +    result |= CURSOR_OUTSIDE_RIGHT;\n> +  } else if (scrollPortRect.XMost() - edgeH < aCursorPosInScrollableFrame.x) {\n\nWhy are these all \"else\" clauses? Shouldn't you set all the relevant bits?\n\n@@ +2271,5 @@\n> +    result |= CURSOR_ON_TOP_EDGE;\n> +  } else if (frameRect.YMost() < aCursorPosInScrollableFrame.y) {\n> +    result |= CURSOR_OUTSIDE_BOTTOM;\n> +  } else if (frameRect.YMost() - edgeV <\n> +               aCursorPosInScrollableFrame.y) {\n\nAgain, why are these all \"else\" clauses?"}, {"id": 5627208, "raw_text": "(In reply to comment #13)\n\nFirst, I should explain the terms of the comments.\n\n         +------------------------------------------------------------+\n         |      ^                                                     |\n         |      v  32px                                               |\n         |<---->+----------------------------------------------+      |\n         | 32px |                                              |      |\n         |      |                                              |      |\n         |      |                                              |      |\n-------->|<---->|<------------------INSIDE_EDGES ------------->|      |\nOUTSIDE    EDGE\n\n\"outside\" means the cursor is outside the scrollport. \"edge\" is the area close to scrollport edge. And \"inside edges\" is the internal area surrounded by \"edge\"s.\n\nSo, each area doesn't include the others. I.e., there is no case such as the (CURSOR_ON_TOP_EDGE | CURSOR_ON_BOTTOM_EDGE) or (CURSOR_ON_TOP_EDGE | CURSOR_OUTSIDE_TOP).\n\n> Comment on attachment 548716 [diff] [details] [review]\n> ::: layout/generic/nsFrame.cpp\n> @@ +2210,5 @@\n> > + *              aScrollableFrame scroll port.\n> > + *              One or two flags of CURSOR_ON_*_EDGE if cursor is on the edge\n> > + *              of the scroll port.\n> > + *              Otherwise, i.e., if cursor is outside the scroll port,\n> > + *              one ore two flags of CURSOR_OUTSIDE_*.\n> \n> This comment makes it sound like INSIDE takes priority over OUTSIDE. But\n> actually OUTSIDE takes priority over INSIDE.\n> \n> But it might be simpler to just let ComputeCursorLocatedInScrollPort return\n> all relevant bits and let the caller be responsible for choosing priorities.\n\nTherefore, if the cursor is located outside the scrollport, it shouldn't return CURSOR_ON_*_EDGE, it doesn't make sense for callers.\n\n> @@ +2258,5 @@\n> > +  } else if (scrollPortRect.x + edgeH > aCursorPosInScrollableFrame.x) {\n> > +    result |= CURSOR_ON_LEFT_EDGE;\n> > +  } else if (scrollPortRect.XMost() < aCursorPosInScrollableFrame.x) {\n> > +    result |= CURSOR_OUTSIDE_RIGHT;\n> > +  } else if (scrollPortRect.XMost() - edgeH < aCursorPosInScrollableFrame.x) {\n> \n> Why are these all \"else\" clauses? Shouldn't you set all the relevant bits?\n> \n> @@ +2271,5 @@\n> > +    result |= CURSOR_ON_TOP_EDGE;\n> > +  } else if (frameRect.YMost() < aCursorPosInScrollableFrame.y) {\n> > +    result |= CURSOR_OUTSIDE_BOTTOM;\n> > +  } else if (frameRect.YMost() - edgeV <\n> > +               aCursorPosInScrollableFrame.y) {\n> \n> Again, why are these all \"else\" clauses?\n\nThe \"else\"s reduce redundant checks like:\n\nif (scrollPortRect.x > aCursorPosInScrollableFrame.x) {\n  result |= CURSOR_OUTSIDE_LEFT;\n}\nif (scrollPortRect.x <= aCursorPosInScrollableFrame.x &&\n    scrollPortRect.x + edgeH > aCursorPosInScrollableFrame.x) {\n  result |= CURSOR_ON_LEFT_EDGE;\n}", "attachment_id": null, "text": "(In reply to comment #13)\n\nFirst, I should explain the terms of the comments.\n\n         +------------------------------------------------------------+\n         |      ^                                                     |\n         |      v  32px                                               |\n         |<---->+----------------------------------------------+      |\n         | 32px |                                              |      |\n         |      |                                              |      |\n         |      |                                              |      |\n-------->|<---->|<------------------INSIDE_EDGES ------------->|      |\nOUTSIDE    EDGE\n\n\"outside\" means the cursor is outside the scrollport. \"edge\" is the area close to scrollport edge. And \"inside edges\" is the internal area surrounded by \"edge\"s.\n\nSo, each area doesn't include the others. I.e., there is no case such as the (CURSOR_ON_TOP_EDGE | CURSOR_ON_BOTTOM_EDGE) or (CURSOR_ON_TOP_EDGE | CURSOR_OUTSIDE_TOP).\n\n> Comment on attachment 548716 [diff] [details] [review]\n> ::: layout/generic/nsFrame.cpp\n> @@ +2210,5 @@\n> > + *              aScrollableFrame scroll port.\n> > + *              One or two flags of CURSOR_ON_*_EDGE if cursor is on the edge\n> > + *              of the scroll port.\n> > + *              Otherwise, i.e., if cursor is outside the scroll port,\n> > + *              one ore two flags of CURSOR_OUTSIDE_*.\n> \n> This comment makes it sound like INSIDE takes priority over OUTSIDE. But\n> actually OUTSIDE takes priority over INSIDE.\n> \n> But it might be simpler to just let ComputeCursorLocatedInScrollPort return\n> all relevant bits and let the caller be responsible for choosing priorities.\n\nTherefore, if the cursor is located outside the scrollport, it shouldn't return CURSOR_ON_*_EDGE, it doesn't make sense for callers.\n\n> @@ +2258,5 @@\n> > +  } else if (scrollPortRect.x + edgeH > aCursorPosInScrollableFrame.x) {\n> > +    result |= CURSOR_ON_LEFT_EDGE;\n> > +  } else if (scrollPortRect.XMost() < aCursorPosInScrollableFrame.x) {\n> > +    result |= CURSOR_OUTSIDE_RIGHT;\n> > +  } else if (scrollPortRect.XMost() - edgeH < aCursorPosInScrollableFrame.x) {\n> \n> Why are these all \"else\" clauses? Shouldn't you set all the relevant bits?\n> \n> @@ +2271,5 @@\n> > +    result |= CURSOR_ON_TOP_EDGE;\n> > +  } else if (frameRect.YMost() < aCursorPosInScrollableFrame.y) {\n> > +    result |= CURSOR_OUTSIDE_BOTTOM;\n> > +  } else if (frameRect.YMost() - edgeV <\n> > +               aCursorPosInScrollableFrame.y) {\n> \n> Again, why are these all \"else\" clauses?\n\nThe \"else\"s reduce redundant checks like:\n\nif (scrollPortRect.x > aCursorPosInScrollableFrame.x) {\n  result |= CURSOR_OUTSIDE_LEFT;\n}\nif (scrollPortRect.x <= aCursorPosInScrollableFrame.x &&\n    scrollPortRect.x + edgeH > aCursorPosInScrollableFrame.x) {\n  result |= CURSOR_ON_LEFT_EDGE;\n}", "bug_id": 671187, "time": "2011-08-02T08:13:46Z", "tags": [], "creation_time": "2011-08-02T08:13:46Z", "author": "masayuki@d-toybox.com", "count": 14, "is_private": false, "creator": "masayuki@d-toybox.com"}, {"bug_id": 671187, "count": 15, "tags": [], "time": "2011-08-02T11:04:41Z", "text": "Comment on attachment 548716\nPatch part.4 Sort out drag handling code of nsFrame\n\nReview of attachment 548716:\n-----------------------------------------------------------------\n\n::: layout/generic/nsFrame.cpp\n@@ +2264,5 @@\n> +  }\n> +\n> +  nsRect frameRect = scrollableFrame->GetRect();\n> +  frameRect.MoveTo(0, 0);\n> +  if (frameRect.y > aCursorPosInScrollableFrame.y) {\n\nWhy are you using scrollableFrame->GetRect() here but GetScrollPortRect above? seems like you should use the same rect in both cases.", "author": "roc@ocallahan.org", "creation_time": "2011-08-02T11:04:41Z", "creator": "roc@ocallahan.org", "is_private": false, "id": 5627369, "raw_text": "Review of attachment 548716:\n-----------------------------------------------------------------\n\n::: layout/generic/nsFrame.cpp\n@@ +2264,5 @@\n> +  }\n> +\n> +  nsRect frameRect = scrollableFrame->GetRect();\n> +  frameRect.MoveTo(0, 0);\n> +  if (frameRect.y > aCursorPosInScrollableFrame.y) {\n\nWhy are you using scrollableFrame->GetRect() here but GetScrollPortRect above? seems like you should use the same rect in both cases.", "attachment_id": 548716}, {"creator": "masayuki@d-toybox.com", "is_private": false, "count": 16, "author": "masayuki@d-toybox.com", "creation_time": "2011-08-02T23:53:52Z", "time": "2011-08-02T23:53:52Z", "tags": [], "bug_id": 671187, "text": "(In reply to comment #15)\n> Comment on attachment 548716 [diff] [details] [review]\n> Patch part.4 Sort out drag handling code of nsFrame\n> \n> Review of attachment 548716 [diff] [details] [review]:\n> -----------------------------------------------------------------\n> \n> ::: layout/generic/nsFrame.cpp\n> @@ +2264,5 @@\n> > +  }\n> > +\n> > +  nsRect frameRect = scrollableFrame->GetRect();\n> > +  frameRect.MoveTo(0, 0);\n> > +  if (frameRect.y > aCursorPosInScrollableFrame.y) {\n> \n> Why are you using scrollableFrame->GetRect() here but GetScrollPortRect\n> above? seems like you should use the same rect in both cases.\n\nOh, sure. It's just my mistake.", "attachment_id": null, "raw_text": "(In reply to comment #15)\n> Comment on attachment 548716 [diff] [details] [review]\n> Patch part.4 Sort out drag handling code of nsFrame\n> \n> Review of attachment 548716 [diff] [details] [review]:\n> -----------------------------------------------------------------\n> \n> ::: layout/generic/nsFrame.cpp\n> @@ +2264,5 @@\n> > +  }\n> > +\n> > +  nsRect frameRect = scrollableFrame->GetRect();\n> > +  frameRect.MoveTo(0, 0);\n> > +  if (frameRect.y > aCursorPosInScrollableFrame.y) {\n> \n> Why are you using scrollableFrame->GetRect() here but GetScrollPortRect\n> above? seems like you should use the same rect in both cases.\n\nOh, sure. It's just my mistake.", "id": 5629243}, {"tags": [], "time": "2011-08-04T02:39:51Z", "text": "Created attachment 550585\nPatch part.4 Sort out drag handling code of nsFrame\n\nI realized why I did the mistake.\n\nWe need to use the frame rect for \"outside\" check because \"edge\" includes scrollbars and borders of the frame.\n\nThis patch explains each words clearly.", "author": "masayuki@d-toybox.com", "creation_time": "2011-08-04T02:39:51Z", "creator": "masayuki@d-toybox.com", "is_private": false, "id": 5632214, "raw_text": "I realized why I did the mistake.\n\nWe need to use the frame rect for \"outside\" check because \"edge\" includes scrollbars and borders of the frame.\n\nThis patch explains each words clearly.", "attachment_id": 550585, "bug_id": 671187, "count": 17}, {"count": 18, "is_private": false, "creator": "roc@ocallahan.org", "text": "Comment on attachment 550585\nPatch part.4 Sort out drag handling code of nsFrame\n\nReview of attachment 550585:\n-----------------------------------------------------------------\n\n::: layout/generic/nsFrame.cpp\n@@ +2222,5 @@\n> + *            | |      |                     |      |    | |\n> + *            | |      |                     |      |    | |\n> + *            | |      |                     |      |    | |\n> + * ----------> <------> <-------------------> <-----------> <------------\n> + *    outside     edge    inside-of-edges         edge         outside\n\nGreat diagram!\n\n@@ +2226,5 @@\n> + *    outside     edge    inside-of-edges         edge         outside\n> + *\n> + * outside, edge and inside-edges are different areas. They must not overlap.\n> + *\n> + * \"edge\" is close area from border of scroll port.  The distance is defined by\n\nI'm not sure what you mean about \"edge\" here.\n\n@@ +2233,5 @@\n> + *\n> + * \"inside-of-edges\" is internal area which is surrounded by all \"edge\"s.\n> + *\n> + * \"outside\" is outside of the scrollable frame.  I.e., it's margin or outer of\n> + * margin box.\n\n\"or outside of margin box\"\n\n@@ +2314,5 @@\n> +\n> +    return result;\n> +  }\n> +\n> +  if (scrollableFrameRect.XMost() < aCursorPosInScrollableFrame.x) {\n\n<= I think\n\n@@ +2320,5 @@\n> +  } else if (scrollableFrameRect.x > aCursorPosInScrollableFrame.x) {\n> +    result |= CURSOR_OUTSIDE_LEFT;\n> +  }\n> +\n> +  if (scrollableFrameRect.YMost() < aCursorPosInScrollableFrame.y) {\n\n<= here too\n\n@@ +2335,5 @@\n> + * aScrollableFrame from current scroll position.\n> + *\n> + * @param aScrollableFrame      A scrollable frame\n> + * @return      SCROLLABLE_TO_NOWHERE if aScrollableFrame isn't scrollable.\n> + *              Otherwise, one or two other SCROLLABLE_TO_* flags.\n\nIt can return all four flags at once, can't it?\n\n@@ +2342,5 @@\n> +  SCROLLABLE_TO_NOWHERE = 0,\n> +  SCROLLABLE_TO_TOP     = 1,\n> +  SCROLLABLE_TO_BOTTOM  = 2,\n> +  SCROLLABLE_TO_LEFT    = 4,\n> +  SCROLLABLE_TO_RIGHT   = 8\n\nSince we're not going to scroll all the way to the top or bottom, I think probably better names would be SCROLLABLE_NOWHERE, SCROLLABLE_UP, SCROLLABLE_DOWN, SCROLLABLE_LEFT, SCROLLABLE_RIGHT.\n\n@@ +2356,5 @@\n> +  if (scrollRange.x < scrollPosition.x) {\n> +    result |= SCROLLABLE_TO_LEFT;\n> +  }\n> +\n> +  if (scrollRange.x + scrollRange.width > scrollPosition.x) {\n\nscrollRange.XMost()\n\n@@ +2364,5 @@\n> +  if (scrollRange.y < scrollPosition.y) {\n> +    result |= SCROLLABLE_TO_TOP;\n> +  }\n> +\n> +  if (scrollRange.y + scrollRange.height > scrollPosition.y) {\n\nscrollRange.YMost()\n\n@@ +2387,5 @@\n> + * @return      SCROLLABLE_TO_NOWHERE if aScrollableFrame isn't scrollable.\n> + *              Otherwise, one or two other SCROLLABLE_TO_* flags.\n> + */\n> +static PRUint32\n> +ComputeActuallScrollableDirection(nsIScrollableFrame* aScrollableFrame,\n\n\"Actual\"\n\nHowever, it's hard to distinguish this function from ComputeScrollableDirection just based on the name. It might be better to just inline ComputeScrollableDirection into this function and call this function ComputeScrollableDirection. Actually \"ComputeScrollableDirections\" would be even better since multiple directions can be returned.\n\n@@ +2430,5 @@\n> + * aScrollableFrame.  If aScrollableFrame isn't large enough, returns smaller\n> + * value than pref value.\n> + */\n> +static nsSize\n> +ComputeOnEdgeScrollAmout(nsIScrollableFrame* aScrollableFrame)\n\nComputeEdgeScrollAmount is probably a better name.\n\n@@ +2438,5 @@\n> +\n> +  nsPresContext* pc = scrollableFrame->PresContext();\n> +  nscoord onePixel = pc->DevPixelsToAppUnits(1);\n> +\n> +  // The scrolling mouse is defined by pref, however, if the amount is\n\n// The scroll amount", "tags": [], "time": "2011-08-08T03:22:34Z", "bug_id": 671187, "creation_time": "2011-08-08T03:22:34Z", "author": "roc@ocallahan.org", "raw_text": "Review of attachment 550585:\n-----------------------------------------------------------------\n\n::: layout/generic/nsFrame.cpp\n@@ +2222,5 @@\n> + *            | |      |                     |      |    | |\n> + *            | |      |                     |      |    | |\n> + *            | |      |                     |      |    | |\n> + * ----------> <------> <-------------------> <-----------> <------------\n> + *    outside     edge    inside-of-edges         edge         outside\n\nGreat diagram!\n\n@@ +2226,5 @@\n> + *    outside     edge    inside-of-edges         edge         outside\n> + *\n> + * outside, edge and inside-edges are different areas. They must not overlap.\n> + *\n> + * \"edge\" is close area from border of scroll port.  The distance is defined by\n\nI'm not sure what you mean about \"edge\" here.\n\n@@ +2233,5 @@\n> + *\n> + * \"inside-of-edges\" is internal area which is surrounded by all \"edge\"s.\n> + *\n> + * \"outside\" is outside of the scrollable frame.  I.e., it's margin or outer of\n> + * margin box.\n\n\"or outside of margin box\"\n\n@@ +2314,5 @@\n> +\n> +    return result;\n> +  }\n> +\n> +  if (scrollableFrameRect.XMost() < aCursorPosInScrollableFrame.x) {\n\n<= I think\n\n@@ +2320,5 @@\n> +  } else if (scrollableFrameRect.x > aCursorPosInScrollableFrame.x) {\n> +    result |= CURSOR_OUTSIDE_LEFT;\n> +  }\n> +\n> +  if (scrollableFrameRect.YMost() < aCursorPosInScrollableFrame.y) {\n\n<= here too\n\n@@ +2335,5 @@\n> + * aScrollableFrame from current scroll position.\n> + *\n> + * @param aScrollableFrame      A scrollable frame\n> + * @return      SCROLLABLE_TO_NOWHERE if aScrollableFrame isn't scrollable.\n> + *              Otherwise, one or two other SCROLLABLE_TO_* flags.\n\nIt can return all four flags at once, can't it?\n\n@@ +2342,5 @@\n> +  SCROLLABLE_TO_NOWHERE = 0,\n> +  SCROLLABLE_TO_TOP     = 1,\n> +  SCROLLABLE_TO_BOTTOM  = 2,\n> +  SCROLLABLE_TO_LEFT    = 4,\n> +  SCROLLABLE_TO_RIGHT   = 8\n\nSince we're not going to scroll all the way to the top or bottom, I think probably better names would be SCROLLABLE_NOWHERE, SCROLLABLE_UP, SCROLLABLE_DOWN, SCROLLABLE_LEFT, SCROLLABLE_RIGHT.\n\n@@ +2356,5 @@\n> +  if (scrollRange.x < scrollPosition.x) {\n> +    result |= SCROLLABLE_TO_LEFT;\n> +  }\n> +\n> +  if (scrollRange.x + scrollRange.width > scrollPosition.x) {\n\nscrollRange.XMost()\n\n@@ +2364,5 @@\n> +  if (scrollRange.y < scrollPosition.y) {\n> +    result |= SCROLLABLE_TO_TOP;\n> +  }\n> +\n> +  if (scrollRange.y + scrollRange.height > scrollPosition.y) {\n\nscrollRange.YMost()\n\n@@ +2387,5 @@\n> + * @return      SCROLLABLE_TO_NOWHERE if aScrollableFrame isn't scrollable.\n> + *              Otherwise, one or two other SCROLLABLE_TO_* flags.\n> + */\n> +static PRUint32\n> +ComputeActuallScrollableDirection(nsIScrollableFrame* aScrollableFrame,\n\n\"Actual\"\n\nHowever, it's hard to distinguish this function from ComputeScrollableDirection just based on the name. It might be better to just inline ComputeScrollableDirection into this function and call this function ComputeScrollableDirection. Actually \"ComputeScrollableDirections\" would be even better since multiple directions can be returned.\n\n@@ +2430,5 @@\n> + * aScrollableFrame.  If aScrollableFrame isn't large enough, returns smaller\n> + * value than pref value.\n> + */\n> +static nsSize\n> +ComputeOnEdgeScrollAmout(nsIScrollableFrame* aScrollableFrame)\n\nComputeEdgeScrollAmount is probably a better name.\n\n@@ +2438,5 @@\n> +\n> +  nsPresContext* pc = scrollableFrame->PresContext();\n> +  nscoord onePixel = pc->DevPixelsToAppUnits(1);\n> +\n> +  // The scrolling mouse is defined by pref, however, if the amount is\n\n// The scroll amount", "attachment_id": 550585, "id": 5638739}, {"count": 19, "creator": "masayuki@d-toybox.com", "is_private": false, "bug_id": 671187, "time": "2011-08-15T07:03:41Z", "tags": [], "text": "Created attachment 553119\nPatch part.4 Sort out drag handling code of nsFrame\n\n> @@ +2335,5 @@\n>> + * aScrollableFrame from current scroll position.\n>> + *\n>> + * @param aScrollableFrame      A scrollable frame\n>> + * @return      SCROLLABLE_TO_NOWHERE if aScrollableFrame isn't scrollable.\n>> + *              Otherwise, one or two other SCROLLABLE_TO_* flags.\n> \n> It can return all four flags at once, can't it?\n\nNo. The function computes the scrollable directions for the mouse cursor position. E.g., when mouse cursor is on both left edge and bottom edge, the result never contains SCROLLABLE_TOP and SCROLLABLE_RIGHT because the auto scrolling shouldn't do scroll to such direction at that time. I guess there are some better names but I have no idea.\n# I added some comments for explaining the reason.", "author": "masayuki@d-toybox.com", "creation_time": "2011-08-15T07:03:41Z", "raw_text": "> @@ +2335,5 @@\n>> + * aScrollableFrame from current scroll position.\n>> + *\n>> + * @param aScrollableFrame      A scrollable frame\n>> + * @return      SCROLLABLE_TO_NOWHERE if aScrollableFrame isn't scrollable.\n>> + *              Otherwise, one or two other SCROLLABLE_TO_* flags.\n> \n> It can return all four flags at once, can't it?\n\nNo. The function computes the scrollable directions for the mouse cursor position. E.g., when mouse cursor is on both left edge and bottom edge, the result never contains SCROLLABLE_TOP and SCROLLABLE_RIGHT because the auto scrolling shouldn't do scroll to such direction at that time. I guess there are some better names but I have no idea.\n# I added some comments for explaining the reason.", "attachment_id": 553119, "id": 5653583}, {"author": "bugs@pettay.fi", "creation_time": "2011-08-26T11:37:33Z", "bug_id": 671187, "tags": [], "time": "2011-08-26T11:37:33Z", "text": "Comment on attachment 548715\nPatch part.3 Use synthesized mousemove event for auto scroll at dragging\n\n\n>+   * NotifyCapturingContentReleased() is called when capturing content is\n>+   * released.  The called instance is the prefShell to have been capturing\nprefShell?\n\n>+nsFrame::DoAutoScroll(nsIFrame* aScrolledFrame,\n>+                      nsFrameSelection* aFrameSelection,\n>+                      const nsPoint &aScrollTo)\n>+{\n>+  nsIPresShell* ps = aFrameSelection->GetShell();\n>+  ps->ScrollFrameRectIntoView(aScrolledFrame, nsRect(aScrollTo, nsSize(1,1)),\n>+                              NS_PRESSHELL_SCROLL_ANYWHERE,\n>+                              NS_PRESSHELL_SCROLL_ANYWHERE, 0);\nIs it guaranteed that aFrameSelection and ps stay alive while calling \nScrollFrameRectIntoView?\nBased on // Note: DoAutoScroll might destroy arbitrary frames etc.\nno, so this could lead to crashes.\n\n>+\n>+  const PRUint32 kAutoScrollTimerDelay = 30;\n>+  aFrameSelection->StartAutoScrollTimer(kAutoScrollTimerDelay);\n>+}\nIt is rather strange to have DoAutoScroll in nsFrame, yet it doesn't do\nanything with 'this' object.", "creator": "bugs@pettay.fi", "is_private": false, "count": 20, "id": 5680250, "attachment_id": 548715, "raw_text": "\n>+   * NotifyCapturingContentReleased() is called when capturing content is\n>+   * released.  The called instance is the prefShell to have been capturing\nprefShell?\n\n>+nsFrame::DoAutoScroll(nsIFrame* aScrolledFrame,\n>+                      nsFrameSelection* aFrameSelection,\n>+                      const nsPoint &aScrollTo)\n>+{\n>+  nsIPresShell* ps = aFrameSelection->GetShell();\n>+  ps->ScrollFrameRectIntoView(aScrolledFrame, nsRect(aScrollTo, nsSize(1,1)),\n>+                              NS_PRESSHELL_SCROLL_ANYWHERE,\n>+                              NS_PRESSHELL_SCROLL_ANYWHERE, 0);\nIs it guaranteed that aFrameSelection and ps stay alive while calling \nScrollFrameRectIntoView?\nBased on // Note: DoAutoScroll might destroy arbitrary frames etc.\nno, so this could lead to crashes.\n\n>+\n>+  const PRUint32 kAutoScrollTimerDelay = 30;\n>+  aFrameSelection->StartAutoScrollTimer(kAutoScrollTimerDelay);\n>+}\nIt is rather strange to have DoAutoScroll in nsFrame, yet it doesn't do\nanything with 'this' object."}, {"id": 5680353, "raw_text": ">@@ -2849,21 +2878,16 @@ nsFrame::ExpandSelectionByMouseMove(nsFr\n>   if (!capturingContent) {\n>     return NS_OK;  // The capture was canceled.\n>   }\n>   nsIContent* selectionRoot =\n>     GetSelectionRootContentForCapturingContent(aPresShell, capturingContent);\n> \n>   nsIScrollableFrame* scrollableFrame =\n>     FindNearestScrollableFrameForSelection(this, selectionRoot);\n>-  // If a non-scrollable content captures by script and there is no scrollable\n>-  // frame between the selection root and this, we don't need to do anymore.\n>-  if (!scrollableFrame) {\n>-    return NS_OK;\n>-  }\nCould you explain why this change is ok.\nThe patch is missing context to see whether null scrollableFrame is ok.\n\n\n> \n>   if (!handleTableSelection) {\n>     nsIScrollableFrame* selectionRootScrollableFrame =\n>       FindNearestScrollableFrameForSelection(selectionRoot->GetPrimaryFrame(),\n>                                              selectionRoot);\n>     while (scrollableFrame) {\n>       nsIFrame* frame = do_QueryFrame(scrollableFrame);\n>       nsPoint cursorPosInScrollableFrame =\n>@@ -2875,16 +2899,84 @@ nsFrame::ExpandSelectionByMouseMove(nsFr\n>                      scrollTo);\n>         return NS_OK;\n>       }\n> \n>       scrollableFrame =\n>         FindNearestScrollableFrameForSelection(frame->GetParent(),\n>                                                selectionRoot);\n>     }\n>+\n>+    // If mouse cursor is in selection root's frame rect but not on any\n>+    // scrollable element's edge in the selection root element, some ancestor\n>+    // frames might hide this frame.  Then, the ancestors should be also\n>+    // scrollabe by on-edge-scroll.\nscrollable\n\n\n>+    nsIFrame* selectionRootFrame = do_QueryFrame(selectionRootScrollableFrame);\n>+    if (!selectionRootFrame) {\n>+      selectionRootFrame = selectionRoot->GetPrimaryFrame();\n>+      if (!selectionRootFrame) {\n>+        return NS_OK;\n>+      }\n>+    }\n>+    nsRect selectionRootFrameRect = selectionRootFrame->GetRect();\n>+    selectionRootFrameRect.MoveTo(0, 0);\n>+    nsPoint cursorPosInSelectionRootFrame =\n>+      nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent, selectionRootFrame);\n>+    if (selectionRootFrameRect.Contains(cursorPosInSelectionRootFrame)){\nMissing space before {", "attachment_id": 548718, "time": "2011-08-26T12:32:56Z", "tags": [], "bug_id": 671187, "text": "Comment on attachment 548718\nPatch part.5 Ancestor scrollable elements of selection root element should be scrollable by on-edge-scrolling\n\n>@@ -2849,21 +2878,16 @@ nsFrame::ExpandSelectionByMouseMove(nsFr\n>   if (!capturingContent) {\n>     return NS_OK;  // The capture was canceled.\n>   }\n>   nsIContent* selectionRoot =\n>     GetSelectionRootContentForCapturingContent(aPresShell, capturingContent);\n> \n>   nsIScrollableFrame* scrollableFrame =\n>     FindNearestScrollableFrameForSelection(this, selectionRoot);\n>-  // If a non-scrollable content captures by script and there is no scrollable\n>-  // frame between the selection root and this, we don't need to do anymore.\n>-  if (!scrollableFrame) {\n>-    return NS_OK;\n>-  }\nCould you explain why this change is ok.\nThe patch is missing context to see whether null scrollableFrame is ok.\n\n\n> \n>   if (!handleTableSelection) {\n>     nsIScrollableFrame* selectionRootScrollableFrame =\n>       FindNearestScrollableFrameForSelection(selectionRoot->GetPrimaryFrame(),\n>                                              selectionRoot);\n>     while (scrollableFrame) {\n>       nsIFrame* frame = do_QueryFrame(scrollableFrame);\n>       nsPoint cursorPosInScrollableFrame =\n>@@ -2875,16 +2899,84 @@ nsFrame::ExpandSelectionByMouseMove(nsFr\n>                      scrollTo);\n>         return NS_OK;\n>       }\n> \n>       scrollableFrame =\n>         FindNearestScrollableFrameForSelection(frame->GetParent(),\n>                                                selectionRoot);\n>     }\n>+\n>+    // If mouse cursor is in selection root's frame rect but not on any\n>+    // scrollable element's edge in the selection root element, some ancestor\n>+    // frames might hide this frame.  Then, the ancestors should be also\n>+    // scrollabe by on-edge-scroll.\nscrollable\n\n\n>+    nsIFrame* selectionRootFrame = do_QueryFrame(selectionRootScrollableFrame);\n>+    if (!selectionRootFrame) {\n>+      selectionRootFrame = selectionRoot->GetPrimaryFrame();\n>+      if (!selectionRootFrame) {\n>+        return NS_OK;\n>+      }\n>+    }\n>+    nsRect selectionRootFrameRect = selectionRootFrame->GetRect();\n>+    selectionRootFrameRect.MoveTo(0, 0);\n>+    nsPoint cursorPosInSelectionRootFrame =\n>+      nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent, selectionRootFrame);\n>+    if (selectionRootFrameRect.Contains(cursorPosInSelectionRootFrame)){\nMissing space before {", "author": "bugs@pettay.fi", "creation_time": "2011-08-26T12:32:56Z", "count": 21, "creator": "bugs@pettay.fi", "is_private": false}, {"id": 5684211, "raw_text": "(In reply to Olli Pettay [:smaug] from comment #21)\n> Comment on attachment 548718\n> Patch part.5 Ancestor scrollable elements of selection root element should\n> be scrollable by on-edge-scrolling\n> \n> >@@ -2849,21 +2878,16 @@ nsFrame::ExpandSelectionByMouseMove(nsFr\n> >   if (!capturingContent) {\n> >     return NS_OK;  // The capture was canceled.\n> >   }\n> >   nsIContent* selectionRoot =\n> >     GetSelectionRootContentForCapturingContent(aPresShell, capturingContent);\n> > \n> >   nsIScrollableFrame* scrollableFrame =\n> >     FindNearestScrollableFrameForSelection(this, selectionRoot);\n> >-  // If a non-scrollable content captures by script and there is no scrollable\n> >-  // frame between the selection root and this, we don't need to do anymore.\n> >-  if (!scrollableFrame) {\n> >-    return NS_OK;\n> >-  }\n> Could you explain why this change is ok.\n> The patch is missing context to see whether null scrollableFrame is ok.\n\nFor example, even if mousedowned iframe's document isn't scrollable, the iframe might be clipped by its ancestor scollable element.  At that time, the clipping ancestor should be scrolled when mouse cursor is moved to its edge and cursor is still in the iframe.  I.e., added code which is after the removing part should be run at that time.", "attachment_id": null, "text": "(In reply to Olli Pettay [:smaug] from comment #21)\n> Comment on attachment 548718\n> Patch part.5 Ancestor scrollable elements of selection root element should\n> be scrollable by on-edge-scrolling\n> \n> >@@ -2849,21 +2878,16 @@ nsFrame::ExpandSelectionByMouseMove(nsFr\n> >   if (!capturingContent) {\n> >     return NS_OK;  // The capture was canceled.\n> >   }\n> >   nsIContent* selectionRoot =\n> >     GetSelectionRootContentForCapturingContent(aPresShell, capturingContent);\n> > \n> >   nsIScrollableFrame* scrollableFrame =\n> >     FindNearestScrollableFrameForSelection(this, selectionRoot);\n> >-  // If a non-scrollable content captures by script and there is no scrollable\n> >-  // frame between the selection root and this, we don't need to do anymore.\n> >-  if (!scrollableFrame) {\n> >-    return NS_OK;\n> >-  }\n> Could you explain why this change is ok.\n> The patch is missing context to see whether null scrollableFrame is ok.\n\nFor example, even if mousedowned iframe's document isn't scrollable, the iframe might be clipped by its ancestor scollable element.  At that time, the clipping ancestor should be scrolled when mouse cursor is moved to its edge and cursor is still in the iframe.  I.e., added code which is after the removing part should be run at that time.", "tags": [], "bug_id": 671187, "time": "2011-08-29T06:27:30Z", "creation_time": "2011-08-29T06:27:30Z", "author": "masayuki@d-toybox.com", "count": 22, "is_private": false, "creator": "masayuki@d-toybox.com"}, {"id": 5684683, "raw_text": "Right. I moved back DoAutoScroll() to nsFrameSelection.", "attachment_id": 556532, "tags": [], "time": "2011-08-29T13:28:43Z", "text": "Created attachment 556532\nPatch part.3 Use synthesized mousemove event for auto scroll at dragging\n\nRight. I moved back DoAutoScroll() to nsFrameSelection.", "author": "masayuki@d-toybox.com", "creation_time": "2011-08-29T13:28:43Z", "creator": "masayuki@d-toybox.com", "is_private": false, "bug_id": 671187, "count": 23}, {"id": 5684717, "attachment_id": null, "raw_text": "Ah, StartAutoScrollTimer() can be protected (or private) method...", "creation_time": "2011-08-29T13:41:51Z", "author": "masayuki@d-toybox.com", "text": "Ah, StartAutoScrollTimer() can be protected (or private) method...", "time": "2011-08-29T13:41:51Z", "bug_id": 671187, "tags": [], "is_private": false, "creator": "masayuki@d-toybox.com", "count": 24}, {"bug_id": 671187, "count": 25, "id": 5684955, "raw_text": ">-  aFrameSelection->StartAutoScrollTimer(scrolledFrame, scrollTo,\n>-                                        kAutoScrollTimerDelay);\n>+  // NOTE: DoAutoScroll() might destroy this frame and something.\nPerhaps drop \"and something\"\n\n>+    if (!mTimer) {\n>+      nsresult rv;\n>+      mTimer = do_CreateInstance(\"@mozilla.org/timer;1\", &rv);\n>+      NS_ENSURE_SUCCESS(rv, );\nNS_ENSURE_SUCCESS without latter parameter looks strange.\nplease use\nif (NS_FAILED(rv)) {\n  return;\n}\n\n\n>+nsFrameSelection::DoAutoScroll(nsIFrame* aScrolledFrame,\n>+                               const nsPoint &aScrollTo)\n>+{\n>+  NS_ENSURE_TRUE(mShell, );\n>+  NS_ASSERTION(this == sDraggingFrameSelection,\n>+               \"Why nsFrameSelection::DoAutoScroll() is called?\");\n>+\n>+  mShell->ScrollFrameRectIntoView(aScrolledFrame,\n>+                                  nsRect(aScrollTo, nsSize(1,1)),\n>+                                  NS_PRESSHELL_SCROLL_ANYWHERE,\n>+                                  NS_PRESSHELL_SCROLL_ANYWHERE, 0);\n>+\n>+  if (!sDraggingFrameSelection) {\n>+    return; // destroyed.\n>+  }\nWhat if sDraggingFrameSelection just points to some other selection object here?\n\n\nThe old code stops timer when DoAutoScroll is called. Why is that not needed anymore?", "attachment_id": 556532, "time": "2011-08-29T15:29:28Z", "tags": [], "text": "Comment on attachment 556532\nPatch part.3 Use synthesized mousemove event for auto scroll at dragging\n\n>-  aFrameSelection->StartAutoScrollTimer(scrolledFrame, scrollTo,\n>-                                        kAutoScrollTimerDelay);\n>+  // NOTE: DoAutoScroll() might destroy this frame and something.\nPerhaps drop \"and something\"\n\n>+    if (!mTimer) {\n>+      nsresult rv;\n>+      mTimer = do_CreateInstance(\"@mozilla.org/timer;1\", &rv);\n>+      NS_ENSURE_SUCCESS(rv, );\nNS_ENSURE_SUCCESS without latter parameter looks strange.\nplease use\nif (NS_FAILED(rv)) {\n  return;\n}\n\n\n>+nsFrameSelection::DoAutoScroll(nsIFrame* aScrolledFrame,\n>+                               const nsPoint &aScrollTo)\n>+{\n>+  NS_ENSURE_TRUE(mShell, );\n>+  NS_ASSERTION(this == sDraggingFrameSelection,\n>+               \"Why nsFrameSelection::DoAutoScroll() is called?\");\n>+\n>+  mShell->ScrollFrameRectIntoView(aScrolledFrame,\n>+                                  nsRect(aScrollTo, nsSize(1,1)),\n>+                                  NS_PRESSHELL_SCROLL_ANYWHERE,\n>+                                  NS_PRESSHELL_SCROLL_ANYWHERE, 0);\n>+\n>+  if (!sDraggingFrameSelection) {\n>+    return; // destroyed.\n>+  }\nWhat if sDraggingFrameSelection just points to some other selection object here?\n\n\nThe old code stops timer when DoAutoScroll is called. Why is that not needed anymore?", "author": "bugs@pettay.fi", "creation_time": "2011-08-29T15:29:28Z", "creator": "bugs@pettay.fi", "is_private": false}, {"id": 5687452, "raw_text": "Okay, this patch checks the auto scrolling state strictly.\n\n> The old code stops timer when DoAutoScroll is called. Why is that not needed anymore?\n\nnsFrame::EndSelectionChangeByMouse() and nsFrameSelection::AbortDragForSelection() calls nsFrameSelection::StopAutoScroll() in new code. I think that it's enough.\n\nHowever, we can do same thing for safer change.", "attachment_id": 556804, "tags": [], "bug_id": 671187, "time": "2011-08-30T12:22:49Z", "text": "Created attachment 556804\nPatch part.3 Use synthesized mousemove event for auto scroll at dragging\n\nOkay, this patch checks the auto scrolling state strictly.\n\n> The old code stops timer when DoAutoScroll is called. Why is that not needed anymore?\n\nnsFrame::EndSelectionChangeByMouse() and nsFrameSelection::AbortDragForSelection() calls nsFrameSelection::StopAutoScroll() in new code. I think that it's enough.\n\nHowever, we can do same thing for safer change.", "author": "masayuki@d-toybox.com", "creation_time": "2011-08-30T12:22:49Z", "count": 26, "creator": "masayuki@d-toybox.com", "is_private": false}, {"count": 27, "is_private": false, "creator": "bugs@pettay.fi", "text": "Comment on attachment 556804\nPatch part.3 Use synthesized mousemove event for auto scroll at dragging\n\nCould you post all these scrolling/selection related patches to\ntryserver (including patches in other bugs).\nI'd like to try them out.", "bug_id": 671187, "time": "2011-08-30T13:40:02Z", "tags": [], "creation_time": "2011-08-30T13:40:02Z", "author": "bugs@pettay.fi", "raw_text": "Could you post all these scrolling/selection related patches to\ntryserver (including patches in other bugs).\nI'd like to try them out.", "attachment_id": 556804, "id": 5687571}, {"bug_id": 671187, "count": 28, "id": 5687592, "raw_text": "http://tbpl.allizom.org/?tree=Try&usebuildbot=1&rev=6532a322ed38\n\nThis also includes bug 672181's patches too but you can test it.", "attachment_id": null, "text": "http://tbpl.allizom.org/?tree=Try&usebuildbot=1&rev=6532a322ed38\n\nThis also includes bug 672181's patches too but you can test it.", "time": "2011-08-30T13:48:00Z", "tags": [], "creation_time": "2011-08-30T13:48:00Z", "author": "masayuki@d-toybox.com", "is_private": false, "creator": "masayuki@d-toybox.com"}, {"id": 14985991, "attachment_id": null, "raw_text": "Resetting assignee which I don't work on in this several months.", "creation_time": "2020-08-12T08:57:58Z", "author": "masayuki@d-toybox.com", "text": "Resetting assignee which I don't work on in this several months.", "tags": [], "bug_id": 671187, "time": "2020-08-12T08:57:58Z", "is_private": false, "creator": "masayuki@d-toybox.com", "count": 29}, {"id": 15687911, "raw_text": "Although bug 552707 is no more reproducible, but this bug has not been fixed yet.", "attachment_id": null, "time": "2021-12-08T03:37:04Z", "tags": [], "bug_id": 671187, "text": "Although bug 552707 is no more reproducible, but this bug has not been fixed yet.", "author": "masayuki@d-toybox.com", "creation_time": "2021-12-08T03:37:04Z", "count": 30, "creator": "masayuki@d-toybox.com", "is_private": false}]}}, "comments": {}}