{"comments": {}, "bugs": {"675314": {"comments": [{"count": 0, "bug_id": 675314, "creator": "marty.rosenberg@gmail.com", "is_private": false, "time": "2011-07-29T21:04:50Z", "tags": [], "text": "I talked with dvander briefly about doing this.  It is going to only handle a small number of cases, only work on arm, and probably will require some non-trivial changes, but anyhow...\n(Assuming we know all variables involved are integers) to do several adds, we do something like:\nadds r0, r1, 2\nldrvs pc, handle_overflow\nadds r1, r2, r0\nldrvs pc, handle_overflow\nadds r2, r2, 4\nldrvs pc, handle_overflow\n\nWhich has branches all over the place.  Even if the branches aren't taken (most of the time they shouldn't be), I can't imagine it does anything good for the branch predictor, nor the pipeline.\n\nInstead, we can lazily check the overflow conditions as such:\n\nadds r0, r1, 2\naddsvc r1, r2, r0\naddsvc r2, r2, 4\nldrvs pc, handle_overflow\n\nThe idea that in the non-overflow case, we execute all of the adds sequentially (oVerflow Clear), then don't take the branch to handle the overflow.\nIf any of the adds overflows, however, the overflow bit gets set, which causes all of the other adds to not get executed, and finally, the branch to be taken.\n\nThe only case that this *really* helps us is in long chains of register based integer arithmetic.  Any time we need to do a compare (that isn't a TST or TEQ, those do not set the overflow bit), we need to emit the overflow handler.  Similarly, Any time we need to branch or do a call, we need to emit the overflow handler.  Also, since the overflow handler will want to know the state of the world from before we executed any of the arithmetic, any time we synchronize the registers with the stack, we need to emit the overflow handler.\n\nSince this is basically impossible to implement in JM, we should try to keep IM's interface open enough that we can see if this is beneficial.", "author": "marty.rosenberg@gmail.com", "creation_time": "2011-07-29T21:04:50Z", "raw_text": "I talked with dvander briefly about doing this.  It is going to only handle a small number of cases, only work on arm, and probably will require some non-trivial changes, but anyhow...\n(Assuming we know all variables involved are integers) to do several adds, we do something like:\nadds r0, r1, 2\nldrvs pc, handle_overflow\nadds r1, r2, r0\nldrvs pc, handle_overflow\nadds r2, r2, 4\nldrvs pc, handle_overflow\n\nWhich has branches all over the place.  Even if the branches aren't taken (most of the time they shouldn't be), I can't imagine it does anything good for the branch predictor, nor the pipeline.\n\nInstead, we can lazily check the overflow conditions as such:\n\nadds r0, r1, 2\naddsvc r1, r2, r0\naddsvc r2, r2, 4\nldrvs pc, handle_overflow\n\nThe idea that in the non-overflow case, we execute all of the adds sequentially (oVerflow Clear), then don't take the branch to handle the overflow.\nIf any of the adds overflows, however, the overflow bit gets set, which causes all of the other adds to not get executed, and finally, the branch to be taken.\n\nThe only case that this *really* helps us is in long chains of register based integer arithmetic.  Any time we need to do a compare (that isn't a TST or TEQ, those do not set the overflow bit), we need to emit the overflow handler.  Similarly, Any time we need to branch or do a call, we need to emit the overflow handler.  Also, since the overflow handler will want to know the state of the world from before we executed any of the arithmetic, any time we synchronize the registers with the stack, we need to emit the overflow handler.\n\nSince this is basically impossible to implement in JM, we should try to keep IM's interface open enough that we can see if this is beneficial.", "attachment_id": null, "id": 5622778}]}}}