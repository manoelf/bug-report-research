{"comments": {}, "bugs": {"634503": {"comments": [{"author": "dvander@alliedmods.net", "text": "Fact-finding bug for information about V8's GC. The first comment will be general VM stuff and then I'll do a second one about JIT integration.", "creator": "dvander@alliedmods.net", "id": 5282073, "attachment_id": null, "creation_time": "2011-02-16T03:01:30Z", "tags": [], "is_private": false, "time": "2011-02-16T03:01:30Z", "count": 0, "bug_id": 634503, "raw_text": "Fact-finding bug for information about V8's GC. The first comment will be general VM stuff and then I'll do a second one about JIT integration."}, {"creation_time": "2011-02-16T06:02:30Z", "author": "dvander@alliedmods.net", "text": "V8's has a single heap per process, divided into the following components:\n * NewSpace: New object allocations go here. Capacity is 8MB. It's divided into two contiguous semispaces, and periodically collected using Cheney's algorithm. Uses bump-allocation.\n * OldSpaces: These allocate memory in 64-128KB chunks of 8KB pages. They come in the following flavors:\n   * MapSpace:     Exclusively for Maps (similar to js::Shape), and Maps *always* go here.\n   * CodeSpace:    Exclusively for Code.\n   * DataSpace:    For flat strings and numbers; can't reference objects, except for maps.\n   * PointerSpace: For anything not a Map or Code that can reference other objects.\n   * CellSpace:    Seems to store global properties or something.\n * LOSpace:  For large objects, where \"large\" means it needs more than ~8KB of storage.\n\nOldSpace allocation keeps a linked list of available pages, and tries to fit on either the current or next page. If it can't, it either uses the free list or tries to grab a new page.\n\nAll GC-things derive from HeapObject. A HeapObject has a header containing a \"map word\". During normal operation, this is a pointer to that object's shape. During compaction, this field becomes a forwarding address.\n\n(Maps themselves are HeapObjects (there is a sentinel Map for Maps), and are analogous to a js::Class combined with js::Shape. They appear to be fixed size, containing just four fields (prototype, IC cache!, property and transition information. Also worth noting is that the GC-thing hierarchy is used far beyond only JS objects. A good example is \"FixedArray,\" a GC-thing which represents a fixed-length vector of GC-things. This is used as a component of all sorts of structures, like hash tables, which are themselves GC-things.)\n\nAll GC pages have the following notable fields at their base:\n * A pointer to the next page.\n * Allocation watermark.\n * 32-bit field of dirty bits. Each page, no matter how large it is, is divided into 32 regions.\n   This allows for a fast write barrier:\n>     WriteBarrier(obj, offset) {\n>        if (obj not in NewSpace) {  // This is only a mask of |obj| and compare to a precomputed address.\n>           page = obj & PageMask\n>           region = ((obj + offset) & ~PageMask) >> 8\n>           page->dirty |= 1 << region\n>        }\n>     }\n * A spare word that spaces can use for indexing.\n * A special word used during mark compaction, which specifies a base forward address.\n\nThe GC can perform either a \"scavenging\" collection, which reclaims only gargabe in the NewSpace, or it can perform a full, mark-sweep collection. The full collection may or may not compact.\n\nFor a scavenging GC:\n (0) The inactive (\"to\") semispace is completely free, and the active\n     (\"from\") semispace contains all newborn objects since the last GC.\n (1) During this process, the \"map\" field specifies whether an object\n     has been moved or not. If it doesn't have a mark bit, then it hasn't\n     been moved. If it does, then the map is actually the object's new\n     address.\n (2) The first pass looks at roots, and copies objects out of the active\n     \"from\" semispace:\n   (a) If the object is already marked, the reference is updated.\n       Otherwise,\n   (b) If the inactive semispace is 25% full, OR if the object survived\n       the last scavenge, copy it to an old space. A watermark from the\n       last scavenge is kept, any object below this is old.\n   (c) Promoted objects (those copied to old space) are added to a\n       \"promotion queue\". The promotion queue is a vector at the top of\n       the \"to\" space, guaranteed to not overflow.\n   (c) If the object is not promoted, it is copied to the \"to\" space.\n   (d) The old object's map pointer becomes a forwarding address with a\n       mark bit set.\n (3) The first pass also iterates over all pages in spaces other than New\n     and Data, and updates/copies any references from dirty regions to\n     the NewSpace. In LO space, a dirty region can be quite large.\n     Otherwise, they are 256 bytes, which is 64 addresses on x86. All\n     fields in dirty regions are GC-things, so no special work is needed.\n (4) After all roots and possible intergenerational references have been\n     scanned, the following algorithm is used.\n   (a) Inspect the \"to\" semispace for any references to the \"from\" space.\n       For each such reference, the object is copied if not yet done,\n       then the reference updated.\n   (b) Do the same thing for each item in the promotion queue until the\n       promotion queue is empty.\n   (b) If the size of the \"to\" semispace has changed, go back to step\n       (a), scanning the unscanned portions of the \"to\" semispace.\n (5) The semispaces are flipped.\n\nAt the end of a GC, some statistics are collected. It determines, based on the current survival rate and last known survival rate, whether the rate is stable, increasing, or fluctuating (with some margin of error). If the rate is increasing, and the survival rate itself is high, the next full GC is scheduled sooner.\n\nA full GC is much more involved. First, a full marking phase occurs:\n (1) For each strong root, add objects to a marking stack. The marking\n     stack uses the inactive semispace, and can overflow. If it overflows,\n     objects are marked with an \"overflowed\" bit. The whole process is\n     iterative. Mark bits overlay the \"map\" pointer.\n (2) For each object in the marking stack:\n   (a) Remove the object from the marking stack.\n   (b) For each unmarked object immediately referenced from that object,\n       add it to the marking stack.\n (3) As long as the marking stack is overflowed, the entire heap is\n     scanned for overflowed objects. The overflow bit is only removed\n     once its contents have been queued or marked as overflowed.\n (4) There's a notable concept of \"object groups\", special collections\n     of roots where if any one object is live in the group, the entire\n     group is live. A comment implies it's for DOM-like structures.\n (5) Once the marking stack is empty and not overflowed...\n (6) The large object space is swept. It is never compacted. Free objects\n     are unlinked, live objects have their mark bit cleared.\n\nThe next phase can either be compaction, or sweeping. There's a heuristic for this that can be toggled by shell flags. If compaction is desired, the MapSpace builds a vector of all its pages, such that (vector[page->index] == page). This is used for a very efficient address-forwarding scheme that overlays map pointers. If the size of this list is larger than 12 bits (~32MB of pages), then the scheme doesn't work and compaction *must* be forfeited for sweeping.\n\nFor compaction:\n (1) For each GC page |p| in all spaces,\n   (a) For each span of dead objects, the first word of this region\n       becomes a placeholder for future passes. The placeholder says\n       \"skip X many bytes to reach the next live object\".\n   (b) For each live object, a new address is chosen starting from the\n       base of that space. It is not yet copied.\n     (1) If the object is the first live object on this page, set\n         p->first_live = new_address\n     (2) Replace the map word with a new word, encoded as such:\n       * Bits 31-21 are the number of live words encountered since setting\n         p->first_live.\n       * Bits 20-13 are the distance between the object's map and the\n         start of the object's map's page.\n       * Bits 12-0 are the object's map's page index, in MapSpace.\n       * Using this scheme, the map is overwritten, but both the\n         map and the object's new address can be recovered.\n (2) For each object in new space, try to reserve a new address for it\n     in old space. If this fails, reserve one in the other semispace.\n     The forwarding address scheme is much simpler for NewSpace objects:\n        offset = (obj - from_space)\n        to_space[offset] = new_address\n (3) At this point, all live objects have a known forwarding pointer.\n (4) For all live objects, starting with MapSpace,\n   (a) Decompose the map pointer into (new_address, map).\n   (b) Find the map object's new address.\n   (c) Update the object's map pointer, using the same encoding as\n       earlier, to be (new_address, new_map_address).\n (5) Relocate internal object references.\n (6) Finally, perform actual object copies, taking care to preserve\n     inter-generational dirty bits if necessary.\n (7) If the NewSpace is under max capacity, and a large amount of\n     objects survived last GC, then double the size of both semispaces.\n\nIf instead, only a sweep is performed:\n (1) For every page, look for dead objects. If all objects are dead,\n     put the page back in its space's free page list. If only some objects\n     are dead, put spans of dead objects into a free list, which is\n     threaded through such regions.\n (2) Try to promote all objects out of the active semispace, or copy them\n     to the other semispace.\n (3) Update pointers into the new space.\n\nWorth noting is the high amount of abstraction in the GC. Everything tends to be expressed in terms of Address, Page, *Space objects, et cetera.\n\nIt seems like our two main engine-wide difficulties in adapting this sort of model would be rooting (both in C++ code and in JIT code) and in adding write barriers. Aside from that, there's a lot to like here. Sharing IC stubs in shapes (probably a Crankshaft change), GC'ing shapes, GC'ing code (haven't investigated this yet), storing prototypes in shapes, is all good stuff.", "creator": "dvander@alliedmods.net", "attachment_id": null, "id": 5282309, "count": 1, "bug_id": 634503, "raw_text": "V8's has a single heap per process, divided into the following components:\n * NewSpace: New object allocations go here. Capacity is 8MB. It's divided into two contiguous semispaces, and periodically collected using Cheney's algorithm. Uses bump-allocation.\n * OldSpaces: These allocate memory in 64-128KB chunks of 8KB pages. They come in the following flavors:\n   * MapSpace:     Exclusively for Maps (similar to js::Shape), and Maps *always* go here.\n   * CodeSpace:    Exclusively for Code.\n   * DataSpace:    For flat strings and numbers; can't reference objects, except for maps.\n   * PointerSpace: For anything not a Map or Code that can reference other objects.\n   * CellSpace:    Seems to store global properties or something.\n * LOSpace:  For large objects, where \"large\" means it needs more than ~8KB of storage.\n\nOldSpace allocation keeps a linked list of available pages, and tries to fit on either the current or next page. If it can't, it either uses the free list or tries to grab a new page.\n\nAll GC-things derive from HeapObject. A HeapObject has a header containing a \"map word\". During normal operation, this is a pointer to that object's shape. During compaction, this field becomes a forwarding address.\n\n(Maps themselves are HeapObjects (there is a sentinel Map for Maps), and are analogous to a js::Class combined with js::Shape. They appear to be fixed size, containing just four fields (prototype, IC cache!, property and transition information. Also worth noting is that the GC-thing hierarchy is used far beyond only JS objects. A good example is \"FixedArray,\" a GC-thing which represents a fixed-length vector of GC-things. This is used as a component of all sorts of structures, like hash tables, which are themselves GC-things.)\n\nAll GC pages have the following notable fields at their base:\n * A pointer to the next page.\n * Allocation watermark.\n * 32-bit field of dirty bits. Each page, no matter how large it is, is divided into 32 regions.\n   This allows for a fast write barrier:\n>     WriteBarrier(obj, offset) {\n>        if (obj not in NewSpace) {  // This is only a mask of |obj| and compare to a precomputed address.\n>           page = obj & PageMask\n>           region = ((obj + offset) & ~PageMask) >> 8\n>           page->dirty |= 1 << region\n>        }\n>     }\n * A spare word that spaces can use for indexing.\n * A special word used during mark compaction, which specifies a base forward address.\n\nThe GC can perform either a \"scavenging\" collection, which reclaims only gargabe in the NewSpace, or it can perform a full, mark-sweep collection. The full collection may or may not compact.\n\nFor a scavenging GC:\n (0) The inactive (\"to\") semispace is completely free, and the active\n     (\"from\") semispace contains all newborn objects since the last GC.\n (1) During this process, the \"map\" field specifies whether an object\n     has been moved or not. If it doesn't have a mark bit, then it hasn't\n     been moved. If it does, then the map is actually the object's new\n     address.\n (2) The first pass looks at roots, and copies objects out of the active\n     \"from\" semispace:\n   (a) If the object is already marked, the reference is updated.\n       Otherwise,\n   (b) If the inactive semispace is 25% full, OR if the object survived\n       the last scavenge, copy it to an old space. A watermark from the\n       last scavenge is kept, any object below this is old.\n   (c) Promoted objects (those copied to old space) are added to a\n       \"promotion queue\". The promotion queue is a vector at the top of\n       the \"to\" space, guaranteed to not overflow.\n   (c) If the object is not promoted, it is copied to the \"to\" space.\n   (d) The old object's map pointer becomes a forwarding address with a\n       mark bit set.\n (3) The first pass also iterates over all pages in spaces other than New\n     and Data, and updates/copies any references from dirty regions to\n     the NewSpace. In LO space, a dirty region can be quite large.\n     Otherwise, they are 256 bytes, which is 64 addresses on x86. All\n     fields in dirty regions are GC-things, so no special work is needed.\n (4) After all roots and possible intergenerational references have been\n     scanned, the following algorithm is used.\n   (a) Inspect the \"to\" semispace for any references to the \"from\" space.\n       For each such reference, the object is copied if not yet done,\n       then the reference updated.\n   (b) Do the same thing for each item in the promotion queue until the\n       promotion queue is empty.\n   (b) If the size of the \"to\" semispace has changed, go back to step\n       (a), scanning the unscanned portions of the \"to\" semispace.\n (5) The semispaces are flipped.\n\nAt the end of a GC, some statistics are collected. It determines, based on the current survival rate and last known survival rate, whether the rate is stable, increasing, or fluctuating (with some margin of error). If the rate is increasing, and the survival rate itself is high, the next full GC is scheduled sooner.\n\nA full GC is much more involved. First, a full marking phase occurs:\n (1) For each strong root, add objects to a marking stack. The marking\n     stack uses the inactive semispace, and can overflow. If it overflows,\n     objects are marked with an \"overflowed\" bit. The whole process is\n     iterative. Mark bits overlay the \"map\" pointer.\n (2) For each object in the marking stack:\n   (a) Remove the object from the marking stack.\n   (b) For each unmarked object immediately referenced from that object,\n       add it to the marking stack.\n (3) As long as the marking stack is overflowed, the entire heap is\n     scanned for overflowed objects. The overflow bit is only removed\n     once its contents have been queued or marked as overflowed.\n (4) There's a notable concept of \"object groups\", special collections\n     of roots where if any one object is live in the group, the entire\n     group is live. A comment implies it's for DOM-like structures.\n (5) Once the marking stack is empty and not overflowed...\n (6) The large object space is swept. It is never compacted. Free objects\n     are unlinked, live objects have their mark bit cleared.\n\nThe next phase can either be compaction, or sweeping. There's a heuristic for this that can be toggled by shell flags. If compaction is desired, the MapSpace builds a vector of all its pages, such that (vector[page->index] == page). This is used for a very efficient address-forwarding scheme that overlays map pointers. If the size of this list is larger than 12 bits (~32MB of pages), then the scheme doesn't work and compaction *must* be forfeited for sweeping.\n\nFor compaction:\n (1) For each GC page |p| in all spaces,\n   (a) For each span of dead objects, the first word of this region\n       becomes a placeholder for future passes. The placeholder says\n       \"skip X many bytes to reach the next live object\".\n   (b) For each live object, a new address is chosen starting from the\n       base of that space. It is not yet copied.\n     (1) If the object is the first live object on this page, set\n         p->first_live = new_address\n     (2) Replace the map word with a new word, encoded as such:\n       * Bits 31-21 are the number of live words encountered since setting\n         p->first_live.\n       * Bits 20-13 are the distance between the object's map and the\n         start of the object's map's page.\n       * Bits 12-0 are the object's map's page index, in MapSpace.\n       * Using this scheme, the map is overwritten, but both the\n         map and the object's new address can be recovered.\n (2) For each object in new space, try to reserve a new address for it\n     in old space. If this fails, reserve one in the other semispace.\n     The forwarding address scheme is much simpler for NewSpace objects:\n        offset = (obj - from_space)\n        to_space[offset] = new_address\n (3) At this point, all live objects have a known forwarding pointer.\n (4) For all live objects, starting with MapSpace,\n   (a) Decompose the map pointer into (new_address, map).\n   (b) Find the map object's new address.\n   (c) Update the object's map pointer, using the same encoding as\n       earlier, to be (new_address, new_map_address).\n (5) Relocate internal object references.\n (6) Finally, perform actual object copies, taking care to preserve\n     inter-generational dirty bits if necessary.\n (7) If the NewSpace is under max capacity, and a large amount of\n     objects survived last GC, then double the size of both semispaces.\n\nIf instead, only a sweep is performed:\n (1) For every page, look for dead objects. If all objects are dead,\n     put the page back in its space's free page list. If only some objects\n     are dead, put spans of dead objects into a free list, which is\n     threaded through such regions.\n (2) Try to promote all objects out of the active semispace, or copy them\n     to the other semispace.\n (3) Update pointers into the new space.\n\nWorth noting is the high amount of abstraction in the GC. Everything tends to be expressed in terms of Address, Page, *Space objects, et cetera.\n\nIt seems like our two main engine-wide difficulties in adapting this sort of model would be rooting (both in C++ code and in JIT code) and in adding write barriers. Aside from that, there's a lot to like here. Sharing IC stubs in shapes (probably a Crankshaft change), GC'ing shapes, GC'ing code (haven't investigated this yet), storing prototypes in shapes, is all good stuff.", "tags": [], "is_private": false, "time": "2011-02-16T06:02:30Z"}, {"is_private": false, "tags": [], "raw_text": "Nice write-up. As you say, a lot to like. We could copy quite a bit in the way of design, incrementally or patch-wise to boot.\n\n>  (4) There's a notable concept of \"object groups\", special collections\n>      of roots where if any one object is live in the group, the entire\n>      group is live. A comment implies it's for DOM-like structures.\n\nThis is like what we had pre-CycleCollector, dbaron's SCC (strongly connected components) algorithm. It handled DOM/JS cycles but not all XPCOM cycles. See bug 283129, recommended reading for all who want to take on DOM memory management.\n\n/be", "attachment_id": null, "id": 5282344, "text": "Nice write-up. As you say, a lot to like. We could copy quite a bit in the way of design, incrementally or patch-wise to boot.\n\n>  (4) There's a notable concept of \"object groups\", special collections\n>      of roots where if any one object is live in the group, the entire\n>      group is live. A comment implies it's for DOM-like structures.\n\nThis is like what we had pre-CycleCollector, dbaron's SCC (strongly connected components) algorithm. It handled DOM/JS cycles but not all XPCOM cycles. See bug 283129, recommended reading for all who want to take on DOM memory management.\n\n/be", "creation_time": "2011-02-16T06:36:14Z", "time": "2011-02-16T06:36:14Z", "count": 2, "bug_id": 634503, "author": "brendan@mozilla.org", "creator": "brendan@mozilla.org"}, {"raw_text": "Brendan pointed out a mistake in IRC, card marking computation is (obj + addr) & PageMask, not ~PageMask. The region number is based on the offset, but the dirty bit is stored in the base page. When marking an object in the LO space, the base dirty bits are treated as the dirty bits for each individual page in that object.", "is_private": false, "tags": [], "creation_time": "2011-02-16T07:48:29Z", "attachment_id": null, "id": 5282411, "text": "Brendan pointed out a mistake in IRC, card marking computation is (obj + addr) & PageMask, not ~PageMask. The region number is based on the offset, but the dirty bit is stored in the base page. When marking an object in the LO space, the base dirty bits are treated as the dirty bits for each individual page in that object.", "bug_id": 634503, "count": 3, "time": "2011-02-16T07:48:29Z", "creator": "dvander@alliedmods.net", "author": "dvander@alliedmods.net"}, {"time": "2011-02-17T20:17:53Z", "is_private": false, "tags": [], "raw_text": "Another design aspect of V8's GC is that you can't garbage collect in between every two lines of code in the engine. Internal functions tend to leave locals unrooted, performing anything fallible or impure operations at the very end of the function, after all allocation has succeeded.\n\nAllocation failure never immediately triggers a GC. Instead a magic \"retry after GC\" cookie propagates back up to top-level API wrappers. These wrappers invoke VM machinery through a CALL_HEAP_FUNCTION macro. This macro invokes the VM function, and if a RetryAfterGC cookie is returned, performs collection. Then it re-runs the internal function, which is safe as long that function has been written properly.", "bug_id": 634503, "count": 4, "attachment_id": null, "id": 5287316, "text": "Another design aspect of V8's GC is that you can't garbage collect in between every two lines of code in the engine. Internal functions tend to leave locals unrooted, performing anything fallible or impure operations at the very end of the function, after all allocation has succeeded.\n\nAllocation failure never immediately triggers a GC. Instead a magic \"retry after GC\" cookie propagates back up to top-level API wrappers. These wrappers invoke VM machinery through a CALL_HEAP_FUNCTION macro. This macro invokes the VM function, and if a RetryAfterGC cookie is returned, performs collection. Then it re-runs the internal function, which is safe as long that function has been written properly.", "creator": "dvander@alliedmods.net", "author": "dvander@alliedmods.net", "creation_time": "2011-02-17T20:17:53Z"}, {"raw_text": "Some grab-bag questions that came up, and their answers:\n\nQ: Do objects ever have inline slots?\nA: Yes. A Map contains a count of how many slots must be inline. When fetching a value from a slot number, the number is decremented by this count, sort of like what we used to do for JS_INITIAL_NSLOTS, except it's not constant. An object has both inline slots and dynamic slots, and dslots never points to inline slots. (Note: there is a global \"empty array\" value.)\n\nQ: Do objects have flags?\nA: I don't see anything like our JSObject::flags.\n\nQ: Do objects have resolve hooks?\nA: It looks like there are various ways of installing interceptors on objects, and these look kind of like our JSClass hooks.\n\nQ: Are there host objects?\nA: A Map encodes a byte that describes various kinds of internal object types. These mostly seem to assist in determining how to GC an object. I don't see anything like JSClass other than that.\n\nQ: What exactly is a Map?\nA: Our js::Shape is a fairly different beast from JSC's Structure, or v8's Map. In these two systems, a \"shape\" is a collection of property descriptors stored in a dictionary. In SpiderMonkey, a Shape is a single property descriptor and a link pointer to the next property in enumeration order. For small property chains, lookup traverses a linked list. For large property property sets, or dictionary-mode objects, all properties along the ancestor line are cloned, and placed into a hashtable stored in the last shape. In V8's model, there is no link pointer, but there are more tables and less shapes for dictionaries.\n\nThe main item of interest in a Map is its \"descriptor\" field. This is a pointer to a 2+N element FixedArray:\n  [0]   - A FixedArray that lists properties and transitions.\n  [1]   - An enumeration-helper that can contain an enumeration cache.\n  [2+N] - Property key list. This uses linear search for < 8 keys, otherwise, binary search with hashing.\n          There is a DescriptorLookupCache, globally, that keys on (DescriptorArray, PropertyName) and\n          maps to an index into the DescriptorArray. It is filled after slow-searching for a property.\n          (There are hash tables and they FixedArrays+probing, but it looks like descriptors are not\n           stored in hash tables).\n\nTransitions are encoded as descriptors, so a lookup can return a descriptor, and that descriptor may be a data field, or a transition, etc.\n\nEnumeration order is encoded in a descriptor's details, but it's not threaded through or anything. Enumeration is multi-step:\n * Build a vector of all enumerable properties.\n * Sort it in enumeration order.\n * Maybe, cache the result inside the Map.", "bug_id": 634503, "count": 5, "time": "2011-02-17T23:46:42Z", "is_private": false, "tags": [], "creation_time": "2011-02-17T23:46:42Z", "id": 5288103, "attachment_id": null, "creator": "dvander@alliedmods.net", "text": "Some grab-bag questions that came up, and their answers:\n\nQ: Do objects ever have inline slots?\nA: Yes. A Map contains a count of how many slots must be inline. When fetching a value from a slot number, the number is decremented by this count, sort of like what we used to do for JS_INITIAL_NSLOTS, except it's not constant. An object has both inline slots and dynamic slots, and dslots never points to inline slots. (Note: there is a global \"empty array\" value.)\n\nQ: Do objects have flags?\nA: I don't see anything like our JSObject::flags.\n\nQ: Do objects have resolve hooks?\nA: It looks like there are various ways of installing interceptors on objects, and these look kind of like our JSClass hooks.\n\nQ: Are there host objects?\nA: A Map encodes a byte that describes various kinds of internal object types. These mostly seem to assist in determining how to GC an object. I don't see anything like JSClass other than that.\n\nQ: What exactly is a Map?\nA: Our js::Shape is a fairly different beast from JSC's Structure, or v8's Map. In these two systems, a \"shape\" is a collection of property descriptors stored in a dictionary. In SpiderMonkey, a Shape is a single property descriptor and a link pointer to the next property in enumeration order. For small property chains, lookup traverses a linked list. For large property property sets, or dictionary-mode objects, all properties along the ancestor line are cloned, and placed into a hashtable stored in the last shape. In V8's model, there is no link pointer, but there are more tables and less shapes for dictionaries.\n\nThe main item of interest in a Map is its \"descriptor\" field. This is a pointer to a 2+N element FixedArray:\n  [0]   - A FixedArray that lists properties and transitions.\n  [1]   - An enumeration-helper that can contain an enumeration cache.\n  [2+N] - Property key list. This uses linear search for < 8 keys, otherwise, binary search with hashing.\n          There is a DescriptorLookupCache, globally, that keys on (DescriptorArray, PropertyName) and\n          maps to an index into the DescriptorArray. It is filled after slow-searching for a property.\n          (There are hash tables and they FixedArrays+probing, but it looks like descriptors are not\n           stored in hash tables).\n\nTransitions are encoded as descriptors, so a lookup can return a descriptor, and that descriptor may be a data field, or a transition, etc.\n\nEnumeration order is encoded in a descriptor's details, but it's not threaded through or anything. Enumeration is multi-step:\n * Build a vector of all enumerable properties.\n * Sort it in enumeration order.\n * Maybe, cache the result inside the Map.", "author": "dvander@alliedmods.net"}, {"creation_time": "2011-02-18T01:39:26Z", "id": 5288405, "attachment_id": null, "text": "(In reply to comment #5)\n> Q: What exactly is a Map?\n> A: Our js::Shape is a fairly different beast from JSC's Structure, or v8's Map.\n\nNo, JSC's Structure is close to our Shape.\n\nV8 Map (IIRC) is based on Ungar et al.'s property maps work for Self:\n\nhttp://portal.acm.org/citation.cfm?id=74884\n\n> In these two systems, a \"shape\" is a collection of property descriptors stored\n> in a dictionary.\n\nThat's not true of JSC Structures, AFAIK -- Structures like Shapes are in a tree until one of several conditions causes a switch to dictionary mode. In either mode, the VM has one Structure or Shape per property.\n\n> In SpiderMonkey, a Shape is a single property descriptor and a\n> link pointer to the next property in enumeration order.\n\nJSC Structures are in enumeration order until in dictionary mode, then they need extra bookkeeping for enumeration.\n\nOur Shapes stay in enumeration order even after going to dictionary mode.\n\n/be", "raw_text": "(In reply to comment #5)\n> Q: What exactly is a Map?\n> A: Our js::Shape is a fairly different beast from JSC's Structure, or v8's Map.\n\nNo, JSC's Structure is close to our Shape.\n\nV8 Map (IIRC) is based on Ungar et al.'s property maps work for Self:\n\nhttp://portal.acm.org/citation.cfm?id=74884\n\n> In these two systems, a \"shape\" is a collection of property descriptors stored\n> in a dictionary.\n\nThat's not true of JSC Structures, AFAIK -- Structures like Shapes are in a tree until one of several conditions causes a switch to dictionary mode. In either mode, the VM has one Structure or Shape per property.\n\n> In SpiderMonkey, a Shape is a single property descriptor and a\n> link pointer to the next property in enumeration order.\n\nJSC Structures are in enumeration order until in dictionary mode, then they need extra bookkeeping for enumeration.\n\nOur Shapes stay in enumeration order even after going to dictionary mode.\n\n/be", "is_private": false, "tags": [], "author": "brendan@mozilla.org", "creator": "brendan@mozilla.org", "count": 6, "bug_id": 634503, "time": "2011-02-18T01:39:26Z"}, {"text": "(In reply to comment #6)\n> (In reply to comment #5)\n> > Q: What exactly is a Map?\n> > A: Our js::Shape is a fairly different beast from JSC's Structure, or v8's Map.\n> \n> No, JSC's Structure is close to our Shape.\n\nAre you sure? Looking at Structure:\n\n        union {\n            TransitionTable* m_table;\n            Structure* m_singleTransition;\n        } m_transitions;\n        PropertyMapHashTable* m_propertyTable;\n ---------^\nThis looks like a string -> attribute map. That seems more like V8.", "id": 5288412, "attachment_id": null, "creation_time": "2011-02-18T01:43:10Z", "tags": [], "is_private": false, "raw_text": "(In reply to comment #6)\n> (In reply to comment #5)\n> > Q: What exactly is a Map?\n> > A: Our js::Shape is a fairly different beast from JSC's Structure, or v8's Map.\n> \n> No, JSC's Structure is close to our Shape.\n\nAre you sure? Looking at Structure:\n\n        union {\n            TransitionTable* m_table;\n            Structure* m_singleTransition;\n        } m_transitions;\n        PropertyMapHashTable* m_propertyTable;\n ---------^\nThis looks like a string -> attribute map. That seems more like V8.", "author": "dvander@alliedmods.net", "creator": "dvander@alliedmods.net", "time": "2011-02-18T01:43:10Z", "count": 7, "bug_id": 634503}, {"count": 8, "raw_text": "Okay, I think I'm wrong, Structure does have a parent link and it's used to materialize that table sometimes.", "bug_id": 634503, "is_private": false, "tags": [], "time": "2011-02-18T01:46:22Z", "creation_time": "2011-02-18T01:46:22Z", "author": "dvander@alliedmods.net", "id": 5288420, "attachment_id": null, "text": "Okay, I think I'm wrong, Structure does have a parent link and it's used to materialize that table sometimes.", "creator": "dvander@alliedmods.net"}, {"id": 5288443, "attachment_id": null, "text": "(In reply to comment #7)\n> (In reply to comment #6)\n> > (In reply to comment #5)\n> > > Q: What exactly is a Map?\n> > > A: Our js::Shape is a fairly different beast from JSC's Structure, or v8's Map.\n> > \n> > No, JSC's Structure is close to our Shape.\n> \n> Are you sure? Looking at Structure:\n> \n>         union {\n>             TransitionTable* m_table;\n>             Structure* m_singleTransition;\n>         } m_transitions;\n>         PropertyMapHashTable* m_propertyTable;\n>  ---------^\n> This looks like a string -> attribute map. That seems more like V8.\n\nNo, that is like our js::KidsPointer from jspropertytree.h. Except that the JSC tree of Structures transitions are keyed by (id, attrs) only, with a mutable specificValue option. We specialize for more of the members of Shape, which can overspecialize sometimes. We both have to despecialize when things go south.\n\nAgain the key to understanding this is not just the parent linkage but the fact that in no case is there a \"Structure\" or \"Shape\" that maps, by itself and ignoring parent, *multiple* property identifiers to property metadata. These grow by induction from empty objects, one prop at a time.\n\n/be", "creation_time": "2011-02-18T01:52:27Z", "is_private": false, "tags": [], "raw_text": "(In reply to comment #7)\n> (In reply to comment #6)\n> > (In reply to comment #5)\n> > > Q: What exactly is a Map?\n> > > A: Our js::Shape is a fairly different beast from JSC's Structure, or v8's Map.\n> > \n> > No, JSC's Structure is close to our Shape.\n> \n> Are you sure? Looking at Structure:\n> \n>         union {\n>             TransitionTable* m_table;\n>             Structure* m_singleTransition;\n>         } m_transitions;\n>         PropertyMapHashTable* m_propertyTable;\n>  ---------^\n> This looks like a string -> attribute map. That seems more like V8.\n\nNo, that is like our js::KidsPointer from jspropertytree.h. Except that the JSC tree of Structures transitions are keyed by (id, attrs) only, with a mutable specificValue option. We specialize for more of the members of Shape, which can overspecialize sometimes. We both have to despecialize when things go south.\n\nAgain the key to understanding this is not just the parent linkage but the fact that in no case is there a \"Structure\" or \"Shape\" that maps, by itself and ignoring parent, *multiple* property identifiers to property metadata. These grow by induction from empty objects, one prop at a time.\n\n/be", "creator": "brendan@mozilla.org", "author": "brendan@mozilla.org", "time": "2011-02-18T01:52:27Z", "bug_id": 634503, "count": 9}, {"author": "allen@mozilla.com", "text": "(In reply to comment #6)\nSome general thoughts about type mapss/shapes/descriptor and how they relate to a GC:\n\nThe structure of a \"type descriptor\" for non-memory management concerns should have no relevance to the GC. It's a separation of concerns issues and a matter of design hygiene.  You really want to be able to change map/shape/descriptor design without having to also make substantial changes to the GC.\n\nThe only thing the GC really cares about is locating the pointers it needs to trace. This typically only requires knowing the size of the object and location of each such pointer.  Everything is simpler (in the GC) if you only have all-pointers or all-nonpointer objects. This GC-level simplification can even justify the expense of using multiple GC-level objects to represent a single complex higher level object. It you can't have such homogeneous objects, then the next best thing is to keep pointers and non-pointers in separate  contiguous regions of the object. In the worst case where you must have arbitrary layout of both pointer and non-pointer data then the GC is going to need some sort of map and it makes sense of keep this map in the same \"type descriptor\" as is used to support non-GC semantics.  However, it is still best to minimize any dependencies of the GC map upon any other semantics encoded in the descriptor. One good approach is to dynamically generate a tracer function for each unique GC object shape and keep a pointer to it in the type descriptor.\n\nThere is always a tension between how much metadata to keep \"per object\" in an object header and how much metadata to push into a shared descriptor.  Smaller headers are good for an overall footprint perspective and mean fewer bytes to copy.  However, access to shared meta state may incur the overhead of multiple levels of indirection and cache misses.\n\nFor example, the size of an object might be in the object header or it might be in the type descriptor.  Not only pointer tracing but any walk over contiguous regions of objects usually require access to the size of individual objects.  Placing that size in the type descriptor is likely to cause cache misses (at various levels of the storage hierarchy). It's usually worth having a slightly larger object header containing a size field to avoid those cache misses. The best scenario is being able to walk an entire segment of objects without having to refer to any separately located description metadata. That is why simple homogeneous object structures are so desirable.\n\nFinally, in a highly dynamic language like JS you are likely to be creating and discarding a lot of type descriptors.  In such situations it is usually best to simply use the GC to manage them rather than to have some sort of specialized memory manager for them. Specialized mangers add overall complexity and usually require additional special cases in the main GC. You really want to built a GC that is good enough that it can manage both regular objects and metadata.", "creator": "allen@mozilla.com", "attachment_id": null, "id": 5290021, "creation_time": "2011-02-18T18:15:56Z", "tags": [], "is_private": false, "time": "2011-02-18T18:15:56Z", "count": 10, "bug_id": 634503, "raw_text": "(In reply to comment #6)\nSome general thoughts about type mapss/shapes/descriptor and how they relate to a GC:\n\nThe structure of a \"type descriptor\" for non-memory management concerns should have no relevance to the GC. It's a separation of concerns issues and a matter of design hygiene.  You really want to be able to change map/shape/descriptor design without having to also make substantial changes to the GC.\n\nThe only thing the GC really cares about is locating the pointers it needs to trace. This typically only requires knowing the size of the object and location of each such pointer.  Everything is simpler (in the GC) if you only have all-pointers or all-nonpointer objects. This GC-level simplification can even justify the expense of using multiple GC-level objects to represent a single complex higher level object. It you can't have such homogeneous objects, then the next best thing is to keep pointers and non-pointers in separate  contiguous regions of the object. In the worst case where you must have arbitrary layout of both pointer and non-pointer data then the GC is going to need some sort of map and it makes sense of keep this map in the same \"type descriptor\" as is used to support non-GC semantics.  However, it is still best to minimize any dependencies of the GC map upon any other semantics encoded in the descriptor. One good approach is to dynamically generate a tracer function for each unique GC object shape and keep a pointer to it in the type descriptor.\n\nThere is always a tension between how much metadata to keep \"per object\" in an object header and how much metadata to push into a shared descriptor.  Smaller headers are good for an overall footprint perspective and mean fewer bytes to copy.  However, access to shared meta state may incur the overhead of multiple levels of indirection and cache misses.\n\nFor example, the size of an object might be in the object header or it might be in the type descriptor.  Not only pointer tracing but any walk over contiguous regions of objects usually require access to the size of individual objects.  Placing that size in the type descriptor is likely to cause cache misses (at various levels of the storage hierarchy). It's usually worth having a slightly larger object header containing a size field to avoid those cache misses. The best scenario is being able to walk an entire segment of objects without having to refer to any separately located description metadata. That is why simple homogeneous object structures are so desirable.\n\nFinally, in a highly dynamic language like JS you are likely to be creating and discarding a lot of type descriptors.  In such situations it is usually best to simply use the GC to manage them rather than to have some sort of specialized memory manager for them. Specialized mangers add overall complexity and usually require additional special cases in the main GC. You really want to built a GC that is good enough that it can manage both regular objects and metadata."}, {"id": 5296340, "attachment_id": null, "creator": "allen@mozilla.com", "text": "As a contrast to the V8 GC design you might want to take a look at the design described in the \"JOVE Runtime Design\" document available at http://www.wirfs-brock.com/allen/things/jove .\n\nThis describes a full multi-generational GC that was built for a Java compiler.", "author": "allen@mozilla.com", "creation_time": "2011-02-22T19:07:53Z", "time": "2011-02-22T19:07:53Z", "is_private": false, "tags": [], "raw_text": "As a contrast to the V8 GC design you might want to take a look at the design described in the \"JOVE Runtime Design\" document available at http://www.wirfs-brock.com/allen/things/jove .\n\nThis describes a full multi-generational GC that was built for a Java compiler.", "bug_id": 634503, "count": 11}, {"creation_time": "2011-03-24T07:06:58Z", "author": "dvander@alliedmods.net", "attachment_id": null, "id": 5365175, "creator": "dvander@alliedmods.net", "text": "Some info on how the moving GC interacts with the JIT. Starting with the 2.x branch, first observation (new to me, perhaps not to anyone else) is that V8 actually has two full code generators for each platform. Both walk the AST, but emit different code.\n\nThe \"full code generator\" is intended for run-once scripts. It's not invoked on anything with loops. It always pushes values directly onto the stack, and pops them off to consume them. There is no register allocation. Registers are hardcoded. Aside from that it's similar to JM in eval/debug mode. It can call directly into the C++ runtime without any extra work, and because the stack is always reified, nothing is held in registers, and thus a moving GC poses no problem.\n\nThe other code generator has an abstraction similar to our FrameState (called a VirtualFrame), except it can nest, and two frames can be merged. Stub calls sync every frame slot, and do not preserve non-volatile registers. All registers are killed, because a GC could move items on the stack.\n\nThe other big difference from JM is how out-of-line code is generated on the main compilation path. JM1 captured the register state of slow paths, then deferred their generation until the end of compilation. The slow paths were then generated in a completely separate pass. JM2 instead emits a sync sequence in a separate, out-of-line code buffer. Stack operands and all registers are synced and killed. This is followed by a C++ call, then register state is restored before rejoining to the inline path.\n\nV8 seems to do exactly what JM1 did. It has \"DeferredCode\" objects which save register state and operation-specific variables. These are processed near the end of compilation. Stub calls in the deferred path don't need the complex and expensive syncing process that JM2 has, nor V8's heavyweight splitting of frames that is used for control flow. Instead, it just spills all in-flight registers, calls into C++, then restores them. Spills go to the normal frame locations so re-loading the registers afterwards is GC safe.\n\nOne thing I don't understand is why stub calls on the inline path sync the entire frame, but stub calls on the out-of-line path don't. I don't know if 2.x did any on-stack replacement for debug mode.\n\nThe only area where JM2 is really not ready for moving GC is how it bakes in object pointers everywhere. V8 does this too, but its assembler tracks when GC things are passed as operands, and adds the position to a relocation table.\n\nTomorrow I'll look at Crankshaft.", "count": 12, "raw_text": "Some info on how the moving GC interacts with the JIT. Starting with the 2.x branch, first observation (new to me, perhaps not to anyone else) is that V8 actually has two full code generators for each platform. Both walk the AST, but emit different code.\n\nThe \"full code generator\" is intended for run-once scripts. It's not invoked on anything with loops. It always pushes values directly onto the stack, and pops them off to consume them. There is no register allocation. Registers are hardcoded. Aside from that it's similar to JM in eval/debug mode. It can call directly into the C++ runtime without any extra work, and because the stack is always reified, nothing is held in registers, and thus a moving GC poses no problem.\n\nThe other code generator has an abstraction similar to our FrameState (called a VirtualFrame), except it can nest, and two frames can be merged. Stub calls sync every frame slot, and do not preserve non-volatile registers. All registers are killed, because a GC could move items on the stack.\n\nThe other big difference from JM is how out-of-line code is generated on the main compilation path. JM1 captured the register state of slow paths, then deferred their generation until the end of compilation. The slow paths were then generated in a completely separate pass. JM2 instead emits a sync sequence in a separate, out-of-line code buffer. Stack operands and all registers are synced and killed. This is followed by a C++ call, then register state is restored before rejoining to the inline path.\n\nV8 seems to do exactly what JM1 did. It has \"DeferredCode\" objects which save register state and operation-specific variables. These are processed near the end of compilation. Stub calls in the deferred path don't need the complex and expensive syncing process that JM2 has, nor V8's heavyweight splitting of frames that is used for control flow. Instead, it just spills all in-flight registers, calls into C++, then restores them. Spills go to the normal frame locations so re-loading the registers afterwards is GC safe.\n\nOne thing I don't understand is why stub calls on the inline path sync the entire frame, but stub calls on the out-of-line path don't. I don't know if 2.x did any on-stack replacement for debug mode.\n\nThe only area where JM2 is really not ready for moving GC is how it bakes in object pointers everywhere. V8 does this too, but its assembler tracks when GC things are passed as operands, and adds the position to a relocation table.\n\nTomorrow I'll look at Crankshaft.", "bug_id": 634503, "is_private": false, "tags": [], "time": "2011-03-24T07:06:58Z"}]}}}