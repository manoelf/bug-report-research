{"bugs": {"672871": {"comments": [{"tags": [], "time": "2011-07-20T18:21:23Z", "text": "Function CERT_PKIXVerifyCert is designed to enable the caller to obtain the list of valid usages for a cert.\n\nThis output is designed to be requested by adding a member of type cert_po_usages to the CERTValOutParam parameter.\n\nThe value must be returned inside the union structure as \"value.scalar.usages\".\n\nI searched nss/lib/libpkix for assignments to any variable named \"usages\", and I couldn't find any match.\n\n\nIt appears this feature has not yet been implemented.", "author": "kaie@kuix.de", "creation_time": "2011-07-20T18:21:23Z", "creator": "kaie@kuix.de", "is_private": false, "id": 5602281, "raw_text": "Function CERT_PKIXVerifyCert is designed to enable the caller to obtain the list of valid usages for a cert.\n\nThis output is designed to be requested by adding a member of type cert_po_usages to the CERTValOutParam parameter.\n\nThe value must be returned inside the union structure as \"value.scalar.usages\".\n\nI searched nss/lib/libpkix for assignments to any variable named \"usages\", and I couldn't find any match.\n\n\nIt appears this feature has not yet been implemented.", "attachment_id": null, "bug_id": 672871, "count": 0}, {"count": 1, "bug_id": 672871, "attachment_id": null, "raw_text": "Where in the libpkix verification code should the code be added that loops through all usages, and tests them individually?\n\n(similar to what happens in classic CERT_VerifyCertificate)", "id": 5602296, "is_private": false, "creator": "kaie@kuix.de", "creation_time": "2011-07-20T18:26:25Z", "author": "kaie@kuix.de", "text": "Where in the libpkix verification code should the code be added that loops through all usages, and tests them individually?\n\n(similar to what happens in classic CERT_VerifyCertificate)", "tags": [], "time": "2011-07-20T18:26:25Z"}, {"count": 2, "is_private": false, "creator": "kaie@kuix.de", "text": "... I suspect it should be added inside PKIX_PL_Cert_VerifyCertAndKeyType, but I don't know the code well enough to be sure.", "tags": [], "bug_id": 672871, "time": "2011-07-20T18:30:10Z", "creation_time": "2011-07-20T18:30:10Z", "author": "kaie@kuix.de", "raw_text": "... I suspect it should be added inside PKIX_PL_Cert_VerifyCertAndKeyType, but I don't know the code well enough to be sure.", "attachment_id": null, "id": 5602312}, {"id": 5602800, "attachment_id": 547234, "raw_text": "This is a quick attempt to implement it.\n\nI don't know if it's complete. I identified the places that need change by tracing, not through code review.\n\nI don't know if PKIX_PL_NssContext is the right object to store the output usages. When I test this with PSM's \"view cert\" functionality, I get mixed results: In the first attempt to view a cert, the results seem to be correct, and multiple uses are displayed (and correct ones as it seems, based on root CA trust flags). However, In the second execution, only a single bit is shown. In the third execution it's complete again.", "author": "kaie@kuix.de", "creation_time": "2011-07-20T21:06:52Z", "time": "2011-07-20T21:06:52Z", "bug_id": 672871, "tags": [], "text": "Created attachment 547234\nPatch v1\n\nThis is a quick attempt to implement it.\n\nI don't know if it's complete. I identified the places that need change by tracing, not through code review.\n\nI don't know if PKIX_PL_NssContext is the right object to store the output usages. When I test this with PSM's \"view cert\" functionality, I get mixed results: In the first attempt to view a cert, the results seem to be correct, and multiple uses are displayed (and correct ones as it seems, based on root CA trust flags). However, In the second execution, only a single bit is shown. In the third execution it's complete again.", "creator": "kaie@kuix.de", "is_private": false, "count": 3}, {"raw_text": "The random behaviour is related to function PKIX_PL_Cert_VerifyCertAndKeyType and the arguments being passed to it during chain building.\n\nPKIX_PL_Cert_VerifyCertAndKeyType has a parameter \"isChainCert\" which means \"not a leaf cert\".\n\nDuring the chain processing, the function gets called twice.\nSometimes isChainCert is 0 both times.\nSometimes isChainCert is 0 once, and once has the value 1.\nThis causes the different results.\n\nDoes pkix chain building have a random component?", "attachment_id": null, "id": 5602853, "count": 4, "is_private": false, "creator": "kaie@kuix.de", "text": "The random behaviour is related to function PKIX_PL_Cert_VerifyCertAndKeyType and the arguments being passed to it during chain building.\n\nPKIX_PL_Cert_VerifyCertAndKeyType has a parameter \"isChainCert\" which means \"not a leaf cert\".\n\nDuring the chain processing, the function gets called twice.\nSometimes isChainCert is 0 both times.\nSometimes isChainCert is 0 once, and once has the value 1.\nThis causes the different results.\n\nDoes pkix chain building have a random component?", "time": "2011-07-20T21:25:12Z", "tags": [], "bug_id": 672871, "creation_time": "2011-07-20T21:25:12Z", "author": "kaie@kuix.de"}, {"id": 6128449, "attachment_id": null, "raw_text": "After getting back to this bug, I'm starting to understand better.\n\nMy patch used a new attribute in the \"NSS-Context\" object used by libpkix. When checking for trust etc, the patch stores the results inside that context object.\n\nThat approach is too simplistic. When the trust checking functions get called multiple times, e.g. because multple certificates are being checked (the chain), then results can be overriden. I saw that the order to function calls (which certs checked first, etc.) can be different - that explains the random results I saw, because the results of the last funciton wins.\n\nAssuming the general approach of this patch still makes sense:\n\n- we need to remember the usages for which certificate are currently being queried\n- when checking trust, inside the trust checking functions,\n  only update the usages output parameter, if the currently processed cert\n  is the certificate being requested by the original caller\n\nMaybe the NSS-context is the wrong place to transport \"usages for which cert are requested\" and \"result usages\"?\n\nMaybe the better place is the Processing-Params object?\n\nIf ProcParams should be used, then I'd have to pass it to additional functions. The functions currently checking trust don't receive it as a paramater.\n\nAlso, I suspect that member \"PKIX_CertSelector *constraints\" inside the ProcParams already contains information about the certificate being processed. But I don't understand yet how to use it.\n\nI wish we had some documentation on the architecture of libPKIX and some documentation on the data flow of important objects. Reading the code is cumbersome.", "creation_time": "2012-03-09T20:32:13Z", "author": "kaie@kuix.de", "text": "After getting back to this bug, I'm starting to understand better.\n\nMy patch used a new attribute in the \"NSS-Context\" object used by libpkix. When checking for trust etc, the patch stores the results inside that context object.\n\nThat approach is too simplistic. When the trust checking functions get called multiple times, e.g. because multple certificates are being checked (the chain), then results can be overriden. I saw that the order to function calls (which certs checked first, etc.) can be different - that explains the random results I saw, because the results of the last funciton wins.\n\nAssuming the general approach of this patch still makes sense:\n\n- we need to remember the usages for which certificate are currently being queried\n- when checking trust, inside the trust checking functions,\n  only update the usages output parameter, if the currently processed cert\n  is the certificate being requested by the original caller\n\nMaybe the NSS-context is the wrong place to transport \"usages for which cert are requested\" and \"result usages\"?\n\nMaybe the better place is the Processing-Params object?\n\nIf ProcParams should be used, then I'd have to pass it to additional functions. The functions currently checking trust don't receive it as a paramater.\n\nAlso, I suspect that member \"PKIX_CertSelector *constraints\" inside the ProcParams already contains information about the certificate being processed. But I don't understand yet how to use it.\n\nI wish we had some documentation on the architecture of libPKIX and some documentation on the data flow of important objects. Reading the code is cumbersome.", "tags": [], "time": "2012-03-09T20:32:13Z", "is_private": false, "creator": "kaie@kuix.de", "bug_id": 672871, "count": 5}, {"bug_id": 672871, "count": 6, "id": 6148851, "raw_text": "Is this an important feature? Perhaps we can just WONTFIX it?\n\nI was able to implement this functionality on top of the existing libpkix code in Gecko by looping through all the usages we are interested in, independently validating the cert for each usage independently. This was not difficult to do. I would prefer to avoid adding more complexity to libpkix that adds functionality that can be done by the application without adding code to libpkix.", "attachment_id": null, "text": "Is this an important feature? Perhaps we can just WONTFIX it?\n\nI was able to implement this functionality on top of the existing libpkix code in Gecko by looping through all the usages we are interested in, independently validating the cert for each usage independently. This was not difficult to do. I would prefer to avoid adding more complexity to libpkix that adds functionality that can be done by the application without adding code to libpkix.", "tags": [], "time": "2012-03-17T17:48:32Z", "creation_time": "2012-03-17T17:48:32Z", "author": "brian@briansmith.org", "is_private": false, "creator": "brian@briansmith.org"}]}}, "comments": {}}