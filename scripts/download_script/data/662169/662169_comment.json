{"comments": {}, "bugs": {"662169": {"comments": [{"author": "bugzilla.org@masklinn.net", "time": "2011-06-05T17:39:46Z", "creation_time": "2011-06-05T17:39:46Z", "creator": "bugzilla.org@masklinn.net", "id": 5514150, "count": 0, "is_private": false, "tags": [], "text": "User-Agent:       Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.6; en; rv:1.9.0.19) Gecko/2011032020 Camino/2.0.7 (like Firefox/3.0.19)\nBuild Identifier: \n\nobject/@type is an optional attribute providing the MIME type of the content. When fetching a remote object and if @type is set (and a valid MIME type), Gecko should send it to the remote host.\n\nWhy:\nContent negotiation of multi-format resources, especially between textual and image formats\n\nUse case:\nI was working on a floor plan demo/API, and most of the floor plan resources were to be made available in a number of formats: an HTML page for details and sub-resources, a JSON for JS code and an image for visualization. I tried to use *object[@type='image/svg+xml']* so that the server side could just return the resource in the format clients liked most, in what I understand to be a RESTful manner.\n\n\nReproducible: Always\n\nSteps to Reproduce:\n1. Add an object tag to a remote resource with an @type set to a valid MIME type\n2. Check the Accept header for the resource\n\nActual Results:  \nGecko does not seem to care for @type, and always sends the same Accept header: 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'\n\n\nExpected Results:  \nGecko uses object/@type to set the Accept header of the resource when object/@data points to a remote resource, if @type is a valid MIME type (or looks like one), do one of:\n* Set Accept to object/@type directly\n* Use @type to craft a better Accept (with correct priorities) if @type is a subtyped MIME: @type='image/svg+xml' would yield the Accept 'image/svg+xml,image/*;q=0.9,*/*;q=0.8*'\n* Put the content of object/@type at the front of the Accept header\n\n\nAttached a Python script (compatible 2 & 3) which launches a very simple WSGI application via WSGIREF. Simply browse to http://localhost:8000, it will assert if the Accept header used when requesting a resource matches the @type of the object tag which linked to this resource, and will display the header's value in red if it does not.", "bug_id": 662169, "raw_text": "User-Agent:       Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.6; en; rv:1.9.0.19) Gecko/2011032020 Camino/2.0.7 (like Firefox/3.0.19)\nBuild Identifier: \n\nobject/@type is an optional attribute providing the MIME type of the content. When fetching a remote object and if @type is set (and a valid MIME type), Gecko should send it to the remote host.\n\nWhy:\nContent negotiation of multi-format resources, especially between textual and image formats\n\nUse case:\nI was working on a floor plan demo/API, and most of the floor plan resources were to be made available in a number of formats: an HTML page for details and sub-resources, a JSON for JS code and an image for visualization. I tried to use *object[@type='image/svg+xml']* so that the server side could just return the resource in the format clients liked most, in what I understand to be a RESTful manner.\n\n\nReproducible: Always\n\nSteps to Reproduce:\n1. Add an object tag to a remote resource with an @type set to a valid MIME type\n2. Check the Accept header for the resource\n\nActual Results:  \nGecko does not seem to care for @type, and always sends the same Accept header: 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'\n\n\nExpected Results:  \nGecko uses object/@type to set the Accept header of the resource when object/@data points to a remote resource, if @type is a valid MIME type (or looks like one), do one of:\n* Set Accept to object/@type directly\n* Use @type to craft a better Accept (with correct priorities) if @type is a subtyped MIME: @type='image/svg+xml' would yield the Accept 'image/svg+xml,image/*;q=0.9,*/*;q=0.8*'\n* Put the content of object/@type at the front of the Accept header\n\n\nAttached a Python script (compatible 2 & 3) which launches a very simple WSGI application via WSGIREF. Simply browse to http://localhost:8000, it will assert if the Accept header used when requesting a resource matches the @type of the object tag which linked to this resource, and will display the header's value in red if it does not.", "attachment_id": null}, {"raw_text": "", "attachment_id": 537462, "tags": [], "text": "Created attachment 537462\nShort WSGIREF script testing the MIME type sent by the browser when fetching a remote resource linked from an object tag", "bug_id": 662169, "id": 5514151, "count": 1, "is_private": false, "author": "bugzilla.org@masklinn.net", "time": "2011-06-05T17:40:33Z", "creation_time": "2011-06-05T17:40:33Z", "creator": "bugzilla.org@masklinn.net"}, {"id": 5515398, "count": 2, "is_private": false, "time": "2011-06-06T17:27:41Z", "creation_time": "2011-06-06T17:27:41Z", "creator": "bzbarsky@mit.edu", "author": "bzbarsky@mit.edu", "attachment_id": null, "raw_text": "The thing is... we in fact accept all types in <object>, as the header says.  The @type is advisory only; what we will do will depend on what type the server response with.\n\nSo changing the Accept header in the ways you describe would in fact be a spec violation (esp. in cases when we don't actually support the type in @type!).", "tags": [], "text": "The thing is... we in fact accept all types in <object>, as the header says.  The @type is advisory only; what we will do will depend on what type the server response with.\n\nSo changing the Accept header in the ways you describe would in fact be a spec violation (esp. in cases when we don't actually support the type in @type!).", "bug_id": 662169}, {"text": "(In reply to comment #2)\n> The thing is... we in fact accept all types in <object>, as the header says.\n> The @type is advisory only; what we will do will depend on what type the\n> server response with.\n> \n> So changing the Accept header in the ways you describe would in fact be a\n> spec violation\n\nI don't see why it would be a spec violation: the Accept header is mostly advisory (I don't know a single web server or framework in which it is binding), and the browser could just tack '*/*;q=0.5' at the end of it.\n\nThe only thing it would do would be providing higher-quality information to the server based on client data.\n\n> (esp. in cases when we don't actually support the type in @type!).\n\nthen the @type could just be dropped \u2014 or reverted to the current behavior \u2014 as if the value was not a valid MIME type. I don't really see why that would be an issue.", "bug_id": 662169, "tags": [], "raw_text": "(In reply to comment #2)\n> The thing is... we in fact accept all types in <object>, as the header says.\n> The @type is advisory only; what we will do will depend on what type the\n> server response with.\n> \n> So changing the Accept header in the ways you describe would in fact be a\n> spec violation\n\nI don't see why it would be a spec violation: the Accept header is mostly advisory (I don't know a single web server or framework in which it is binding), and the browser could just tack '*/*;q=0.5' at the end of it.\n\nThe only thing it would do would be providing higher-quality information to the server based on client data.\n\n> (esp. in cases when we don't actually support the type in @type!).\n\nthen the @type could just be dropped \u2014 or reverted to the current behavior \u2014 as if the value was not a valid MIME type. I don't really see why that would be an issue.", "attachment_id": null, "author": "bugzilla.org@masklinn.net", "creator": "bugzilla.org@masklinn.net", "time": "2011-06-06T19:12:40Z", "creation_time": "2011-06-06T19:12:40Z", "is_private": false, "id": 5515694, "count": 3}, {"is_private": false, "id": 11058494, "count": 4, "author": "bzbarsky@mit.edu", "creator": "bzbarsky@mit.edu", "creation_time": "2016-01-08T14:42:18Z", "time": "2016-01-08T14:42:18Z", "raw_text": "", "attachment_id": null, "text": "*** Bug 1232583 has been marked as a duplicate of this bug. ***", "bug_id": 662169, "tags": []}, {"creation_time": "2016-01-08T14:43:32Z", "time": "2016-01-08T14:43:32Z", "creator": "bzbarsky@mit.edu", "author": "bzbarsky@mit.edu", "count": 5, "id": 11058499, "is_private": false, "bug_id": 662169, "text": "Note that other browsers just send \"Accept: */*\" according to bug 1232583.  We could certainly do that, but the only good reason to do it is to save space in the HTTP request...", "tags": [], "attachment_id": null, "raw_text": "Note that other browsers just send \"Accept: */*\" according to bug 1232583.  We could certainly do that, but the only good reason to do it is to save space in the HTTP request..."}, {"bug_id": 662169, "text": "Bulk-downgrade of unassigned, >=3 years untouched DOM/Storage bug's priority.\n\nIf you have reason to believe this is wrong, please write a comment and ni :jstutte.", "tags": [], "raw_text": "Bulk-downgrade of unassigned, >=3 years untouched DOM/Storage bug's priority.\n\nIf you have reason to believe this is wrong, please write a comment and ni :jstutte.", "attachment_id": null, "author": "jstutte@mozilla.com", "creation_time": "2020-12-14T15:46:02Z", "time": "2020-12-14T15:46:02Z", "creator": "jstutte@mozilla.com", "id": 15174137, "count": 6, "is_private": false}]}}}