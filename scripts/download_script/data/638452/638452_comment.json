{"comments": {}, "bugs": {"638452": {"comments": [{"id": 5318777, "count": 0, "author": "bokowski@gmail.com", "time": "2011-03-03T16:23:25Z", "is_private": false, "text": "User-Agent:       Mozilla/5.0 (Macintosh; Intel Mac OS X 10.6; rv:2.0b12) Gecko/20100101 Firefox/4.0b12\nBuild Identifier: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.6; rv:2.0b12) Gecko/20100101 Firefox/4.0b12\n\nThe Orion project (http://wiki.eclipse.org/Orion) has a high-performance and scalable code editor. Unfortunately, it is performing significantly better on Safari and Chrome than it is on Firefox, with the end result that Orion developers and users are more likely to use these other browsers and not Firefox. We have a vested interest in Firefox because of our good relationship to the Firebug team - we've started to work on integration features between Orion and Firebug. It would be great if Firefox could become the best browser to use with Orion.\n\nReproducible: Always\n\nSteps to Reproduce:\n1. Go to http://orion.eclipse.org/editor/samples/demo.html\n2. Make sure your browser window is the same size for every browser (e.g. maximized to the full screen).\n3. Click on the \"JavaScript file\" button to load the editor with sample content\n4. Click on the \"PageDown Scroll\" button each time you want to run a timed test. The other buttons test other things, but the PageDown test is a good representative.\nActual Results:  \nHere are results from running the \"PageDown Scroll\" test repeatedly on different browsers, roughly sorted from fastest to slowest. I used my MacBook Pro i5, with a screen size of 1680x1050, and each browser was maximized to fill the entire screen.\n\nChrome 9.0.597.107\ntime(page down)=6461\ntime(page down)=7063\ntime(page down)=4335\ntime(page down)=2678\ntime(page down)=3145\ntime(page down)=3146\ntime(page down)=2633\ntime(page down)=2956\ntime(page down)=3306\ntime(page down)=2721\n\nSafari 5.0.3\ntime(page down)=6826\ntime(page down)=6482\ntime(page down)=4067\ntime(page down)=4023\ntime(page down)=3878\ntime(page down)=3932\ntime(page down)=4001\ntime(page down)=3958\ntime(page down)=3954\ntime(page down)=4059\ntime(page down)=4018\n\nFF 4.0b10\ntime(page down)=5561\ntime(page down)=6032\ntime(page down)=5390\ntime(page down)=5459\ntime(page down)=5661\ntime(page down)=6037\ntime(page down)=5359\ntime(page down)=5360\ntime(page down)=6270\ntime(page down)=5380\n\nFF4.0b12\ntime(page down)=5853\ntime(page down)=5579\ntime(page down)=5852\ntime(page down)=5674\ntime(page down)=5844\ntime(page down)=5871\ntime(page down)=5829\ntime(page down)=5621\ntime(page down)=5689\ntime(page down)=5802\n\nOpera 11.01\ntime(page down)=7334\ntime(page down)=7278\ntime(page down)=7240\ntime(page down)=7253\ntime(page down)=7198\ntime(page down)=7226\ntime(page down)=7308\ntime(page down)=7304\n\nFF 3.6.13\ntime(page down)=7631\ntime(page down)=7437\ntime(page down)=9253\ntime(page down)=8722\ntime(page down)=7507\ntime(page down)=8840\ntime(page down)=8590\ntime(page down)=7742\ntime(page down)=7430\n\n\nExpected Results:  \nPlease help us get close to the Safari and Chrome numbers!\n\nIt is of course possible that the Orion editor is doing things that slow it down on Firefox but not on WebKit browsers. Incidentally, the JavaScript example file that you load in step 3 is the source code of the Orion editor. If you spot anything that we could do on our side, please let us know.\n\nI do realize that this is not a micro-benchmark that is easy to optimize for. Instead, it is an example of a real-world load and I don't expect any easy wins. But better to file a bug than remain silent about it.\n\nThe numbers above are from running the test on Snow Leopard. We see similar differences on the other platforms (Linux, Windows).", "bug_id": 638452, "creator": "bokowski@gmail.com", "raw_text": "User-Agent:       Mozilla/5.0 (Macintosh; Intel Mac OS X 10.6; rv:2.0b12) Gecko/20100101 Firefox/4.0b12\nBuild Identifier: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.6; rv:2.0b12) Gecko/20100101 Firefox/4.0b12\n\nThe Orion project (http://wiki.eclipse.org/Orion) has a high-performance and scalable code editor. Unfortunately, it is performing significantly better on Safari and Chrome than it is on Firefox, with the end result that Orion developers and users are more likely to use these other browsers and not Firefox. We have a vested interest in Firefox because of our good relationship to the Firebug team - we've started to work on integration features between Orion and Firebug. It would be great if Firefox could become the best browser to use with Orion.\n\nReproducible: Always\n\nSteps to Reproduce:\n1. Go to http://orion.eclipse.org/editor/samples/demo.html\n2. Make sure your browser window is the same size for every browser (e.g. maximized to the full screen).\n3. Click on the \"JavaScript file\" button to load the editor with sample content\n4. Click on the \"PageDown Scroll\" button each time you want to run a timed test. The other buttons test other things, but the PageDown test is a good representative.\nActual Results:  \nHere are results from running the \"PageDown Scroll\" test repeatedly on different browsers, roughly sorted from fastest to slowest. I used my MacBook Pro i5, with a screen size of 1680x1050, and each browser was maximized to fill the entire screen.\n\nChrome 9.0.597.107\ntime(page down)=6461\ntime(page down)=7063\ntime(page down)=4335\ntime(page down)=2678\ntime(page down)=3145\ntime(page down)=3146\ntime(page down)=2633\ntime(page down)=2956\ntime(page down)=3306\ntime(page down)=2721\n\nSafari 5.0.3\ntime(page down)=6826\ntime(page down)=6482\ntime(page down)=4067\ntime(page down)=4023\ntime(page down)=3878\ntime(page down)=3932\ntime(page down)=4001\ntime(page down)=3958\ntime(page down)=3954\ntime(page down)=4059\ntime(page down)=4018\n\nFF 4.0b10\ntime(page down)=5561\ntime(page down)=6032\ntime(page down)=5390\ntime(page down)=5459\ntime(page down)=5661\ntime(page down)=6037\ntime(page down)=5359\ntime(page down)=5360\ntime(page down)=6270\ntime(page down)=5380\n\nFF4.0b12\ntime(page down)=5853\ntime(page down)=5579\ntime(page down)=5852\ntime(page down)=5674\ntime(page down)=5844\ntime(page down)=5871\ntime(page down)=5829\ntime(page down)=5621\ntime(page down)=5689\ntime(page down)=5802\n\nOpera 11.01\ntime(page down)=7334\ntime(page down)=7278\ntime(page down)=7240\ntime(page down)=7253\ntime(page down)=7198\ntime(page down)=7226\ntime(page down)=7308\ntime(page down)=7304\n\nFF 3.6.13\ntime(page down)=7631\ntime(page down)=7437\ntime(page down)=9253\ntime(page down)=8722\ntime(page down)=7507\ntime(page down)=8840\ntime(page down)=8590\ntime(page down)=7742\ntime(page down)=7430\n\n\nExpected Results:  \nPlease help us get close to the Safari and Chrome numbers!\n\nIt is of course possible that the Orion editor is doing things that slow it down on Firefox but not on WebKit browsers. Incidentally, the JavaScript example file that you load in step 3 is the source code of the Orion editor. If you spot anything that we could do on our side, please let us know.\n\nI do realize that this is not a micro-benchmark that is easy to optimize for. Instead, it is an example of a real-world load and I don't expect any easy wins. But better to file a bug than remain silent about it.\n\nThe numbers above are from running the test on Snow Leopard. We see similar differences on the other platforms (Linux, Windows).", "attachment_id": null, "creation_time": "2011-03-03T16:23:25Z", "tags": []}, {"is_private": false, "time": "2011-03-04T20:24:47Z", "author": "bzbarsky@mit.edu", "count": 1, "id": 5322577, "creation_time": "2011-03-04T20:24:47Z", "tags": [], "attachment_id": null, "raw_text": "Thanks for the testcase.\n\nI tossed some beginProfiling()/endProfiling() in there and profiled on Mac.  Short summary:\n\n  20% of the time is painting (half is painting text; the rest is backgrounds,\n      GL stuff, borders).\n   7% is reflow triggered from WillPaint.\n   2% is restyles triggered from WillPaint\n   3% event loop stuff\n  13% removeChild handling calls.  The issue here is not that there's a\n      particular removeChild we're slow to handle, but that there are a _lot_ of\n      these, based on the profile data I'm seeing.\n   6% layout triggered by getting scrollWidth\n   8% insertBefore calls (again, a _lot_ of them).\n   2% innerHTML sets\n   2% setting inline style\n   2% createElement calls\n  13% layout triggered from getBoundingClientRect.\n\nThere's a pretty big long tail, but those are the major bits.\n\nSo obvious questions are:\n\n1)  What are all these node insertions and removals?\n2)  Why are there several callsites triggering layout (basically breaking our\n    reflow coalescing by forcing layout at random points instead of when we\n    actually need to update what the user sees).", "creator": "bzbarsky@mit.edu", "bug_id": 638452, "text": "Thanks for the testcase.\n\nI tossed some beginProfiling()/endProfiling() in there and profiled on Mac.  Short summary:\n\n  20% of the time is painting (half is painting text; the rest is backgrounds,\n      GL stuff, borders).\n   7% is reflow triggered from WillPaint.\n   2% is restyles triggered from WillPaint\n   3% event loop stuff\n  13% removeChild handling calls.  The issue here is not that there's a\n      particular removeChild we're slow to handle, but that there are a _lot_ of\n      these, based on the profile data I'm seeing.\n   6% layout triggered by getting scrollWidth\n   8% insertBefore calls (again, a _lot_ of them).\n   2% innerHTML sets\n   2% setting inline style\n   2% createElement calls\n  13% layout triggered from getBoundingClientRect.\n\nThere's a pretty big long tail, but those are the major bits.\n\nSo obvious questions are:\n\n1)  What are all these node insertions and removals?\n2)  Why are there several callsites triggering layout (basically breaking our\n    reflow coalescing by forcing layout at random points instead of when we\n    actually need to update what the user sees)."}, {"text": "Oh, and there are things on our end that we can do to make things like the reflow here faster, but based on the above profile it looks like this code could be faster in _all_ browsers.", "creator": "bzbarsky@mit.edu", "raw_text": "Oh, and there are things on our end that we can do to make things like the reflow here faster, but based on the above profile it looks like this code could be faster in _all_ browsers.", "count": 2, "time": "2011-03-04T20:26:46Z", "bug_id": 638452, "attachment_id": null, "creation_time": "2011-03-04T20:26:46Z", "tags": [], "id": 5322581, "author": "bzbarsky@mit.edu", "is_private": false}, {"bug_id": 638452, "text": "OK, so I dunno about the insert/remove stuff yet, but for the layout flushes, we have code sorta like this (lots of stuff ripped out):\n\n  _getScroll: function() {\n    var editorDiv = this._editorDiv;\n    return {x: editorDiv.scrollLeft, y: editorDiv.scrollTop};\n  },\n  _handleScroll: function () {\n    var scroll = this._getScroll ();\n    // etc\n  },\n  _doPageDown: function() {\n    var verticalScrollOffset = this._getScroll().y;\n    this._scrollView(0, something);\n  },\n  _scrollView: function (pixelX, pixelY) {\n    this._editorDiv.scrollLeft += pixelX;\n    this._editorDiv.scrollTop += pixelY;\n    this._handleScroll();\n  },\n\nSo in _doPageDown we flush out layout, then we call _scrollView which flushes _again_ (getting scroll*) and changes scroll positions and then calls _handleScroll which also flushes layout.  You might get some mileage out of passing the x/y to _handleScroll, since the caller in this case actually has them.\n\nThat said, roc, can we somehow optimize the reflow we end up doing on scroll* changes?  :(\n\nFor at least some of the bounding client rect stuff and DOM-munging, the issue is presumably that _getBoundsAtOffset removes the existing child of the line, creates a text node and a span and sticks them in the DOM and then flushes out layout and then blows them away and puts back the original textnode.  This is called from _getOffsetToX in _doPageDown.  Also, _getXToOffset causes similar issues.\n\nKeep in mind that if you modify the DOM and then ask for the size of the new nodes you added, then _all_ the layout for the page has to be updated, in general.  So this \"insert into the DOM and then measure\" pattern is very expensive....", "attachment_id": null, "creation_time": "2011-03-04T20:48:06Z", "tags": [], "creator": "bzbarsky@mit.edu", "raw_text": "OK, so I dunno about the insert/remove stuff yet, but for the layout flushes, we have code sorta like this (lots of stuff ripped out):\n\n  _getScroll: function() {\n    var editorDiv = this._editorDiv;\n    return {x: editorDiv.scrollLeft, y: editorDiv.scrollTop};\n  },\n  _handleScroll: function () {\n    var scroll = this._getScroll ();\n    // etc\n  },\n  _doPageDown: function() {\n    var verticalScrollOffset = this._getScroll().y;\n    this._scrollView(0, something);\n  },\n  _scrollView: function (pixelX, pixelY) {\n    this._editorDiv.scrollLeft += pixelX;\n    this._editorDiv.scrollTop += pixelY;\n    this._handleScroll();\n  },\n\nSo in _doPageDown we flush out layout, then we call _scrollView which flushes _again_ (getting scroll*) and changes scroll positions and then calls _handleScroll which also flushes layout.  You might get some mileage out of passing the x/y to _handleScroll, since the caller in this case actually has them.\n\nThat said, roc, can we somehow optimize the reflow we end up doing on scroll* changes?  :(\n\nFor at least some of the bounding client rect stuff and DOM-munging, the issue is presumably that _getBoundsAtOffset removes the existing child of the line, creates a text node and a span and sticks them in the DOM and then flushes out layout and then blows them away and puts back the original textnode.  This is called from _getOffsetToX in _doPageDown.  Also, _getXToOffset causes similar issues.\n\nKeep in mind that if you modify the DOM and then ask for the size of the new nodes you added, then _all_ the layout for the page has to be updated, in general.  So this \"insert into the DOM and then measure\" pattern is very expensive....", "id": 5322624, "is_private": false, "count": 3, "author": "bzbarsky@mit.edu", "time": "2011-03-04T20:48:06Z"}, {"raw_text": "Thanks for looking at this already! Silenio, I hope you can respond to the comments after the weekend.", "creator": "bokowski@gmail.com", "text": "Thanks for looking at this already! Silenio, I hope you can respond to the comments after the weekend.", "time": "2011-03-04T22:22:42Z", "count": 4, "tags": [], "creation_time": "2011-03-04T22:22:42Z", "attachment_id": null, "bug_id": 638452, "is_private": false, "author": "bokowski@gmail.com", "id": 5322846}, {"id": 5323542, "time": "2011-03-05T04:14:56Z", "author": "roc@ocallahan.org", "count": 5, "is_private": false, "text": "(In reply to comment #3)\n> That said, roc, can we somehow optimize the reflow we end up doing on scroll*\n> changes?  :(\n\nThat shouldn't be dirtying any frames except possibly for scrollbar thumbs or something. Is that what you're seeing?\n\nIf the DOM munging and getBoundingClientRect is trying to measure offsets within a textnode, maybe the code should be using Range.getBoundingClientRect instead?", "bug_id": 638452, "raw_text": "(In reply to comment #3)\n> That said, roc, can we somehow optimize the reflow we end up doing on scroll*\n> changes?  :(\n\nThat shouldn't be dirtying any frames except possibly for scrollbar thumbs or something. Is that what you're seeing?\n\nIf the DOM munging and getBoundingClientRect is trying to measure offsets within a textnode, maybe the code should be using Range.getBoundingClientRect instead?", "creator": "roc@ocallahan.org", "creation_time": "2011-03-05T04:14:56Z", "tags": [], "attachment_id": null}, {"time": "2011-03-05T04:25:43Z", "author": "bzbarsky@mit.edu", "count": 6, "is_private": false, "id": 5323563, "raw_text": "> Is that what you're seeing?\n\nI'm not sure yet.  For one thing, since I made that comment I've decided that I have no idea which parts of the reflow are caused by the scroll and which by the DOM munging.  Disentangling the two will be a good start.", "creator": "bzbarsky@mit.edu", "tags": [], "creation_time": "2011-03-05T04:25:43Z", "attachment_id": null, "text": "> Is that what you're seeing?\n\nI'm not sure yet.  For one thing, since I made that comment I've decided that I have no idea which parts of the reflow are caused by the scroll and which by the DOM munging.  Disentangling the two will be a good start.", "bug_id": 638452}, {"attachment_id": null, "creation_time": "2011-03-05T04:42:13Z", "tags": [], "creator": "roc@ocallahan.org", "raw_text": "See who's calling mDirtyRoots.AppendElement I guess...", "bug_id": 638452, "text": "See who's calling mDirtyRoots.AppendElement I guess...", "is_private": false, "count": 7, "time": "2011-03-05T04:42:13Z", "author": "roc@ocallahan.org", "id": 5323578}, {"time": "2011-03-05T21:21:52Z", "count": 8, "raw_text": "(In reply to comment #1)\n> 1)  What are all these node insertions and removals?\n> 2)  Why are there several callsites triggering layout (basically breaking our\n>     reflow coalescing by forcing layout at random points instead of when we\n>     actually need to update what the user sees).\n\nThe editor strategy is to create only the visible lines of the content in the DOM. This is done for several reasons, but the main reason is scalibity (been able to show huge content). As the editor scrolls, it removes the lines that were previously visible and add the new visible lines.\n\nIs beginProfiling()/endProfiling() some internal tool? Am I able to use it?\n\n(In reply to comment #3)\n> So in _doPageDown we flush out layout, then we call _scrollView which flushes\n> _again_ (getting scroll*) and changes scroll positions and then calls\n> _handleScroll which also flushes layout.  You might get some mileage out of\n> passing the x/y to _handleScroll, since the caller in this case actually has\n> them.\n> \n> That said, roc, can we somehow optimize the reflow we end up doing on scroll*\n> changes?  :(\n\nGood catch. I released changes to avoid the extra _getScroll() in this specific case. Unfortunately the improvement is not very significant.\n\n> \n> For at least some of the bounding client rect stuff and DOM-munging, the issue\n> is presumably that _getBoundsAtOffset removes the existing child of the line,\n> creates a text node and a span and sticks them in the DOM and then flushes out\n> layout and then blows them away and puts back the original textnode.  This is\n> called from _getOffsetToX in _doPageDown.  Also, _getXToOffset causes similar\n> issues.\n> \n> Keep in mind that if you modify the DOM and then ask for the size of the new\n> nodes you added, then _all_ the layout for the page has to be updated, in\n> general.  So this \"insert into the DOM and then measure\" pattern is very\n> expensive....\n\n\nIn these scrolling benchmarks, _getOffsetToX() is called only once and _getXToOffset() is called once per page/line down/up. Only _getXToOffset() matters. I changed _getXToOffset() to return the first offset of the line without doing any work (see below). This would be the perfect situation. The improvement varies between 0% and 5%. From 7950ms to 7450ms for the best case. I believe it is worth investigating a different strategy to do hit testing, but these benchmarks would still be quite slower compared to Chrome (5050ms). One idea we have is to perform all measurements in a serapate IFRAME so that we would not have to modify the DOM and then put back the original text node. The DOM of the separate IFRAME would be smaller as well (probably just one DIV (line)) which in theory would mean faster reflows. We still have to experiment with this.\n\nIdeally, it would be great if Firefox provided API similar to IE which makes it possible to measure a text range. This would avoid modifying the DOM at all when performance hit testing.\n\n...\n_getXToOffset_FF: function (lineIndex, x) {\n\tvar model = this._model;\n\tif (true) return model.getLineStart(lineIndex);\n...\n\nImproving hit testing is certainly desirable, but I believe it will not improve these benchmarks. The code that needs attention is updatePage() where all the lines are added/removed to/from the DOM.\n\nIt would be interesting to know how many reflows are performed per page down. Does the profiling tool show this info?", "creator": "silenio_quarti@ca.ibm.com", "text": "(In reply to comment #1)\n> 1)  What are all these node insertions and removals?\n> 2)  Why are there several callsites triggering layout (basically breaking our\n>     reflow coalescing by forcing layout at random points instead of when we\n>     actually need to update what the user sees).\n\nThe editor strategy is to create only the visible lines of the content in the DOM. This is done for several reasons, but the main reason is scalibity (been able to show huge content). As the editor scrolls, it removes the lines that were previously visible and add the new visible lines.\n\nIs beginProfiling()/endProfiling() some internal tool? Am I able to use it?\n\n(In reply to comment #3)\n> So in _doPageDown we flush out layout, then we call _scrollView which flushes\n> _again_ (getting scroll*) and changes scroll positions and then calls\n> _handleScroll which also flushes layout.  You might get some mileage out of\n> passing the x/y to _handleScroll, since the caller in this case actually has\n> them.\n> \n> That said, roc, can we somehow optimize the reflow we end up doing on scroll*\n> changes?  :(\n\nGood catch. I released changes to avoid the extra _getScroll() in this specific case. Unfortunately the improvement is not very significant.\n\n> \n> For at least some of the bounding client rect stuff and DOM-munging, the issue\n> is presumably that _getBoundsAtOffset removes the existing child of the line,\n> creates a text node and a span and sticks them in the DOM and then flushes out\n> layout and then blows them away and puts back the original textnode.  This is\n> called from _getOffsetToX in _doPageDown.  Also, _getXToOffset causes similar\n> issues.\n> \n> Keep in mind that if you modify the DOM and then ask for the size of the new\n> nodes you added, then _all_ the layout for the page has to be updated, in\n> general.  So this \"insert into the DOM and then measure\" pattern is very\n> expensive....\n\n\nIn these scrolling benchmarks, _getOffsetToX() is called only once and _getXToOffset() is called once per page/line down/up. Only _getXToOffset() matters. I changed _getXToOffset() to return the first offset of the line without doing any work (see below). This would be the perfect situation. The improvement varies between 0% and 5%. From 7950ms to 7450ms for the best case. I believe it is worth investigating a different strategy to do hit testing, but these benchmarks would still be quite slower compared to Chrome (5050ms). One idea we have is to perform all measurements in a serapate IFRAME so that we would not have to modify the DOM and then put back the original text node. The DOM of the separate IFRAME would be smaller as well (probably just one DIV (line)) which in theory would mean faster reflows. We still have to experiment with this.\n\nIdeally, it would be great if Firefox provided API similar to IE which makes it possible to measure a text range. This would avoid modifying the DOM at all when performance hit testing.\n\n...\n_getXToOffset_FF: function (lineIndex, x) {\n\tvar model = this._model;\n\tif (true) return model.getLineStart(lineIndex);\n...\n\nImproving hit testing is certainly desirable, but I believe it will not improve these benchmarks. The code that needs attention is updatePage() where all the lines are added/removed to/from the DOM.\n\nIt would be interesting to know how many reflows are performed per page down. Does the profiling tool show this info?", "author": "silenio_quarti@ca.ibm.com", "is_private": false, "id": 5324361, "tags": [], "creation_time": "2011-03-05T21:21:52Z", "attachment_id": null, "bug_id": 638452}, {"is_private": false, "count": 9, "time": "2011-03-05T21:25:39Z", "author": "silenio_quarti@ca.ibm.com", "id": 5324366, "attachment_id": null, "tags": [], "creation_time": "2011-03-05T21:25:39Z", "creator": "silenio_quarti@ca.ibm.com", "raw_text": "(In reply to comment #5)\n> If the DOM munging and getBoundingClientRect is trying to measure offsets\n> within a textnode, maybe the code should be using Range.getBoundingClientRect\n> instead?\n\nYes, it is exactly doing that. Is Range.getBoundingClientRect available in Firefox 4? This API would certainly avoid a lot of our DOM munging. I will check...", "bug_id": 638452, "text": "(In reply to comment #5)\n> If the DOM munging and getBoundingClientRect is trying to measure offsets\n> within a textnode, maybe the code should be using Range.getBoundingClientRect\n> instead?\n\nYes, it is exactly doing that. Is Range.getBoundingClientRect available in Firefox 4? This API would certainly avoid a lot of our DOM munging. I will check..."}, {"count": 10, "time": "2011-03-05T23:04:45Z", "creator": "silenio_quarti@ca.ibm.com", "raw_text": "Answering my own question. Yes, Range.getBoundingClientRect is a available in Firefox 4 (latest chrome and opera as well). I released changes to use this API (if available) when performing hit testing instead of munging the DOM.  The performance improvement is around 2%. Thanks for pointing it out.", "text": "Answering my own question. Yes, Range.getBoundingClientRect is a available in Firefox 4 (latest chrome and opera as well). I released changes to use this API (if available) when performing hit testing instead of munging the DOM.  The performance improvement is around 2%. Thanks for pointing it out.", "is_private": false, "author": "silenio_quarti@ca.ibm.com", "id": 5324444, "attachment_id": null, "tags": [], "creation_time": "2011-03-05T23:04:45Z", "bug_id": 638452}, {"is_private": false, "time": "2011-03-07T19:00:00Z", "author": "bzbarsky@mit.edu", "count": 11, "id": 5327722, "tags": [], "creation_time": "2011-03-07T19:00:00Z", "attachment_id": null, "raw_text": "> As the editor scrolls, it removes the lines that\n> were previously visible and add the new visible lines.\n\nOK.  Have you considered doing that off a refresh observer instead of synchronously on scroll?  That might help things some...  Maybe.  Maybe not.  See below.\n\n> Is beginProfiling()/endProfiling() some internal tool? Am I able to use it?\n\nNot really, and if you have a Mac then yes.  Make sure you have Shark installed, download http://ftp.mozilla.org/pub/mozilla.org/firefox/nightly/latest-mozilla-central/firefox-4.0b13pre.en-US.mac-shark.dmg then start shark, put it in programmatic control mode, add startProfiling() and stopProfiling() (not begin and end as I said above) calls where you want to start and stop the profiler, and you get data about where time is spent.\n\nNow interpreting that data may take some work..  It's low-level profiling data for the C++ code involved, so you can see _where_ time is spent but usually not _why_ (because that information is in the JS).\n\n> Good catch. I released changes to avoid the extra _getScroll() in this\n> specific case. Unfortunately the improvement is not very significant.\n\nWell, nothing in the profile looks \"significant\" on its own.   There's no obvious hotspot.  There are a variety of several-percent wins that _could_ add up to something.\n\n> It would be interesting to know how many reflows are performed per page down.\n> Does the profiling tool show this info?\n\nNo, but it's pretty easy to measure this with some code changes.  The number is 47 for the demo as it appears today (on my setup the demo shows 42.3 lines of text in case that matters).\n\nWe do know that our incremental layout stuff is somewhat slower than Webkit, and we're working on that.  But in the meantime, reducing that 47 to, say, 1 might help some.  ;)", "creator": "bzbarsky@mit.edu", "bug_id": 638452, "text": "> As the editor scrolls, it removes the lines that\n> were previously visible and add the new visible lines.\n\nOK.  Have you considered doing that off a refresh observer instead of synchronously on scroll?  That might help things some...  Maybe.  Maybe not.  See below.\n\n> Is beginProfiling()/endProfiling() some internal tool? Am I able to use it?\n\nNot really, and if you have a Mac then yes.  Make sure you have Shark installed, download http://ftp.mozilla.org/pub/mozilla.org/firefox/nightly/latest-mozilla-central/firefox-4.0b13pre.en-US.mac-shark.dmg then start shark, put it in programmatic control mode, add startProfiling() and stopProfiling() (not begin and end as I said above) calls where you want to start and stop the profiler, and you get data about where time is spent.\n\nNow interpreting that data may take some work..  It's low-level profiling data for the C++ code involved, so you can see _where_ time is spent but usually not _why_ (because that information is in the JS).\n\n> Good catch. I released changes to avoid the extra _getScroll() in this\n> specific case. Unfortunately the improvement is not very significant.\n\nWell, nothing in the profile looks \"significant\" on its own.   There's no obvious hotspot.  There are a variety of several-percent wins that _could_ add up to something.\n\n> It would be interesting to know how many reflows are performed per page down.\n> Does the profiling tool show this info?\n\nNo, but it's pretty easy to measure this with some code changes.  The number is 47 for the demo as it appears today (on my setup the demo shows 42.3 lines of text in case that matters).\n\nWe do know that our incremental layout stuff is somewhat slower than Webkit, and we're working on that.  But in the meantime, reducing that 47 to, say, 1 might help some.  ;)"}, {"bug_id": 638452, "text": "Created attachment 517464\nPatch I used to measure reflows\n\nI applied this patch, then added a dump() call at the top of the |function t| callback in test_pageDownScrolling.\n\nI'll do a bit more looking into this on our end too.", "tags": [], "creation_time": "2011-03-07T19:03:20Z", "attachment_id": 517464, "raw_text": "I applied this patch, then added a dump() call at the top of the |function t| callback in test_pageDownScrolling.\n\nI'll do a bit more looking into this on our end too.", "creator": "bzbarsky@mit.edu", "id": 5327730, "is_private": false, "author": "bzbarsky@mit.edu", "time": "2011-03-07T19:03:20Z", "count": 12}, {"is_private": false, "count": 13, "author": "bzbarsky@mit.edu", "time": "2011-03-07T20:10:15Z", "id": 5327963, "attachment_id": null, "creation_time": "2011-03-07T20:10:15Z", "tags": [], "creator": "bzbarsky@mit.edu", "raw_text": "Looking at the data a bit more, layout is 26% of the time.  So reducing the number of reflows will help by at most 26%.\n\nThe other big obvious things are removeChild at 12-13% and insertBefore about 9%.\n\nFor the removeChild, about 2/3 if the time is the invalidations it does.  Another 20% is the actual frame destruction.  It looks like there's a separate block for each line here or something?\n\nFor the insertBefore, there's some time spent in AdoptNode (why?  Aren't the nodes being created in the right document?), and some time spent doing eager frame construction (because we're in an editor)....\n\nNo obvious ways to win there on the part of the page other than eliminating the adoptNode bit (!-2% of total time) and possibly not being as eager to create nodes (see comment 11).\n\nAgain, there are a bunch of things we have in the pipeline on our end that will help with some of that stuff (e.g. the invalidation bit), but that doesn't help you guys.", "bug_id": 638452, "text": "Looking at the data a bit more, layout is 26% of the time.  So reducing the number of reflows will help by at most 26%.\n\nThe other big obvious things are removeChild at 12-13% and insertBefore about 9%.\n\nFor the removeChild, about 2/3 if the time is the invalidations it does.  Another 20% is the actual frame destruction.  It looks like there's a separate block for each line here or something?\n\nFor the insertBefore, there's some time spent in AdoptNode (why?  Aren't the nodes being created in the right document?), and some time spent doing eager frame construction (because we're in an editor)....\n\nNo obvious ways to win there on the part of the page other than eliminating the adoptNode bit (!-2% of total time) and possibly not being as eager to create nodes (see comment 11).\n\nAgain, there are a bunch of things we have in the pipeline on our end that will help with some of that stuff (e.g. the invalidation bit), but that doesn't help you guys."}, {"count": 14, "time": "2011-03-09T20:13:25Z", "author": "silenio_quarti@ca.ibm.com", "is_private": false, "id": 5333931, "creator": "silenio_quarti@ca.ibm.com", "raw_text": "(In reply to comment #11)\n> OK.  Have you considered doing that off a refresh observer instead of\n> synchronously on scroll?  That might help things some...  Maybe.  Maybe not. \n> See below.\n> \n\nI am not sure what the refresh observers are (?).  I experimented making scrolling not synchronous in scrollView() by just not calling _doScroll() and letting the _handleScroll() be called from \"scroll\" event handler only.  I did not see any improvements in this specific bench.\n\n\n> Not really, and if you have a Mac then yes.  Make sure you have Shark\n> installed, download\n> http://ftp.mozilla.org/pub/mozilla.org/firefox/nightly/latest-mozilla-central/firefox-4.0b13pre.en-US.mac-shark.dmg\n> then start shark, put it in programmatic control mode, add startProfiling() and\n> stopProfiling() (not begin and end as I said above) calls where you want to\n> start and stop the profiler, and you get data about where time is spent.\n> \n> Now interpreting that data may take some work..  It's low-level profiling data\n> for the C++ code involved, so you can see _where_ time is spent but usually not\n> _why_ (because that information is in the JS).\n\n\nThanks for the instructions. Got this setup going. Interpreting to data is quite hard for me given that I am not familiar with the mozilla internals.\n\n\n(In reply to comment #13)\n> Looking at the data a bit more, layout is 26% of the time.  So reducing the\n> number of reflows will help by at most 26%.\n> \n> The other big obvious things are removeChild at 12-13% and insertBefore about\n> 9%.\n> \n> For the removeChild, about 2/3 if the time is the invalidations it does. \n> Another 20% is the actual frame destruction.  It looks like there's a separate\n> block for each line here or something?\n\nThat is it. Every line is one DIV with one or more SPAN as children.\n\n> \n> For the insertBefore, there's some time spent in AdoptNode (why?  Aren't the\n> nodes being created in the right document?), and some time spent doing eager\n> frame construction (because we're in an editor)....\n>\n> No obvious ways to win there on the part of the page other than eliminating the\n> adoptNode bit (!-2% of total time) and possibly not being as eager to create\n> nodes (see comment 11).\n\nI found a couple of places we were using the wrong document. It should be fixed now.  The improvement as you said is around 2%. Thanks!", "attachment_id": null, "tags": [], "creation_time": "2011-03-09T20:13:25Z", "text": "(In reply to comment #11)\n> OK.  Have you considered doing that off a refresh observer instead of\n> synchronously on scroll?  That might help things some...  Maybe.  Maybe not. \n> See below.\n> \n\nI am not sure what the refresh observers are (?).  I experimented making scrolling not synchronous in scrollView() by just not calling _doScroll() and letting the _handleScroll() be called from \"scroll\" event handler only.  I did not see any improvements in this specific bench.\n\n\n> Not really, and if you have a Mac then yes.  Make sure you have Shark\n> installed, download\n> http://ftp.mozilla.org/pub/mozilla.org/firefox/nightly/latest-mozilla-central/firefox-4.0b13pre.en-US.mac-shark.dmg\n> then start shark, put it in programmatic control mode, add startProfiling() and\n> stopProfiling() (not begin and end as I said above) calls where you want to\n> start and stop the profiler, and you get data about where time is spent.\n> \n> Now interpreting that data may take some work..  It's low-level profiling data\n> for the C++ code involved, so you can see _where_ time is spent but usually not\n> _why_ (because that information is in the JS).\n\n\nThanks for the instructions. Got this setup going. Interpreting to data is quite hard for me given that I am not familiar with the mozilla internals.\n\n\n(In reply to comment #13)\n> Looking at the data a bit more, layout is 26% of the time.  So reducing the\n> number of reflows will help by at most 26%.\n> \n> The other big obvious things are removeChild at 12-13% and insertBefore about\n> 9%.\n> \n> For the removeChild, about 2/3 if the time is the invalidations it does. \n> Another 20% is the actual frame destruction.  It looks like there's a separate\n> block for each line here or something?\n\nThat is it. Every line is one DIV with one or more SPAN as children.\n\n> \n> For the insertBefore, there's some time spent in AdoptNode (why?  Aren't the\n> nodes being created in the right document?), and some time spent doing eager\n> frame construction (because we're in an editor)....\n>\n> No obvious ways to win there on the part of the page other than eliminating the\n> adoptNode bit (!-2% of total time) and possibly not being as eager to create\n> nodes (see comment 11).\n\nI found a couple of places we were using the wrong document. It should be fixed now.  The improvement as you said is around 2%. Thanks!", "bug_id": 638452}, {"text": "Instead of removing many nodes or inserting many nodes one at a time, you could use a DOM range to select the entire range of elements you want to remove, then remove them in one call to deleteContents. And you could use a document fragment to collect all the nodes you want to insert and insert them all at once:\nhttps://developer.mozilla.org/en/DOM/range.deleteContents\nhttps://developer.mozilla.org/en/DOM/document.createDocumentFragment\n\nThis would probably make your editor faster in all browsers, but that's not a bad thing, right? :-)", "creator": "roc@ocallahan.org", "raw_text": "Instead of removing many nodes or inserting many nodes one at a time, you could use a DOM range to select the entire range of elements you want to remove, then remove them in one call to deleteContents. And you could use a document fragment to collect all the nodes you want to insert and insert them all at once:\nhttps://developer.mozilla.org/en/DOM/range.deleteContents\nhttps://developer.mozilla.org/en/DOM/document.createDocumentFragment\n\nThis would probably make your editor faster in all browsers, but that's not a bad thing, right? :-)", "count": 15, "time": "2011-03-10T00:06:33Z", "bug_id": 638452, "attachment_id": null, "tags": [], "creation_time": "2011-03-10T00:06:33Z", "id": 5334722, "is_private": false, "author": "roc@ocallahan.org"}, {"count": 16, "time": "2011-03-10T05:17:37Z", "creator": "bzbarsky@mit.edu", "raw_text": "> I am not sure what the refresh observers are\n\nhttp://weblogs.mozillazine.org/roc/archives/2010/08/mozrequestanima.html\n\nAs I said, it may well not help.\n\nIt really looks like the things that will help on our end are possibly painting less, faster invalidation simpler block data structures that cost less to create and tear down.\n\nI'm not sure what else you can do on your end at the moment, apart from trying comment 15.", "text": "> I am not sure what the refresh observers are\n\nhttp://weblogs.mozillazine.org/roc/archives/2010/08/mozrequestanima.html\n\nAs I said, it may well not help.\n\nIt really looks like the things that will help on our end are possibly painting less, faster invalidation simpler block data structures that cost less to create and tear down.\n\nI'm not sure what else you can do on your end at the moment, apart from trying comment 15.", "author": "bzbarsky@mit.edu", "is_private": false, "id": 5335210, "attachment_id": null, "creation_time": "2011-03-10T05:17:37Z", "tags": [], "bug_id": 638452}, {"creator": "silenio_quarti@ca.ibm.com", "raw_text": "(In reply to comment #15)\n> Instead of removing many nodes or inserting many nodes one at a time, you\n> use a DOM range to select the entire range of elements you want to remove,\n> remove them in one call to deleteContents. And you could use a document\n> fragment to collect all the nodes you want to insert and insert them all at\n> once:\n> https://developer.mozilla.org/en/DOM/range.deleteContents\n> https://developer.mozilla.org/en/DOM/document.createDocumentFragment\n> This would probably make your editor faster in all browsers, but that's not a\n> bad thing, right? :-)\n\nWe had tried document.createDocumentFragment in the past and did not see much of an improvement.  I tried again last week and confirmed that.\n\nI still have not tried range.deleteContents.\n\nWhile trying createDocumentFragment, I had to rearrange the code which used to create one line, add the line the DOM and measure it. In order to take advantage of createDocumentFragment, I had to create consecutive lines adding to the fragment and measure these lines (getBoundingClientRect) after adding the fragment to the DOM.  This change actually made a difference on my WinXp, Window7 and Linux systems (around 13%).  Strange enough, it seems to made less of a difference on my Mac (around 4%). \n\nAs it stands, the scrolling bench on FF4 is comparable to Chrome/Opera on my WinXp. It still lags quite a bit on my Windows 7, Linux and Mac.", "attachment_id": null, "creation_time": "2011-03-21T17:04:22Z", "tags": [], "text": "(In reply to comment #15)\n> Instead of removing many nodes or inserting many nodes one at a time, you\n> use a DOM range to select the entire range of elements you want to remove,\n> remove them in one call to deleteContents. And you could use a document\n> fragment to collect all the nodes you want to insert and insert them all at\n> once:\n> https://developer.mozilla.org/en/DOM/range.deleteContents\n> https://developer.mozilla.org/en/DOM/document.createDocumentFragment\n> This would probably make your editor faster in all browsers, but that's not a\n> bad thing, right? :-)\n\nWe had tried document.createDocumentFragment in the past and did not see much of an improvement.  I tried again last week and confirmed that.\n\nI still have not tried range.deleteContents.\n\nWhile trying createDocumentFragment, I had to rearrange the code which used to create one line, add the line the DOM and measure it. In order to take advantage of createDocumentFragment, I had to create consecutive lines adding to the fragment and measure these lines (getBoundingClientRect) after adding the fragment to the DOM.  This change actually made a difference on my WinXp, Window7 and Linux systems (around 13%).  Strange enough, it seems to made less of a difference on my Mac (around 4%). \n\nAs it stands, the scrolling bench on FF4 is comparable to Chrome/Opera on my WinXp. It still lags quite a bit on my Windows 7, Linux and Mac.", "bug_id": 638452, "count": 17, "time": "2011-03-21T17:04:22Z", "author": "silenio_quarti@ca.ibm.com", "is_private": false, "id": 5357454}, {"attachment_id": null, "tags": [], "creation_time": "2011-07-27T17:38:33Z", "bug_id": 638452, "is_private": false, "author": "dzbarsky@gmail.com", "id": 5617048, "creator": "dzbarsky@gmail.com", "raw_text": "The testcase in comment 0 is now 404.", "text": "The testcase in comment 0 is now 404.", "count": 18, "time": "2011-07-27T17:38:33Z"}, {"count": 19, "time": "2011-07-27T18:01:40Z", "creator": "silenio_quarti@ca.ibm.com", "raw_text": "(In reply to comment #18)\n> The testcase in comment 0 is now 404.\n\nThis is the updated URL:\n\nhttp://orion.eclipse.org/examples/textview/demo.html", "text": "(In reply to comment #18)\n> The testcase in comment 0 is now 404.\n\nThis is the updated URL:\n\nhttp://orion.eclipse.org/examples/textview/demo.html", "author": "silenio_quarti@ca.ibm.com", "is_private": false, "id": 5617103, "attachment_id": null, "creation_time": "2011-07-27T18:01:40Z", "tags": [], "bug_id": 638452}, {"is_private": false, "time": "2011-09-15T05:18:23Z", "author": "bzbarsky@mit.edu", "count": 20, "id": 5718140, "tags": [], "creation_time": "2011-09-15T05:18:23Z", "attachment_id": null, "raw_text": "Nathan, this is the bug I was telling you about.", "creator": "bzbarsky@mit.edu", "bug_id": 638452, "text": "Nathan, this is the bug I was telling you about."}]}}}