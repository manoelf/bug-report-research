{"comments": {}, "bugs": {"698523": {"comments": [{"bug_id": 698523, "id": 5815783, "is_private": false, "count": 0, "tags": [], "time": "2011-10-31T18:33:22Z", "attachment_id": null, "text": "User Agent: Mozilla/5.0 (X11; Linux x86_64; rv:7.0) Gecko/20100101 Firefox/7.0\nBuild ID: 20110927153135\n\nSteps to reproduce:\n\nTrying to create multiple https connections to the same host and url with different username and passwords using xmlhttprequest.\n\nURI = https://exchange2010.example.com/EWS/Exchange.asmx\nusers:\n1. username = jane, domain=example, password=test1\n2. username = john, domain=example, password=test2\n3. username = karel, doman=example, password=test3\netc...\n\n\nActual results:\n\nThree connections are created but the are all authenticated with the first set of credentials because the first is stored in cache and for the following this entry is used because credentials are stored in the authcache based on shema, host, port and realm. The key is the same for all connections.\n\n\nExpected results:\n\nThe key for saving in cache should also contain the username or some other settable part.\n\nI get it to work when i specify a different hostname for the same ip-address for each connection. Because the key will be different then and for each set of credentials a new key is saved. But this is not workable because normal users cannot control this.", "creation_time": "2011-10-31T18:33:22Z", "raw_text": "User Agent: Mozilla/5.0 (X11; Linux x86_64; rv:7.0) Gecko/20100101 Firefox/7.0\nBuild ID: 20110927153135\n\nSteps to reproduce:\n\nTrying to create multiple https connections to the same host and url with different username and passwords using xmlhttprequest.\n\nURI = https://exchange2010.example.com/EWS/Exchange.asmx\nusers:\n1. username = jane, domain=example, password=test1\n2. username = john, domain=example, password=test2\n3. username = karel, doman=example, password=test3\netc...\n\n\nActual results:\n\nThree connections are created but the are all authenticated with the first set of credentials because the first is stored in cache and for the following this entry is used because credentials are stored in the authcache based on shema, host, port and realm. The key is the same for all connections.\n\n\nExpected results:\n\nThe key for saving in cache should also contain the username or some other settable part.\n\nI get it to work when i specify a different hostname for the same ip-address for each connection. Because the key will be different then and for each set of credentials a new key is saved. But this is not workable because normal users cannot control this.", "author": "info@1st-setup.nl", "creator": "info@1st-setup.nl"}, {"creator": "info@1st-setup.nl", "author": "info@1st-setup.nl", "bug_id": 698523, "tags": [], "count": 1, "is_private": false, "id": 5815800, "text": "The authentication credentials are stored in a hashtable which uses the scheme, host, port and realm as key to store the credentials. See following part in file \"nsHttpChannelAuthProvider.cpp\" method \"nsHttpChannelAuthProvider::GetCredentialsForChallenge\"\n\n    nsHttpAuthEntry *entry = nsnull;\n    authCache->GetAuthEntryForDomain(scheme.get(), host, port,\n                                     realm.get(), &entry);\n\nAfter this the check is done if the identity is valid. When not valid and NOT identFromURI and matching credentials from cache the specified credentials are replaced by the cached credentials.\n\nIn the case where we try to create three connections to the same server with different usernames it will always replace the specified credentials by the cached version.\n\n\n    // hold reference to the auth session state (in case we clear our\n    // reference to the entry).\n    nsCOMPtr<nsISupports> sessionStateGrip;\n    if (entry)\n        sessionStateGrip = entry->mMetaData;\n\n    // for digest auth, maybe our cached nonce value simply timed out...\n    PRBool identityInvalid;\n    nsISupports *sessionState = sessionStateGrip;\n    rv = auth->ChallengeReceived(mAuthChannel,\n                                 challenge,\n                                 proxyAuth,\n                                 &sessionState,\n                                 &*continuationState,\n                                 &identityInvalid);\n    sessionStateGrip.swap(sessionState);\n    if (NS_FAILED(rv)) return rv;\n\n    LOG((\"  identity invalid = %d\\n\", identityInvalid));\n\n    if (identityInvalid) {\n        if (entry) {\n            if (ident->Equals(entry->Identity())) {\n                LOG((\"  clearing bad auth cache entry\\n\"));\n                // ok, we've already tried this user identity, so clear the\n                // corresponding entry from the auth cache.\n                authCache->ClearAuthEntry(scheme.get(), host,\n                                          port, realm.get());\n                entry = nsnull;\n                ident->Clear();\n            }\n            else if (!identFromURI ||\n                     nsCRT::strcmp(ident->User(),\n                                   entry->Identity().User()) == 0) {\n                LOG((\"  taking identity from auth cache\\n\"));\n                // the password from the auth cache is more likely to be\n                // correct than the one in the URL.  at least, we know that it\n                // works with the given username.  it is possible for a server\n                // to distinguish logons based on the supplied password alone,\n                // but that would be quite unusual... and i don't think we need\n                // to worry about such unorthodox cases.\n                ident->Set(entry->Identity());\n                identFromURI = PR_FALSE;\n                if (entry->Creds()[0] != '\\0') {\n                    LOG((\"    using cached credentials!\\n\"));\n                    creds.Assign(entry->Creds());\n                    return entry->AddPath(path.get());\n                }\n            }\n        }\n        else if (!identFromURI) {\n            // hmm... identity invalid, but no auth entry!  the realm probably\n            // changed (see bug 201986).\n            ident->Clear();\n        }", "time": "2011-10-31T18:38:57Z", "attachment_id": null, "creation_time": "2011-10-31T18:38:57Z", "raw_text": "The authentication credentials are stored in a hashtable which uses the scheme, host, port and realm as key to store the credentials. See following part in file \"nsHttpChannelAuthProvider.cpp\" method \"nsHttpChannelAuthProvider::GetCredentialsForChallenge\"\n\n    nsHttpAuthEntry *entry = nsnull;\n    authCache->GetAuthEntryForDomain(scheme.get(), host, port,\n                                     realm.get(), &entry);\n\nAfter this the check is done if the identity is valid. When not valid and NOT identFromURI and matching credentials from cache the specified credentials are replaced by the cached credentials.\n\nIn the case where we try to create three connections to the same server with different usernames it will always replace the specified credentials by the cached version.\n\n\n    // hold reference to the auth session state (in case we clear our\n    // reference to the entry).\n    nsCOMPtr<nsISupports> sessionStateGrip;\n    if (entry)\n        sessionStateGrip = entry->mMetaData;\n\n    // for digest auth, maybe our cached nonce value simply timed out...\n    PRBool identityInvalid;\n    nsISupports *sessionState = sessionStateGrip;\n    rv = auth->ChallengeReceived(mAuthChannel,\n                                 challenge,\n                                 proxyAuth,\n                                 &sessionState,\n                                 &*continuationState,\n                                 &identityInvalid);\n    sessionStateGrip.swap(sessionState);\n    if (NS_FAILED(rv)) return rv;\n\n    LOG((\"  identity invalid = %d\\n\", identityInvalid));\n\n    if (identityInvalid) {\n        if (entry) {\n            if (ident->Equals(entry->Identity())) {\n                LOG((\"  clearing bad auth cache entry\\n\"));\n                // ok, we've already tried this user identity, so clear the\n                // corresponding entry from the auth cache.\n                authCache->ClearAuthEntry(scheme.get(), host,\n                                          port, realm.get());\n                entry = nsnull;\n                ident->Clear();\n            }\n            else if (!identFromURI ||\n                     nsCRT::strcmp(ident->User(),\n                                   entry->Identity().User()) == 0) {\n                LOG((\"  taking identity from auth cache\\n\"));\n                // the password from the auth cache is more likely to be\n                // correct than the one in the URL.  at least, we know that it\n                // works with the given username.  it is possible for a server\n                // to distinguish logons based on the supplied password alone,\n                // but that would be quite unusual... and i don't think we need\n                // to worry about such unorthodox cases.\n                ident->Set(entry->Identity());\n                identFromURI = PR_FALSE;\n                if (entry->Creds()[0] != '\\0') {\n                    LOG((\"    using cached credentials!\\n\"));\n                    creds.Assign(entry->Creds());\n                    return entry->AddPath(path.get());\n                }\n            }\n        }\n        else if (!identFromURI) {\n            // hmm... identity invalid, but no auth entry!  the realm probably\n            // changed (see bug 201986).\n            ident->Clear();\n        }"}, {"creation_time": "2017-09-13T18:41:07Z", "raw_text": "Bulk change to priority: https://bugzilla.mozilla.org/show_bug.cgi?id=1399258", "text": "Bulk change to priority: https://bugzilla.mozilla.org/show_bug.cgi?id=1399258", "creator": "bug-husbandry-bot@mozilla.bugs", "attachment_id": null, "time": "2017-09-13T18:41:07Z", "author": "bug-husbandry-bot@mozilla.bugs", "is_private": false, "count": 2, "tags": [], "id": 12659050, "bug_id": 698523}]}}}