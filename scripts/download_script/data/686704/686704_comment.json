{"comments": {}, "bugs": {"686704": {"comments": [{"creator": "gps@mozilla.com", "author": "gps@mozilla.com", "is_private": false, "count": 0, "tags": [], "id": 5717144, "bug_id": 686704, "creation_time": "2011-09-14T17:25:07Z", "raw_text": "The previous implementation of send tab to device (bug 676375) is using client commands to send URIs. After discussion, we want to support sending the tab context blob as part of the API.\n\nThis blob is quite sizable and may exceed the size limit on the clients engine. Not to mention it would be subverting the clients engine quite a bit. Discussion is leaning towards a new engine to support this. This bug tracks this new implementation, whatever it may be.\n\nWe also need to decide if we want to keep the old implementation around.", "text": "The previous implementation of send tab to device (bug 676375) is using client commands to send URIs. After discussion, we want to support sending the tab context blob as part of the API.\n\nThis blob is quite sizable and may exceed the size limit on the clients engine. Not to mention it would be subverting the clients engine quite a bit. Discussion is leaning towards a new engine to support this. This bug tracks this new implementation, whatever it may be.\n\nWe also need to decide if we want to keep the old implementation around.", "attachment_id": null, "time": "2011-09-14T17:25:07Z"}, {"bug_id": 686704, "id": 5717218, "is_private": false, "count": 1, "tags": [], "attachment_id": null, "time": "2011-09-14T17:52:13Z", "text": "(In reply to Gregory Szorc [:gps] from comment #0)\n> The previous implementation of send tab to device (bug 676375) is using\n> client commands to send URIs. After discussion, we want to support sending\n> the tab context blob as part of the API.\n\nYep, if by tab context you mean stuff like the session history and form data. We should probably come up with a data format for that because Firefox and Fennec use different formats for that already in session restore.\n\n> This blob is quite sizable and may exceed the size limit on the clients\n> engine.\n\nMaybe, with lots of form data, and/or lots of tabs being sent to a single device. A WBO record can be up to 256k, so we should see how much room we have.\n\nBut yes, perhaps a separate engine would be better.", "creation_time": "2011-09-14T17:52:13Z", "raw_text": "(In reply to Gregory Szorc [:gps] from comment #0)\n> The previous implementation of send tab to device (bug 676375) is using\n> client commands to send URIs. After discussion, we want to support sending\n> the tab context blob as part of the API.\n\nYep, if by tab context you mean stuff like the session history and form data. We should probably come up with a data format for that because Firefox and Fennec use different formats for that already in session restore.\n\n> This blob is quite sizable and may exceed the size limit on the clients\n> engine.\n\nMaybe, with lots of form data, and/or lots of tabs being sent to a single device. A WBO record can be up to 256k, so we should see how much room we have.\n\nBut yes, perhaps a separate engine would be better.", "author": "philipp@weitershausen.de", "creator": "philipp@weitershausen.de"}, {"author": "bugzilla@twinql.com", "creator": "bugzilla@twinql.com", "bug_id": 686704, "id": 5717677, "count": 2, "is_private": false, "tags": [], "attachment_id": null, "time": "2011-09-14T21:25:54Z", "text": "> But yes, perhaps a separate engine would be better.\n\nOr, for that matter, a combination of engine for storage and Clients for command pushing...", "creation_time": "2011-09-14T21:25:54Z", "raw_text": "> But yes, perhaps a separate engine would be better.\n\nOr, for that matter, a combination of engine for storage and Clients for command pushing..."}, {"count": 3, "is_private": false, "tags": [], "id": 5717913, "bug_id": 686704, "creation_time": "2011-09-14T23:34:09Z", "raw_text": "Recapping some IRC discussion:\n\nEngine == commands, just grab and parse new commands, discard stuff that doesn't match that client ID.\nAllows commands targeting multiple clients, and means clientID doesn't have to get exposed to the server.\nAlso means we can support infinite commands per client.", "creator": "mconnor@mozilla.com", "text": "Recapping some IRC discussion:\n\nEngine == commands, just grab and parse new commands, discard stuff that doesn't match that client ID.\nAllows commands targeting multiple clients, and means clientID doesn't have to get exposed to the server.\nAlso means we can support infinite commands per client.", "attachment_id": null, "time": "2011-09-14T23:34:09Z", "author": "mconnor@mozilla.com"}, {"creation_time": "2011-09-27T01:11:06Z", "raw_text": "Here is an untested and likely bug-ridden implementation of a new \"processRecord\" command API which stores record data in arbitrary collections. I included a very stub implementation of the APIs for sending tabs with state to give an idea how it works.\n\nThere are some obvious issues with the patch. The 'options' argument to sendProcessRecordCommand() is one thing that makes me cringe.\n\nI'm submitting for feedback on the concept of the new command and how the records are stored, transferred, etc. I know the patch is full of bugs and likely has syntax errors. So, please, no nits unless they are relatively high level.", "attachment_id": 562617, "time": "2011-09-27T01:11:06Z", "text": "Created attachment 562617\n\"processRecord\" command support, v0\n\nHere is an untested and likely bug-ridden implementation of a new \"processRecord\" command API which stores record data in arbitrary collections. I included a very stub implementation of the APIs for sending tabs with state to give an idea how it works.\n\nThere are some obvious issues with the patch. The 'options' argument to sendProcessRecordCommand() is one thing that makes me cringe.\n\nI'm submitting for feedback on the concept of the new command and how the records are stored, transferred, etc. I know the patch is full of bugs and likely has syntax errors. So, please, no nits unless they are relatively high level.", "id": 5738856, "tags": [], "count": 4, "is_private": false, "bug_id": 686704, "author": "gps@mozilla.com", "creator": "gps@mozilla.com"}, {"id": 5739413, "tags": [], "is_private": false, "count": 5, "bug_id": 686704, "raw_text": "Review of attachment 562617:\n-----------------------------------------------------------------\n\nNote that you can update the Bug XXXXXX and description now:\n\n  Bug 686704: Send Tab to Device - Support for session state\n\n---\nI gave detailed comments as I went through, just because Splinter makes it easy. Please don't interpret them as raining on your parade; just saving time later.\n---\n\nMore broadly:\n\n* You should have some tests to go along with this. There are a couple of syntax errors that implies that this code hasn't even been run, which is generally not a good sign. It's easier to start with 100% coverage and get worse over time than to go the other way!\n\n* The functionality you've added can be summarized as \"put a big fat command in a collection; add a small indirection 'load' command to the clients engine\". This seems to carry a gentle form of RPC semantics: you're instructing the client to pull down a command of arbitrary size and run it. That's quite possibly not a good idea: maybe I'm on a low-bandwidth connection? Perhaps I want to introspect the command before I decide if I want to spend the time to download and run it?\n\nI would suggest flipping this around a little. Have the big fat payload go to the collection, and put a real command, just as you did for your first draft of send-tab-to-device, into the clients engine. That command can refer to bigfatpayloads/someguid. You can still generalize the command with some kind of dispatch semantics if you want (e.g., specify an engine and a command name, so we don't end up with a switch statement in the clients engine), but don't force a download before the command can be examined.\n\nDoing it this way allows, say, Fennec to prompt the user:\n\n  Open <some slashdot URI> sent from Greg's Desktop?\n\nbefore downloading the whole tab state payload. The command could even refer to multiple blobs, if you someday go over the 256KB limit:\n\n  {engine: \"tabs\",\n   command: \"open\",\n   tabstate: \"tabstates/abcdefghijkl\",\n   localstorage: \"localstorage/foobarbaznoo\"}\n\nThis approach also opens up interesting possibilities, such as sending different page-processing commands to different device types (Read It Later vs open now, for example) whilst preserving the same state object.\n\nThoughts?\n\n::: services/sync/modules/engines/clients.js\n@@ +52,5 @@\n>  \n>  const CLIENTS_TTL = 1814400; // 21 days\n>  const CLIENTS_TTL_REFRESH = 604800; // 7 days\n>  \n> +// Filename used to store outbound record commands until sync\n\nClosing period.\n\n@@ +55,5 @@\n>  \n> +// Filename used to store outbound record commands until sync\n> +const OUTBOUND_RECORD_COMMANDS_FILENAME = \"outbound_record_commands\";\n> +\n> +// Collection holding records storing tab state for tab loading.\n\nArgh, English!\n\n// The collection that holds records which store tab state for tab loading.\n\nwould be a minor improvement.\n\n@@ +165,5 @@\n> +    SyncEngine.prototype._uploadOutgoing.call(this);\n> +\n> +    let cb = Async.makeSyncCallback();\n> +    Utils.jsonLoad(OUTBOUND_RECORD_COMMANDS_FILENAME, this, cb);\n> +    let json = Async.waitForSyncCallback(cb);\n\n_uploadOutgoing has to block, so yes, you have to spin the event loop.\n\nI'd much rather you only do it once, though! Chain jsonLoad and jsonSave, and spin on the callback inside jsonSave (or invoke it on the load failure case, of course).\n\n@@ +167,5 @@\n> +    let cb = Async.makeSyncCallback();\n> +    Utils.jsonLoad(OUTBOUND_RECORD_COMMANDS_FILENAME, this, cb);\n> +    let json = Async.waitForSyncCallback(cb);\n> +\n> +    if (!json || !json.keys().length) {\n\nDo you mean\n\n  Object.keys(json).length\n\n?\n\n@@ +174,5 @@\n> +\n> +    for (let [guid, v] in Iterator(json)) {\n> +      let record = new WBORecord(v[0], guid);\n> +      record.ttl = v[1];\n> +      record.payload = JSON.stringify(v[2]);\n\nLet's use destructuring here.\n\n  let [collection, ttl, payload] = v;\n\nAlso, IIRC the payload of a WBORecord is an object, not a JSON string\u2026\n\n@@ +176,5 @@\n> +      let record = new WBORecord(v[0], guid);\n> +      record.ttl = v[1];\n> +      record.payload = JSON.stringify(v[2]);\n> +\n> +      record.upload(this.storageURL + v[0] + \"/\" + guid);\n\nThis could be more efficient when you're dealing with more than one object at a time.\n\nYou make one HTTP request per object. You concatenate the storage URL once per object.\n\nIf you take a look at SyncEngine._uploadOutgoing, you'll see a way to use Collection to batch your uploads.\n\nYes, it's likely there's only be a small number of objects\u2026 right up until the day we allow you to send *all* of the tabs in this folder, or this window, to another device.\n\n@@ +371,5 @@\n>      }\n>    },\n>  \n>    /**\n> +   * Send a remote record command to a set of clients\n\nClosing period.\n\n@@ +376,5 @@\n> +   *\n> +   * Commands sent using this function result in:\n> +   *\n> +   *   1) A new record consisting of the data specified being added to the\n> +   *      collection specified\n\nI will do a grammar overhaul prior to r+ :D\n\n@@ +392,5 @@\n> +   * @param clients\n> +   *        Client ID or IDs to send command to. Can be specified as:\n> +   *          string    single Client ID to send command to\n> +   *          array     list of Client IDs to send command to\n> +   *          undefined send command to all remote clients\n\nNormally we avoid this kind of polymorphism. At the very least let's require an array here, or some constant Clients.ALL object.\n\n@@ +400,5 @@\n> +   *          deleteOnRead - If true, the client is instructed to delete the\n> +   *                         record after reading. By default, this is set to\n> +   *                         true if the command is being sent to one client\n> +   *                         and false if sent to multiple clients.\n> +   */\n\nIt strikes me that some control over TTL would be useful. Other than deletion, TTL is the only mechanism offered by this approach for preventing garbage overrunning the user's quota.\n\n@@ +416,5 @@\n> +      destinationClients.push(clients);\n> +    }\n> +\n> +    // We assemble the full record and queue it for upload.\n> +    if (options === undefined) {\n\nif (!options) ...\n\nor, better\n\n  options = options || { ... }\n\nOtherwise I can pass null for options, and you'll get\n\n  Error: invalid 'in' operand null\n\nbecause !(null === undefined).\n\n@@ +424,5 @@\n> +    }\n> +\n> +    if ('deleteOnRead' in options) {\n> +      record.deleteOnRead = options.deleteOnRead;\n> +    else if (destinationClients.length) {\n\nMissing }.\n\n@@ +475,5 @@\n> +    let record = remoteRecord.fetch(uri);\n> +\n> +    if (collection == LOAD_TAB_COLLECTION) {\n> +      this._handleLoadTabCommand(record);\n> +    }\n\nThis strikes me as inverted control.\n\nHow about instead of adding what amounts to a glorified switch statement, you use OO dispatch?\n\nHave the command specify an engine name (e.g., \"tabs\").\n\nWhen you receive a message, look up the engine (Engines.get(name)). If you get an engine, see if it has a .handleMessage method in its prototype chain. Hand over the message.\n\nYou can provide a default handler on SyncEngine if you wish.\n\nThe reason I make this remark is that you're pitching this as a generic capability: put a record somewhere else, and then have an engine handle it. If that's the case, have the engine handle it!", "creation_time": "2011-09-27T07:04:16Z", "time": "2011-09-27T07:04:16Z", "attachment_id": 562617, "text": "Comment on attachment 562617\n\"processRecord\" command support, v0\n\nReview of attachment 562617:\n-----------------------------------------------------------------\n\nNote that you can update the Bug XXXXXX and description now:\n\n  Bug 686704: Send Tab to Device - Support for session state\n\n---\nI gave detailed comments as I went through, just because Splinter makes it easy. Please don't interpret them as raining on your parade; just saving time later.\n---\n\nMore broadly:\n\n* You should have some tests to go along with this. There are a couple of syntax errors that implies that this code hasn't even been run, which is generally not a good sign. It's easier to start with 100% coverage and get worse over time than to go the other way!\n\n* The functionality you've added can be summarized as \"put a big fat command in a collection; add a small indirection 'load' command to the clients engine\". This seems to carry a gentle form of RPC semantics: you're instructing the client to pull down a command of arbitrary size and run it. That's quite possibly not a good idea: maybe I'm on a low-bandwidth connection? Perhaps I want to introspect the command before I decide if I want to spend the time to download and run it?\n\nI would suggest flipping this around a little. Have the big fat payload go to the collection, and put a real command, just as you did for your first draft of send-tab-to-device, into the clients engine. That command can refer to bigfatpayloads/someguid. You can still generalize the command with some kind of dispatch semantics if you want (e.g., specify an engine and a command name, so we don't end up with a switch statement in the clients engine), but don't force a download before the command can be examined.\n\nDoing it this way allows, say, Fennec to prompt the user:\n\n  Open <some slashdot URI> sent from Greg's Desktop?\n\nbefore downloading the whole tab state payload. The command could even refer to multiple blobs, if you someday go over the 256KB limit:\n\n  {engine: \"tabs\",\n   command: \"open\",\n   tabstate: \"tabstates/abcdefghijkl\",\n   localstorage: \"localstorage/foobarbaznoo\"}\n\nThis approach also opens up interesting possibilities, such as sending different page-processing commands to different device types (Read It Later vs open now, for example) whilst preserving the same state object.\n\nThoughts?\n\n::: services/sync/modules/engines/clients.js\n@@ +52,5 @@\n>  \n>  const CLIENTS_TTL = 1814400; // 21 days\n>  const CLIENTS_TTL_REFRESH = 604800; // 7 days\n>  \n> +// Filename used to store outbound record commands until sync\n\nClosing period.\n\n@@ +55,5 @@\n>  \n> +// Filename used to store outbound record commands until sync\n> +const OUTBOUND_RECORD_COMMANDS_FILENAME = \"outbound_record_commands\";\n> +\n> +// Collection holding records storing tab state for tab loading.\n\nArgh, English!\n\n// The collection that holds records which store tab state for tab loading.\n\nwould be a minor improvement.\n\n@@ +165,5 @@\n> +    SyncEngine.prototype._uploadOutgoing.call(this);\n> +\n> +    let cb = Async.makeSyncCallback();\n> +    Utils.jsonLoad(OUTBOUND_RECORD_COMMANDS_FILENAME, this, cb);\n> +    let json = Async.waitForSyncCallback(cb);\n\n_uploadOutgoing has to block, so yes, you have to spin the event loop.\n\nI'd much rather you only do it once, though! Chain jsonLoad and jsonSave, and spin on the callback inside jsonSave (or invoke it on the load failure case, of course).\n\n@@ +167,5 @@\n> +    let cb = Async.makeSyncCallback();\n> +    Utils.jsonLoad(OUTBOUND_RECORD_COMMANDS_FILENAME, this, cb);\n> +    let json = Async.waitForSyncCallback(cb);\n> +\n> +    if (!json || !json.keys().length) {\n\nDo you mean\n\n  Object.keys(json).length\n\n?\n\n@@ +174,5 @@\n> +\n> +    for (let [guid, v] in Iterator(json)) {\n> +      let record = new WBORecord(v[0], guid);\n> +      record.ttl = v[1];\n> +      record.payload = JSON.stringify(v[2]);\n\nLet's use destructuring here.\n\n  let [collection, ttl, payload] = v;\n\nAlso, IIRC the payload of a WBORecord is an object, not a JSON string\u2026\n\n@@ +176,5 @@\n> +      let record = new WBORecord(v[0], guid);\n> +      record.ttl = v[1];\n> +      record.payload = JSON.stringify(v[2]);\n> +\n> +      record.upload(this.storageURL + v[0] + \"/\" + guid);\n\nThis could be more efficient when you're dealing with more than one object at a time.\n\nYou make one HTTP request per object. You concatenate the storage URL once per object.\n\nIf you take a look at SyncEngine._uploadOutgoing, you'll see a way to use Collection to batch your uploads.\n\nYes, it's likely there's only be a small number of objects\u2026 right up until the day we allow you to send *all* of the tabs in this folder, or this window, to another device.\n\n@@ +371,5 @@\n>      }\n>    },\n>  \n>    /**\n> +   * Send a remote record command to a set of clients\n\nClosing period.\n\n@@ +376,5 @@\n> +   *\n> +   * Commands sent using this function result in:\n> +   *\n> +   *   1) A new record consisting of the data specified being added to the\n> +   *      collection specified\n\nI will do a grammar overhaul prior to r+ :D\n\n@@ +392,5 @@\n> +   * @param clients\n> +   *        Client ID or IDs to send command to. Can be specified as:\n> +   *          string    single Client ID to send command to\n> +   *          array     list of Client IDs to send command to\n> +   *          undefined send command to all remote clients\n\nNormally we avoid this kind of polymorphism. At the very least let's require an array here, or some constant Clients.ALL object.\n\n@@ +400,5 @@\n> +   *          deleteOnRead - If true, the client is instructed to delete the\n> +   *                         record after reading. By default, this is set to\n> +   *                         true if the command is being sent to one client\n> +   *                         and false if sent to multiple clients.\n> +   */\n\nIt strikes me that some control over TTL would be useful. Other than deletion, TTL is the only mechanism offered by this approach for preventing garbage overrunning the user's quota.\n\n@@ +416,5 @@\n> +      destinationClients.push(clients);\n> +    }\n> +\n> +    // We assemble the full record and queue it for upload.\n> +    if (options === undefined) {\n\nif (!options) ...\n\nor, better\n\n  options = options || { ... }\n\nOtherwise I can pass null for options, and you'll get\n\n  Error: invalid 'in' operand null\n\nbecause !(null === undefined).\n\n@@ +424,5 @@\n> +    }\n> +\n> +    if ('deleteOnRead' in options) {\n> +      record.deleteOnRead = options.deleteOnRead;\n> +    else if (destinationClients.length) {\n\nMissing }.\n\n@@ +475,5 @@\n> +    let record = remoteRecord.fetch(uri);\n> +\n> +    if (collection == LOAD_TAB_COLLECTION) {\n> +      this._handleLoadTabCommand(record);\n> +    }\n\nThis strikes me as inverted control.\n\nHow about instead of adding what amounts to a glorified switch statement, you use OO dispatch?\n\nHave the command specify an engine name (e.g., \"tabs\").\n\nWhen you receive a message, look up the engine (Engines.get(name)). If you get an engine, see if it has a .handleMessage method in its prototype chain. Hand over the message.\n\nYou can provide a default handler on SyncEngine if you wish.\n\nThe reason I make this remark is that you're pitching this as a generic capability: put a record somewhere else, and then have an engine handle it. If that's the case, have the engine handle it!", "author": "bugzilla@twinql.com", "creator": "bugzilla@twinql.com"}, {"creator": "gps@mozilla.com", "author": "gps@mozilla.com", "text": "(In reply to Richard Newman [:rnewman] from comment #5)\n> * You should have some tests to go along with this.\n\nPer my note on desired feedback, I wanted high-level feedback before implementing tests to save refactor time if feedback was negative.\n\n> There are a couple of syntax errors that implies that this code hasn't even\n> been run.\n\nYup. I called this out when I submitted the diff.\n \n> Perhaps I want to introspect the command before I decide if I\n> want to spend the time to download and run it?\n\nYeah. I purposefully designed the data model to make this possible (but putting the bulk data in arbitrary collections so the client could key off the collection name before fetching the record). I just implemented it improperly. It has been fixed on my local machine.\n\n> I would suggest flipping this around a little. Have the big fat payload go\n> to the collection, and put a real command, just as you did for your first\n> draft of send-tab-to-device, into the clients engine.\n\nUmm, that's what I did.\n\n> Doing it this way allows, say, Fennec to prompt the user:\n> \n>   Open <some slashdot URI> sent from Greg's Desktop?\n> \n> before downloading the whole tab state payload. The command could even refer\n> to multiple blobs, if you someday go over the 256KB limit:\n> \n>   {engine: \"tabs\",\n>    command: \"open\",\n>    tabstate: \"tabstates/abcdefghijkl\",\n>    localstorage: \"localstorage/foobarbaznoo\"}\n> \n> This approach also opens up interesting possibilities, such as sending\n> different page-processing commands to different device types (Read It Later\n> vs open now, for example) whilst preserving the same state object.\n> \n> Thoughts?\n\nOK, now we're getting to some interesting feedback! There are a few areas to explore here.\n\nAt what level of command processing do we wish to bake in the processing semantics? We could go with individual commands for every little thing (like tab sending), but a lot of the small metadata in the individual command as arguments, and reference the larger blob in some remote collection. Going up a level, we could go with what is implemented here: a generic \"processRecord\" command that is effectively a pointer. The base command has minimal metadata (like flags for semantics for delete on read, ignore on unknown, etc). We could even go with a hybrid of this approach, where we use per-action commands and move the smaller metadata to the command itself.\n\nYour remark about automatic dispatch of commands is also interesting. I like this approach. It keeps the Clients Engine domain specific and allows other engines to staple on functionality without modifying core code. Another advantage of this method is that fetching of referenced record (if that is needed at all), is totally up to the other engine. We may provide a helper API, but the Clients Engine won't need to fetch the record before control is handed off to someone else. And, we won't enforce semantics of how a record is referenced. I'm really liking this.\n\nNow, the above two paragraphs are somewhat in conflict and the implementation seems to be mutually exclusive. We have 1) create a special command with strong semantics that handles data stored in remote records 2) add an 'engine' key to command records that, when present, forwards the command to another engine for processing, having it deal with remote records if necessary.\n\nTo further complicate things, commands all exist within the clients record. This has known issues (race conditions, size limitations). If we open up a generic way for engines to send their own commands without modifying the Clients Engine, we give other engines (some possibly provided by 3rd party extensions) the opportunity to shoot themselves (and the core) in the foot. Do we want to open this door?\n\nI agree that a generic and extensible command processing feature is nice (and I want it). But, do we want to cross that bridge now. Should it be a blocker for this bug?", "time": "2011-09-27T19:48:25Z", "attachment_id": null, "creation_time": "2011-09-27T19:48:25Z", "raw_text": "(In reply to Richard Newman [:rnewman] from comment #5)\n> * You should have some tests to go along with this.\n\nPer my note on desired feedback, I wanted high-level feedback before implementing tests to save refactor time if feedback was negative.\n\n> There are a couple of syntax errors that implies that this code hasn't even\n> been run.\n\nYup. I called this out when I submitted the diff.\n \n> Perhaps I want to introspect the command before I decide if I\n> want to spend the time to download and run it?\n\nYeah. I purposefully designed the data model to make this possible (but putting the bulk data in arbitrary collections so the client could key off the collection name before fetching the record). I just implemented it improperly. It has been fixed on my local machine.\n\n> I would suggest flipping this around a little. Have the big fat payload go\n> to the collection, and put a real command, just as you did for your first\n> draft of send-tab-to-device, into the clients engine.\n\nUmm, that's what I did.\n\n> Doing it this way allows, say, Fennec to prompt the user:\n> \n>   Open <some slashdot URI> sent from Greg's Desktop?\n> \n> before downloading the whole tab state payload. The command could even refer\n> to multiple blobs, if you someday go over the 256KB limit:\n> \n>   {engine: \"tabs\",\n>    command: \"open\",\n>    tabstate: \"tabstates/abcdefghijkl\",\n>    localstorage: \"localstorage/foobarbaznoo\"}\n> \n> This approach also opens up interesting possibilities, such as sending\n> different page-processing commands to different device types (Read It Later\n> vs open now, for example) whilst preserving the same state object.\n> \n> Thoughts?\n\nOK, now we're getting to some interesting feedback! There are a few areas to explore here.\n\nAt what level of command processing do we wish to bake in the processing semantics? We could go with individual commands for every little thing (like tab sending), but a lot of the small metadata in the individual command as arguments, and reference the larger blob in some remote collection. Going up a level, we could go with what is implemented here: a generic \"processRecord\" command that is effectively a pointer. The base command has minimal metadata (like flags for semantics for delete on read, ignore on unknown, etc). We could even go with a hybrid of this approach, where we use per-action commands and move the smaller metadata to the command itself.\n\nYour remark about automatic dispatch of commands is also interesting. I like this approach. It keeps the Clients Engine domain specific and allows other engines to staple on functionality without modifying core code. Another advantage of this method is that fetching of referenced record (if that is needed at all), is totally up to the other engine. We may provide a helper API, but the Clients Engine won't need to fetch the record before control is handed off to someone else. And, we won't enforce semantics of how a record is referenced. I'm really liking this.\n\nNow, the above two paragraphs are somewhat in conflict and the implementation seems to be mutually exclusive. We have 1) create a special command with strong semantics that handles data stored in remote records 2) add an 'engine' key to command records that, when present, forwards the command to another engine for processing, having it deal with remote records if necessary.\n\nTo further complicate things, commands all exist within the clients record. This has known issues (race conditions, size limitations). If we open up a generic way for engines to send their own commands without modifying the Clients Engine, we give other engines (some possibly provided by 3rd party extensions) the opportunity to shoot themselves (and the core) in the foot. Do we want to open this door?\n\nI agree that a generic and extensible command processing feature is nice (and I want it). But, do we want to cross that bridge now. Should it be a blocker for this bug?", "bug_id": 686704, "is_private": false, "count": 6, "tags": [], "id": 5741006}, {"attachment_id": null, "time": "2011-09-27T21:36:37Z", "author": "philipp@weitershausen.de", "text": "These are good ideas, but can we please build abstractions when we need them? As long as the record format stays stable, we can make the client code more pluggable later when we find more use cases for this. But (a) this stuff needs to ship (stat!) and (b) I don't feel at all like creating abstractions based on 1 case. Just my 2 cents. :)", "creator": "philipp@weitershausen.de", "creation_time": "2011-09-27T21:36:37Z", "raw_text": "These are good ideas, but can we please build abstractions when we need them? As long as the record format stays stable, we can make the client code more pluggable later when we find more use cases for this. But (a) this stuff needs to ship (stat!) and (b) I don't feel at all like creating abstractions based on 1 case. Just my 2 cents. :)", "bug_id": 686704, "id": 5741388, "is_private": false, "count": 7, "tags": []}, {"id": 5741717, "tags": [], "count": 8, "is_private": false, "bug_id": 686704, "creation_time": "2011-09-27T23:07:22Z", "raw_text": "Summary of where I think this should go:\n\n* sendTabToDevice command, which includes a pointer to a remote record.\n* The method which handles sendTabToDevice (just like the existing sendURIToDevice command) is responsible for fetching and otherwise owning the remote record.\n* By all means provide an argument channel for things like \"delete this when you're done\".\n\nThis gives us a decent separation of control, and a starting point for possible future extension.\n\nOne thing that hasn't been discussed is wipeServer. For the first time there won't be a 1:1 mapping between engine names and collections; you're going to have to touch Service._freshStart to ensure that the appropriate dependent collections get cleared.", "author": "bugzilla@twinql.com", "attachment_id": null, "time": "2011-09-27T23:07:22Z", "text": "Summary of where I think this should go:\n\n* sendTabToDevice command, which includes a pointer to a remote record.\n* The method which handles sendTabToDevice (just like the existing sendURIToDevice command) is responsible for fetching and otherwise owning the remote record.\n* By all means provide an argument channel for things like \"delete this when you're done\".\n\nThis gives us a decent separation of control, and a starting point for possible future extension.\n\nOne thing that hasn't been discussed is wipeServer. For the first time there won't be a 1:1 mapping between engine names and collections; you're going to have to touch Service._freshStart to ensure that the appropriate dependent collections get cleared.", "creator": "bugzilla@twinql.com"}, {"bug_id": 686704, "id": 5741730, "tags": [], "is_private": false, "count": 9, "attachment_id": null, "time": "2011-09-27T23:11:36Z", "text": "(In reply to Gregory Szorc [:gps] from comment #6)\n> > * You should have some tests to go along with this.\n> \n> Per my note on desired feedback, I wanted high-level feedback before\n> implementing tests to save refactor time if feedback was negative.\n\nAt the risk of flogging a dead horse: a couple of \"success branch\" tests are a really good way to illustrate how an API will be used, and to help you design it. Furthermore, tests help you refactor!\n\nTests are your friend :)\n\n> Yup. I called this out when I submitted the diff.\n\nYou can't put code in front of me or Philipp without having us point out nits :)", "raw_text": "(In reply to Gregory Szorc [:gps] from comment #6)\n> > * You should have some tests to go along with this.\n> \n> Per my note on desired feedback, I wanted high-level feedback before\n> implementing tests to save refactor time if feedback was negative.\n\nAt the risk of flogging a dead horse: a couple of \"success branch\" tests are a really good way to illustrate how an API will be used, and to help you design it. Furthermore, tests help you refactor!\n\nTests are your friend :)\n\n> Yup. I called this out when I submitted the diff.\n\nYou can't put code in front of me or Philipp without having us point out nits :)", "creation_time": "2011-09-27T23:11:36Z", "author": "bugzilla@twinql.com", "creator": "bugzilla@twinql.com"}, {"creator": "gps@mozilla.com", "author": "gps@mozilla.com", "bug_id": 686704, "count": 10, "is_private": false, "tags": [], "id": 5756306, "text": "Created attachment 564446\nImplement \"displayTab\" command, v1\n\nHere is the implementation of the new command, taking the direction that was decided on in IRC.\n\nI fully expect a f- because there are many items that need feedback. These are explicitly marked with TODO.\n\nThere are a few tests that need to be implemented. These are also documented with TODO. One (the failing tab state record upload/download one) requires feedback on proper error handling before it is implemented (this question is posed as a TODO). If you can think of additional tests, please say so.\n\nIt is my hope that the feedback from this attachment will lead directly to additional coding which will produce a patch that can be r+ (if I do my end right), so please use scrutiny.", "attachment_id": 564446, "time": "2011-10-04T03:11:29Z", "creation_time": "2011-10-04T03:11:29Z", "raw_text": "Here is the implementation of the new command, taking the direction that was decided on in IRC.\n\nI fully expect a f- because there are many items that need feedback. These are explicitly marked with TODO.\n\nThere are a few tests that need to be implemented. These are also documented with TODO. One (the failing tab state record upload/download one) requires feedback on proper error handling before it is implemented (this question is posed as a TODO). If you can think of additional tests, please say so.\n\nIt is my hope that the feedback from this attachment will lead directly to additional coding which will produce a patch that can be r+ (if I do my end right), so please use scrutiny."}, {"author": "philipp@weitershausen.de", "creator": "philipp@weitershausen.de", "attachment_id": 564446, "time": "2011-10-04T03:26:47Z", "text": "Comment on attachment 564446\nImplement \"displayTab\" command, v1\n\n(I haven't looked at the impl at all, just giving some feedback on some of the comments:)\n\n>+// TODO philikon wants a better name. what is it?\n>+const SESSION_STATE_COLLECTION = \"session-states\";\n\nYeah, session state sounds like we're syncing sessionstore.js or something, but we're not. We're sending a tab link over the wire. The *tab* state is just a bonus. I don't imagine all clients will support it (e.g. Blackberry Sync, Firefox Home for iOS, etc.).\n\nI suggest SendTab* for object names and 'sendtab' for collection.\n\n>+  /**\n>+   * Sends a tab to another client.\n>+   *\n>+   * This can be thought of as a more powerful version of\n>+   * sendURIToClientForDisplay(). This version takes an options\n>+   * argument which controls how the sending works.\n>+   *\n>+   * Calling this function with session state will eventually result in a\n>+   * record in another collection being created. This record is only\n>+   * referenced in the command. It is protected against orphanage by a\n>+   * server-side expiration TTL.\n>+   *\n>+   * Session state (as obtained from NSISessionStore) may optionally be sent\n>+   * with the command. Session state may vary between application types (e.g.\n>+   * desktop vs. mobile).\n\nSo how are you proposing to deal with the differences between the tab state format? E.g. I want to send a tab from desktop to mobile (most common use case). How would that work? I think there's no way around defining what this format looks like ourselves and then adding some appropriate translators. Also, what if the if the nsISessionStore format changes between versions? All of a sudden records can't be synced anymore.\n\nThere's also an architectural purity argument to be made here: none of the other record formats are tied to a specific Firefox API. They're specifically defined to be app-agnostic. Just saying \"this format is whatever nsISessionStore deems to be the format\" would be a crass deviation from that principle.\n\n(Also, nit: it's nsISessionStore with a lower case 'ns').", "creation_time": "2011-10-04T03:26:47Z", "raw_text": "(I haven't looked at the impl at all, just giving some feedback on some of the comments:)\n\n>+// TODO philikon wants a better name. what is it?\n>+const SESSION_STATE_COLLECTION = \"session-states\";\n\nYeah, session state sounds like we're syncing sessionstore.js or something, but we're not. We're sending a tab link over the wire. The *tab* state is just a bonus. I don't imagine all clients will support it (e.g. Blackberry Sync, Firefox Home for iOS, etc.).\n\nI suggest SendTab* for object names and 'sendtab' for collection.\n\n>+  /**\n>+   * Sends a tab to another client.\n>+   *\n>+   * This can be thought of as a more powerful version of\n>+   * sendURIToClientForDisplay(). This version takes an options\n>+   * argument which controls how the sending works.\n>+   *\n>+   * Calling this function with session state will eventually result in a\n>+   * record in another collection being created. This record is only\n>+   * referenced in the command. It is protected against orphanage by a\n>+   * server-side expiration TTL.\n>+   *\n>+   * Session state (as obtained from NSISessionStore) may optionally be sent\n>+   * with the command. Session state may vary between application types (e.g.\n>+   * desktop vs. mobile).\n\nSo how are you proposing to deal with the differences between the tab state format? E.g. I want to send a tab from desktop to mobile (most common use case). How would that work? I think there's no way around defining what this format looks like ourselves and then adding some appropriate translators. Also, what if the if the nsISessionStore format changes between versions? All of a sudden records can't be synced anymore.\n\nThere's also an architectural purity argument to be made here: none of the other record formats are tied to a specific Firefox API. They're specifically defined to be app-agnostic. Just saying \"this format is whatever nsISessionStore deems to be the format\" would be a crass deviation from that principle.\n\n(Also, nit: it's nsISessionStore with a lower case 'ns').", "bug_id": 686704, "id": 5756343, "count": 11, "is_private": false, "tags": []}, {"text": "Comment on attachment 564446\nImplement \"displayTab\" command, v1\n\nReview of attachment 564446:\n-----------------------------------------------------------------\n\nLots and lots of feedback. You're going in the right direction, so you get f+.\n\nTests on error -- including partial error -- are an absolute requirement for this getting r+.\n\n::: services/sync/modules/engines/clients.js\n@@ +53,5 @@\n>  const CLIENTS_TTL = 1814400; // 21 days\n>  const CLIENTS_TTL_REFRESH = 604800; // 7 days\n>  \n> +// TODO philikon wants a better name. what is it?\n> +const SESSION_STATE_COLLECTION = \"session-states\";\n\nconst TAB_STATE_COLLECTION = \"sendtab\";\n\n@@ +56,5 @@\n> +// TODO philikon wants a better name. what is it?\n> +const SESSION_STATE_COLLECTION = \"session-states\";\n> +\n> +// TODO verify this TTL is appropriate\n> +const SESSION_STATE_TTL = 604800; // 7 days\n\nTAB_STATE_TTL.\n\n@@ +76,5 @@\n> +  * It is used by the send tab command. Tab states are stored in their own\n> +  * collection because they could be large and could exhaust space in the\n> +  * clients record.\n> +  */\n> +function SessionStateRec(collection, id) {\n\nSendTabRecord.\n\n@@ +179,5 @@\n>  \n> +  // We override the default implementation to additionally upload tab state\n> +  // records.\n> +  _uploadOutgoing: function _uploadOutgoing() {\n> +    SyncEngine.prototype._uploadOutgoing.call(this);\n\nI think this is backward.\n\nAccording to my reading of this, what you do is:\n\n* Upload commands by invoking the prototype method.\n* Attempt to upload tab state records.\n\nSo, what happens when you upload a bunch of tab open requests, take five minutes to upload the tab state payload for the first, and the other client processes the commands in the mean time? Oops.\n\nThis takes careful handling.\n\nYou don't want to upload a command record without the tab state having been uploaded. We have a failed-record system; use it.\n\nHowever, you don't want to stall the processing of other commands while you wait for tab state to upload, perhaps unsuccessfully (for quota reasons).\n\nA few possible remediations for this:\n\n* Upload non-dependent commands, then process the dependent commands one by one, attempting to send the tab data for each prior to sending the command.\n* Similar, but batch the tab data and cross your fingers.\n* Do what you do now, but have the consumer queue the command and try again later if it gets a 404 fetching the tab state.\n\n@@ +186,5 @@\n> +      return;\n> +    }\n> +\n> +    let collection = new Collection(\n> +      this.storageURL + SESSION_STATE_COLLECTION);\n\nIf you look in engines.js, you'll see an idiom like this:\n\n  get cryptoKeysURL() this.storageURL + \"crypto/keys\",\n\nI suggest you do something similar, so you can say\n\n  let collection = new Collection(this.tabStateURL);\n\nthroughout this file.\n\n@@ +188,5 @@\n> +\n> +    let collection = new Collection(\n> +      this.storageURL + SESSION_STATE_COLLECTION);\n> +\n> +    // TODO limit upload to N records at a time?\n\nYes. See engines.js:1138; MAX_UPLOAD_RECORDS.\n\n@@ +194,5 @@\n> +      let [ttl, state] = v;\n> +\n> +      let record = new SessionStateRec(guid, SESSION_STATE_COLLECTION);\n> +      // TODO [gps] I thought .id was populated automagically by the ctor? The\n> +      // fake HTTP server doesn't like it unless the next line is defined. Huh?\n\nDefine \"doesn't like it\"?\n\nDid you write a trivial test that instantiates a SessionStateRec and pokes .id?\n\nIt certainly looks like the constructors chain appropriately. It's possible that there's a bug; I see CryptoWrapper also sets .id itself.\n\nNote that your hackery should be inside the SessionStateRec ctor in any case...\n\n@@ +205,5 @@\n> +      collection.pushData(record);\n> +    }\n> +\n> +    // TODO probably need error checking on this. What's appropriate?\n> +    collection.post();\n\nThe idiom goes something like\n\n        let resp = collection.post();\n        if (!resp.success) {\n          this._log.debug(\"Uploading records failed: \" + resp);\n          resp.failureCode = ENGINE_UPLOAD_FAIL;\n          throw resp;\n        }\n\nbut ask philikon if his SyncError stuff is ready yet.\n\n@@ +214,1 @@\n>    // Always process incoming items because they might have commands\n\nWhile you're here, add a '.' to these evil fragmented comments.\n\n@@ +453,5 @@\n> +   * record in another collection being created. This record is only\n> +   * referenced in the command. It is protected against orphanage by a\n> +   * server-side expiration TTL.\n> +   *\n> +   * Session state (as obtained from NSISessionStore) may optionally be sent\n\ns/NS/ns.\n\nThis is not NeXTSTEP :)\n\n@@ +454,5 @@\n> +   * referenced in the command. It is protected against orphanage by a\n> +   * server-side expiration TTL.\n> +   *\n> +   * Session state (as obtained from NSISessionStore) may optionally be sent\n> +   * with the command. Session state may vary between application types (e.g.\n\n\u2026 tab state. This applies throughout.\n\n@@ +457,5 @@\n> +   * Session state (as obtained from NSISessionStore) may optionally be sent\n> +   * with the command. Session state may vary between application types (e.g.\n> +   * desktop vs. mobile). This function currently sends along the local client\n> +   * ID as part of the command. The receiver can infer the session state format\n> +   * by looking up the sender's type by its ID.\n\n*Scooby Doo impression*\n\nNope. Define a record format that includes the information you need to build a tab on any device. Sync needs to be device agnostic; a dump of an object isn't adequate.\n\nJust think: the alternative is that you send a mobile record to a desktop, and the *desktop* needs to know how to do the translation. Now you've got N*M*V translations (for each pairwise translation of client types and versions), rather than N translations to a common format.\n\n@@ +460,5 @@\n> +   * ID as part of the command. The receiver can infer the session state format\n> +   * by looking up the sender's type by its ID.\n> +   *\n> +   * @param uri\n> +   *        String URI to send to the remote client\n\n'.'\n\n@@ +467,5 @@\n> +   * @param options\n> +   *        Object containing metadata to control how sending works. Can\n> +   *        contain the following keys:\n> +   *          sessionState - Tab's session state (as obtained from\n> +   *          NSISessionStore). If not defined, no session state is sent.\n\ns/NS/ns\n\n@@ +478,5 @@\n> +\n> +    options = options || {};\n> +\n> +    if (!(\"ttl\" in options)) {\n> +      options.ttl = SESSION_STATE_TTL;\n\nPerhaps call this DEFAULT_TAB_STATE_TTL, then?\n\n@@ +481,5 @@\n> +    if (!(\"ttl\" in options)) {\n> +      options.ttl = SESSION_STATE_TTL;\n> +    }\n> +\n> +    let args = {uri: uri, senderID: this.localID};\n\nSplit line, please. It'll grow\u2026\n\n@@ +490,5 @@\n> +    // record, outside of the clients collection.\n> +    if (\"sessionState\" in options) {\n> +      let guid = Utils.makeGUID();\n> +      args.stateID = guid;\n> +      this._store._outgoingTabStateRecords[guid] = [options.ttl, options.sessionState];\n\nWhy did you elect to use an array here instead of an object? Just pass options!\n\n@@ +508,5 @@\n> +    // Commands may or may not have tab state. If they do, it is stored in a\n> +    // foreign record, which we'll need to fetch.\n> +    if (\"stateID\" in args) {\n> +      let record = new SessionStateRec(SESSION_STATE_COLLECTION, args.stateID);\n> +      let uri = this.storageURL + SESSION_STATE_COLLECTION + \"/\"\n\nAgain, this.tabStateURL.\n\n@@ +513,5 @@\n> +                + args.stateID;\n> +\n> +      this._log.debug(\"Fetching remote record from: \" + uri);\n> +\n> +      // This is synchronous, but spins the event loop. It also throws on\n\ns/but/and!\n\n@@ +514,5 @@\n> +\n> +      this._log.debug(\"Fetching remote record from: \" + uri);\n> +\n> +      // This is synchronous, but spins the event loop. It also throws on\n> +      // error.\n\nI don't believe it does.\n\n  // Get thyself from your URI, then deserialize.\n  // Set thine 'response' field.\n  fetch: function fetch(uri) {\n    let r = new Resource(uri).get();\n    if (r.success) {\n      this.deserialize(r);   // Warning! Muffles exceptions!\n    }\n    this.response = r;\n    return this;\n  },\n\nResource.get() will throw in some circumstances, but not a 404:\n\n--\n[21:30:57.706] new (Components.utils.import(\"resource://services-sync/resource.js\").Resource)(\"http://twinql.com/40440400000\").get().status;\n[21:30:57.852] 404\n\nYou definitely want to check for success here... and then you have to decide what happens when you can't get the data for a command!\n\n@@ +522,5 @@\n> +      state = record.sessionState;\n> +      this._log.debug(\"Received tab state record: \" + args.stateID);\n> +\n> +      // TODO what do we do about the record? do we let the server auto-expire?\n> +      // Do we perform an async delete?\n\nGood question. Are they ever shared between commands? How big are they?\n\nIf a user is sending 5 tabs per day, and each one carries 1MB of encrypted+base64ed+JSONified data, he's going to hit his quota by Friday.\n\nIn that case you definitely need to consider cleanup. Something like accumulating the IDs and doing a batched async (RESTRequest) DELETE with ids= at the end of a sync would suffice, mm?\n\n@@ +540,5 @@\n>  }\n>  ClientStore.prototype = {\n>    __proto__: Store.prototype,\n>  \n> +  // Holds tab state records for \"displayTab\" commands that haven't been sent\n\n\"haven't yet been sent.\"\n\n@@ +541,5 @@\n>  ClientStore.prototype = {\n>    __proto__: Store.prototype,\n>  \n> +  // Holds tab state records for \"displayTab\" commands that haven't been sent\n> +  // yet. Record ID -> payload object\n\n'.'\n\n@@ +548,1 @@\n>    create: function create(record) this.update(record),\n\nPlease use explicit  { return ...; }. It'll make Emacs happy.\n\n@@ +548,3 @@\n>    create: function create(record) this.update(record),\n>  \n>    update: function update(record) {\n\nPlease fix this while you're here: brackets and cuddling and such.\n\nYou get extra points if you clean up and make the whole file follow coding standards in a part 0, but I am aware of the awfulness of rebase hell if you try to do that with hg mq, so a part 2 is fine :)\n\n@@ +581,5 @@\n>    },\n>  \n>    wipe: function wipe() {\n> +    this._remoteClients           = {};\n> +    this._outgoingTabStateRecords = {};\n\n<3 indenting.\n\n::: services/sync/tests/unit/test_clients_engine.js\n@@ +797,5 @@\n> +  do_check_true(Clients.processIncomingCommands());\n> +});\n> +\n> +// TODO add test for multiple send tab commands in one go\n> +// TODO add test exercising failures in tab state record upload and download\n\nYes.\n\nI am curious about the error strategy here.", "attachment_id": 564446, "time": "2011-10-04T04:33:55Z", "raw_text": "Review of attachment 564446:\n-----------------------------------------------------------------\n\nLots and lots of feedback. You're going in the right direction, so you get f+.\n\nTests on error -- including partial error -- are an absolute requirement for this getting r+.\n\n::: services/sync/modules/engines/clients.js\n@@ +53,5 @@\n>  const CLIENTS_TTL = 1814400; // 21 days\n>  const CLIENTS_TTL_REFRESH = 604800; // 7 days\n>  \n> +// TODO philikon wants a better name. what is it?\n> +const SESSION_STATE_COLLECTION = \"session-states\";\n\nconst TAB_STATE_COLLECTION = \"sendtab\";\n\n@@ +56,5 @@\n> +// TODO philikon wants a better name. what is it?\n> +const SESSION_STATE_COLLECTION = \"session-states\";\n> +\n> +// TODO verify this TTL is appropriate\n> +const SESSION_STATE_TTL = 604800; // 7 days\n\nTAB_STATE_TTL.\n\n@@ +76,5 @@\n> +  * It is used by the send tab command. Tab states are stored in their own\n> +  * collection because they could be large and could exhaust space in the\n> +  * clients record.\n> +  */\n> +function SessionStateRec(collection, id) {\n\nSendTabRecord.\n\n@@ +179,5 @@\n>  \n> +  // We override the default implementation to additionally upload tab state\n> +  // records.\n> +  _uploadOutgoing: function _uploadOutgoing() {\n> +    SyncEngine.prototype._uploadOutgoing.call(this);\n\nI think this is backward.\n\nAccording to my reading of this, what you do is:\n\n* Upload commands by invoking the prototype method.\n* Attempt to upload tab state records.\n\nSo, what happens when you upload a bunch of tab open requests, take five minutes to upload the tab state payload for the first, and the other client processes the commands in the mean time? Oops.\n\nThis takes careful handling.\n\nYou don't want to upload a command record without the tab state having been uploaded. We have a failed-record system; use it.\n\nHowever, you don't want to stall the processing of other commands while you wait for tab state to upload, perhaps unsuccessfully (for quota reasons).\n\nA few possible remediations for this:\n\n* Upload non-dependent commands, then process the dependent commands one by one, attempting to send the tab data for each prior to sending the command.\n* Similar, but batch the tab data and cross your fingers.\n* Do what you do now, but have the consumer queue the command and try again later if it gets a 404 fetching the tab state.\n\n@@ +186,5 @@\n> +      return;\n> +    }\n> +\n> +    let collection = new Collection(\n> +      this.storageURL + SESSION_STATE_COLLECTION);\n\nIf you look in engines.js, you'll see an idiom like this:\n\n  get cryptoKeysURL() this.storageURL + \"crypto/keys\",\n\nI suggest you do something similar, so you can say\n\n  let collection = new Collection(this.tabStateURL);\n\nthroughout this file.\n\n@@ +188,5 @@\n> +\n> +    let collection = new Collection(\n> +      this.storageURL + SESSION_STATE_COLLECTION);\n> +\n> +    // TODO limit upload to N records at a time?\n\nYes. See engines.js:1138; MAX_UPLOAD_RECORDS.\n\n@@ +194,5 @@\n> +      let [ttl, state] = v;\n> +\n> +      let record = new SessionStateRec(guid, SESSION_STATE_COLLECTION);\n> +      // TODO [gps] I thought .id was populated automagically by the ctor? The\n> +      // fake HTTP server doesn't like it unless the next line is defined. Huh?\n\nDefine \"doesn't like it\"?\n\nDid you write a trivial test that instantiates a SessionStateRec and pokes .id?\n\nIt certainly looks like the constructors chain appropriately. It's possible that there's a bug; I see CryptoWrapper also sets .id itself.\n\nNote that your hackery should be inside the SessionStateRec ctor in any case...\n\n@@ +205,5 @@\n> +      collection.pushData(record);\n> +    }\n> +\n> +    // TODO probably need error checking on this. What's appropriate?\n> +    collection.post();\n\nThe idiom goes something like\n\n        let resp = collection.post();\n        if (!resp.success) {\n          this._log.debug(\"Uploading records failed: \" + resp);\n          resp.failureCode = ENGINE_UPLOAD_FAIL;\n          throw resp;\n        }\n\nbut ask philikon if his SyncError stuff is ready yet.\n\n@@ +214,1 @@\n>    // Always process incoming items because they might have commands\n\nWhile you're here, add a '.' to these evil fragmented comments.\n\n@@ +453,5 @@\n> +   * record in another collection being created. This record is only\n> +   * referenced in the command. It is protected against orphanage by a\n> +   * server-side expiration TTL.\n> +   *\n> +   * Session state (as obtained from NSISessionStore) may optionally be sent\n\ns/NS/ns.\n\nThis is not NeXTSTEP :)\n\n@@ +454,5 @@\n> +   * referenced in the command. It is protected against orphanage by a\n> +   * server-side expiration TTL.\n> +   *\n> +   * Session state (as obtained from NSISessionStore) may optionally be sent\n> +   * with the command. Session state may vary between application types (e.g.\n\n\u2026 tab state. This applies throughout.\n\n@@ +457,5 @@\n> +   * Session state (as obtained from NSISessionStore) may optionally be sent\n> +   * with the command. Session state may vary between application types (e.g.\n> +   * desktop vs. mobile). This function currently sends along the local client\n> +   * ID as part of the command. The receiver can infer the session state format\n> +   * by looking up the sender's type by its ID.\n\n*Scooby Doo impression*\n\nNope. Define a record format that includes the information you need to build a tab on any device. Sync needs to be device agnostic; a dump of an object isn't adequate.\n\nJust think: the alternative is that you send a mobile record to a desktop, and the *desktop* needs to know how to do the translation. Now you've got N*M*V translations (for each pairwise translation of client types and versions), rather than N translations to a common format.\n\n@@ +460,5 @@\n> +   * ID as part of the command. The receiver can infer the session state format\n> +   * by looking up the sender's type by its ID.\n> +   *\n> +   * @param uri\n> +   *        String URI to send to the remote client\n\n'.'\n\n@@ +467,5 @@\n> +   * @param options\n> +   *        Object containing metadata to control how sending works. Can\n> +   *        contain the following keys:\n> +   *          sessionState - Tab's session state (as obtained from\n> +   *          NSISessionStore). If not defined, no session state is sent.\n\ns/NS/ns\n\n@@ +478,5 @@\n> +\n> +    options = options || {};\n> +\n> +    if (!(\"ttl\" in options)) {\n> +      options.ttl = SESSION_STATE_TTL;\n\nPerhaps call this DEFAULT_TAB_STATE_TTL, then?\n\n@@ +481,5 @@\n> +    if (!(\"ttl\" in options)) {\n> +      options.ttl = SESSION_STATE_TTL;\n> +    }\n> +\n> +    let args = {uri: uri, senderID: this.localID};\n\nSplit line, please. It'll grow\u2026\n\n@@ +490,5 @@\n> +    // record, outside of the clients collection.\n> +    if (\"sessionState\" in options) {\n> +      let guid = Utils.makeGUID();\n> +      args.stateID = guid;\n> +      this._store._outgoingTabStateRecords[guid] = [options.ttl, options.sessionState];\n\nWhy did you elect to use an array here instead of an object? Just pass options!\n\n@@ +508,5 @@\n> +    // Commands may or may not have tab state. If they do, it is stored in a\n> +    // foreign record, which we'll need to fetch.\n> +    if (\"stateID\" in args) {\n> +      let record = new SessionStateRec(SESSION_STATE_COLLECTION, args.stateID);\n> +      let uri = this.storageURL + SESSION_STATE_COLLECTION + \"/\"\n\nAgain, this.tabStateURL.\n\n@@ +513,5 @@\n> +                + args.stateID;\n> +\n> +      this._log.debug(\"Fetching remote record from: \" + uri);\n> +\n> +      // This is synchronous, but spins the event loop. It also throws on\n\ns/but/and!\n\n@@ +514,5 @@\n> +\n> +      this._log.debug(\"Fetching remote record from: \" + uri);\n> +\n> +      // This is synchronous, but spins the event loop. It also throws on\n> +      // error.\n\nI don't believe it does.\n\n  // Get thyself from your URI, then deserialize.\n  // Set thine 'response' field.\n  fetch: function fetch(uri) {\n    let r = new Resource(uri).get();\n    if (r.success) {\n      this.deserialize(r);   // Warning! Muffles exceptions!\n    }\n    this.response = r;\n    return this;\n  },\n\nResource.get() will throw in some circumstances, but not a 404:\n\n--\n[21:30:57.706] new (Components.utils.import(\"resource://services-sync/resource.js\").Resource)(\"http://twinql.com/40440400000\").get().status;\n[21:30:57.852] 404\n\nYou definitely want to check for success here... and then you have to decide what happens when you can't get the data for a command!\n\n@@ +522,5 @@\n> +      state = record.sessionState;\n> +      this._log.debug(\"Received tab state record: \" + args.stateID);\n> +\n> +      // TODO what do we do about the record? do we let the server auto-expire?\n> +      // Do we perform an async delete?\n\nGood question. Are they ever shared between commands? How big are they?\n\nIf a user is sending 5 tabs per day, and each one carries 1MB of encrypted+base64ed+JSONified data, he's going to hit his quota by Friday.\n\nIn that case you definitely need to consider cleanup. Something like accumulating the IDs and doing a batched async (RESTRequest) DELETE with ids= at the end of a sync would suffice, mm?\n\n@@ +540,5 @@\n>  }\n>  ClientStore.prototype = {\n>    __proto__: Store.prototype,\n>  \n> +  // Holds tab state records for \"displayTab\" commands that haven't been sent\n\n\"haven't yet been sent.\"\n\n@@ +541,5 @@\n>  ClientStore.prototype = {\n>    __proto__: Store.prototype,\n>  \n> +  // Holds tab state records for \"displayTab\" commands that haven't been sent\n> +  // yet. Record ID -> payload object\n\n'.'\n\n@@ +548,1 @@\n>    create: function create(record) this.update(record),\n\nPlease use explicit  { return ...; }. It'll make Emacs happy.\n\n@@ +548,3 @@\n>    create: function create(record) this.update(record),\n>  \n>    update: function update(record) {\n\nPlease fix this while you're here: brackets and cuddling and such.\n\nYou get extra points if you clean up and make the whole file follow coding standards in a part 0, but I am aware of the awfulness of rebase hell if you try to do that with hg mq, so a part 2 is fine :)\n\n@@ +581,5 @@\n>    },\n>  \n>    wipe: function wipe() {\n> +    this._remoteClients           = {};\n> +    this._outgoingTabStateRecords = {};\n\n<3 indenting.\n\n::: services/sync/tests/unit/test_clients_engine.js\n@@ +797,5 @@\n> +  do_check_true(Clients.processIncomingCommands());\n> +});\n> +\n> +// TODO add test for multiple send tab commands in one go\n> +// TODO add test exercising failures in tab state record upload and download\n\nYes.\n\nI am curious about the error strategy here.", "creation_time": "2011-10-04T04:33:55Z", "bug_id": 686704, "count": 12, "is_private": false, "tags": [], "id": 5756472, "creator": "bugzilla@twinql.com", "author": "bugzilla@twinql.com"}, {"creation_time": "2011-10-04T19:04:46Z", "raw_text": "I found another bug:\n\nin sendTabToClient(), we create the outgoing state record before we send the command. If there is an error sending the command (unknown client ID, perhaps), we are left with an orphaned tab state record which gets uploaded on next sync.", "text": "I found another bug:\n\nin sendTabToClient(), we create the outgoing state record before we send the command. If there is an error sending the command (unknown client ID, perhaps), we are left with an orphaned tab state record which gets uploaded on next sync.", "attachment_id": null, "time": "2011-10-04T19:04:46Z", "tags": [], "is_private": false, "count": 13, "id": 5758187, "bug_id": 686704, "creator": "gps@mozilla.com", "author": "gps@mozilla.com"}, {"creator": "gps@mozilla.com", "author": "gps@mozilla.com", "creation_time": "2011-10-04T21:51:07Z", "raw_text": "(In reply to Richard Newman [:rnewman] from comment #12)\n> @@ +179,5 @@\n> >  \n> > +  // We override the default implementation to additionally upload tab state\n> > +  // records.\n> > +  _uploadOutgoing: function _uploadOutgoing() {\n> > +    SyncEngine.prototype._uploadOutgoing.call(this);\n> So, what happens when you upload a bunch of tab open requests, take five\n> minutes to upload the tab state payload for the first, and the other client\n> processes the commands in the mean time? Oops.\n\nGood observation!\n \n> A few possible remediations for this:\n>\n> * Upload non-dependent commands, then process the dependent commands one by\n> one, attempting to send the tab data for each prior to sending the command.\n\nUnfortunately, commands are all in one array in the client record. So, correct me if I'm wrong, but if we do this approach, we have a race condition between the sending client uploading the \"displayTab\" commands and the receiving client(s) uploading the record signifying they processed the original, non-displayTab commands which the sending client already sent during that sync.\n\n> * Similar, but batch the tab data and cross your fingers.\n\nAre you suggesting batching the clients and tab data collection data? I already batch the tab data records in one POST. I don't think it is possible to modify 2 collections in one HTTP request.\n\n> * Do what you do now, but have the consumer queue the command and try again\n> later if it gets a 404 fetching the tab state.\n\nThat's a possibility without too much controversy. Easy enough to implement with timers and callbacks too.\n\n> However, you don't want to stall the processing of other commands while you\n> wait for tab state to upload, perhaps unsuccessfully (for quota reasons).\n\nIs this really that large of an issue? When the user initiates a send tab command, that will incur a sync via score trigger. Is it not safe to assume then that the syncs transferring send tab commands will be transferring this data and none other (at least for the vast majority of the time)? One exception is the case where send tab is initiated and the Sync server is unavailable. What are the others? Do we care? We have other sync scheduling issues today and we don't care too much about them (at least the bugs aren't resolved). Is this one warranting the extra level of scrutiny?\n\n(I'm just throwing ideas out here. I don't have a solid opinion yet.)\n\n> @@ +194,5 @@\n> > +      let [ttl, state] = v;\n> > +\n> > +      let record = new SessionStateRec(guid, SESSION_STATE_COLLECTION);\n> > +      // TODO [gps] I thought .id was populated automagically by the ctor? The\n> > +      // fake HTTP server doesn't like it unless the next line is defined. Huh?\n> \n> Define \"doesn't like it\"?\n> \n> Did you write a trivial test that instantiates a SessionStateRec and pokes\n> .id?\n> \n> It certainly looks like the constructors chain appropriately. It's possible\n> that there's a bug; I see CryptoWrapper also sets .id itself.\n\nThe problems I encountered manifested in the test code. The test HTTP server (the new one) didn't like the POST to a collection URI. It auto-created a WBO at a collection URI or something. I'll poke around to identify the root.\n\n> @@ +490,5 @@\n> > +    // record, outside of the clients collection.\n> > +    if (\"sessionState\" in options) {\n> > +      let guid = Utils.makeGUID();\n> > +      args.stateID = guid;\n> > +      this._store._outgoingTabStateRecords[guid] = [options.ttl, options.sessionState];\n> \n> Why did you elect to use an array here instead of an object? Just pass\n> options!\n\nYeah, this is my low-level background manifesting. I surely can throw an object around.\n  \n> @@ +514,5 @@\n> > +\n> > +      this._log.debug(\"Fetching remote record from: \" + uri);\n> > +\n> > +      // This is synchronous, but spins the event loop. It also throws on\n> > +      // error.\n> \n> I don't believe it does.\n> \n>   // Get thyself from your URI, then deserialize.\n>   // Set thine 'response' field.\n>   fetch: function fetch(uri) {\n>     let r = new Resource(uri).get();\n>     if (r.success) {\n>       this.deserialize(r);   // Warning! Muffles exceptions!\n>     }\n>     this.response = r;\n>     return this;\n>   },\n\nGo down the rabbit hole and you will find that Resource.get() calls Resource._request() which calls AsyncResource._doRequest() while spinning the event loop.\n\n> @@ +522,5 @@\n> > +      state = record.sessionState;\n> > +      this._log.debug(\"Received tab state record: \" + args.stateID);\n> > +\n> > +      // TODO what do we do about the record? do we let the server auto-expire?\n> > +      // Do we perform an async delete?\n> \n> Good question. Are they ever shared between commands? How big are they?\n> \n> If a user is sending 5 tabs per day, and each one carries 1MB of\n> encrypted+base64ed+JSONified data, he's going to hit his quota by Friday.\n> \n> In that case you definitely need to consider cleanup. Something like\n> accumulating the IDs and doing a batched async (RESTRequest) DELETE with\n> ids= at the end of a sync would suffice, mm?\n\nYeah, I definitely need to get some data on how big the state records will be. Unless we staple extra functionality out of reusing tab states, I too was thinking doing a batched async delete at the end of a sync would be best.", "text": "(In reply to Richard Newman [:rnewman] from comment #12)\n> @@ +179,5 @@\n> >  \n> > +  // We override the default implementation to additionally upload tab state\n> > +  // records.\n> > +  _uploadOutgoing: function _uploadOutgoing() {\n> > +    SyncEngine.prototype._uploadOutgoing.call(this);\n> So, what happens when you upload a bunch of tab open requests, take five\n> minutes to upload the tab state payload for the first, and the other client\n> processes the commands in the mean time? Oops.\n\nGood observation!\n \n> A few possible remediations for this:\n>\n> * Upload non-dependent commands, then process the dependent commands one by\n> one, attempting to send the tab data for each prior to sending the command.\n\nUnfortunately, commands are all in one array in the client record. So, correct me if I'm wrong, but if we do this approach, we have a race condition between the sending client uploading the \"displayTab\" commands and the receiving client(s) uploading the record signifying they processed the original, non-displayTab commands which the sending client already sent during that sync.\n\n> * Similar, but batch the tab data and cross your fingers.\n\nAre you suggesting batching the clients and tab data collection data? I already batch the tab data records in one POST. I don't think it is possible to modify 2 collections in one HTTP request.\n\n> * Do what you do now, but have the consumer queue the command and try again\n> later if it gets a 404 fetching the tab state.\n\nThat's a possibility without too much controversy. Easy enough to implement with timers and callbacks too.\n\n> However, you don't want to stall the processing of other commands while you\n> wait for tab state to upload, perhaps unsuccessfully (for quota reasons).\n\nIs this really that large of an issue? When the user initiates a send tab command, that will incur a sync via score trigger. Is it not safe to assume then that the syncs transferring send tab commands will be transferring this data and none other (at least for the vast majority of the time)? One exception is the case where send tab is initiated and the Sync server is unavailable. What are the others? Do we care? We have other sync scheduling issues today and we don't care too much about them (at least the bugs aren't resolved). Is this one warranting the extra level of scrutiny?\n\n(I'm just throwing ideas out here. I don't have a solid opinion yet.)\n\n> @@ +194,5 @@\n> > +      let [ttl, state] = v;\n> > +\n> > +      let record = new SessionStateRec(guid, SESSION_STATE_COLLECTION);\n> > +      // TODO [gps] I thought .id was populated automagically by the ctor? The\n> > +      // fake HTTP server doesn't like it unless the next line is defined. Huh?\n> \n> Define \"doesn't like it\"?\n> \n> Did you write a trivial test that instantiates a SessionStateRec and pokes\n> .id?\n> \n> It certainly looks like the constructors chain appropriately. It's possible\n> that there's a bug; I see CryptoWrapper also sets .id itself.\n\nThe problems I encountered manifested in the test code. The test HTTP server (the new one) didn't like the POST to a collection URI. It auto-created a WBO at a collection URI or something. I'll poke around to identify the root.\n\n> @@ +490,5 @@\n> > +    // record, outside of the clients collection.\n> > +    if (\"sessionState\" in options) {\n> > +      let guid = Utils.makeGUID();\n> > +      args.stateID = guid;\n> > +      this._store._outgoingTabStateRecords[guid] = [options.ttl, options.sessionState];\n> \n> Why did you elect to use an array here instead of an object? Just pass\n> options!\n\nYeah, this is my low-level background manifesting. I surely can throw an object around.\n  \n> @@ +514,5 @@\n> > +\n> > +      this._log.debug(\"Fetching remote record from: \" + uri);\n> > +\n> > +      // This is synchronous, but spins the event loop. It also throws on\n> > +      // error.\n> \n> I don't believe it does.\n> \n>   // Get thyself from your URI, then deserialize.\n>   // Set thine 'response' field.\n>   fetch: function fetch(uri) {\n>     let r = new Resource(uri).get();\n>     if (r.success) {\n>       this.deserialize(r);   // Warning! Muffles exceptions!\n>     }\n>     this.response = r;\n>     return this;\n>   },\n\nGo down the rabbit hole and you will find that Resource.get() calls Resource._request() which calls AsyncResource._doRequest() while spinning the event loop.\n\n> @@ +522,5 @@\n> > +      state = record.sessionState;\n> > +      this._log.debug(\"Received tab state record: \" + args.stateID);\n> > +\n> > +      // TODO what do we do about the record? do we let the server auto-expire?\n> > +      // Do we perform an async delete?\n> \n> Good question. Are they ever shared between commands? How big are they?\n> \n> If a user is sending 5 tabs per day, and each one carries 1MB of\n> encrypted+base64ed+JSONified data, he's going to hit his quota by Friday.\n> \n> In that case you definitely need to consider cleanup. Something like\n> accumulating the IDs and doing a batched async (RESTRequest) DELETE with\n> ids= at the end of a sync would suffice, mm?\n\nYeah, I definitely need to get some data on how big the state records will be. Unless we staple extra functionality out of reusing tab states, I too was thinking doing a batched async delete at the end of a sync would be best.", "time": "2011-10-04T21:51:07Z", "attachment_id": null, "is_private": false, "count": 14, "tags": [], "id": 5758726, "bug_id": 686704}, {"author": "gps@mozilla.com", "creator": "gps@mozilla.com", "bug_id": 686704, "id": 5773336, "tags": [], "count": 15, "is_private": false, "attachment_id": 566095, "time": "2011-10-11T00:47:40Z", "text": "Created attachment 566095\nPart 1: add APIs to engines to define collections\n\nWhen we add the \"sendtab\" collection to Clients, this will necessitate some extra logic for wiping multiple collections registered to one engine. This patch provides that functionality. It is a little more complicated than I would like because the Clients engine is special and not treated as part of the regular set of engines by EngineManagerSvc. But, there's not much getting around that.", "creation_time": "2011-10-11T00:47:40Z", "raw_text": "When we add the \"sendtab\" collection to Clients, this will necessitate some extra logic for wiping multiple collections registered to one engine. This patch provides that functionality. It is a little more complicated than I would like because the Clients engine is special and not treated as part of the regular set of engines by EngineManagerSvc. But, there's not much getting around that."}, {"creator": "bugzilla@twinql.com", "author": "bugzilla@twinql.com", "tags": [], "is_private": false, "count": 16, "id": 5778814, "bug_id": 686704, "creation_time": "2011-10-12T22:15:20Z", "raw_text": "Review of attachment 566095:\n-----------------------------------------------------------------\n\nNeeds to be re-interpreted on top of Bug 684798, which will make this simpler.\n\n::: services/sync/modules/engines.js\n@@ +430,5 @@\n> +\n> +  /**\n> +   * Returns an array of all the names of collections belonging to all engines.\n> +   */\n> +  get allCollectionNames() {\n\nYou can eliminate this.\n\n@@ +450,5 @@\n> +    let collections = [];\n> +    for each (let engine in this.getAll()) {\n> +      for each (let collection in engine.wipeCollectionNames) {\n> +        collections.push(collection);\n> +      }\n\nAnd this.\n\n@@ +619,5 @@\n>      Svc.Prefs.set(this.name + \".syncID\", value);\n>    },\n>  \n> +  /**\n> +   * Returns an array of all collections this engine is responsible for.\n\n\"for which this engine is responsible.\"\n\nYou should document that either (a) this returns a new array each time, suitable for mutating, or (b) the array should be treated as immutable.\n\n@@ +621,5 @@\n>  \n> +  /**\n> +   * Returns an array of all collections this engine is responsible for.\n> +   *\n> +   * This set is used for determining what server collections to wipe when\n\ns/what/which.\n\n@@ +622,5 @@\n> +  /**\n> +   * Returns an array of all collections this engine is responsible for.\n> +   *\n> +   * This set is used for determining what server collections to wipe when\n> +   * clearing all server data, for example.\n\ns/for example//\n\n@@ +624,5 @@\n> +   *\n> +   * This set is used for determining what server collections to wipe when\n> +   * clearing all server data, for example.\n> +   */\n> +  get allCollectionNames() {\n\nWhat's wrong with \"collections\" here?\n\n  Engines.get(\"bookmarks\").collections;\n\nseems much neater than\n\n  Engines.get(\"bookmarks\").allCollectionNames;\n\n@@ +636,5 @@\n> +   * This is typically the same as allCollectionNames. It is only different in\n> +   * specific circumstances, such as the Clients engine/collection, which is\n> +   * treated specially.\n> +   */\n> +  get wipeCollectionNames() {\n\n\u2026 and here, \"collectionsToWipe\". \"wipeCollections\" sounds like verb + noun, which implies that you're going to wipe the collections.\n\n@@ +774,5 @@\n>  \n>      // Delete any existing data and reupload on bad version or missing meta.\n>      // No crypto component here...? We could regenerate per-collection keys...\n>      if (needsWipe) {\n> +      this.wipeServer();\n\nI believe this will conflict with changes in current s-c, because we already fixed this.\n\n::: services/sync/modules/service.js\n@@ +1569,5 @@\n>      Records.set(this.metaURL, meta);\n>  \n>      // Wipe everything we know about except meta because we just uploaded it\n> +    let names = Clients.allCollectionNames.concat(Engines.allCollectionNames);\n> +    this.wipeServer(names);\n\nThis was just changed in another patch; we now DELETE /storage instead, and do it before meta/global. You can remove this, which is why EngineManagerSvc no longer needs to care about this stuff.", "text": "Comment on attachment 566095\nPart 1: add APIs to engines to define collections\n\nReview of attachment 566095:\n-----------------------------------------------------------------\n\nNeeds to be re-interpreted on top of Bug 684798, which will make this simpler.\n\n::: services/sync/modules/engines.js\n@@ +430,5 @@\n> +\n> +  /**\n> +   * Returns an array of all the names of collections belonging to all engines.\n> +   */\n> +  get allCollectionNames() {\n\nYou can eliminate this.\n\n@@ +450,5 @@\n> +    let collections = [];\n> +    for each (let engine in this.getAll()) {\n> +      for each (let collection in engine.wipeCollectionNames) {\n> +        collections.push(collection);\n> +      }\n\nAnd this.\n\n@@ +619,5 @@\n>      Svc.Prefs.set(this.name + \".syncID\", value);\n>    },\n>  \n> +  /**\n> +   * Returns an array of all collections this engine is responsible for.\n\n\"for which this engine is responsible.\"\n\nYou should document that either (a) this returns a new array each time, suitable for mutating, or (b) the array should be treated as immutable.\n\n@@ +621,5 @@\n>  \n> +  /**\n> +   * Returns an array of all collections this engine is responsible for.\n> +   *\n> +   * This set is used for determining what server collections to wipe when\n\ns/what/which.\n\n@@ +622,5 @@\n> +  /**\n> +   * Returns an array of all collections this engine is responsible for.\n> +   *\n> +   * This set is used for determining what server collections to wipe when\n> +   * clearing all server data, for example.\n\ns/for example//\n\n@@ +624,5 @@\n> +   *\n> +   * This set is used for determining what server collections to wipe when\n> +   * clearing all server data, for example.\n> +   */\n> +  get allCollectionNames() {\n\nWhat's wrong with \"collections\" here?\n\n  Engines.get(\"bookmarks\").collections;\n\nseems much neater than\n\n  Engines.get(\"bookmarks\").allCollectionNames;\n\n@@ +636,5 @@\n> +   * This is typically the same as allCollectionNames. It is only different in\n> +   * specific circumstances, such as the Clients engine/collection, which is\n> +   * treated specially.\n> +   */\n> +  get wipeCollectionNames() {\n\n\u2026 and here, \"collectionsToWipe\". \"wipeCollections\" sounds like verb + noun, which implies that you're going to wipe the collections.\n\n@@ +774,5 @@\n>  \n>      // Delete any existing data and reupload on bad version or missing meta.\n>      // No crypto component here...? We could regenerate per-collection keys...\n>      if (needsWipe) {\n> +      this.wipeServer();\n\nI believe this will conflict with changes in current s-c, because we already fixed this.\n\n::: services/sync/modules/service.js\n@@ +1569,5 @@\n>      Records.set(this.metaURL, meta);\n>  \n>      // Wipe everything we know about except meta because we just uploaded it\n> +    let names = Clients.allCollectionNames.concat(Engines.allCollectionNames);\n> +    this.wipeServer(names);\n\nThis was just changed in another patch; we now DELETE /storage instead, and do it before meta/global. You can remove this, which is why EngineManagerSvc no longer needs to care about this stuff.", "attachment_id": 566095, "time": "2011-10-12T22:15:20Z"}, {"creation_time": "2011-11-04T22:28:53Z", "raw_text": "Here is the core clients engine code to support the \"displayTab\" command. It requires the patch in bug 699631 to work properly. There are a few TODO items, so I'm expecting r-. Other than that, please bit nitpicky.\n\nThe overall patch will be split into 3 components:\n\n1) Core clients engine support for sending tabs, with tab state (this patch)\n2) \"middleware\" JS to actually assemble and restore tab state to/from browser objects on desktop and mobile\n3) UX hooking into above\n\nI'm designing the patches such that they are built on top of each other. 3 requires 2 requires 1. I would prefer to check in patches as they are available to prevent bit rot. I can't guarantee we won't revisit the previous patches when implementing the latter phases. But, I think it's best to make progress and land stuff.", "text": "Created attachment 572101\nImplement \"displayTab\" command, v2\n\nHere is the core clients engine code to support the \"displayTab\" command. It requires the patch in bug 699631 to work properly. There are a few TODO items, so I'm expecting r-. Other than that, please bit nitpicky.\n\nThe overall patch will be split into 3 components:\n\n1) Core clients engine support for sending tabs, with tab state (this patch)\n2) \"middleware\" JS to actually assemble and restore tab state to/from browser objects on desktop and mobile\n3) UX hooking into above\n\nI'm designing the patches such that they are built on top of each other. 3 requires 2 requires 1. I would prefer to check in patches as they are available to prevent bit rot. I can't guarantee we won't revisit the previous patches when implementing the latter phases. But, I think it's best to make progress and land stuff.", "attachment_id": 572101, "time": "2011-11-04T22:28:53Z", "tags": [], "count": 17, "is_private": false, "id": 5827660, "bug_id": 686704, "creator": "gps@mozilla.com", "author": "gps@mozilla.com"}, {"time": "2011-11-07T08:30:10Z", "attachment_id": 572101, "text": "Comment on attachment 572101\nImplement \"displayTab\" command, v2\n\nReview of attachment 572101:\n-----------------------------------------------------------------\n\nSome nits and some broader questions to address.\n\n\nNit: \n\n  hg qref -m \"Bug 686704 - Send Tab to Device: support for displayTab command in clients engine. r=rnewman\n\n::: services/sync/modules/engines/clients.js\n@@ +53,4 @@\n>  const CLIENTS_TTL = 1814400; // 21 days\n>  const CLIENTS_TTL_REFRESH = 604800; // 7 days\n>  \n> +const TAB_STATE_COLLECTION = \"sendtab\";\n\nWhat's wrong with \"tabstate\"?\n\n@@ +55,5 @@\n>  \n> +const TAB_STATE_COLLECTION = \"sendtab\";\n> +\n> +// TODO verify TTL is appropriate\n> +const DEFAULT_TAB_STATE_TTL = 604800; // 7 days\n\nNot sure that \"verify\" is the right word here :)\n\n\"Decide\" is more accurate!\n\nI would suggest that, given that we delete records after processing the command, a fairly long value is acceptable. Whether 7 days counts as \"fairly long\" is debatable.\n\nI encourage you to simply make an informed decision here, and justify your working in a brief comment (either in the code or in the bug).\n\n@@ +75,5 @@\n> +  * It is used by the send tab command. Tab states are stored in their own\n> +  * collection because they could be large and could exhaust space in the\n> +  * clients record.\n> +  */\n> +function SendTabRecord(collection, id) {\n\nSo if this is the record for individual tab states, why isn't it called TabStateRecord?\n\n@@ +179,5 @@\n> +\n> +  /**\n> +   * Obtain the URL of the tab state collection.\n> +   *\n> +   * @return string\n\nCapitalize string for consistency.\n\n@@ +183,5 @@\n> +   * @return string\n> +   *         URI to tabstate collection.\n> +   */\n> +  get tabStateURL() {\n> +    return this.storageURL + TAB_STATE_COLLECTION;\n\nNit: be consistent. URL or URI.\n\n@@ +206,5 @@\n> +  // records.\n> +  _uploadOutgoing: function _uploadOutgoing() {\n> +    // We upload the tab state records first because there could be a race\n> +    // condition between another client processing the command to pull the\n> +    // state and this client uploading the records.\n\n*gasps for breath*\n\nHow about:\n\n  // There might be a race condition between our upload of tab state records\n  // and another client processing the command to fetch them.\n  // Upload the tab state records first to avoid this.\n\n@@ +216,5 @@\n> +    if (!Object.keys(this._store._outgoingSendTabRecords).length) {\n> +      return;\n> +    }\n> +\n> +    let getTabRecord = function(id) {\n\nfunction getTabRecord(id) {\n\nAdd a comment that this will be invoked with `this` bound to the engine.\n\n@@ +228,5 @@\n> +      return record;\n> +    };\n> +\n> +    // The value of lastSync is irrelevant.\n> +    let result = this._uploadOutgoingRecords(\n\n\"_uploadTabStateRecords\" (see earlier remark).\n\n@@ +232,5 @@\n> +    let result = this._uploadOutgoingRecords(\n> +      Object.keys(this._store._outgoingSendTabRecords),\n> +      this.tabStateURL,\n> +      this.lastSync,\n> +      getTabRecord\n\nUgh, so misshapen. Can't wait to rip out the old engine code.\n\n@@ +237,5 @@\n> +    );\n> +\n> +    // Technically we should only wipe out records which were successfully\n> +    // uploaded. But with tab state, we have one shot at it. If it doesn't\n> +    // work, we move forward.\n\nWhat are the consequences?\n\nPerhaps more importantly, uploading records returns an object that includes failed IDs. Why don't you use that?\n\n@@ +473,5 @@\n>      Svc.Obs.notify(\"weave:engine:clients:display-uri\", subject);\n> +  },\n> +\n> +  /**\n> +   * Sends a tab to another client as a new tab.\n\nLast four words are either redundant or inaccurate (e.g., if the client decides a tab is already open).\n\n@@ +484,5 @@\n> +   * record in another collection being created. This record is only\n> +   * referenced in the command. It is protected against orphanage by a\n> +   * server-side expiration TTL.\n> +   *\n> +   * Tab state may is a complicated beast. As far as this API is concerned,\n\ns/may //\n\n@@ +486,5 @@\n> +   * server-side expiration TTL.\n> +   *\n> +   * Tab state may is a complicated beast. As far as this API is concerned,\n> +   * tab state is treated as a black box. However, various clients expect\n> +   * a specific format. ext/TabState.js contains the code for interacting\n\nErr, I don't think this is true, mm?\n\n@@ +507,5 @@\n> +\n> +    options = options || {};\n> +\n> +    if (!(\"ttl\" in options)) {\n> +      options.ttl = DEFAULT_TAB_STATE_TTL;\n\nY'know you're mutating an input object here, right? Don't do that. Unpack the input options into named `let`s.\n\n@@ +552,5 @@\n> +   *\n> +   *   uri      - string URI to display\n> +   *   tabState - Object defining tab state. May not be defined. The tab state\n> +   *              should be treated as a black box. The format is not\n> +   *              well-defined outside the Clients engine at this time.\n\nIt's OK for this set of methods to ignore the contents of tab state, but \"should\" implies that the caller should, too. Rephrase to clarify intent.\n\n@@ +559,5 @@\n> +   * In Firefox, the notification is handled by BrowserGlue. The handler then\n> +   * calls back into this engine (restoreTab) with the subject object and a\n> +   * browser instance and the tab is restored. This may seem like a very\n> +   * roundabout way of doing things. However, the alternative is UI code would\n> +   * be tightly integrated with Sync, which is theoretically supposed to remain\n\ns/theoretically //\n\n@@ +560,5 @@\n> +   * calls back into this engine (restoreTab) with the subject object and a\n> +   * browser instance and the tab is restored. This may seem like a very\n> +   * roundabout way of doing things. However, the alternative is UI code would\n> +   * be tightly integrated with Sync, which is theoretically supposed to remain\n> +   * application agnostic.\n\nHyphenated phrase.\n\n@@ +577,5 @@\n> +      this._log.debug(\"Fetching remote record from: \" + uri);\n> +\n> +      // This is synchronous and spins the event loop. It also throws on\n> +      // some errors.\n> +      record.fetch(uri);\n\nIf so, then now so does processIncomingCommands. Do you want this to throw if fetching throws, or to proceed on?\n\n@@ +580,5 @@\n> +      // some errors.\n> +      record.fetch(uri);\n> +\n> +      // TODO is this the best way to test for properly fetched record?\n> +      if (record.ciphertext) {\n\nrecord.response.success, for the basics. But checking for ciphertext (and IV and hmac!) is fine.\n\n@@ +581,5 @@\n> +      record.fetch(uri);\n> +\n> +      // TODO is this the best way to test for properly fetched record?\n> +      if (record.ciphertext) {\n> +        record.decrypt();\n\ndecrypt() can throw. Beyond that, we generally assume that records which decrypt successfully will be well-formed.\n\nI would be inclined to wrap the whole fetch/decrypt/process section in a try\u2026catch, and just allow decrypt to throw on missing ciphertext as well as other failures.\n\n@@ +588,5 @@\n> +\n> +        // Issue an async delete request for the resource. We don't care\n> +        // what the response is.\n> +        let resource = new AsyncResource(uri);\n> +        resource.delete(function() {});\n\nYou can roll those two lines together.\n\n::: services/sync/tests/unit/test_clients_sendtab.js\n@@ +14,5 @@\n> +  let users = {};\n> +  users[username] = password;\n> +  return serverForUsers(users, {\n> +    meta: {global: {engines: {\n> +      clients: {version: Clients.version, syncID: Clients.syncID}\n\nmeta: {\n  global: {\n    engines: {\n      clients: {version: Clients.version,\n                syncID: Clients.syncID\n      }\n    }\n  }\n}\n\nYeah, I know.\n\n@@ +23,5 @@\n> +\n> +function configure_client_and_get_server(username) {\n> +  const password = \"password\";\n> +\n> +  Svc.Prefs.set(\"clusterURL\", \"http://localhost:8080/\");\n\nSet serverURL first. (See Bug 700071 for why.)\n\n@@ +47,5 @@\n> +  else {\n> +    run_next_test();\n> +  }\n> +\n> +  // We never get here.\n\nYes we do. It's just that it ends our current event loop cycle without doing anything else of note.\n\nKill this comment :)\n\n@@ +51,5 @@\n> +  // We never get here.\n> +}\n> +\n> +add_test(function test_send_tab_to_client() {\n> +  _(\"Ensure sendURIToClient() sends commands properly.\");\n\nEither the name of the function or the comment is wrong\u2026\n\n@@ +448,5 @@\n> +function run_test() {\n> +  initTestLogging(\"Trace\");\n> +  Log4Moz.repository.getLogger(\"Sync.Engine.Clients\").level = Log4Moz.Level.Trace;\n> +  run_next_test();\n> +}\n\nCould you move run_test to be in front of all of the add_tests? Makes appending later much easier.", "raw_text": "Review of attachment 572101:\n-----------------------------------------------------------------\n\nSome nits and some broader questions to address.\n\n\nNit: \n\n  hg qref -m \"Bug 686704 - Send Tab to Device: support for displayTab command in clients engine. r=rnewman\n\n::: services/sync/modules/engines/clients.js\n@@ +53,4 @@\n>  const CLIENTS_TTL = 1814400; // 21 days\n>  const CLIENTS_TTL_REFRESH = 604800; // 7 days\n>  \n> +const TAB_STATE_COLLECTION = \"sendtab\";\n\nWhat's wrong with \"tabstate\"?\n\n@@ +55,5 @@\n>  \n> +const TAB_STATE_COLLECTION = \"sendtab\";\n> +\n> +// TODO verify TTL is appropriate\n> +const DEFAULT_TAB_STATE_TTL = 604800; // 7 days\n\nNot sure that \"verify\" is the right word here :)\n\n\"Decide\" is more accurate!\n\nI would suggest that, given that we delete records after processing the command, a fairly long value is acceptable. Whether 7 days counts as \"fairly long\" is debatable.\n\nI encourage you to simply make an informed decision here, and justify your working in a brief comment (either in the code or in the bug).\n\n@@ +75,5 @@\n> +  * It is used by the send tab command. Tab states are stored in their own\n> +  * collection because they could be large and could exhaust space in the\n> +  * clients record.\n> +  */\n> +function SendTabRecord(collection, id) {\n\nSo if this is the record for individual tab states, why isn't it called TabStateRecord?\n\n@@ +179,5 @@\n> +\n> +  /**\n> +   * Obtain the URL of the tab state collection.\n> +   *\n> +   * @return string\n\nCapitalize string for consistency.\n\n@@ +183,5 @@\n> +   * @return string\n> +   *         URI to tabstate collection.\n> +   */\n> +  get tabStateURL() {\n> +    return this.storageURL + TAB_STATE_COLLECTION;\n\nNit: be consistent. URL or URI.\n\n@@ +206,5 @@\n> +  // records.\n> +  _uploadOutgoing: function _uploadOutgoing() {\n> +    // We upload the tab state records first because there could be a race\n> +    // condition between another client processing the command to pull the\n> +    // state and this client uploading the records.\n\n*gasps for breath*\n\nHow about:\n\n  // There might be a race condition between our upload of tab state records\n  // and another client processing the command to fetch them.\n  // Upload the tab state records first to avoid this.\n\n@@ +216,5 @@\n> +    if (!Object.keys(this._store._outgoingSendTabRecords).length) {\n> +      return;\n> +    }\n> +\n> +    let getTabRecord = function(id) {\n\nfunction getTabRecord(id) {\n\nAdd a comment that this will be invoked with `this` bound to the engine.\n\n@@ +228,5 @@\n> +      return record;\n> +    };\n> +\n> +    // The value of lastSync is irrelevant.\n> +    let result = this._uploadOutgoingRecords(\n\n\"_uploadTabStateRecords\" (see earlier remark).\n\n@@ +232,5 @@\n> +    let result = this._uploadOutgoingRecords(\n> +      Object.keys(this._store._outgoingSendTabRecords),\n> +      this.tabStateURL,\n> +      this.lastSync,\n> +      getTabRecord\n\nUgh, so misshapen. Can't wait to rip out the old engine code.\n\n@@ +237,5 @@\n> +    );\n> +\n> +    // Technically we should only wipe out records which were successfully\n> +    // uploaded. But with tab state, we have one shot at it. If it doesn't\n> +    // work, we move forward.\n\nWhat are the consequences?\n\nPerhaps more importantly, uploading records returns an object that includes failed IDs. Why don't you use that?\n\n@@ +473,5 @@\n>      Svc.Obs.notify(\"weave:engine:clients:display-uri\", subject);\n> +  },\n> +\n> +  /**\n> +   * Sends a tab to another client as a new tab.\n\nLast four words are either redundant or inaccurate (e.g., if the client decides a tab is already open).\n\n@@ +484,5 @@\n> +   * record in another collection being created. This record is only\n> +   * referenced in the command. It is protected against orphanage by a\n> +   * server-side expiration TTL.\n> +   *\n> +   * Tab state may is a complicated beast. As far as this API is concerned,\n\ns/may //\n\n@@ +486,5 @@\n> +   * server-side expiration TTL.\n> +   *\n> +   * Tab state may is a complicated beast. As far as this API is concerned,\n> +   * tab state is treated as a black box. However, various clients expect\n> +   * a specific format. ext/TabState.js contains the code for interacting\n\nErr, I don't think this is true, mm?\n\n@@ +507,5 @@\n> +\n> +    options = options || {};\n> +\n> +    if (!(\"ttl\" in options)) {\n> +      options.ttl = DEFAULT_TAB_STATE_TTL;\n\nY'know you're mutating an input object here, right? Don't do that. Unpack the input options into named `let`s.\n\n@@ +552,5 @@\n> +   *\n> +   *   uri      - string URI to display\n> +   *   tabState - Object defining tab state. May not be defined. The tab state\n> +   *              should be treated as a black box. The format is not\n> +   *              well-defined outside the Clients engine at this time.\n\nIt's OK for this set of methods to ignore the contents of tab state, but \"should\" implies that the caller should, too. Rephrase to clarify intent.\n\n@@ +559,5 @@\n> +   * In Firefox, the notification is handled by BrowserGlue. The handler then\n> +   * calls back into this engine (restoreTab) with the subject object and a\n> +   * browser instance and the tab is restored. This may seem like a very\n> +   * roundabout way of doing things. However, the alternative is UI code would\n> +   * be tightly integrated with Sync, which is theoretically supposed to remain\n\ns/theoretically //\n\n@@ +560,5 @@\n> +   * calls back into this engine (restoreTab) with the subject object and a\n> +   * browser instance and the tab is restored. This may seem like a very\n> +   * roundabout way of doing things. However, the alternative is UI code would\n> +   * be tightly integrated with Sync, which is theoretically supposed to remain\n> +   * application agnostic.\n\nHyphenated phrase.\n\n@@ +577,5 @@\n> +      this._log.debug(\"Fetching remote record from: \" + uri);\n> +\n> +      // This is synchronous and spins the event loop. It also throws on\n> +      // some errors.\n> +      record.fetch(uri);\n\nIf so, then now so does processIncomingCommands. Do you want this to throw if fetching throws, or to proceed on?\n\n@@ +580,5 @@\n> +      // some errors.\n> +      record.fetch(uri);\n> +\n> +      // TODO is this the best way to test for properly fetched record?\n> +      if (record.ciphertext) {\n\nrecord.response.success, for the basics. But checking for ciphertext (and IV and hmac!) is fine.\n\n@@ +581,5 @@\n> +      record.fetch(uri);\n> +\n> +      // TODO is this the best way to test for properly fetched record?\n> +      if (record.ciphertext) {\n> +        record.decrypt();\n\ndecrypt() can throw. Beyond that, we generally assume that records which decrypt successfully will be well-formed.\n\nI would be inclined to wrap the whole fetch/decrypt/process section in a try\u2026catch, and just allow decrypt to throw on missing ciphertext as well as other failures.\n\n@@ +588,5 @@\n> +\n> +        // Issue an async delete request for the resource. We don't care\n> +        // what the response is.\n> +        let resource = new AsyncResource(uri);\n> +        resource.delete(function() {});\n\nYou can roll those two lines together.\n\n::: services/sync/tests/unit/test_clients_sendtab.js\n@@ +14,5 @@\n> +  let users = {};\n> +  users[username] = password;\n> +  return serverForUsers(users, {\n> +    meta: {global: {engines: {\n> +      clients: {version: Clients.version, syncID: Clients.syncID}\n\nmeta: {\n  global: {\n    engines: {\n      clients: {version: Clients.version,\n                syncID: Clients.syncID\n      }\n    }\n  }\n}\n\nYeah, I know.\n\n@@ +23,5 @@\n> +\n> +function configure_client_and_get_server(username) {\n> +  const password = \"password\";\n> +\n> +  Svc.Prefs.set(\"clusterURL\", \"http://localhost:8080/\");\n\nSet serverURL first. (See Bug 700071 for why.)\n\n@@ +47,5 @@\n> +  else {\n> +    run_next_test();\n> +  }\n> +\n> +  // We never get here.\n\nYes we do. It's just that it ends our current event loop cycle without doing anything else of note.\n\nKill this comment :)\n\n@@ +51,5 @@\n> +  // We never get here.\n> +}\n> +\n> +add_test(function test_send_tab_to_client() {\n> +  _(\"Ensure sendURIToClient() sends commands properly.\");\n\nEither the name of the function or the comment is wrong\u2026\n\n@@ +448,5 @@\n> +function run_test() {\n> +  initTestLogging(\"Trace\");\n> +  Log4Moz.repository.getLogger(\"Sync.Engine.Clients\").level = Log4Moz.Level.Trace;\n> +  run_next_test();\n> +}\n\nCould you move run_test to be in front of all of the add_tests? Makes appending later much easier.", "creation_time": "2011-11-07T08:30:10Z", "bug_id": 686704, "id": 5830033, "tags": [], "is_private": false, "count": 18, "author": "bugzilla@twinql.com", "creator": "bugzilla@twinql.com"}, {"attachment_id": null, "time": "2011-11-07T21:33:48Z", "text": "(In reply to Richard Newman [:rnewman] from comment #18)\n>   hg qref -m \"Bug 686704 - Send Tab to Device: support for displayTab\n> command in clients engine. r=rnewman\n\nCreated patch from Git. I'm not bothering with the overhead of Git<->Mercurial until the patch is ready to land.\n\n> What's wrong with \"tabstate\"?\n\nSee comment #12. You are contradicting yourself!\n\n> So if this is the record for individual tab states, why isn't it called\n> TabStateRecord?\n\nSee comment #12. More contradiction.\n \n> @@ +179,5 @@\n> > +\n> > +  /**\n> > +   * Obtain the URL of the tab state collection.\n> > +   *\n> > +   * @return string\n> \n> Capitalize string for consistency.\n\nWuh? I didn't think we capitalized the types in the Javadoc-style docs unless the types themselves were capitalized.\n\n> @@ +237,5 @@\n> > +    );\n> > +\n> > +    // Technically we should only wipe out records which were successfully\n> > +    // uploaded. But with tab state, we have one shot at it. If it doesn't\n> > +    // work, we move forward.\n> \n> What are the consequences?\n> \n> Perhaps more importantly, uploading records returns an object that includes\n> failed IDs. Why don't you use that?\n\nMy implementation is much simpler and cleaner than the alternative.\n\nIf we want to differentiate between successful and failed records, this means we'd have to cancel out the commands for failed records *during* sync. This feels wrong to me. Also, if we somehow fail a tab state upload and send the command, the tab state record could be orphaned on the server for its TTL. We shouldn't do this.\n\nI think the \"best effort\" method as currently coded strikes a good balance and is conveniently also the simplest. If you insist on stapling on extra complexity, I can do that. But, I'd much prefer to wait until commands are coded properly in the next version of the clients engine to address it.\n\n> @@ +577,5 @@\n> > +      this._log.debug(\"Fetching remote record from: \" + uri);\n> > +\n> > +      // This is synchronous and spins the event loop. It also throws on\n> > +      // some errors.\n> > +      record.fetch(uri);\n> \n> If so, then now so does processIncomingCommands. Do you want this to throw\n> if fetching throws, or to proceed on?\n\nI don't know. IMO we should probably skip over failed record fetches since that is the \"SLA\" on tab state uploads (unless we decide to change that - see above).", "raw_text": "(In reply to Richard Newman [:rnewman] from comment #18)\n>   hg qref -m \"Bug 686704 - Send Tab to Device: support for displayTab\n> command in clients engine. r=rnewman\n\nCreated patch from Git. I'm not bothering with the overhead of Git<->Mercurial until the patch is ready to land.\n\n> What's wrong with \"tabstate\"?\n\nSee comment #12. You are contradicting yourself!\n\n> So if this is the record for individual tab states, why isn't it called\n> TabStateRecord?\n\nSee comment #12. More contradiction.\n \n> @@ +179,5 @@\n> > +\n> > +  /**\n> > +   * Obtain the URL of the tab state collection.\n> > +   *\n> > +   * @return string\n> \n> Capitalize string for consistency.\n\nWuh? I didn't think we capitalized the types in the Javadoc-style docs unless the types themselves were capitalized.\n\n> @@ +237,5 @@\n> > +    );\n> > +\n> > +    // Technically we should only wipe out records which were successfully\n> > +    // uploaded. But with tab state, we have one shot at it. If it doesn't\n> > +    // work, we move forward.\n> \n> What are the consequences?\n> \n> Perhaps more importantly, uploading records returns an object that includes\n> failed IDs. Why don't you use that?\n\nMy implementation is much simpler and cleaner than the alternative.\n\nIf we want to differentiate between successful and failed records, this means we'd have to cancel out the commands for failed records *during* sync. This feels wrong to me. Also, if we somehow fail a tab state upload and send the command, the tab state record could be orphaned on the server for its TTL. We shouldn't do this.\n\nI think the \"best effort\" method as currently coded strikes a good balance and is conveniently also the simplest. If you insist on stapling on extra complexity, I can do that. But, I'd much prefer to wait until commands are coded properly in the next version of the clients engine to address it.\n\n> @@ +577,5 @@\n> > +      this._log.debug(\"Fetching remote record from: \" + uri);\n> > +\n> > +      // This is synchronous and spins the event loop. It also throws on\n> > +      // some errors.\n> > +      record.fetch(uri);\n> \n> If so, then now so does processIncomingCommands. Do you want this to throw\n> if fetching throws, or to proceed on?\n\nI don't know. IMO we should probably skip over failed record fetches since that is the \"SLA\" on tab state uploads (unless we decide to change that - see above).", "creation_time": "2011-11-07T21:33:48Z", "bug_id": 686704, "id": 5832088, "tags": [], "is_private": false, "count": 19, "author": "gps@mozilla.com", "creator": "gps@mozilla.com"}, {"author": "bugzilla@twinql.com", "creator": "bugzilla@twinql.com", "id": 5832245, "tags": [], "count": 20, "is_private": false, "bug_id": 686704, "creation_time": "2011-11-07T22:13:19Z", "raw_text": "(In reply to Gregory Szorc [:gps] from comment #19)\n\n> Created patch from Git. I'm not bothering with the overhead of\n> Git<->Mercurial until the patch is ready to land.\n\nJust don't forget :D\n\n> > What's wrong with \"tabstate\"?\n> \n> See comment #12. You are contradicting yourself!\n\nHeh. Well, either is better than \"session-states\" :)\n\nSee below.\n \n> > So if this is the record for individual tab states, why isn't it called\n> > TabStateRecord?\n> \n> See comment #12. More contradiction.\n\nDon't assume it's a contradiction! Things change over time, y'know, and the prior comments were on early-days draft.\n\nThat was a question. If these are records that hold stuff for send tab to device, including but not limited to tab state, then SendTabRecord is appropriate. If all they do is hold tab state, and nothing else, and never will, then TabStateRecord is appropriate.\n\nThat's why this is a question: do you ever think we'll want to jam more data for a \"send tab\" operation into these records? If no, then we can change the names to \"tabstate\" (or \"tabstates\", maybe) and \"TabStateRecord\". If yes, then \"sendtab\" etc. are fine.\n\n> > Capitalize string for consistency.\n> \n> Wuh? I didn't think we capitalized the types in the Javadoc-style docs\n> unless the types themselves were capitalized.\n\nAhem:\n\n+   * @param uri\n+   *        String URI to send to the remote client.\n+   * @param client\n+   *        String client ID to send the command to. Must be defined.\n\nI don't care which you do, so long as you're consistent.\n\n> > Perhaps more importantly, uploading records returns an object that includes\n> > failed IDs. Why don't you use that?\n> \n> My implementation is much simpler and cleaner than the alternative.\n\nYes, but it might have consequences, which is why I asked :)\n\n> If we want to differentiate between successful and failed records, this\n> means we'd have to cancel out the commands for failed records *during* sync.\n\nOr best-effort reupload later, just as we would for other kinds of records.\n\nConsider: you choose \"send tab to device\" because you're on a flaky wireless network. The upload of the tab state fails. Should we skip it? Fail the sync?\n\nWhat if the user then immediately bookmarks the page, giving us another opportunity to sync (instant sync)?\n\nI think it's important that this feature is not just robust, but also humane, in the face of faults\u2026\n\n> This feels wrong to me. Also, if we somehow fail a tab state upload and send\n> the command, the tab state record could be orphaned on the server for its\n> TTL. We shouldn't do this.\n\nI presume you're talking about the case of a retry? (If we fail the tab state upload, it won't be on the server at all\u2026)\n\nIf we retry, we already know the current command set, so we can avoid uploading records for which the command has already been processed, no?\n\n> I think the \"best effort\" method as currently coded strikes a good balance\n> and is conveniently also the simplest. If you insist on stapling on extra\n> complexity, I can do that. But, I'd much prefer to wait until commands are\n> coded properly in the next version of the clients engine to address it.\n\nNot insisting, just requesting a thorough consideration (and documentation, whether in code, bug, or feature page) of the constraints.\n\nThink of it this way: at some point QA is going to come back and say \"I was testing send to device, and I didn't get any of my form fields\". Ideally the feature page will provide enough information about how failure modes affect behavior that they can look at a log and understand that things are working fine.\n\nIf you're using a best-effort one-try upload, you're diverging from how Sync currently works. I'd like to see us either retry, or document the hell out of the decision for QA and user expectations. If we can do the former without too much confusion or complexity\n\nMake sense?\n\n> > If so, then now so does processIncomingCommands. Do you want this to throw\n> > if fetching throws, or to proceed on?\n> \n> I don't know. IMO we should probably skip over failed record fetches since\n> that is the \"SLA\" on tab state uploads (unless we decide to change that -\n> see above).\n\nWFM. Need to catch there, then.", "attachment_id": null, "time": "2011-11-07T22:13:19Z", "text": "(In reply to Gregory Szorc [:gps] from comment #19)\n\n> Created patch from Git. I'm not bothering with the overhead of\n> Git<->Mercurial until the patch is ready to land.\n\nJust don't forget :D\n\n> > What's wrong with \"tabstate\"?\n> \n> See comment #12. You are contradicting yourself!\n\nHeh. Well, either is better than \"session-states\" :)\n\nSee below.\n \n> > So if this is the record for individual tab states, why isn't it called\n> > TabStateRecord?\n> \n> See comment #12. More contradiction.\n\nDon't assume it's a contradiction! Things change over time, y'know, and the prior comments were on early-days draft.\n\nThat was a question. If these are records that hold stuff for send tab to device, including but not limited to tab state, then SendTabRecord is appropriate. If all they do is hold tab state, and nothing else, and never will, then TabStateRecord is appropriate.\n\nThat's why this is a question: do you ever think we'll want to jam more data for a \"send tab\" operation into these records? If no, then we can change the names to \"tabstate\" (or \"tabstates\", maybe) and \"TabStateRecord\". If yes, then \"sendtab\" etc. are fine.\n\n> > Capitalize string for consistency.\n> \n> Wuh? I didn't think we capitalized the types in the Javadoc-style docs\n> unless the types themselves were capitalized.\n\nAhem:\n\n+   * @param uri\n+   *        String URI to send to the remote client.\n+   * @param client\n+   *        String client ID to send the command to. Must be defined.\n\nI don't care which you do, so long as you're consistent.\n\n> > Perhaps more importantly, uploading records returns an object that includes\n> > failed IDs. Why don't you use that?\n> \n> My implementation is much simpler and cleaner than the alternative.\n\nYes, but it might have consequences, which is why I asked :)\n\n> If we want to differentiate between successful and failed records, this\n> means we'd have to cancel out the commands for failed records *during* sync.\n\nOr best-effort reupload later, just as we would for other kinds of records.\n\nConsider: you choose \"send tab to device\" because you're on a flaky wireless network. The upload of the tab state fails. Should we skip it? Fail the sync?\n\nWhat if the user then immediately bookmarks the page, giving us another opportunity to sync (instant sync)?\n\nI think it's important that this feature is not just robust, but also humane, in the face of faults\u2026\n\n> This feels wrong to me. Also, if we somehow fail a tab state upload and send\n> the command, the tab state record could be orphaned on the server for its\n> TTL. We shouldn't do this.\n\nI presume you're talking about the case of a retry? (If we fail the tab state upload, it won't be on the server at all\u2026)\n\nIf we retry, we already know the current command set, so we can avoid uploading records for which the command has already been processed, no?\n\n> I think the \"best effort\" method as currently coded strikes a good balance\n> and is conveniently also the simplest. If you insist on stapling on extra\n> complexity, I can do that. But, I'd much prefer to wait until commands are\n> coded properly in the next version of the clients engine to address it.\n\nNot insisting, just requesting a thorough consideration (and documentation, whether in code, bug, or feature page) of the constraints.\n\nThink of it this way: at some point QA is going to come back and say \"I was testing send to device, and I didn't get any of my form fields\". Ideally the feature page will provide enough information about how failure modes affect behavior that they can look at a log and understand that things are working fine.\n\nIf you're using a best-effort one-try upload, you're diverging from how Sync currently works. I'd like to see us either retry, or document the hell out of the decision for QA and user expectations. If we can do the former without too much confusion or complexity\n\nMake sense?\n\n> > If so, then now so does processIncomingCommands. Do you want this to throw\n> > if fetching throws, or to proceed on?\n> \n> I don't know. IMO we should probably skip over failed record fetches since\n> that is the \"SLA\" on tab state uploads (unless we decide to change that -\n> see above).\n\nWFM. Need to catch there, then."}, {"author": "gps@mozilla.com", "creator": "gps@mozilla.com", "id": 5847603, "is_private": false, "count": 21, "tags": [], "bug_id": 686704, "raw_text": "(In reply to Richard Newman [:rnewman] from comment #20)\n> That's why this is a question: do you ever think we'll want to jam more data\n> for a \"send tab\" operation into these records? If no, then we can change the\n> names to \"tabstate\" (or \"tabstates\", maybe) and \"TabStateRecord\". If yes,\n> then \"sendtab\" etc. are fine.\n\nI don't have the gift of foresight. I like keeping the door open to future changes, so I prefer \"SendTabRecord\" over \"TabStateRecord.\" I think both names are acceptable and the name is not exported, so it is easy enough to change in the future if we change functionality. I'm more concerned about the name of server collection, which we can't just change.\n\nAs far as tab state record uploading, if there is an error on upload (during sync), an exception is thrown. This is unhanded by my code thus surfacing the error to the main sync handler thus triggering a sync abort. I think the behavior is sufficient.", "creation_time": "2011-11-14T21:00:53Z", "attachment_id": null, "time": "2011-11-14T21:00:53Z", "text": "(In reply to Richard Newman [:rnewman] from comment #20)\n> That's why this is a question: do you ever think we'll want to jam more data\n> for a \"send tab\" operation into these records? If no, then we can change the\n> names to \"tabstate\" (or \"tabstates\", maybe) and \"TabStateRecord\". If yes,\n> then \"sendtab\" etc. are fine.\n\nI don't have the gift of foresight. I like keeping the door open to future changes, so I prefer \"SendTabRecord\" over \"TabStateRecord.\" I think both names are acceptable and the name is not exported, so it is easy enough to change in the future if we change functionality. I'm more concerned about the name of server collection, which we can't just change.\n\nAs far as tab state record uploading, if there is an error on upload (during sync), an exception is thrown. This is unhanded by my code thus surfacing the error to the main sync handler thus triggering a sync abort. I think the behavior is sufficient."}, {"time": "2011-11-14T21:40:28Z", "attachment_id": null, "text": "(In reply to Gregory Szorc [:gps] from comment #21)\n\n> I don't have the gift of foresight. I like keeping the door open to future\n> changes, so I prefer \"SendTabRecord\" over \"TabStateRecord.\" I think both\n> names are acceptable and the name is not exported, so it is easy enough to\n> change in the future if we change functionality. I'm more concerned about\n> the name of server collection, which we can't just change.\n\nWFM.\n\n> As far as tab state record uploading, if there is an error on upload (during\n> sync), an exception is thrown. This is unhanded by my code thus surfacing\n> the error to the main sync handler thus triggering a sync abort. I think the\n> behavior is sufficient.\n\nPlease make sure you write some tests for this; a handler throwing a 401 for upload (and blanking the server to mimic a node reallocation) would be nice. We really want to be confident (and have documented!) the failure cases for this.", "raw_text": "(In reply to Gregory Szorc [:gps] from comment #21)\n\n> I don't have the gift of foresight. I like keeping the door open to future\n> changes, so I prefer \"SendTabRecord\" over \"TabStateRecord.\" I think both\n> names are acceptable and the name is not exported, so it is easy enough to\n> change in the future if we change functionality. I'm more concerned about\n> the name of server collection, which we can't just change.\n\nWFM.\n\n> As far as tab state record uploading, if there is an error on upload (during\n> sync), an exception is thrown. This is unhanded by my code thus surfacing\n> the error to the main sync handler thus triggering a sync abort. I think the\n> behavior is sufficient.\n\nPlease make sure you write some tests for this; a handler throwing a 401 for upload (and blanking the server to mimic a node reallocation) would be nice. We really want to be confident (and have documented!) the failure cases for this.", "creation_time": "2011-11-14T21:40:28Z", "bug_id": 686704, "id": 5847743, "count": 22, "is_private": false, "tags": [], "author": "bugzilla@twinql.com", "creator": "bugzilla@twinql.com"}, {"creation_time": "2012-01-21T15:35:56Z", "raw_text": "Did this stall?", "time": "2012-01-21T15:35:56Z", "attachment_id": null, "author": "pwd.mozilla@yahoo.co.uk", "text": "Did this stall?", "creator": "pwd.mozilla@yahoo.co.uk", "id": 5998182, "is_private": false, "count": 23, "tags": [], "bug_id": 686704}, {"raw_text": "(In reply to Paul [sabret00the] from comment #23)\n> Did this stall?\n\nThis feature has been stalled due to work on the rewrite of Firefox for mobile devices (native Fennec). Once Fennec has stabilized, this feature will be revisited.\n\nIf you want to use a simple version of this feature, you can try out https://addons.mozilla.org/en-US/firefox/addon/send-tab-to-device/", "creation_time": "2012-01-21T18:24:32Z", "creator": "gps@mozilla.com", "text": "(In reply to Paul [sabret00the] from comment #23)\n> Did this stall?\n\nThis feature has been stalled due to work on the rewrite of Firefox for mobile devices (native Fennec). Once Fennec has stabilized, this feature will be revisited.\n\nIf you want to use a simple version of this feature, you can try out https://addons.mozilla.org/en-US/firefox/addon/send-tab-to-device/", "author": "gps@mozilla.com", "time": "2012-01-21T18:24:32Z", "attachment_id": null, "tags": [], "count": 24, "is_private": false, "id": 5998329, "bug_id": 686704}, {"attachment_id": null, "time": "2013-01-23T18:44:10Z", "text": "CCing the session store folks.", "creation_time": "2013-01-23T18:44:10Z", "raw_text": "CCing the session store folks.", "bug_id": 686704, "id": 7030884, "is_private": false, "count": 25, "tags": [], "author": "bugzilla@twinql.com", "creator": "bugzilla@twinql.com"}]}}}