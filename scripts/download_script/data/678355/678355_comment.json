{"bugs": {"678355": {"comments": [{"attachment_id": null, "tags": [], "creator": "marty.rosenberg@gmail.com", "is_private": false, "creation_time": "2011-08-11T21:22:57Z", "time": "2011-08-11T21:22:57Z", "raw_text": "currently, vn's are a single integer that, and when assigning a variable,\nwe do something like\nnew_vn <- hash(op, left_vn, right_vn).\nEven if hash is an associative + commutative operation when op is an associative, commutative operation, we still lose information, particularly when doing things that look like indexing into arrays.\n\nDepending on the use patterns that we see, it may be helpful to increase vn's to two integers, a \"real\" vn, and an offset, then do something like this\nif (op == add)\n    (new_rvn, new_offset) = (hash(left_vn,right_vn), left_offset+right_offset)\nelse\n    (new_rvn, new_offset) = (hash(left_vn, right_vn, left_offset, right_offset),0)\nso in the cases that we know that two values are related by a constant offset, we record that, and as soon as that value gets used in some other context, it gets collapsed into a normal vn.", "text": "currently, vn's are a single integer that, and when assigning a variable,\nwe do something like\nnew_vn <- hash(op, left_vn, right_vn).\nEven if hash is an associative + commutative operation when op is an associative, commutative operation, we still lose information, particularly when doing things that look like indexing into arrays.\n\nDepending on the use patterns that we see, it may be helpful to increase vn's to two integers, a \"real\" vn, and an offset, then do something like this\nif (op == add)\n    (new_rvn, new_offset) = (hash(left_vn,right_vn), left_offset+right_offset)\nelse\n    (new_rvn, new_offset) = (hash(left_vn, right_vn, left_offset, right_offset),0)\nso in the cases that we know that two values are related by a constant offset, we record that, and as soon as that value gets used in some other context, it gets collapsed into a normal vn.", "count": 0, "author": "marty.rosenberg@gmail.com", "bug_id": 678355, "id": 5648620}, {"id": 8994094, "bug_id": 678355, "text": "This is an interesting idea, though it's unclear to me how it would work in practice. Can you describe an example in which this optimization might apply?", "count": 1, "author": "sunfish@mozilla.com", "time": "2014-06-30T14:59:14Z", "raw_text": "This is an interesting idea, though it's unclear to me how it would work in practice. Can you describe an example in which this optimization might apply?", "is_private": false, "creation_time": "2014-06-30T14:59:14Z", "creator": "sunfish@mozilla.com", "tags": [], "attachment_id": null}, {"author": "marty.rosenberg@gmail.com", "count": 2, "text": "The most immediate thing that comes to mind is indexing into an asm.js heap.  If there is a structure like:\nstruct foo {\n    int x;\n    struct bar {\n        int i, j\n\n    };\n    bar y[20];\n}\nthen a loop over foo.y[idx].j may look sort of like\nheap[(&foo + 4) + (8*idx + 4)]\nwhere we can collapse the two immediates into one.\n\n*more far flung case*\nIf we happen to get to the same value through two different struct lookup paths\ne.g. heap[(&foo+8) + (8*idx +4)] and heap[(&foo + 4) + (8*idx + 8)]\nare currently not recognized as accessing the same location in memory, but would be with this patch.  I suspect more relevant examples can be found in multi-dimensional arrays.", "bug_id": 678355, "id": 8994247, "time": "2014-06-30T15:24:44Z", "raw_text": "The most immediate thing that comes to mind is indexing into an asm.js heap.  If there is a structure like:\nstruct foo {\n    int x;\n    struct bar {\n        int i, j\n\n    };\n    bar y[20];\n}\nthen a loop over foo.y[idx].j may look sort of like\nheap[(&foo + 4) + (8*idx + 4)]\nwhere we can collapse the two immediates into one.\n\n*more far flung case*\nIf we happen to get to the same value through two different struct lookup paths\ne.g. heap[(&foo+8) + (8*idx +4)] and heap[(&foo + 4) + (8*idx + 8)]\nare currently not recognized as accessing the same location in memory, but would be with this patch.  I suspect more relevant examples can be found in multi-dimensional arrays.", "creator": "marty.rosenberg@gmail.com", "creation_time": "2014-06-30T15:24:44Z", "is_private": false, "attachment_id": null, "tags": []}, {"tags": [], "attachment_id": null, "is_private": false, "creation_time": "2014-06-30T16:05:05Z", "creator": "nicolas.b.pierron@mozilla.com", "time": "2014-06-30T16:05:05Z", "raw_text": "Doesn't this kind of optimization would make sense to alias some array accesses in cases where we have already unrolled a few iteration of a loop?\n\nAlso, when you say multidimensional arrays, I think you mean encoding multidimensional array in a sequential one, as on the other case we still have some aliasing where array accesses might alias each others.", "id": 8994482, "bug_id": 678355, "count": 3, "text": "Doesn't this kind of optimization would make sense to alias some array accesses in cases where we have already unrolled a few iteration of a loop?\n\nAlso, when you say multidimensional arrays, I think you mean encoding multidimensional array in a sequential one, as on the other case we still have some aliasing where array accesses might alias each others.", "author": "nicolas.b.pierron@mozilla.com"}, {"tags": [], "time": "2014-06-30T19:07:27Z", "raw_text": "(In reply to Nicolas B. Pierron [:nbp] from comment #3)\n> Doesn't this kind of optimization would make sense to alias some array\n> accesses in cases where we have already unrolled a few iteration of a loop?\nYes, it will!\n> Also, when you say multidimensional arrays, I think you mean encoding\n> multidimensional array in a sequential one, as on the other case we still\n> have some aliasing where array accesses might alias each others.\nI guess it was unclear, but I was talking about asm.js arrays the whole time, which only has sequential arrays.", "attachment_id": null, "id": 8995468, "bug_id": 678355, "creation_time": "2014-06-30T19:07:27Z", "is_private": false, "creator": "marty.rosenberg@gmail.com", "count": 4, "text": "(In reply to Nicolas B. Pierron [:nbp] from comment #3)\n> Doesn't this kind of optimization would make sense to alias some array\n> accesses in cases where we have already unrolled a few iteration of a loop?\nYes, it will!\n> Also, when you say multidimensional arrays, I think you mean encoding\n> multidimensional array in a sequential one, as on the other case we still\n> have some aliasing where array accesses might alias each others.\nI guess it was unclear, but I was talking about asm.js arrays the whole time, which only has sequential arrays.", "author": "marty.rosenberg@gmail.com"}]}}, "comments": {}}