{"comments": {}, "bugs": {"644256": {"comments": [{"text": "User-Agent:       Mozilla/5.0 (X11; U; Linux x86_64; en-US; rv:1.9.2.15) Gecko/20110308 Fedora/3.6.15-1.fc14 Firefox/3.6.15\nBuild Identifier: 4.1.1+\n\nWhen noresolveonopenblockers is enabled and you have a blocker/dependent\nrelationship, you cannot simultaneously resolve both a blocker bug and\nits dependent bug via 'Change Several Bugs at Once'.\n\nYou are forced to either remove the relationship or resolve the bugs one\nat a time.  Frequently neither of these options is desirable, especially\nwhen bugs are being automatically resolved from a source code control\nsystem.\n\n\nReproducible: Always", "bug_id": 644256, "creator": "mrbball17@gmail.com", "raw_text": "User-Agent:       Mozilla/5.0 (X11; U; Linux x86_64; en-US; rv:1.9.2.15) Gecko/20110308 Fedora/3.6.15-1.fc14 Firefox/3.6.15\nBuild Identifier: 4.1.1+\n\nWhen noresolveonopenblockers is enabled and you have a blocker/dependent\nrelationship, you cannot simultaneously resolve both a blocker bug and\nits dependent bug via 'Change Several Bugs at Once'.\n\nYou are forced to either remove the relationship or resolve the bugs one\nat a time.  Frequently neither of these options is desirable, especially\nwhen bugs are being automatically resolved from a source code control\nsystem.\n\n\nReproducible: Always", "attachment_id": null, "creation_time": "2011-03-23T18:24:57Z", "tags": [], "id": 5363197, "count": 0, "author": "mrbball17@gmail.com", "time": "2011-03-23T18:24:57Z", "is_private": false}, {"raw_text": "This is true, but unlikely to be fixed due to the complexity of doing so.", "creator": "mkanat@bugzilla.org", "tags": [], "creation_time": "2011-03-23T20:33:04Z", "attachment_id": null, "text": "This is true, but unlikely to be fixed due to the complexity of doing so.", "bug_id": 644256, "time": "2011-03-23T20:33:04Z", "author": "mkanat@bugzilla.org", "count": 1, "is_private": false, "id": 5363621}, {"bug_id": 644256, "text": "Perhaps that points to a deeper issue.  I wouldn't expect it to be so\ncomplex.\n\nCould Object::set() simply take a params argument and pass it along to\nthe validator?  That would appear to allow the flexibility to perform\nadditional checks in the validator, as necessary.\n\nIn this particular case, it would allow process_bug to add a hash of all\nbugs being updated to the params arg on the calls to Bug::set_resolution()\nand Bug::set_status() (which also calls set_resolution()), and then\nBug::set_resolution() would pass the hash on to Object::set().  Ultimately,\nBug::_check_resolution() would get the hash and NOT throw a \"still_unresolved_bugs\" error if all the unresolved bugs were in the hash.", "creation_time": "2011-03-24T00:24:02Z", "tags": [], "attachment_id": null, "raw_text": "Perhaps that points to a deeper issue.  I wouldn't expect it to be so\ncomplex.\n\nCould Object::set() simply take a params argument and pass it along to\nthe validator?  That would appear to allow the flexibility to perform\nadditional checks in the validator, as necessary.\n\nIn this particular case, it would allow process_bug to add a hash of all\nbugs being updated to the params arg on the calls to Bug::set_resolution()\nand Bug::set_status() (which also calls set_resolution()), and then\nBug::set_resolution() would pass the hash on to Object::set().  Ultimately,\nBug::_check_resolution() would get the hash and NOT throw a \"still_unresolved_bugs\" error if all the unresolved bugs were in the hash.", "creator": "mrbball17@gmail.com", "id": 5364555, "is_private": false, "time": "2011-03-24T00:24:02Z", "author": "mrbball17@gmail.com", "count": 2}, {"text": "  Hey Kent. Tracing down a dependency tree for every single dependency change on every single bug in a list probably isn't a good idea. You're welcome to look at the code of Bugzilla::Bug::set_all and see what you can do.", "bug_id": 644256, "creator": "mkanat@bugzilla.org", "raw_text": "  Hey Kent. Tracing down a dependency tree for every single dependency change on every single bug in a list probably isn't a good idea. You're welcome to look at the code of Bugzilla::Bug::set_all and see what you can do.", "attachment_id": null, "tags": [], "creation_time": "2011-03-24T20:47:15Z", "id": 5367201, "count": 3, "time": "2011-03-24T20:47:15Z", "author": "mkanat@bugzilla.org", "is_private": false}, {"id": 5367417, "is_private": false, "author": "mrbball17@gmail.com", "bug_id": 644256, "attachment_id": null, "tags": [], "creation_time": "2011-03-24T21:49:01Z", "count": 4, "time": "2011-03-24T21:49:01Z", "text": "Why would you need to trace down the whole tree?  Isn't _check_resolution()\ncalled for every bug in a batch update?  If so, each bug only needs to\nworry about its blockers, and the check simply needs to be added to the\ncurrent noresolveonopenblockers check there.\n\nThe only bit of information that _check_resolution() doesn't have is the\nlist of bugs being updated.  But, if Object::set() were updated to take a\nparams argument that allowed it to take additional information, it could\neasily be passed along.\n\nI was able to implement this fairly quickly on my local installation.\nHowever, we are only running 3.6.2 and I see now that the code around\nbatch update has changed quite a bit since that release. :-|\n\nAfter looking at this briefly in tip, I'm guessing that my\nimplementation is still pretty close.  Bug::set_all() is already\nreceiving a params hash with an 'other_bugs' key, and hopefully it\nwouldn't be too difficult to pass that down to the validator.\n\nUnfortunately, I wouldn't be able to look at this any closer until\nwe actually migrate to 4.0, which won't be until late 2011.", "creator": "mrbball17@gmail.com", "raw_text": "Why would you need to trace down the whole tree?  Isn't _check_resolution()\ncalled for every bug in a batch update?  If so, each bug only needs to\nworry about its blockers, and the check simply needs to be added to the\ncurrent noresolveonopenblockers check there.\n\nThe only bit of information that _check_resolution() doesn't have is the\nlist of bugs being updated.  But, if Object::set() were updated to take a\nparams argument that allowed it to take additional information, it could\neasily be passed along.\n\nI was able to implement this fairly quickly on my local installation.\nHowever, we are only running 3.6.2 and I see now that the code around\nbatch update has changed quite a bit since that release. :-|\n\nAfter looking at this briefly in tip, I'm guessing that my\nimplementation is still pretty close.  Bug::set_all() is already\nreceiving a params hash with an 'other_bugs' key, and hopefully it\nwouldn't be too difficult to pass that down to the validator.\n\nUnfortunately, I wouldn't be able to look at this any closer until\nwe actually migrate to 4.0, which won't be until late 2011."}, {"creator": "mkanat@bugzilla.org", "raw_text": "(In reply to comment #4)\n> Why would you need to trace down the whole tree? \n\n  You can't guarantee the order that bugs are being changed in. Think about situations where a later change will lead to an invalid state, with complex dependency trees (at least A -> B -> C where the order of changes happens as C, B, A).\n\n> But, if Object::set() were updated to take a\n> params argument that allowed it to take additional information, it could\n> easily be passed along.\n\n  Every validator already gets such an argument, actually.\n\n> Unfortunately, I wouldn't be able to look at this any closer until\n> we actually migrate to 4.0, which won't be until late 2011.\n\n  Okay. If you do look at it, we might take it if it's very simple.", "text": "(In reply to comment #4)\n> Why would you need to trace down the whole tree? \n\n  You can't guarantee the order that bugs are being changed in. Think about situations where a later change will lead to an invalid state, with complex dependency trees (at least A -> B -> C where the order of changes happens as C, B, A).\n\n> But, if Object::set() were updated to take a\n> params argument that allowed it to take additional information, it could\n> easily be passed along.\n\n  Every validator already gets such an argument, actually.\n\n> Unfortunately, I wouldn't be able to look at this any closer until\n> we actually migrate to 4.0, which won't be until late 2011.\n\n  Okay. If you do look at it, we might take it if it's very simple.", "count": 5, "time": "2011-03-24T22:18:42Z", "attachment_id": null, "creation_time": "2011-03-24T22:18:42Z", "tags": [], "bug_id": 644256, "author": "mkanat@bugzilla.org", "is_private": false, "id": 5367534}, {"is_private": false, "count": 6, "time": "2011-03-24T22:43:41Z", "author": "mrbball17@gmail.com", "id": 5367626, "attachment_id": null, "tags": [], "creation_time": "2011-03-24T22:43:41Z", "creator": "mrbball17@gmail.com", "raw_text": ">   You can't guarantee the order that bugs are being changed in. Think about\n> situations where a later change will lead to an invalid state, with complex\n> dependency trees (at least A -> B -> C where the order of changes happens as C,\n> B, A).\n> \nI don't see why order matters.  If your blocker(s) are in the list,\nyou're good to go because they're going to get updated.  In your example,\nregardless of whether A is updated first or last, if B is in the list, it's\nallowed.\n\n> > But, if Object::set() were updated to take a\n> > params argument that allowed it to take additional information, it could\n> > easily be passed along.\n> \n>   Every validator already gets such an argument, actually.\n> \nI don't see that.  For example, Bug::_check_resolution() only appears\nto get only a resolution value.  Actually, it looks like the field name\nis also passed in (from Object::set()) but is ignored.", "bug_id": 644256, "text": ">   You can't guarantee the order that bugs are being changed in. Think about\n> situations where a later change will lead to an invalid state, with complex\n> dependency trees (at least A -> B -> C where the order of changes happens as C,\n> B, A).\n> \nI don't see why order matters.  If your blocker(s) are in the list,\nyou're good to go because they're going to get updated.  In your example,\nregardless of whether A is updated first or last, if B is in the list, it's\nallowed.\n\n> > But, if Object::set() were updated to take a\n> > params argument that allowed it to take additional information, it could\n> > easily be passed along.\n> \n>   Every validator already gets such an argument, actually.\n> \nI don't see that.  For example, Bug::_check_resolution() only appears\nto get only a resolution value.  Actually, it looks like the field name\nis also passed in (from Object::set()) but is ignored."}, {"raw_text": "  Hmm, okay, you may be right. Let's work this out in detail:\n\n  Here's a dependency chain: A -> B -> C -> D. Let's pretend they're all open, but only A and B are in our list.\n\n  Right now, here's what would happen:\n\n  Resolve A first: Fails, B is open.\n\n  In your proposal, we would check B and see \"okay, we're also resolving B, it is OK to resolve A.\" But then we would fail to resolve B. So that works properly.\n\n  And yeah, in any other situation that I can currently come up with, you're also right, provided there are no side effects of running the check (and Bugzilla is architected such that there should be no side effects) and provided there are no situations in which Bugzilla can silently fail to change a bug to a closed state (I don't know of any such situations).", "creator": "mkanat@bugzilla.org", "creation_time": "2011-03-24T23:24:40Z", "tags": [], "attachment_id": null, "text": "  Hmm, okay, you may be right. Let's work this out in detail:\n\n  Here's a dependency chain: A -> B -> C -> D. Let's pretend they're all open, but only A and B are in our list.\n\n  Right now, here's what would happen:\n\n  Resolve A first: Fails, B is open.\n\n  In your proposal, we would check B and see \"okay, we're also resolving B, it is OK to resolve A.\" But then we would fail to resolve B. So that works properly.\n\n  And yeah, in any other situation that I can currently come up with, you're also right, provided there are no side effects of running the check (and Bugzilla is architected such that there should be no side effects) and provided there are no situations in which Bugzilla can silently fail to change a bug to a closed state (I don't know of any such situations).", "bug_id": 644256, "author": "mkanat@bugzilla.org", "time": "2011-03-24T23:24:40Z", "count": 7, "is_private": false, "id": 5367773}, {"bug_id": 644256, "creation_time": "2011-03-24T23:25:12Z", "tags": [], "attachment_id": null, "id": 5367778, "author": "mkanat@bugzilla.org", "is_private": false, "text": "By the way, you could accomplish this now by changing the sort order. (That'd be a workaround.)", "raw_text": "By the way, you could accomplish this now by changing the sort order. (That'd be a workaround.)", "creator": "mkanat@bugzilla.org", "time": "2011-03-24T23:25:12Z", "count": 8}, {"id": 5894846, "author": "mrbball17@gmail.com", "is_private": false, "bug_id": 644256, "creation_time": "2011-12-06T17:43:37Z", "tags": [], "attachment_id": 579344, "time": "2011-12-06T17:43:37Z", "count": 9, "text": "Created attachment 579344\nV1 - patch to get list of bugs being updated to _check_resolution()\n\nI finally got around to migrating to 4.0 and re-working my 3.6 mod to\nwork on 4.0.  It was fairly simple, requiring only that Bug::set_all()\npass ALL the params (including 'other_bugs') up to Object::set_all() so\nthat they can be passed on to the Bug set_* functions and thus eventually\nto the validators.\n\nOnce the _check_resolution() validator has access to the \"other_bugs\"\nparameter, it can easily determine if all blocker bugs are also in the\nlist to be updated.", "raw_text": "I finally got around to migrating to 4.0 and re-working my 3.6 mod to\nwork on 4.0.  It was fairly simple, requiring only that Bug::set_all()\npass ALL the params (including 'other_bugs') up to Object::set_all() so\nthat they can be passed on to the Bug set_* functions and thus eventually\nto the validators.\n\nOnce the _check_resolution() validator has access to the \"other_bugs\"\nparameter, it can easily determine if all blocker bugs are also in the\nlist to be updated.", "creator": "mrbball17@gmail.com"}, {"id": 6074204, "is_private": false, "author": "LpSolit@gmail.com", "bug_id": 644256, "creation_time": "2012-02-19T01:06:23Z", "tags": [], "attachment_id": 579344, "time": "2012-02-19T01:06:23Z", "count": 10, "text": "Comment on attachment 579344\nV1 - patch to get list of bugs being updated to _check_resolution()\n\n>=== modified file 'Bugzilla/Object.pm'\n>-        next if !exists $field_values{$key};\n>         my $method = \"set_$key\";\n>+        next if !$self->can($method) || !exists $field_values{$key};\n\nIt's not ok to ignore a set_foo() command() if this command doesn't exist. Such attempts must be caught and an error must be thrown. set_all() is used in many places within the Bugzilla code, not only from Bug.pm.", "raw_text": ">=== modified file 'Bugzilla/Object.pm'\n>-        next if !exists $field_values{$key};\n>         my $method = \"set_$key\";\n>+        next if !$self->can($method) || !exists $field_values{$key};\n\nIt's not ok to ignore a set_foo() command() if this command doesn't exist. Such attempts must be caught and an error must be thrown. set_all() is used in many places within the Bugzilla code, not only from Bug.pm.", "creator": "LpSolit@gmail.com"}, {"author": "mrbball17@gmail.com", "time": "2013-05-16T16:17:32Z", "count": 11, "is_private": false, "id": 7431095, "raw_text": "I didn't understand the comments in your review.  Can you elaborate on why it is a\nproblem to ignore set_foo() if it doesn't exist?\n\nIf \"foo\" was intended to be set and there wasn't a set_foo(), that would be an\ninternal (i.e. code) error.  It might be nice to catch that and throw an error, but\nwithout this logic, I don't see a way to pass additional, non-settable parameters to\nObject::set_all() such that they can be passed on to the individual set methods and\nthen to the validators.\n\nDo you have other ideas/recommendations?  Another argument to set_all()?\n\nI have been running the code in attachment 579344 in my Bugzilla installation for 1.5\nyears without issue.\n\nFWIW, as of 4.2.3, I only see the Object::set_all() called from these places:\n\nBug::set_all()\neditproducts.cgi (via Product class)\neditkeywords.cgi (via Keyword class)\nemail_in.pl (via Comment class)\npost_bug.cgi (via Comment class)", "creator": "mrbball17@gmail.com", "tags": [], "creation_time": "2013-05-16T16:17:32Z", "attachment_id": null, "text": "I didn't understand the comments in your review.  Can you elaborate on why it is a\nproblem to ignore set_foo() if it doesn't exist?\n\nIf \"foo\" was intended to be set and there wasn't a set_foo(), that would be an\ninternal (i.e. code) error.  It might be nice to catch that and throw an error, but\nwithout this logic, I don't see a way to pass additional, non-settable parameters to\nObject::set_all() such that they can be passed on to the individual set methods and\nthen to the validators.\n\nDo you have other ideas/recommendations?  Another argument to set_all()?\n\nI have been running the code in attachment 579344 in my Bugzilla installation for 1.5\nyears without issue.\n\nFWIW, as of 4.2.3, I only see the Object::set_all() called from these places:\n\nBug::set_all()\neditproducts.cgi (via Product class)\neditkeywords.cgi (via Keyword class)\nemail_in.pl (via Comment class)\npost_bug.cgi (via Comment class)", "bug_id": 644256}]}}}