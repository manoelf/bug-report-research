{"bugs": {"666365": {"comments": [{"bug_id": 666365, "count": 0, "text": "Currently it's called but implemented as NS_NOTREACHED. This is similar to Bug 617804.", "tags": [], "time": "2011-06-22T20:20:05Z", "creation_time": "2011-06-22T20:20:05Z", "author": "felipc@gmail.com", "is_private": false, "creator": "felipc@gmail.com", "id": 5549156, "raw_text": "Currently it's called but implemented as NS_NOTREACHED. This is similar to Bug 617804.", "attachment_id": null}, {"count": 1, "bug_id": 666365, "attachment_id": null, "raw_text": "Mass tracking-e10s flag change. Filter bugmail on \"2be0fcce-e36a-4e2c-aa80-0e3d33eb5406\".", "id": 8653107, "creator": "cpeterson@mozilla.com", "is_private": false, "author": "cpeterson@mozilla.com", "creation_time": "2014-04-11T22:54:27Z", "time": "2014-04-11T22:54:27Z", "tags": [], "text": "Mass tracking-e10s flag change. Filter bugmail on \"2be0fcce-e36a-4e2c-aa80-0e3d33eb5406\"."}, {"count": 2, "is_private": false, "creator": "mconley@mozilla.com", "text": "So this has been a bit of a trip.\n\nTabChild implements nsIEmbeddingSiteWindow, which means that it implements the visibility attribute. Originally, I believe that attribute was exposed to embedders to allow them to hide and show the embedded web content easily, and to read the hidden / shown state.\n\nSo that seems to be why TabChild has it.\n\nFrom here on out, I was interested in who is supposed to call SetVisibility on things. Specifically, I care about who calls SetVisibility(false), since this is a thing that TabChild does not support (it's current implementation makes it so that we ignore SetVisibility, and always return true for GetVisibility).\n\nnsDocShellTreeOwner is apparently the one who makes calls to SetVisibility for nsIEmbeddingSiteWindow's, and it's really just forwarding calls to its own SetVisibility. Yes, nsDocShellTreeOwner gets a visibility attribute as well, by way of the nsIBaseWindow interface.\n\nSo the question is: who normally calls SetVisibility(false) on an nsDocShellTreeOwner? DXR reports this list as quite small:\n\ndom/base/nsFocusManager.cpp\n691     baseWindow->SetVisibility(true);\n\ndom/base/nsFrameLoader.cpp\n705     baseWindow->SetVisibility(true);\n861     baseWin->SetVisibility(false);\n\ndom/ipc/TabChild.cpp\n1623     baseWindow->SetVisibility(true);\n\nembedding/components/windowwatcher/nsWindowWatcher.cpp\n2181     treeOwnerAsWin->SetVisibility(true);\n\nxpfe/appshell/nsXULWindow.cpp\n872     shellAsWin->SetVisibility(aVisibility);\n\nOnly one spot - in nsFrameLoader.cpp, on line 861.\n\nThat's in the nsFrameLoader::Hide method, here: https://dxr.mozilla.org/mozilla-central/rev/5e0140b6d11821e0c2a2de25bc5431783f03380a/dom/base/nsFrameLoader.cpp#861\n\nAnd it looks like we intentionally do not support hiding remote frameloaders - we do an early return in that case: https://dxr.mozilla.org/mozilla-central/rev/5e0140b6d11821e0c2a2de25bc5431783f03380a/dom/base/nsFrameLoader.cpp#851\n\nSo far, the way I see it - the only reason we'd care about TabChild::SetVisibility is if for some reason, nsFrameLoader::Hide on a remote browser needs to set it to false. And I'm not sure it does.\n\nThe list of things that call nsFrameLoader::Hide are small:\n\ndom/base/nsFrameLoader.cpp\n748     Hide();\n\nlayout/generic/nsSubDocumentFrame.cpp\n145     frameloader->Hide();\n955     mFrameLoader->Hide();\n\nThe first one is part of the initialization of the frame - and it looks like it's supposed to re-hide if ::Hide was called sometime while nsFrameLoader::Show was called.\n\nAnd the only other times ::Hide is called are from within nsSubDocumentFrame.\n\nI see two places where it\u2019s called from within nsSubDocumentFrame. The first is in ::Init, where it looks like we do this if the subframe was reframed into a new document somehow\u2026 and the presentation is different, so we hide it. Presumably to show it once AsyncFrameInit has run, which calls ShowViewer, which will then call frameloader->Show.\n\nI don\u2019t _think_ we associate an nsSubDocumentFrame with a remote nsFrameLoader\u2026 if we do, we might want to care about the reframing case, but I think that\u2019s edge-casey.\n\nThe other place where nsSubDocumentFrame calls nsFrameLoader::Hide is from within the nsHideViewer runnable, which is fired when an nsSubDocumentFrame is pulled out of the DOM.\n\nSo, I think we\u2019re doing the right thing IF there\u2019s no direct relationship between a remote frameloader and an nsSubDocumentFrame.", "time": "2016-02-29T20:47:17Z", "bug_id": 666365, "tags": [], "creation_time": "2016-02-29T20:47:17Z", "author": "mconley@mozilla.com", "raw_text": "So this has been a bit of a trip.\n\nTabChild implements nsIEmbeddingSiteWindow, which means that it implements the visibility attribute. Originally, I believe that attribute was exposed to embedders to allow them to hide and show the embedded web content easily, and to read the hidden / shown state.\n\nSo that seems to be why TabChild has it.\n\nFrom here on out, I was interested in who is supposed to call SetVisibility on things. Specifically, I care about who calls SetVisibility(false), since this is a thing that TabChild does not support (it's current implementation makes it so that we ignore SetVisibility, and always return true for GetVisibility).\n\nnsDocShellTreeOwner is apparently the one who makes calls to SetVisibility for nsIEmbeddingSiteWindow's, and it's really just forwarding calls to its own SetVisibility. Yes, nsDocShellTreeOwner gets a visibility attribute as well, by way of the nsIBaseWindow interface.\n\nSo the question is: who normally calls SetVisibility(false) on an nsDocShellTreeOwner? DXR reports this list as quite small:\n\ndom/base/nsFocusManager.cpp\n691     baseWindow->SetVisibility(true);\n\ndom/base/nsFrameLoader.cpp\n705     baseWindow->SetVisibility(true);\n861     baseWin->SetVisibility(false);\n\ndom/ipc/TabChild.cpp\n1623     baseWindow->SetVisibility(true);\n\nembedding/components/windowwatcher/nsWindowWatcher.cpp\n2181     treeOwnerAsWin->SetVisibility(true);\n\nxpfe/appshell/nsXULWindow.cpp\n872     shellAsWin->SetVisibility(aVisibility);\n\nOnly one spot - in nsFrameLoader.cpp, on line 861.\n\nThat's in the nsFrameLoader::Hide method, here: https://dxr.mozilla.org/mozilla-central/rev/5e0140b6d11821e0c2a2de25bc5431783f03380a/dom/base/nsFrameLoader.cpp#861\n\nAnd it looks like we intentionally do not support hiding remote frameloaders - we do an early return in that case: https://dxr.mozilla.org/mozilla-central/rev/5e0140b6d11821e0c2a2de25bc5431783f03380a/dom/base/nsFrameLoader.cpp#851\n\nSo far, the way I see it - the only reason we'd care about TabChild::SetVisibility is if for some reason, nsFrameLoader::Hide on a remote browser needs to set it to false. And I'm not sure it does.\n\nThe list of things that call nsFrameLoader::Hide are small:\n\ndom/base/nsFrameLoader.cpp\n748     Hide();\n\nlayout/generic/nsSubDocumentFrame.cpp\n145     frameloader->Hide();\n955     mFrameLoader->Hide();\n\nThe first one is part of the initialization of the frame - and it looks like it's supposed to re-hide if ::Hide was called sometime while nsFrameLoader::Show was called.\n\nAnd the only other times ::Hide is called are from within nsSubDocumentFrame.\n\nI see two places where it\u2019s called from within nsSubDocumentFrame. The first is in ::Init, where it looks like we do this if the subframe was reframed into a new document somehow\u2026 and the presentation is different, so we hide it. Presumably to show it once AsyncFrameInit has run, which calls ShowViewer, which will then call frameloader->Show.\n\nI don\u2019t _think_ we associate an nsSubDocumentFrame with a remote nsFrameLoader\u2026 if we do, we might want to care about the reframing case, but I think that\u2019s edge-casey.\n\nThe other place where nsSubDocumentFrame calls nsFrameLoader::Hide is from within the nsHideViewer runnable, which is fired when an nsSubDocumentFrame is pulled out of the DOM.\n\nSo, I think we\u2019re doing the right thing IF there\u2019s no direct relationship between a remote frameloader and an nsSubDocumentFrame.", "attachment_id": null, "id": 11204875}, {"count": 3, "is_private": false, "creator": "mconley@mozilla.com", "text": "Hey smaug, is there any kind of relationship possible between a remote frameloader and an nsSubDocumentFrame in the parent process? I suspect not, but wanted to check.", "bug_id": 666365, "tags": [], "time": "2016-02-29T20:47:57Z", "creation_time": "2016-02-29T20:47:57Z", "author": "mconley@mozilla.com", "raw_text": "Hey smaug, is there any kind of relationship possible between a remote frameloader and an nsSubDocumentFrame in the parent process? I suspect not, but wanted to check.", "attachment_id": null, "id": 11204878}, {"id": 11228552, "attachment_id": null, "raw_text": "So nsSubDocumentFrame is the primary nsIFrame for the nsFrameLoader::mOwnerContent.\nhttp://mxr.mozilla.org/mozilla-central/source/layout/base/nsCSSFrameConstructor.cpp?rev=06bc3102b900#4316\n\nI think the Hide in the Init() is bogus since if we've moved the xul:browser or html:iframe to another document, we've created a new nsFrameLoader for it.", "creation_time": "2016-03-08T18:28:29Z", "author": "bugs@pettay.fi", "text": "So nsSubDocumentFrame is the primary nsIFrame for the nsFrameLoader::mOwnerContent.\nhttp://mxr.mozilla.org/mozilla-central/source/layout/base/nsCSSFrameConstructor.cpp?rev=06bc3102b900#4316\n\nI think the Hide in the Init() is bogus since if we've moved the xul:browser or html:iframe to another document, we've created a new nsFrameLoader for it.", "bug_id": 666365, "tags": [], "time": "2016-03-08T18:28:29Z", "is_private": false, "creator": "bugs@pettay.fi", "count": 4}, {"tags": [], "time": "2016-03-11T17:43:55Z", "bug_id": 666365, "text": "Ah, I see. So if I understand correctly, if a remote frame is in the midst of being re-framed, we don't do what we'd normally do for a non-remote iframe, which is to SetVisibility to false on it until the reframe is complete. Does that sound correct? And if so, is that problematic?", "author": "mconley@mozilla.com", "creation_time": "2016-03-11T17:43:55Z", "count": 5, "creator": "mconley@mozilla.com", "is_private": false, "id": 11239932, "raw_text": "Ah, I see. So if I understand correctly, if a remote frame is in the midst of being re-framed, we don't do what we'd normally do for a non-remote iframe, which is to SetVisibility to false on it until the reframe is complete. Does that sound correct? And if so, is that problematic?", "attachment_id": null}, {"author": "bugs@pettay.fi", "creation_time": "2016-03-11T17:56:08Z", "bug_id": 666365, "time": "2016-03-11T17:56:08Z", "tags": [], "text": "Well, I think in principle if one has display: none; remote frame, we should mark that visibility hidden. But whether that matters currently, not sure. For tabs we anyway manually do all the\nactivate/deactivate stuff and so.\n\nBut might make sense to send some update to remote frame when frameloader gets Show() or Hide() call.\nAnd looks like in Show() case we already do that, but Hide could also send some message and then\nwe could just update TabChild's docshell's visibility based on those messages.\nThough, that would need some testing. I'm a bit worried what nsDocumentViewer::Hide() would do when called on child in this case.", "creator": "bugs@pettay.fi", "is_private": false, "count": 6, "id": 11239961, "attachment_id": null, "raw_text": "Well, I think in principle if one has display: none; remote frame, we should mark that visibility hidden. But whether that matters currently, not sure. For tabs we anyway manually do all the\nactivate/deactivate stuff and so.\n\nBut might make sense to send some update to remote frame when frameloader gets Show() or Hide() call.\nAnd looks like in Show() case we already do that, but Hide could also send some message and then\nwe could just update TabChild's docshell's visibility based on those messages.\nThough, that would need some testing. I'm a bit worried what nsDocumentViewer::Hide() would do when called on child in this case."}, {"count": 7, "bug_id": 666365, "creator": "mconley@mozilla.com", "is_private": false, "time": "2016-04-12T14:56:08Z", "tags": [], "text": "So, in conclusion, I think we should give this a shot. There might be some perf win potential here, but we'd need to try it. The implications really aren't clear at this point - we're pretty deep in the machine here.", "author": "mconley@mozilla.com", "creation_time": "2016-04-12T14:56:08Z", "raw_text": "So, in conclusion, I think we should give this a shot. There might be some perf win potential here, but we'd need to try it. The implications really aren't clear at this point - we're pretty deep in the machine here.", "attachment_id": null, "id": 11319215}, {"is_private": false, "creator": "sledru@mozilla.com", "count": 8, "creation_time": "2018-11-05T12:52:20Z", "author": "sledru@mozilla.com", "text": "Moving to p3 because no activity for at least 1 year(s).\nSee https://github.com/mozilla/bug-handling/blob/master/policy/triage-bugzilla.md#how-do-you-triage for more information", "tags": [], "bug_id": 666365, "time": "2018-11-05T12:52:20Z", "attachment_id": null, "raw_text": "Moving to p3 because no activity for at least 1 year(s).\nSee https://github.com/mozilla/bug-handling/blob/master/policy/triage-bugzilla.md#how-do-you-triage for more information", "id": 13735535}]}}, "comments": {}}