{"bugs": {"656783": {"comments": [{"time": "2011-05-12T22:26:09Z", "is_private": false, "attachment_id": null, "bug_id": 656783, "creator": "jonozzz@yahoo.com", "count": 0, "tags": [], "raw_text": "User-Agent:       Mozilla/5.0 (Windows NT 6.1; WOW64; rv:2.0.1) Gecko/20100101 Firefox/4.0.1\nBuild Identifier: \n\nI'm basically calling TestCase.list with the following parameters: tags=\"tag1 tag2\", tags_type=\"allwords\".\n\nLet's say I have one test case tagged with tag1, tag2, tag3. I expect it to be matched, but it's not! Digging into the code it becomes obvious why. Look at the SQL query generated:\n\nSELECT DISTINCT test_cases.case_id,test_cases.case_id \nFROM test_cases  \nINNER JOIN test_case_plans AS case_plans ON (test_cases.case_id = case_plans.case_id) \nINNER JOIN test_plans ON (case_plans.plan_id = test_plans.plan_id) \nINNER JOIN test_case_tags  AS case_tags ON (test_cases.case_id = case_tags.case_id) \nINNER JOIN test_tags ON (case_tags.tag_id = test_tags.tag_id) \n\nWHERE ((test_tags.tag_name REGEXP '(^|[^a-z0-9])tag1($|[^a-z0-9])' \n  AND test_tags.tag_name REGEXP '(^|[^a-z0-9])tag2($|[^a-z0-9])')\n )\n\nThe tag_name is a single WORD, therefore it can't be both tag1 AND tag2. This is a many-to-many relationship between testcases and tags.\n\nA correct query that yields the results I'm expecting would look like:\n\nSELECT DISTINCT test_cases.case_id,test_cases.case_id, COUNT(*) AS _cnt \nFROM test_cases  \nINNER JOIN test_case_plans AS case_plans ON (test_cases.case_id = case_plans.case_id) \nINNER JOIN test_plans ON (case_plans.plan_id = test_plans.plan_id) \nINNER JOIN test_case_tags  AS case_tags ON (test_cases.case_id = case_tags.case_id) \nINNER JOIN test_tags ON (case_tags.tag_id = test_tags.tag_id) \n\nWHERE (\n    test_tags.tag_name = 'tag1' or \n    test_tags.tag_name = 'tag2'\n    )\nGROUP BY test_cases.case_id\nHAVING _cnt = 2\n\n\nReproducible: Always", "id": 5466816, "text": "User-Agent:       Mozilla/5.0 (Windows NT 6.1; WOW64; rv:2.0.1) Gecko/20100101 Firefox/4.0.1\nBuild Identifier: \n\nI'm basically calling TestCase.list with the following parameters: tags=\"tag1 tag2\", tags_type=\"allwords\".\n\nLet's say I have one test case tagged with tag1, tag2, tag3. I expect it to be matched, but it's not! Digging into the code it becomes obvious why. Look at the SQL query generated:\n\nSELECT DISTINCT test_cases.case_id,test_cases.case_id \nFROM test_cases  \nINNER JOIN test_case_plans AS case_plans ON (test_cases.case_id = case_plans.case_id) \nINNER JOIN test_plans ON (case_plans.plan_id = test_plans.plan_id) \nINNER JOIN test_case_tags  AS case_tags ON (test_cases.case_id = case_tags.case_id) \nINNER JOIN test_tags ON (case_tags.tag_id = test_tags.tag_id) \n\nWHERE ((test_tags.tag_name REGEXP '(^|[^a-z0-9])tag1($|[^a-z0-9])' \n  AND test_tags.tag_name REGEXP '(^|[^a-z0-9])tag2($|[^a-z0-9])')\n )\n\nThe tag_name is a single WORD, therefore it can't be both tag1 AND tag2. This is a many-to-many relationship between testcases and tags.\n\nA correct query that yields the results I'm expecting would look like:\n\nSELECT DISTINCT test_cases.case_id,test_cases.case_id, COUNT(*) AS _cnt \nFROM test_cases  \nINNER JOIN test_case_plans AS case_plans ON (test_cases.case_id = case_plans.case_id) \nINNER JOIN test_plans ON (case_plans.plan_id = test_plans.plan_id) \nINNER JOIN test_case_tags  AS case_tags ON (test_cases.case_id = case_tags.case_id) \nINNER JOIN test_tags ON (case_tags.tag_id = test_tags.tag_id) \n\nWHERE (\n    test_tags.tag_name = 'tag1' or \n    test_tags.tag_name = 'tag2'\n    )\nGROUP BY test_cases.case_id\nHAVING _cnt = 2\n\n\nReproducible: Always", "creation_time": "2011-05-12T22:26:09Z", "author": "jonozzz@yahoo.com"}]}}, "comments": {}}