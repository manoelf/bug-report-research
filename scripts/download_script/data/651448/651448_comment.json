{"comments": {}, "bugs": {"651448": {"comments": [{"bug_id": 651448, "raw_text": "Spurred by discussion in bug 649576. As Jim pointed out to me, simply adding in decls.clear() to the bottom of the compileScript loop only caused two failures, both of which appear quite fixable:\n\n1. regress-551763-2, which was due to an invalid optimization in the former code. Our shell actually binds a configurable property on the global object named \"arguments\" during setup (which is pretty evil). A test was performing |var arguments = 42; assert(delete arguments, false);| and cleverly-but-inappropriately deducing that arguments was a known non-configurable binding, at which point the constant folder replaced the unary deletion with a simple JSOP_FALSE. Even with the top level decls cleared out, there may be some more bugs along the lines of |var arguments = delete arguments;| -- I'll have to think through the state space a bit more in tests.\n\n2. regress-452498-187, which happened due to a bug in the const semantics. Even *without* clearing decls, the following problem exists:\n\n$ ./js -e 'const x = 42; for (x in {}); print(\"okay!\")'\n-e:1: SyntaxError: invalid for/in left-hand side:\n-e:1: const x = 42; for (x in {}); print(\"okay!\")\n-e:1: ...................^\n$ ./js -e 'const x = 42' -e 'for (x in {}); print(\"okay!\")'\nokay!\n\nSeparating out translation units for top level statements shouldn't have this kind of effect. Normally we communicate global binding information through the shapes on the global object.\n\nThe question that I have to ask in order to fix this correctly: does binding to a read-only global var (as observed at a compile time) trigger a syntax error? I could see a counter argument being \"the first thing a script may want to do is delete a read-only but configurable global object property in order to make later top-level code valid\".", "count": 0, "time": "2011-04-20T09:07:08Z", "tags": [], "is_private": false, "creation_time": "2011-04-20T09:07:08Z", "text": "Spurred by discussion in bug 649576. As Jim pointed out to me, simply adding in decls.clear() to the bottom of the compileScript loop only caused two failures, both of which appear quite fixable:\n\n1. regress-551763-2, which was due to an invalid optimization in the former code. Our shell actually binds a configurable property on the global object named \"arguments\" during setup (which is pretty evil). A test was performing |var arguments = 42; assert(delete arguments, false);| and cleverly-but-inappropriately deducing that arguments was a known non-configurable binding, at which point the constant folder replaced the unary deletion with a simple JSOP_FALSE. Even with the top level decls cleared out, there may be some more bugs along the lines of |var arguments = delete arguments;| -- I'll have to think through the state space a bit more in tests.\n\n2. regress-452498-187, which happened due to a bug in the const semantics. Even *without* clearing decls, the following problem exists:\n\n$ ./js -e 'const x = 42; for (x in {}); print(\"okay!\")'\n-e:1: SyntaxError: invalid for/in left-hand side:\n-e:1: const x = 42; for (x in {}); print(\"okay!\")\n-e:1: ...................^\n$ ./js -e 'const x = 42' -e 'for (x in {}); print(\"okay!\")'\nokay!\n\nSeparating out translation units for top level statements shouldn't have this kind of effect. Normally we communicate global binding information through the shapes on the global object.\n\nThe question that I have to ask in order to fix this correctly: does binding to a read-only global var (as observed at a compile time) trigger a syntax error? I could see a counter argument being \"the first thing a script may want to do is delete a read-only but configurable global object property in order to make later top-level code valid\".", "creator": "cdleary@acm.org", "attachment_id": null, "id": 5420822, "author": "cdleary@acm.org"}, {"creation_time": "2011-04-20T21:56:31Z", "author": "jimb@mozilla.com", "attachment_id": null, "id": 5422462, "creator": "jimb@mozilla.com", "text": "You da man.\n\nI don't think binding to a read-only variable is ever a SyntaxError (and all SyntaxErrors are early errors; see chapter 16). It's assigning to 'eval' or 'arguments' in strict mode code that's an error.", "count": 1, "raw_text": "You da man.\n\nI don't think binding to a read-only variable is ever a SyntaxError (and all SyntaxErrors are early errors; see chapter 16). It's assigning to 'eval' or 'arguments' in strict mode code that's an error.", "bug_id": 651448, "is_private": false, "tags": [], "time": "2011-04-20T21:56:31Z"}, {"raw_text": "(In reply to comment #1)\n> I don't think binding to a read-only variable is ever a SyntaxError\n\nOkay, so the new question becomes why the latter example didn't raise a TypeError at runtime for binding the read-only global shape x.", "is_private": false, "tags": [], "creation_time": "2011-04-21T01:04:25Z", "attachment_id": null, "id": 5423105, "text": "(In reply to comment #1)\n> I don't think binding to a read-only variable is ever a SyntaxError\n\nOkay, so the new question becomes why the latter example didn't raise a TypeError at runtime for binding the read-only global shape x.", "bug_id": 651448, "count": 2, "time": "2011-04-21T01:04:25Z", "creator": "cdleary@acm.org", "author": "cdleary@acm.org"}, {"is_private": false, "tags": [], "time": "2011-04-21T01:07:58Z", "count": 3, "raw_text": "Assignment to non-writable, non-configurable bindings is only a TypeError in strict mode code.", "bug_id": 651448, "author": "jwalden@mit.edu", "id": 5423108, "attachment_id": null, "creator": "jwalden@mit.edu", "text": "Assignment to non-writable, non-configurable bindings is only a TypeError in strict mode code.", "creation_time": "2011-04-21T01:07:58Z"}, {"creator": "cdleary@acm.org", "author": "cdleary@acm.org", "bug_id": 651448, "count": 4, "time": "2011-09-07T18:52:36Z", "creation_time": "2011-09-07T18:52:36Z", "text": "Created attachment 558899\nWIP: double barrel arenas.\n\nProof of concept that separates out the lifetimes and removes recycling, on top of my arena rewrite in bug 684039. Passes jit/js tests.\n\nNicer way of separating the lifetimes in the parser/codegen datastructures (to make sure we clear everything properly) is clearly desirable.\n\n(I wanted to be able to test the benefit of a very large primary chunk in the arena rewrite bug, but it's a lame experiment without a properly cleared statement arena.)", "id": 5705569, "attachment_id": 558899, "raw_text": "Proof of concept that separates out the lifetimes and removes recycling, on top of my arena rewrite in bug 684039. Passes jit/js tests.\n\nNicer way of separating the lifetimes in the parser/codegen datastructures (to make sure we clear everything properly) is clearly desirable.\n\n(I wanted to be able to test the benefit of a very large primary chunk in the arena rewrite bug, but it's a lame experiment without a properly cleared statement arena.)", "tags": [], "is_private": false}, {"attachment_id": 558924, "id": 5705813, "text": "Created attachment 558924\nTest tweaks required.\n\nregress-422269.js: conservative stack scanner breaks this fragile \"leak\" test.\nregress-452498-187.js: const in eval scope used as a LHS really shouldn't be a syntax error -- that implies that the checks for const are syntactic instead of semantic. Should probably remove the associated code path as well.\nregress-551763-2.js: frontend is confusing |delete arguments| with var-declared arguments when there's already a configurable binding on the global. We should file a separate bug to remove that invalid optimization (Jason may have already filed one).", "creation_time": "2011-09-07T20:21:48Z", "is_private": false, "tags": [], "raw_text": "regress-422269.js: conservative stack scanner breaks this fragile \"leak\" test.\nregress-452498-187.js: const in eval scope used as a LHS really shouldn't be a syntax error -- that implies that the checks for const are syntactic instead of semantic. Should probably remove the associated code path as well.\nregress-551763-2.js: frontend is confusing |delete arguments| with var-declared arguments when there's already a configurable binding on the global. We should file a separate bug to remove that invalid optimization (Jason may have already filed one).", "author": "cdleary@acm.org", "creator": "cdleary@acm.org", "time": "2011-09-07T20:21:48Z", "count": 5, "bug_id": 651448}, {"creation_time": "2011-09-08T00:01:15Z", "text": "This sounds very promising for reducing memory usage and/or churn.  Some stats (high-water mark for each pool?  total number of parsenodes created?) before and after would be great!", "attachment_id": null, "id": 5706432, "raw_text": "This sounds very promising for reducing memory usage and/or churn.  Some stats (high-water mark for each pool?  total number of parsenodes created?) before and after would be great!", "tags": [], "is_private": false, "creator": "n.nethercote@gmail.com", "author": "n.nethercote@gmail.com", "bug_id": 651448, "count": 6, "time": "2011-09-08T00:01:15Z"}, {"creation_time": "2011-10-20T20:10:56Z", "creator": "jimb@mozilla.com", "text": "Comment on attachment 558899\nWIP: double barrel arenas.\n\nReview of attachment 558899:\n-----------------------------------------------------------------\n\nOverall comment: huzzah! This is exactly what I expected.\n\n::: js/src/jscntxt.h\n@@ +191,5 @@\n>  \n>      /* Temporary arena pool used while compiling and decompiling. */\n>      static const size_t TEMP_POOL_PRIMARY_CHUNK_SIZE = 1 << 12;\n>      js::QuadArena               tempPool;\n> +    js::QuadArena               boxPool;\n\nWhy does the compiler allocate from LifoAllocs in ThreadData? Couldn't the lifos be members of Compiler, so that their storage is owned by the compiler? I guess that would be a separate patch.\n\nIf that's not practical, it seems like having a LifoAllocScope as a member of the Compiler would release the storage naturally, as a replacement for tempPoolMark.\n\n(BTW, I think LifoAlloc is a much better term than 'arena' or 'pool'. Says what it means, rather than alluding to it, but still terse.)\n\n::: js/src/jsparse.cpp\n@@ -507,5 @@\n>  \n>  } /* namespace js */\n>  \n>  /*\n> - * Push the children of |pn| on |stack|. Return true if |pn| itself could be\n\nAhh, the smell of deleted horrible code in the morning...\n\n@@ +838,5 @@\n>  \n>      inDirectivePrologue = true;\n>      tokenStream.setOctalCharacterEscape(false);\n>      for (;;) {\n> +        QuadArenaScope qas(&JS_THREAD_DATA(cx)->tempPool);\n\nI would want a comment above this. If one isn't alert to the amazing semantics of LifoAllocScope, then it'd be a surprise.", "id": 5795322, "attachment_id": 558899, "author": "jimb@mozilla.com", "bug_id": 651448, "raw_text": "Review of attachment 558899:\n-----------------------------------------------------------------\n\nOverall comment: huzzah! This is exactly what I expected.\n\n::: js/src/jscntxt.h\n@@ +191,5 @@\n>  \n>      /* Temporary arena pool used while compiling and decompiling. */\n>      static const size_t TEMP_POOL_PRIMARY_CHUNK_SIZE = 1 << 12;\n>      js::QuadArena               tempPool;\n> +    js::QuadArena               boxPool;\n\nWhy does the compiler allocate from LifoAllocs in ThreadData? Couldn't the lifos be members of Compiler, so that their storage is owned by the compiler? I guess that would be a separate patch.\n\nIf that's not practical, it seems like having a LifoAllocScope as a member of the Compiler would release the storage naturally, as a replacement for tempPoolMark.\n\n(BTW, I think LifoAlloc is a much better term than 'arena' or 'pool'. Says what it means, rather than alluding to it, but still terse.)\n\n::: js/src/jsparse.cpp\n@@ -507,5 @@\n>  \n>  } /* namespace js */\n>  \n>  /*\n> - * Push the children of |pn| on |stack|. Return true if |pn| itself could be\n\nAhh, the smell of deleted horrible code in the morning...\n\n@@ +838,5 @@\n>  \n>      inDirectivePrologue = true;\n>      tokenStream.setOctalCharacterEscape(false);\n>      for (;;) {\n> +        QuadArenaScope qas(&JS_THREAD_DATA(cx)->tempPool);\n\nI would want a comment above this. If one isn't alert to the amazing semantics of LifoAllocScope, then it'd be a surprise.", "count": 7, "time": "2011-10-20T20:10:56Z", "tags": [], "is_private": false}, {"bug_id": 651448, "raw_text": "Does that feedback cover what you wanted me to look at?\n\nIs it really the case that all the failures this change caused were due to bogus optimizations and bad tests? It's astonishing that we had such hairy code to preserve so little.", "count": 8, "time": "2011-10-20T20:14:18Z", "tags": [], "is_private": false, "creation_time": "2011-10-20T20:14:18Z", "creator": "jimb@mozilla.com", "text": "Does that feedback cover what you wanted me to look at?\n\nIs it really the case that all the failures this change caused were due to bogus optimizations and bad tests? It's astonishing that we had such hairy code to preserve so little.", "attachment_id": null, "id": 5795335, "author": "jimb@mozilla.com"}, {"is_private": false, "tags": [], "time": "2013-03-27T10:52:16Z", "count": 9, "raw_text": "cdleary won't work on this, anymore. Might still be MemShrink material, though.", "bug_id": 651448, "author": "till@tillschneidereit.net", "id": 7248733, "attachment_id": null, "creator": "till@tillschneidereit.net", "text": "cdleary won't work on this, anymore. Might still be MemShrink material, though.", "creation_time": "2013-03-27T10:52:16Z"}]}}}