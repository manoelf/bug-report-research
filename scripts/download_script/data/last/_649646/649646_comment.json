{"bugs": {"649646": {"comments": [{"bug_id": 649646, "count": 0, "time": "2011-04-13T15:18:00Z", "creator": "bent.mozilla@gmail.com", "author": "bent.mozilla@gmail.com", "raw_text": "We currently deserialize, modify, and then reserialize structured clone data on the DB thread when adding to object stores that use inline keys and a key generator. In an effort to keep one runtime per thread we should just modify the data directly.", "tags": [], "is_private": false, "creation_time": "2011-04-13T15:18:00Z", "text": "We currently deserialize, modify, and then reserialize structured clone data on the DB thread when adding to object stores that use inline keys and a key generator. In an effort to keep one runtime per thread we should just modify the data directly.", "attachment_id": null, "id": 5406510}, {"creator": "jonas@sicking.cc", "text": "The basic use-case is something like this:\n\nWhen serializing, we have an object like:\n\n{\n  foo: \"bar\",\n  hello: { world: \"fahrvergnugen\" },\n  deep: {},\n  x: 2\n}\n\nAt a later point, we want to modify the object such that it looks like:\n\n{\n  foo: \"bar\",\n  hello: { world: \"fahrvergnugen\" },\n  deep: { cow: { id: 4 } },\n  x: 2\n}\n\n\nIn other words, we want to set the property \"deep.cow.id\" to 4 (and in the process create any objects that are missing).\n\n\nAnother thing that might help is that the property being written is always a 64bit integer. And we know during the initial serialization where we'll want to write it. I.e. the name of the property that we want to set.\n\nThe only thing we don't know is the actual value.\n\n\nOne thing occurred to me though. We *could* actually implement this without any involvement of the structured clone code. What we could do is to store in the database the generated id, and store that separately from the serialized clone.\n\nThen when reading data from the database we'd parse the serialized value and then insert the generated id in the newly created JS object. And do that every time when reading data from the database.\n\nI'd likely not be as performant, but it'd get us off of using the runtime from the wrong thread.", "attachment_id": null, "id": 5408520, "author": "jonas@sicking.cc", "creation_time": "2011-04-14T01:59:58Z", "time": "2011-04-14T01:59:58Z", "tags": [], "is_private": false, "bug_id": 649646, "raw_text": "The basic use-case is something like this:\n\nWhen serializing, we have an object like:\n\n{\n  foo: \"bar\",\n  hello: { world: \"fahrvergnugen\" },\n  deep: {},\n  x: 2\n}\n\nAt a later point, we want to modify the object such that it looks like:\n\n{\n  foo: \"bar\",\n  hello: { world: \"fahrvergnugen\" },\n  deep: { cow: { id: 4 } },\n  x: 2\n}\n\n\nIn other words, we want to set the property \"deep.cow.id\" to 4 (and in the process create any objects that are missing).\n\n\nAnother thing that might help is that the property being written is always a 64bit integer. And we know during the initial serialization where we'll want to write it. I.e. the name of the property that we want to set.\n\nThe only thing we don't know is the actual value.\n\n\nOne thing occurred to me though. We *could* actually implement this without any involvement of the structured clone code. What we could do is to store in the database the generated id, and store that separately from the serialized clone.\n\nThen when reading data from the database we'd parse the serialized value and then insert the generated id in the newly created JS object. And do that every time when reading data from the database.\n\nI'd likely not be as performant, but it'd get us off of using the runtime from the wrong thread.", "count": 1}, {"creator": "sdwilsh@forerunnerdesigns.com", "text": "(In reply to comment #1)\n> One thing occurred to me though. We *could* actually implement this without any\n> involvement of the structured clone code. What we could do is to store in the\n> database the generated id, and store that separately from the serialized clone.\nWe already do this AFAIK.\n\n> Then when reading data from the database we'd parse the serialized value and\n> then insert the generated id in the newly created JS object. And do that every\n> time when reading data from the database.\nThis shouldn't be too hard to do.", "attachment_id": null, "id": 5408571, "author": "sdwilsh@forerunnerdesigns.com", "creation_time": "2011-04-14T02:27:49Z", "time": "2011-04-14T02:27:49Z", "tags": [], "is_private": false, "bug_id": 649646, "raw_text": "(In reply to comment #1)\n> One thing occurred to me though. We *could* actually implement this without any\n> involvement of the structured clone code. What we could do is to store in the\n> database the generated id, and store that separately from the serialized clone.\nWe already do this AFAIK.\n\n> Then when reading data from the database we'd parse the serialized value and\n> then insert the generated id in the newly created JS object. And do that every\n> time when reading data from the database.\nThis shouldn't be too hard to do.", "count": 2}, {"creator": "overholt@mozilla.com", "author": "overholt@mozilla.com", "time": "2018-12-11T16:14:12Z", "bug_id": 649646, "count": 3, "id": 13806029, "attachment_id": null, "text": "Given some recent discussions with the JS team, it seems like we want to do this some time soon.", "creation_time": "2018-12-11T16:14:12Z", "is_private": false, "tags": [], "raw_text": "Given some recent discussions with the JS team, it seems like we want to do this some time soon."}, {"bug_id": 649646, "raw_text": "To clarify, the following is the part that is interesting. It would allow using a single StructureSerialize when the spec currently involves two calls to this but avoid some of the existing complexity in trying to avoid the two copies.\n\n(In reply to Jonas Sicking (:sicking) No longer reading bugmail consistently from comment #1) \n> One thing occurred to me though. We *could* actually implement this without\n> any involvement of the structured clone code. What we could do is to store\n> in the database the generated id, and store that separately from the\n> serialized clone.\n> \n> Then when reading data from the database we'd parse the serialized value and\n> then insert the generated id in the newly created JS object. And do that\n> every time when reading data from the database.", "count": 4, "time": "2018-12-11T23:22:18Z", "tags": [], "is_private": false, "creation_time": "2018-12-11T23:22:18Z", "text": "To clarify, the following is the part that is interesting. It would allow using a single StructureSerialize when the spec currently involves two calls to this but avoid some of the existing complexity in trying to avoid the two copies.\n\n(In reply to Jonas Sicking (:sicking) No longer reading bugmail consistently from comment #1) \n> One thing occurred to me though. We *could* actually implement this without\n> any involvement of the structured clone code. What we could do is to store\n> in the database the generated id, and store that separately from the\n> serialized clone.\n> \n> Then when reading data from the database we'd parse the serialized value and\n> then insert the generated id in the newly created JS object. And do that\n> every time when reading data from the database.", "creator": "tcampbell@mozilla.com", "attachment_id": null, "id": 13807490, "author": "tcampbell@mozilla.com"}, {"time": "2018-12-15T08:45:44Z", "is_private": false, "tags": [], "raw_text": "I wonder if we can move compression/decompression to content processes once we fix this.", "bug_id": 649646, "count": 5, "attachment_id": null, "id": 13815377, "text": "I wonder if we can move compression/decompression to content processes once we fix this.", "creator": "jvarga@mozilla.com", "author": "jvarga@mozilla.com", "creation_time": "2018-12-15T08:45:44Z"}, {"time": "2020-01-17T13:39:20Z", "tags": [], "is_private": false, "bug_id": 649646, "raw_text": ":janv, is this still something we would want to do?", "count": 6, "creator": "jstutte@mozilla.com", "text": ":janv, is this still something we would want to do?", "attachment_id": null, "id": 14597551, "author": "jstutte@mozilla.com", "creation_time": "2020-01-17T13:39:20Z"}, {"id": 14597558, "attachment_id": null, "creator": "jvarga@mozilla.com", "text": "Yes, this would definitely be a nice improvement.", "author": "jvarga@mozilla.com", "creation_time": "2020-01-17T13:42:49Z", "time": "2020-01-17T13:42:49Z", "is_private": false, "tags": [], "raw_text": "Yes, this would definitely be a nice improvement.", "bug_id": 649646, "count": 7}]}}, "comments": {}}