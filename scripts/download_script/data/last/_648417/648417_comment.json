{"bugs": {"648417": {"comments": [{"creation_time": "2011-04-07T23:41:39Z", "text": "It's not entirely trivial to share the font cache.  Before doing so, let's find out how big it gets during normal browsing, to see if sharing is worth the engineering cost.  I'm not sure how to measure it or what constitutes \"normal\" browsing wrt fonts.\n\nJoe: who's the right person to work on this?", "id": 5395448, "attachment_id": null, "raw_text": "It's not entirely trivial to share the font cache.  Before doing so, let's find out how big it gets during normal browsing, to see if sharing is worth the engineering cost.  I'm not sure how to measure it or what constitutes \"normal\" browsing wrt fonts.\n\nJoe: who's the right person to work on this?", "tags": [], "is_private": false, "creator": "cjones.bugs@gmail.com", "author": "cjones.bugs@gmail.com", "bug_id": 648417, "count": 0, "time": "2011-04-07T23:41:39Z"}, {"raw_text": "As noted in the e10s meeting, this is going to be much more interesting/important for the multiple-content-process case than for the single chrome/content split, because the chrome process *ought* to have only the UI fonts loaded and cached. Although we should probably verify that as well.", "bug_id": 648417, "count": 1, "time": "2011-04-08T17:38:46Z", "is_private": false, "tags": [], "creation_time": "2011-04-08T17:38:46Z", "id": 5396837, "attachment_id": null, "text": "As noted in the e10s meeting, this is going to be much more interesting/important for the multiple-content-process case than for the single chrome/content split, because the chrome process *ought* to have only the UI fonts loaded and cached. Although we should probably verify that as well.", "creator": "benjamin@smedbergs.us", "author": "benjamin@smedbergs.us"}, {"creation_time": "2011-04-12T02:06:03Z", "id": 5402572, "attachment_id": null, "text": "The text rendering system in gfx has a set of caches:\n\n  - \"font cache\" == cache of gfxFont objects (one per style/size combination)\n  - \"font table cache\" == cache of tables pulled in per face\n  - other system-wide font list info (e.g. cmaps, names)\n  - \"word cache\" == cache of already computed text runs per word (temporal)\n\nThe first three would be candidates for sharing across content processes, probably not the word cache.  This would also be a good time to come up with better metrics for how efficient/needed these caches are.", "raw_text": "The text rendering system in gfx has a set of caches:\n\n  - \"font cache\" == cache of gfxFont objects (one per style/size combination)\n  - \"font table cache\" == cache of tables pulled in per face\n  - other system-wide font list info (e.g. cmaps, names)\n  - \"word cache\" == cache of already computed text runs per word (temporal)\n\nThe first three would be candidates for sharing across content processes, probably not the word cache.  This would also be a good time to come up with better metrics for how efficient/needed these caches are.", "is_private": false, "tags": [], "author": "jd.bugzilla@gmail.com", "creator": "jd.bugzilla@gmail.com", "count": 2, "bug_id": 648417, "time": "2011-04-12T02:06:03Z"}, {"time": "2011-04-12T05:25:44Z", "bug_id": 648417, "count": 3, "creator": "joe@drew.ca", "author": "joe@drew.ca", "is_private": false, "tags": [], "raw_text": "I suspect that John would like to work on this, if and when we decide it's what we want to do. That can change at any time though :-)", "id": 5402866, "attachment_id": null, "text": "I suspect that John would like to work on this, if and when we decide it's what we want to do. That can change at any time though :-)", "creation_time": "2011-04-12T05:25:44Z"}, {"raw_text": "Should probably get them into about:memory to see what the amounts look like in the field.", "tags": [], "is_private": false, "creation_time": "2011-07-20T21:52:49Z", "text": "Should probably get them into about:memory to see what the amounts look like in the field.", "attachment_id": null, "id": 5602945, "count": 4, "bug_id": 648417, "time": "2011-07-20T21:52:49Z", "author": "shaver@mozilla.org", "creator": "shaver@mozilla.org"}, {"tags": [], "is_private": false, "time": "2013-02-26T08:32:43Z", "count": 5, "bug_id": 648417, "raw_text": "Not clear yet what the cost/benefit ratio is for this work, but sharing font resources efficiently is definitely a major technical issue.", "author": "cjones.bugs@gmail.com", "text": "Not clear yet what the cost/benefit ratio is for this work, but sharing font resources efficiently is definitely a major technical issue.", "creator": "cjones.bugs@gmail.com", "attachment_id": null, "id": 7142828, "creation_time": "2013-02-26T08:32:43Z"}, {"creation_time": "2013-02-27T00:44:22Z", "author": "jd.bugzilla@gmail.com", "attachment_id": null, "id": 7146813, "creator": "jd.bugzilla@gmail.com", "text": "(In reply to Chris Jones [:cjones] [:warhammer] from comment #5)\n> Not clear yet what the cost/benefit ratio is for this work, but sharing font\n> resources efficiently is definitely a major technical issue.\n\nAnd I think it needs to be worked out whether sharing these across processes is the right approach.  Other options are simply caching less and/or reducing the lifespan of what's cached.  Those are *definitely* easier to consider that trying to do cross-process caches.  There may also be platform-specific options where the underlying platform provides less support for efficient font resource loading (e.g. Android/FreeType).", "count": 6, "raw_text": "(In reply to Chris Jones [:cjones] [:warhammer] from comment #5)\n> Not clear yet what the cost/benefit ratio is for this work, but sharing font\n> resources efficiently is definitely a major technical issue.\n\nAnd I think it needs to be worked out whether sharing these across processes is the right approach.  Other options are simply caching less and/or reducing the lifespan of what's cached.  Those are *definitely* easier to consider that trying to do cross-process caches.  There may also be platform-specific options where the underlying platform provides less support for efficient font resource loading (e.g. Android/FreeType).", "bug_id": 648417, "is_private": false, "tags": [], "time": "2013-02-27T00:44:22Z"}, {"tags": [], "is_private": false, "raw_text": "Nicholas, I'm not sure this is really a P2 anything.  Labeling as such I think is a distraction from other ways of decreasing font-related memory usage.", "text": "Nicholas, I'm not sure this is really a P2 anything.  Labeling as such I think is a distraction from other ways of decreasing font-related memory usage.", "id": 7172322, "attachment_id": null, "creation_time": "2013-03-06T01:19:25Z", "time": "2013-03-06T01:19:25Z", "bug_id": 648417, "count": 7, "creator": "jd.bugzilla@gmail.com", "author": "jd.bugzilla@gmail.com"}, {"creator": "n.nethercote@gmail.com", "author": "n.nethercote@gmail.com", "time": "2013-03-06T01:23:23Z", "bug_id": 648417, "count": 8, "id": 7172331, "attachment_id": null, "text": "(In reply to John Daggett (:jtd) from comment #7)\n> Nicholas, I'm not sure this is really a P2 anything.  Labeling as such I\n> think is a distraction from other ways of decreasing font-related memory\n> usage.\n\nWe triage all MemShrink-tagged bugs as P1, P2 or P3.  See \nhttps://wiki.mozilla.org/Performance/MemShrink#Bug_Tracking\nfor details.", "creation_time": "2013-03-06T01:23:23Z", "is_private": false, "tags": [], "raw_text": "(In reply to John Daggett (:jtd) from comment #7)\n> Nicholas, I'm not sure this is really a P2 anything.  Labeling as such I\n> think is a distraction from other ways of decreasing font-related memory\n> usage.\n\nWe triage all MemShrink-tagged bugs as P1, P2 or P3.  See \nhttps://wiki.mozilla.org/Performance/MemShrink#Bug_Tracking\nfor details."}, {"bug_id": 648417, "count": 9, "time": "2013-03-06T23:22:27Z", "creator": "n.nethercote@gmail.com", "author": "n.nethercote@gmail.com", "raw_text": "> The text rendering system in gfx has a set of caches:\n> \n>   - \"font cache\" == cache of gfxFont objects (one per style/size combination)\n>   - \"font table cache\" == cache of tables pulled in per face\n>   - other system-wide font list info (e.g. cmaps, names)\n>   - \"word cache\" == cache of already computed text runs per word (temporal)\n> \n> The first three would be candidates for sharing across content processes,\n> probably not the word cache.  This would also be a good time to come up with\n> better metrics for how efficient/needed these caches are.\n\nThe font/text things reported in about:memory that I know about are:\n\n- \"gfx/font-shaped-words\"\n- \"gfx/font-cache\" (presumably this is the \"font cache\" mentioned above)\n- \"window(...)/layout/text-runs\" (which is per-window)\n\nDo we need memory reporters for the latter three items in the list above?", "tags": [], "is_private": false, "creation_time": "2013-03-06T23:22:27Z", "text": "> The text rendering system in gfx has a set of caches:\n> \n>   - \"font cache\" == cache of gfxFont objects (one per style/size combination)\n>   - \"font table cache\" == cache of tables pulled in per face\n>   - other system-wide font list info (e.g. cmaps, names)\n>   - \"word cache\" == cache of already computed text runs per word (temporal)\n> \n> The first three would be candidates for sharing across content processes,\n> probably not the word cache.  This would also be a good time to come up with\n> better metrics for how efficient/needed these caches are.\n\nThe font/text things reported in about:memory that I know about are:\n\n- \"gfx/font-shaped-words\"\n- \"gfx/font-cache\" (presumably this is the \"font cache\" mentioned above)\n- \"window(...)/layout/text-runs\" (which is per-window)\n\nDo we need memory reporters for the latter three items in the list above?", "attachment_id": null, "id": 7175879}, {"creator": "hzbz@pm.me", "author": "hzbz@pm.me", "time": "2014-01-04T03:09:53Z", "bug_id": 648417, "count": 10, "text": "John, did that last 9 months of development provide any illumination as to whether this is worth investigating still?", "attachment_id": null, "id": 8252981, "creation_time": "2014-01-04T03:09:53Z", "tags": [], "is_private": false, "raw_text": "John, did that last 9 months of development provide any illumination as to whether this is worth investigating still?"}, {"bug_id": 648417, "raw_text": "gfxFont cache is an nsExpirationTracker, which via ExpirationTrackerObserver listens for memory-pressure events and purges the cache. Thats not ideal but it should make the font cache irrelevant under memory pressure. Sharing it might improve performance of concurrently rendering processes. In case of FFOS where memory is tightest only one process renders at any given time, so there at most this is a app switching latency problem (process needs some time to recover from having its font cache purged).", "count": 11, "time": "2014-01-04T03:18:07Z", "tags": [], "is_private": false, "creation_time": "2014-01-04T03:18:07Z", "creator": "gal@uci.edu", "text": "gfxFont cache is an nsExpirationTracker, which via ExpirationTrackerObserver listens for memory-pressure events and purges the cache. Thats not ideal but it should make the font cache irrelevant under memory pressure. Sharing it might improve performance of concurrently rendering processes. In case of FFOS where memory is tightest only one process renders at any given time, so there at most this is a app switching latency problem (process needs some time to recover from having its font cache purged).", "attachment_id": null, "id": 8252983, "author": "gal@uci.edu"}, {"count": 12, "raw_text": "The FrameTextRunCache is an nsExpirationTracker as well so same applies there.", "bug_id": 648417, "is_private": false, "tags": [], "time": "2014-01-04T03:22:43Z", "creation_time": "2014-01-04T03:22:43Z", "author": "gal@uci.edu", "attachment_id": null, "id": 8252987, "text": "The FrameTextRunCache is an nsExpirationTracker as well so same applies there.", "creator": "gal@uci.edu"}, {"creation_time": "2014-01-06T08:58:09Z", "author": "jd.bugzilla@gmail.com", "creator": "jd.bugzilla@gmail.com", "text": "(In reply to Andreas Gal :gal from comment #11)\n> gfxFont cache is an nsExpirationTracker, which via ExpirationTrackerObserver\n> listens for memory-pressure events and purges the cache. Thats not ideal but\n> it should make the font cache irrelevant under memory pressure. Sharing it\n> might improve performance of concurrently rendering processes. In case of\n> FFOS where memory is tightest only one process renders at any given time, so\n> there at most this is a app switching latency problem (process needs some\n> time to recover from having its font cache purged).\n\nHmmm. Rather than introducing relatively complex machinery for sharing cached text and font related data at various granularity, I think it's simpler just to look at what data is retained and focus first on how to reduce the need to retain that data.  That starts way up in layout text frame code and runs all the way down to harfbuzz shaping code.\n\nSpecifically, I don't think derived data objects like gfxFont's (which own size-specific metrics, extents and a word cache) or gfxTextRun's can easily be shared across processes in an efficient manner.  The code is just too complex to easily refactor in a way that could be easily shared across processes.\n\nI do think there might be a benefit to having some way of sharing lower-level system font data (e.g. font tables, enumerated lists of font data like localized family names and postscript ==> font mappings, and the cmap sets needed for font fallback).\n\nTo varying degrees, desktop OSes provide services that already effectively share font data across processes.  For example, DirectWrite and CoreText cache font family lists and provide fallback methods that eliminate the need to load cmaps for determining fallback fonts.  FFOS and Android lack this but the number of fonts supplied on the system is much lower.  I imagine Android will eventually evolve to have some form of system font cache, that's the evolution most systems take.  For FFOS I think it would be just simpler to figure out a way of distilling font metadata (e.g. fallback lists, names) as part of the build process in such a way that the amount of per-process data is very small when loaded.", "attachment_id": null, "id": 8254757, "count": 13, "bug_id": 648417, "raw_text": "(In reply to Andreas Gal :gal from comment #11)\n> gfxFont cache is an nsExpirationTracker, which via ExpirationTrackerObserver\n> listens for memory-pressure events and purges the cache. Thats not ideal but\n> it should make the font cache irrelevant under memory pressure. Sharing it\n> might improve performance of concurrently rendering processes. In case of\n> FFOS where memory is tightest only one process renders at any given time, so\n> there at most this is a app switching latency problem (process needs some\n> time to recover from having its font cache purged).\n\nHmmm. Rather than introducing relatively complex machinery for sharing cached text and font related data at various granularity, I think it's simpler just to look at what data is retained and focus first on how to reduce the need to retain that data.  That starts way up in layout text frame code and runs all the way down to harfbuzz shaping code.\n\nSpecifically, I don't think derived data objects like gfxFont's (which own size-specific metrics, extents and a word cache) or gfxTextRun's can easily be shared across processes in an efficient manner.  The code is just too complex to easily refactor in a way that could be easily shared across processes.\n\nI do think there might be a benefit to having some way of sharing lower-level system font data (e.g. font tables, enumerated lists of font data like localized family names and postscript ==> font mappings, and the cmap sets needed for font fallback).\n\nTo varying degrees, desktop OSes provide services that already effectively share font data across processes.  For example, DirectWrite and CoreText cache font family lists and provide fallback methods that eliminate the need to load cmaps for determining fallback fonts.  FFOS and Android lack this but the number of fonts supplied on the system is much lower.  I imagine Android will eventually evolve to have some form of system font cache, that's the evolution most systems take.  For FFOS I think it would be just simpler to figure out a way of distilling font metadata (e.g. fallback lists, names) as part of the build process in such a way that the amount of per-process data is very small when loaded.", "tags": [], "is_private": false, "time": "2014-01-06T08:58:09Z"}, {"creator": "jd.bugzilla@gmail.com", "author": "jd.bugzilla@gmail.com", "time": "2014-01-06T09:01:31Z", "bug_id": 648417, "count": 14, "text": "(In reply to Dietrich Ayala (:dietrich) from comment #10)\n> John, did that last 9 months of development provide any illumination as to\n> whether this is worth investigating still?\n\nBasically, no. While there might be room for improvement in areas such as lower-level font table data caching on Android and FFOS, overall cross-process sharing seems like a big gun applied to a tiny problem.", "id": 8254767, "attachment_id": null, "creation_time": "2014-01-06T09:01:31Z", "tags": [], "is_private": false, "raw_text": "(In reply to Dietrich Ayala (:dietrich) from comment #10)\n> John, did that last 9 months of development provide any illumination as to\n> whether this is worth investigating still?\n\nBasically, no. While there might be room for improvement in areas such as lower-level font table data caching on Android and FFOS, overall cross-process sharing seems like a big gun applied to a tiny problem."}, {"text": "This came up again in the context of fission, see bug 1471309 comment 13.\n\nIn that bug we discussed two caches - the cache of loaded fonts from the system, and the word cache. Jonathan, are there others of interest? I'm not sure how well comment 2 has aged over seven years.\n\nThe first cache (loaded fonts from the system) seems like something we're going to need to share. We can end up doing some pretty expensive work the first time common fonts are loaded. This work generally gets amortized across process lifetime, but that will matter less in a fission world. I'd also imagine the data structures aren't small. Jonathan, can you measure?\n\nAnother question is whether any of the APIs we use to load fonts on Windows are going away in the content process. Jonathan, can you give a rough outline of the API surface to jimm, who can then answer this question?\n\nThe next topic is the shaped word caches. These are high-traffic, and so from a performance and complexity standpoint it would likely be simpler to avoid sharing them. The question is how much it will cost us memory-wise to avoid sharing shaped words across domains, and whether that overhead is acceptable. Jonathan, can you comment/measure?", "id": 13458233, "attachment_id": null, "creation_time": "2018-07-09T17:02:39Z", "tags": [], "is_private": false, "raw_text": "This came up again in the context of fission, see bug 1471309 comment 13.\n\nIn that bug we discussed two caches - the cache of loaded fonts from the system, and the word cache. Jonathan, are there others of interest? I'm not sure how well comment 2 has aged over seven years.\n\nThe first cache (loaded fonts from the system) seems like something we're going to need to share. We can end up doing some pretty expensive work the first time common fonts are loaded. This work generally gets amortized across process lifetime, but that will matter less in a fission world. I'd also imagine the data structures aren't small. Jonathan, can you measure?\n\nAnother question is whether any of the APIs we use to load fonts on Windows are going away in the content process. Jonathan, can you give a rough outline of the API surface to jimm, who can then answer this question?\n\nThe next topic is the shaped word caches. These are high-traffic, and so from a performance and complexity standpoint it would likely be simpler to avoid sharing them. The question is how much it will cost us memory-wise to avoid sharing shaped words across domains, and whether that overhead is acceptable. Jonathan, can you comment/measure?", "creator": "bholley@mozilla.com", "author": "bholley@mozilla.com", "time": "2018-07-09T17:02:39Z", "bug_id": 648417, "count": 15}, {"text": "We also have bug bug 1258781 on file for reducing the skia glyph cache; I'm not sure if that's the same as the shaped word cache being mentioned.", "creator": "ericrahm+bz@gmail.com", "id": 13458250, "attachment_id": null, "author": "ericrahm+bz@gmail.com", "creation_time": "2018-07-09T17:09:34Z", "time": "2018-07-09T17:09:34Z", "tags": [], "is_private": false, "bug_id": 648417, "raw_text": "We also have bug bug 1258781 on file for reducing the skia glyph cache; I'm not sure if that's the same as the shaped word cache being mentioned.", "count": 16}, {"count": 17, "raw_text": "(In reply to Eric Rahm [:erahm] (please no mozreview requests) from comment #16)\n> We also have bug bug 1258781 on file for reducing the skia glyph cache; I'm\n> not sure if that's the same as the shaped word cache being mentioned.\n\nThis is about mWordCache [1], which caches gfxShapedText, which is used during layout. So I think it's different.\n\n[1] https://searchfox.org/mozilla-central/rev/28daa2806c89684b3dfa4f0b551db1d099dda7c2/gfx/thebes/gfxFont.h#2258", "bug_id": 648417, "is_private": false, "tags": [], "time": "2018-07-09T17:15:45Z", "creation_time": "2018-07-09T17:15:45Z", "author": "bholley@mozilla.com", "attachment_id": null, "id": 13458264, "creator": "bholley@mozilla.com", "text": "(In reply to Eric Rahm [:erahm] (please no mozreview requests) from comment #16)\n> We also have bug bug 1258781 on file for reducing the skia glyph cache; I'm\n> not sure if that's the same as the shaped word cache being mentioned.\n\nThis is about mWordCache [1], which caches gfxShapedText, which is used during layout. So I think it's different.\n\n[1] https://searchfox.org/mozilla-central/rev/28daa2806c89684b3dfa4f0b551db1d099dda7c2/gfx/thebes/gfxFont.h#2258"}, {"author": "kmaglione+bmo@mozilla.com", "creator": "kmaglione+bmo@mozilla.com", "count": 18, "bug_id": 648417, "time": "2018-07-09T22:32:50Z", "creation_time": "2018-07-09T22:32:50Z", "text": "(In reply to Bobby Holley (:bholley) from comment #15)\n> The next topic is the shaped word caches. These are high-traffic, and so\n> from a performance and complexity standpoint it would likely be simpler to\n> avoid sharing them. The question is how much it will cost us memory-wise to\n> avoid sharing shaped words across domains, and whether that overhead is\n> acceptable. Jonathan, can you comment/measure?\n\nDepending on how big they get and how many of the entries wind up shared between origins, we might be able to get away with an approach similar to bug 1471025, where we have a base cache shared between processes, and a per-process dynamic cache on top of that. We'd have to do some work to periodically send heavily-used cache entries to the parent processes during idle slices, and then send updated snapshots to all children. But if we can save more than 100K/child that way, it's probably worth it.\n\nOne other benefit of the snapshot approach is that we have much more opportunity to optimize the layout of the snapshot than we do of a pure dynamic hashtable, which means we can probably fit many more entries in the same amount of memory, and we can make sure lookups always have an optimal probe length (assuming a static hashtable rather than a binary tree, as our other snapshots currently use).\n\nAnd as a bonus, if we're doing multi-threaded layout, the static caches can be probed without any locking, as long as each thread keeps its own reference to the cache.", "attachment_id": null, "id": 13459057, "raw_text": "(In reply to Bobby Holley (:bholley) from comment #15)\n> The next topic is the shaped word caches. These are high-traffic, and so\n> from a performance and complexity standpoint it would likely be simpler to\n> avoid sharing them. The question is how much it will cost us memory-wise to\n> avoid sharing shaped words across domains, and whether that overhead is\n> acceptable. Jonathan, can you comment/measure?\n\nDepending on how big they get and how many of the entries wind up shared between origins, we might be able to get away with an approach similar to bug 1471025, where we have a base cache shared between processes, and a per-process dynamic cache on top of that. We'd have to do some work to periodically send heavily-used cache entries to the parent processes during idle slices, and then send updated snapshots to all children. But if we can save more than 100K/child that way, it's probably worth it.\n\nOne other benefit of the snapshot approach is that we have much more opportunity to optimize the layout of the snapshot than we do of a pure dynamic hashtable, which means we can probably fit many more entries in the same amount of memory, and we can make sure lookups always have an optimal probe length (assuming a static hashtable rather than a binary tree, as our other snapshots currently use).\n\nAnd as a bonus, if we're doing multi-threaded layout, the static caches can be probed without any locking, as long as each thread keeps its own reference to the cache.", "tags": [], "is_private": false}, {"is_private": false, "tags": [], "raw_text": "David, do you know who can work on this? It has a pretty big impact across the board for per content process overhead.", "attachment_id": null, "id": 13461054, "text": "David, do you know who can work on this? It has a pretty big impact across the board for per content process overhead.", "creation_time": "2018-07-10T18:24:51Z", "time": "2018-07-10T18:24:51Z", "bug_id": 648417, "count": 19, "creator": "ericrahm+bz@gmail.com", "author": "ericrahm+bz@gmail.com"}, {"creation_time": "2018-07-10T19:06:53Z", "attachment_id": null, "id": 13461167, "text": "(In reply to Eric Rahm [:erahm] (please no mozreview requests) from comment #19)\n> David, do you know who can work on this? It has a pretty big impact across\n> the board for per content process overhead.\n\nI think jfkthame is probably the right person.", "raw_text": "(In reply to Eric Rahm [:erahm] (please no mozreview requests) from comment #19)\n> David, do you know who can work on this? It has a pretty big impact across\n> the board for per content process overhead.\n\nI think jfkthame is probably the right person.", "is_private": false, "tags": [], "creator": "bholley@mozilla.com", "author": "bholley@mozilla.com", "bug_id": 648417, "count": 20, "time": "2018-07-10T19:06:53Z"}, {"count": 21, "bug_id": 648417, "time": "2018-07-10T19:07:26Z", "author": "bholley@mozilla.com", "creator": "bholley@mozilla.com", "raw_text": "(Will chat with him about it once he's back from PTO, removing NI from dbolter for now).", "tags": [], "is_private": false, "creation_time": "2018-07-10T19:07:26Z", "text": "(Will chat with him about it once he's back from PTO, removing NI from dbolter for now).", "id": 13461168, "attachment_id": null}, {"author": "jfkthame@gmail.com", "creator": "jfkthame@gmail.com", "time": "2018-07-16T09:44:37Z", "count": 22, "bug_id": 648417, "text": "There are a couple of things that may be worth exploring here, with potentially varying levels of complexity, performance trade-offs, etc.\n\n(1) The system font list (managed by platform-specific implementations of gfxPlatformFontList). This holds a list of all the installed font families, created at startup (and rarely updated during a session, though the possibility has to be handled).\n\nOn some platforms, we already build this list \"from scratch\" (via platform APIs) only in the chrome process, and pass it via IPC to content processes; this was done because using platform APIs to iterate over all available fonts can be a bit expensive.\n\nNote, however, that the objects in the font list are not entirely static; they're subject to lazy initialization (again for performance reasons; it's too expensive to populate everything during startup). So we start with a simple list of font families. On demand, we populate the families with their list of available faces; and on demand, we examine individual faces to determine their character coverage. These details are retrieved on first use, and then cached in the font list.\n\nSo a shared font list will need to allow for this progressive enhancement as various font families and faces get used and therefore fully initialized.\n\nIn my current session, I'm seeing memory usage in the 150-200K range for the font list (this will depend on the user's installed fonts -- I have quite a lot), so there's a substantial memory win to be had if we can take this out of the individual content processes.\n\n(2) When we actually measure/render text with a given font, we cache the shaped glyph records that represent each word, as this gives a substantial perf win in text layout (most of the time, given that common words occur repeatedly). The memory used for this caching varies greatly depending on the kind of content a process is handling; it may be negligible, or just a few kilobytes, or it may be hundreds of KB. (I currently have about 1.3MB in a content process that has loaded the NYTimes home page, for example.)\n\nBecause this data is specific to text in a given font face and size, it's unclear how often we'd get a big win by sharing it between processes. This would only happen if multiple content processes are using the exact same styles. In a world of short-lived content processes and repeated visits to certain sites, though, it might become pretty significant.", "attachment_id": null, "id": 13473577, "creation_time": "2018-07-16T09:44:37Z", "tags": [], "is_private": false, "raw_text": "There are a couple of things that may be worth exploring here, with potentially varying levels of complexity, performance trade-offs, etc.\n\n(1) The system font list (managed by platform-specific implementations of gfxPlatformFontList). This holds a list of all the installed font families, created at startup (and rarely updated during a session, though the possibility has to be handled).\n\nOn some platforms, we already build this list \"from scratch\" (via platform APIs) only in the chrome process, and pass it via IPC to content processes; this was done because using platform APIs to iterate over all available fonts can be a bit expensive.\n\nNote, however, that the objects in the font list are not entirely static; they're subject to lazy initialization (again for performance reasons; it's too expensive to populate everything during startup). So we start with a simple list of font families. On demand, we populate the families with their list of available faces; and on demand, we examine individual faces to determine their character coverage. These details are retrieved on first use, and then cached in the font list.\n\nSo a shared font list will need to allow for this progressive enhancement as various font families and faces get used and therefore fully initialized.\n\nIn my current session, I'm seeing memory usage in the 150-200K range for the font list (this will depend on the user's installed fonts -- I have quite a lot), so there's a substantial memory win to be had if we can take this out of the individual content processes.\n\n(2) When we actually measure/render text with a given font, we cache the shaped glyph records that represent each word, as this gives a substantial perf win in text layout (most of the time, given that common words occur repeatedly). The memory used for this caching varies greatly depending on the kind of content a process is handling; it may be negligible, or just a few kilobytes, or it may be hundreds of KB. (I currently have about 1.3MB in a content process that has loaded the NYTimes home page, for example.)\n\nBecause this data is specific to text in a given font face and size, it's unclear how often we'd get a big win by sharing it between processes. This would only happen if multiple content processes are using the exact same styles. In a world of short-lived content processes and repeated visits to certain sites, though, it might become pretty significant."}, {"author": "jfkthame@gmail.com", "creator": "jfkthame@gmail.com", "count": 23, "bug_id": 648417, "time": "2018-07-16T09:50:17Z", "creation_time": "2018-07-16T09:50:17Z", "attachment_id": null, "id": 13473584, "text": "A potentially tricky part of sharing the system font list is that it currently holds platform font references (e.g. Core Text font references, DirectWrite font faces, FreeType faces, etc) that aren't likely to be usable across processes. So I guess we'll end up needing some kind of cache for these on the content-process side, even if we can keep the bulk of the metadata in a shared list.", "raw_text": "A potentially tricky part of sharing the system font list is that it currently holds platform font references (e.g. Core Text font references, DirectWrite font faces, FreeType faces, etc) that aren't likely to be usable across processes. So I guess we'll end up needing some kind of cache for these on the content-process side, even if we can keep the bulk of the metadata in a shared list.", "is_private": false, "tags": []}, {"author": "bzbarsky@mit.edu", "creator": "bzbarsky@mit.edu", "count": 24, "bug_id": 648417, "time": "2018-07-16T18:43:41Z", "creation_time": "2018-07-16T18:43:41Z", "text": "> On demand, we populate the families with their list of available faces; and on demand, we examine individual\n> faces to determine their character coverage.\n\nDoes this happen in the content process, or get remoted to the chrome process and then shipped back down to the content process?", "id": 13474791, "attachment_id": null, "raw_text": "> On demand, we populate the families with their list of available faces; and on demand, we examine individual\n> faces to determine their character coverage.\n\nDoes this happen in the content process, or get remoted to the chrome process and then shipped back down to the content process?", "tags": [], "is_private": false}, {"creation_time": "2018-07-16T20:32:27Z", "author": "jfkthame@gmail.com", "id": 13475099, "attachment_id": null, "text": "Currently, in the content process.", "creator": "jfkthame@gmail.com", "count": 25, "raw_text": "Currently, in the content process.", "bug_id": 648417, "is_private": false, "tags": [], "time": "2018-07-16T20:32:27Z"}, {"time": "2018-07-17T16:42:54Z", "is_private": false, "tags": [], "raw_text": "Ok. Sounds to me like sharing the system font stuff across processes is something we probably need to do.\n\nSharing the shaped words seems less likely to be an obvious memory win. That said, I think we should measure. I propose the following experiment:\n(1) Instrument the shaped word cache such that entries also contain an array of RefPtr<BasePrincipal>.\n(2) New cache entries have a 1-element array with the document principal. Cache hits scan the list for matches (via BasePrincipal::FastEquals) and insert the document principal if no matches are found.\n(3) Set dom.ipc.processCount to 1. Set the word cache size to unbounded (if a cap exists, not sure).\n(4) Load the sites in [1], one per tab.\n(5) Iterate over the cache. For each entry, add size_of(Word) * (array.length - 1) to the total count. dump the total count. Also dump the total size of the words in the table ignoring the principal array.\n\nWDYT Jonathan?\n\n\n[1] https://docs.google.com/document/d/1I5MlrMgNTMjicHgauWa0zltS9tMBxcgN-hCPgNBxZA8/edit#", "bug_id": 648417, "count": 26, "id": 13477342, "attachment_id": null, "creator": "bholley@mozilla.com", "text": "Ok. Sounds to me like sharing the system font stuff across processes is something we probably need to do.\n\nSharing the shaped words seems less likely to be an obvious memory win. That said, I think we should measure. I propose the following experiment:\n(1) Instrument the shaped word cache such that entries also contain an array of RefPtr<BasePrincipal>.\n(2) New cache entries have a 1-element array with the document principal. Cache hits scan the list for matches (via BasePrincipal::FastEquals) and insert the document principal if no matches are found.\n(3) Set dom.ipc.processCount to 1. Set the word cache size to unbounded (if a cap exists, not sure).\n(4) Load the sites in [1], one per tab.\n(5) Iterate over the cache. For each entry, add size_of(Word) * (array.length - 1) to the total count. dump the total count. Also dump the total size of the words in the table ignoring the principal array.\n\nWDYT Jonathan?\n\n\n[1] https://docs.google.com/document/d/1I5MlrMgNTMjicHgauWa0zltS9tMBxcgN-hCPgNBxZA8/edit#", "author": "bholley@mozilla.com", "creation_time": "2018-07-17T16:42:54Z"}, {"count": 27, "bug_id": 648417, "raw_text": "Just to update here, I've started to think about how we can create a system font list that resides in shared memory (meaning we can't do it with our existing hashtables/arrays/strings/etc that use pointers all over the place!), as it seems clear there's a substantial memory win to be had there, particularly in the Fission world. (I'd expect there should be a minor startup-time win for content processes, too.)\n\nAs noted in comment 26, it's less clear whether sharing shaped-word caches would be a significant win in typical cases (I'm also more uncertain whether it could be made sufficiently performant). Some measurement along the lines suggested above would help give us more insight here. My suspicion is that many of the high-profile sites of interest will be using site-specific webfonts, which would limit the scope for cache-sharing.", "tags": [], "is_private": false, "time": "2018-07-25T14:42:15Z", "creation_time": "2018-07-25T14:42:15Z", "author": "jfkthame@gmail.com", "text": "Just to update here, I've started to think about how we can create a system font list that resides in shared memory (meaning we can't do it with our existing hashtables/arrays/strings/etc that use pointers all over the place!), as it seems clear there's a substantial memory win to be had there, particularly in the Fission world. (I'd expect there should be a minor startup-time win for content processes, too.)\n\nAs noted in comment 26, it's less clear whether sharing shaped-word caches would be a significant win in typical cases (I'm also more uncertain whether it could be made sufficiently performant). Some measurement along the lines suggested above would help give us more insight here. My suspicion is that many of the high-profile sites of interest will be using site-specific webfonts, which would limit the scope for cache-sharing.", "creator": "jfkthame@gmail.com", "attachment_id": null, "id": 13498353}, {"time": "2019-03-26T15:21:05Z", "tags": ["obsolete"], "is_private": false, "bug_id": 648417, "raw_text": "Is this still on track for M2 (landing in April?) Thanks", "count": 28, "creator": "nika@thelayzells.com", "text": "Is this still on track for M2 (landing in April?) Thanks", "id": 14012412, "attachment_id": null, "author": "nika@thelayzells.com", "creation_time": "2019-03-26T15:21:05Z"}, {"is_private": false, "tags": ["obsolete"], "time": "2019-04-04T11:08:00Z", "count": 29, "raw_text": "Sorry, I appear to have pasted the wrong bug number into the meeting notes. It is bug 1514869 that is being targeted at M2.", "bug_id": 648417, "author": "jwatt@jwatt.org", "attachment_id": null, "id": 14032860, "text": "Sorry, I appear to have pasted the wrong bug number into the meeting notes. It is bug 1514869 that is being targeted at M2.", "creator": "jwatt@jwatt.org", "creation_time": "2019-04-04T11:08:00Z"}, {"creation_time": "2019-06-28T01:46:37Z", "attachment_id": null, "id": 14203312, "text": "Jonathan, are you still looking into this?", "creator": "jwatt@jwatt.org", "author": "jwatt@jwatt.org", "raw_text": "Jonathan, are you still looking into this?", "bug_id": 648417, "count": 30, "time": "2019-06-28T01:46:37Z", "is_private": false, "tags": []}, {"time": "2019-06-28T17:38:34Z", "bug_id": 648417, "count": 31, "creator": "jfkthame@gmail.com", "author": "jfkthame@gmail.com", "is_private": false, "tags": [], "raw_text": "The shared-fontlist work is part of this, so yes, that's in progress; bug 1533462 intends to start preffing it on once the dependencies there are resolved.\n\nThere's no current work on sharing the fonts' shaped-word caches between processes, which would be the other potential memory win (although it's unclear how big of a win in practice, and I'm pretty doubtful it could be made sufficiently performant).", "attachment_id": null, "id": 14204695, "text": "The shared-fontlist work is part of this, so yes, that's in progress; bug 1533462 intends to start preffing it on once the dependencies there are resolved.\n\nThere's no current work on sharing the fonts' shaped-word caches between processes, which would be the other potential memory win (although it's unclear how big of a win in practice, and I'm pretty doubtful it could be made sufficiently performant).", "creation_time": "2019-06-28T17:38:34Z"}, {"author": "jmathies@mozilla.com", "attachment_id": null, "id": 15305418, "text": "There's no obvious and easily attainable memshrink wins identified here. I don't think fission team needs to track what's left.", "creator": "jmathies@mozilla.com", "creation_time": "2021-03-11T18:35:31Z", "is_private": false, "tags": [], "time": "2021-03-11T18:35:31Z", "count": 32, "raw_text": "There's no obvious and easily attainable memshrink wins identified here. I don't think fission team needs to track what's left.", "bug_id": 648417}, {"count": 33, "bug_id": 648417, "raw_text": "Jonathan, it'd help to know what could be the memory win with this work. Would you possibly have time to investigate this? Or maybe you already have findings to share? :)", "tags": [], "is_private": false, "time": "2021-04-01T18:24:33Z", "creation_time": "2021-04-01T18:24:33Z", "author": "nkochar@mozilla.com", "text": "Jonathan, it'd help to know what could be the memory win with this work. Would you possibly have time to investigate this? Or maybe you already have findings to share? :)", "creator": "nkochar@mozilla.com", "id": 15340992, "attachment_id": null}]}}, "comments": {}}