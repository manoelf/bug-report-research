{"bugs": {"653236": {"comments": [{"time": "2011-04-27T20:54:24Z", "tags": [], "is_private": false, "bug_id": 653236, "raw_text": "+++ This bug was initially created as a clone of Bug #653032 +++\n\nIn Bug 653032 Comment 6, Owen wrote:\n\n> why does the code for P384 call mp_submod(), doesn't\n> that completely defeat the point of having an\n> optimized mod function?", "count": 0, "creator": "brian@briansmith.org", "text": "+++ This bug was initially created as a clone of Bug #653032 +++\n\nIn Bug 653032 Comment 6, Owen wrote:\n\n> why does the code for P384 call mp_submod(), doesn't\n> that completely defeat the point of having an\n> optimized mod function?", "id": 5435673, "attachment_id": null, "author": "brian@briansmith.org", "creation_time": "2011-04-27T20:54:24Z"}, {"raw_text": "This is a faster implementation of the P-384 modulus function that performs the final reduction using additions and subtractions.", "tags": [], "is_private": false, "creation_time": "2011-04-30T01:33:52Z", "text": "Created attachment 529253\nA faster implementation of P-384 mod.\n\nThis is a faster implementation of the P-384 modulus function that performs the final reduction using additions and subtractions.", "attachment_id": 529253, "id": 5440851, "bug_id": 653236, "count": 1, "time": "2011-04-30T01:33:52Z", "creator": "osk@exegin.com", "author": "osk@exegin.com"}, {"author": "brian@briansmith.org", "attachment_id": 529253, "id": 5474459, "text": "Comment on attachment 529253\nA faster implementation of P-384 mod.\n\nBob, is there someone else who should (also) review this?", "creator": "brian@briansmith.org", "creation_time": "2011-05-17T11:31:36Z", "is_private": false, "tags": [], "time": "2011-05-17T11:31:36Z", "count": 2, "raw_text": "Bob, is there someone else who should (also) review this?", "bug_id": 653236}, {"creation_time": "2011-06-15T01:12:38Z", "author": "rrelyea@redhat.com", "attachment_id": 529253, "id": 5533027, "creator": "rrelyea@redhat.com", "text": "Comment on attachment 529253\nA faster implementation of P-384 mod.\n\nr+  I've convinced myself the code is correct, though I have few comments, and would like to have a few changes included (mostly the addition of comments):\n\n1) The comment above the 'a_used > ECP384_DIGITS' test is in correct. you need\nto drop 'or polynomials not using all words'. The main goal of this patch appears to handle the or case, so we should drop it from the comment.\n\n2) The test  a_used > ECP384_DIGITS*2 will allow some cases where a >= p^2 through. I've looked at the algorithm and decided that a < p^2 really is an unnecessary restriction. Checking for a < 2^768 is sufficient, which is what this test accomplishes. The previous code also allowed values of a between p^2 and 2^768-1 inclusive through. It may be worth a comment here to note this for someone who actually compares this code with Handerson, Menezes, and Vanstone.\n\n3) The test a_used < ECP384_DIGITS is correct, but really too small. We should check for a_used <= ECP384_DIGITS and if a_used == ECP384_DIGITS, check for a > p. If a> p do one subtraction. There are lots of numbers between p and 2^320-1 (or 2^352-1 in the 32-bit case) that we are running the whole algorithm on unnecessarily. There are relatively few numbers between 2^384-1 and p where we'll have to do the single subtraction. Again, the current code is correct, it is just doing more work than it needs to in this particular case.\n\n4) NIT: The loop filling in s[2] loops i from ECP386_DIGITS to a_used. I think it would be clearer if it looped from 0 to a_used-ECP386_DIGITS:\n\nfor (i=0; i < a_used-ECP386_DIGITS; i++) {\n   s[2][i] = MP_DIGIT(a,i+ECP386_DIGITS);\n}\n\nThis also makes the following while loop much cleaner:\n\nwhile (i < ECP384_DIGITS) s[2][i++] = 0;\n\n5) Comment /* s_mp_add_is faster than mp_sub */ raises the question: why not add m[7] as well at get down to one sub? I believe the answer is worry about overflow, since we are using hand contructed mp_ints, the mp_add could very well try realloc our statically created mp_digits and blow up. I believe the code is right, but we should include a comment. I think the overflow may be rare enough not to be caught in casual testing if someone tried to make this 'optimization'\n\nIn general, this looks like a good patch. Thanks for providing it.", "count": 3, "raw_text": "r+  I've convinced myself the code is correct, though I have few comments, and would like to have a few changes included (mostly the addition of comments):\n\n1) The comment above the 'a_used > ECP384_DIGITS' test is in correct. you need\nto drop 'or polynomials not using all words'. The main goal of this patch appears to handle the or case, so we should drop it from the comment.\n\n2) The test  a_used > ECP384_DIGITS*2 will allow some cases where a >= p^2 through. I've looked at the algorithm and decided that a < p^2 really is an unnecessary restriction. Checking for a < 2^768 is sufficient, which is what this test accomplishes. The previous code also allowed values of a between p^2 and 2^768-1 inclusive through. It may be worth a comment here to note this for someone who actually compares this code with Handerson, Menezes, and Vanstone.\n\n3) The test a_used < ECP384_DIGITS is correct, but really too small. We should check for a_used <= ECP384_DIGITS and if a_used == ECP384_DIGITS, check for a > p. If a> p do one subtraction. There are lots of numbers between p and 2^320-1 (or 2^352-1 in the 32-bit case) that we are running the whole algorithm on unnecessarily. There are relatively few numbers between 2^384-1 and p where we'll have to do the single subtraction. Again, the current code is correct, it is just doing more work than it needs to in this particular case.\n\n4) NIT: The loop filling in s[2] loops i from ECP386_DIGITS to a_used. I think it would be clearer if it looped from 0 to a_used-ECP386_DIGITS:\n\nfor (i=0; i < a_used-ECP386_DIGITS; i++) {\n   s[2][i] = MP_DIGIT(a,i+ECP386_DIGITS);\n}\n\nThis also makes the following while loop much cleaner:\n\nwhile (i < ECP384_DIGITS) s[2][i++] = 0;\n\n5) Comment /* s_mp_add_is faster than mp_sub */ raises the question: why not add m[7] as well at get down to one sub? I believe the answer is worry about overflow, since we are using hand contructed mp_ints, the mp_add could very well try realloc our statically created mp_digits and blow up. I believe the code is right, but we should include a comment. I think the overflow may be rare enough not to be caught in casual testing if someone tried to make this 'optimization'\n\nIn general, this looks like a good patch. Thanks for providing it.", "bug_id": 653236, "is_private": false, "tags": [], "time": "2011-06-15T01:12:38Z"}, {"raw_text": "(In reply to comment #3)\n> Comment on attachment 529253 [details] [review]\n> A faster implementation of P-384 mod.\n> \n> r+  I've convinced myself the code is correct, though I have few comments,\n> and would like to have a few changes included (mostly the addition of\n> comments):\n> \n> 1) The comment above the 'a_used > ECP384_DIGITS' test is in correct. you\n> need\n> to drop 'or polynomials not using all words'. The main goal of this patch\n> appears to handle the or case, so we should drop it from the comment.\nThank you, I must have copied the comment from the old code, which no longer reflects the behavior of this function.\n\n> 2) The test  a_used > ECP384_DIGITS*2 will allow some cases where a >= p^2\n> through. I've looked at the algorithm and decided that a < p^2 really is an\n> unnecessary restriction. Checking for a < 2^768 is sufficient, which is what\n> this test accomplishes. The previous code also allowed values of a between\n> p^2 and 2^768-1 inclusive through. It may be worth a comment here to note\n> this for someone who actually compares this code with Handerson, Menezes,\n> and Vanstone.\nYes, a comment may be appropriate here. I've noticed that all of the other elliptic curve mod functions only check for the number of digits instead of checking for p^2. Perhaps a similar comment would be appropriate for them as well?\n\n> 3) The test a_used < ECP384_DIGITS is correct, but really too small. We\n> should check for a_used <= ECP384_DIGITS and if a_used == ECP384_DIGITS,\n> check for a > p. If a> p do one subtraction. There are lots of numbers\n> between p and 2^320-1 (or 2^352-1 in the 32-bit case) that we are running\n> the whole algorithm on unnecessarily. There are relatively few numbers\n> between 2^384-1 and p where we'll have to do the single subtraction. Again,\n> the current code is correct, it is just doing more work than it needs to in\n> this particular case.\nYes, I think this could improve speed for p <= a < 2^384. It seemed like an uncommon enough case that I didn't write a check for it.\n\n> 4) NIT: The loop filling in s[2] loops i from ECP386_DIGITS to a_used. I\n> think it would be clearer if it looped from 0 to a_used-ECP386_DIGITS:\n> \n> for (i=0; i < a_used-ECP386_DIGITS; i++) {\n>    s[2][i] = MP_DIGIT(a,i+ECP386_DIGITS);\n> }\n> \n> This also makes the following while loop much cleaner:\n> \n> while (i < ECP384_DIGITS) s[2][i++] = 0;\nI agree, your suggestion makes the code much cleaner.\n\n> 5) Comment /* s_mp_add_is faster than mp_sub */ raises the question: why not\n> add m[7] as well at get down to one sub? I believe the answer is worry about\n> overflow, since we are using hand contructed mp_ints, the mp_add could very\n> well try realloc our statically created mp_digits and blow up. I believe the\n> code is right, but we should include a comment. I think the overflow may be\n> rare enough not to be caught in casual testing if someone tried to make this\n> 'optimization'\nTo be honest, I hadn't considered the possibility of an overflow, and I didn't encounter any crashes when testing various combinations of s_mp_add and mp_sub. I settled on a single call to s_mp_add because it was the fastest. Combining m[7], m[8] and m[9] actually made the function slightly slower than two calls to mp_sub. It is not 100% clear to me why this was the case, but now that you mention it, an overflow may have been the cause.\n\nSince submitting this patch, I have tweaked this function a little more to eliminate terms m[8] and m[9] and skip a subtraction. The result runs a little quicker, but would require more scrutiny. I can submit my latest version as well if you think it would be worthwhile.\n\n> In general, this looks like a good patch. Thanks for providing it.\nYou're very welcome, thanks for taking the time to review it.", "bug_id": 653236, "count": 4, "time": "2011-06-15T18:14:05Z", "is_private": false, "tags": [], "creation_time": "2011-06-15T18:14:05Z", "attachment_id": null, "id": 5534557, "text": "(In reply to comment #3)\n> Comment on attachment 529253 [details] [review]\n> A faster implementation of P-384 mod.\n> \n> r+  I've convinced myself the code is correct, though I have few comments,\n> and would like to have a few changes included (mostly the addition of\n> comments):\n> \n> 1) The comment above the 'a_used > ECP384_DIGITS' test is in correct. you\n> need\n> to drop 'or polynomials not using all words'. The main goal of this patch\n> appears to handle the or case, so we should drop it from the comment.\nThank you, I must have copied the comment from the old code, which no longer reflects the behavior of this function.\n\n> 2) The test  a_used > ECP384_DIGITS*2 will allow some cases where a >= p^2\n> through. I've looked at the algorithm and decided that a < p^2 really is an\n> unnecessary restriction. Checking for a < 2^768 is sufficient, which is what\n> this test accomplishes. The previous code also allowed values of a between\n> p^2 and 2^768-1 inclusive through. It may be worth a comment here to note\n> this for someone who actually compares this code with Handerson, Menezes,\n> and Vanstone.\nYes, a comment may be appropriate here. I've noticed that all of the other elliptic curve mod functions only check for the number of digits instead of checking for p^2. Perhaps a similar comment would be appropriate for them as well?\n\n> 3) The test a_used < ECP384_DIGITS is correct, but really too small. We\n> should check for a_used <= ECP384_DIGITS and if a_used == ECP384_DIGITS,\n> check for a > p. If a> p do one subtraction. There are lots of numbers\n> between p and 2^320-1 (or 2^352-1 in the 32-bit case) that we are running\n> the whole algorithm on unnecessarily. There are relatively few numbers\n> between 2^384-1 and p where we'll have to do the single subtraction. Again,\n> the current code is correct, it is just doing more work than it needs to in\n> this particular case.\nYes, I think this could improve speed for p <= a < 2^384. It seemed like an uncommon enough case that I didn't write a check for it.\n\n> 4) NIT: The loop filling in s[2] loops i from ECP386_DIGITS to a_used. I\n> think it would be clearer if it looped from 0 to a_used-ECP386_DIGITS:\n> \n> for (i=0; i < a_used-ECP386_DIGITS; i++) {\n>    s[2][i] = MP_DIGIT(a,i+ECP386_DIGITS);\n> }\n> \n> This also makes the following while loop much cleaner:\n> \n> while (i < ECP384_DIGITS) s[2][i++] = 0;\nI agree, your suggestion makes the code much cleaner.\n\n> 5) Comment /* s_mp_add_is faster than mp_sub */ raises the question: why not\n> add m[7] as well at get down to one sub? I believe the answer is worry about\n> overflow, since we are using hand contructed mp_ints, the mp_add could very\n> well try realloc our statically created mp_digits and blow up. I believe the\n> code is right, but we should include a comment. I think the overflow may be\n> rare enough not to be caught in casual testing if someone tried to make this\n> 'optimization'\nTo be honest, I hadn't considered the possibility of an overflow, and I didn't encounter any crashes when testing various combinations of s_mp_add and mp_sub. I settled on a single call to s_mp_add because it was the fastest. Combining m[7], m[8] and m[9] actually made the function slightly slower than two calls to mp_sub. It is not 100% clear to me why this was the case, but now that you mention it, an overflow may have been the cause.\n\nSince submitting this patch, I have tweaked this function a little more to eliminate terms m[8] and m[9] and skip a subtraction. The result runs a little quicker, but would require more scrutiny. I can submit my latest version as well if you think it would be worthwhile.\n\n> In general, this looks like a good patch. Thanks for providing it.\nYou're very welcome, thanks for taking the time to review it.", "creator": "osk@exegin.com", "author": "osk@exegin.com"}]}}, "comments": {}}