{"comments": {}, "bugs": {"644368": {"comments": [{"raw_text": "Current plan is approximately\n - extend layers to allow shader \"effects pipelines\" to be applied to their textures at render time\n - lower SVG filters to shader programs.  I don't know yet how much dynamic compilation is needed vs. just having a static set of filter shaders like we do for all the layers shaders currently (I know almost nothing about filters atm ;)).  It would be interesting to apply traditional compiler optimizations to filter pipelines, but that's almost certainly not needed initially.\n - on systems without a GPU (or with GPU rendering forced off), implement filter shaders with SIMD instructions, using a tool like bug 486800.  Not a high priority, but I set the dep anyway.\n\nWe'll want this for d3d10 initially, for competitive reasons.", "tags": [], "is_private": false, "creation_time": "2011-03-23T22:16:01Z", "text": "Current plan is approximately\n - extend layers to allow shader \"effects pipelines\" to be applied to their textures at render time\n - lower SVG filters to shader programs.  I don't know yet how much dynamic compilation is needed vs. just having a static set of filter shaders like we do for all the layers shaders currently (I know almost nothing about filters atm ;)).  It would be interesting to apply traditional compiler optimizations to filter pipelines, but that's almost certainly not needed initially.\n - on systems without a GPU (or with GPU rendering forced off), implement filter shaders with SIMD instructions, using a tool like bug 486800.  Not a high priority, but I set the dep anyway.\n\nWe'll want this for d3d10 initially, for competitive reasons.", "id": 5364070, "attachment_id": null, "bug_id": 644368, "count": 0, "time": "2011-03-23T22:16:01Z", "creator": "cjones.bugs@gmail.com", "author": "cjones.bugs@gmail.com"}, {"bug_id": 644368, "raw_text": "I hacked around with feColorMatrix this afternoon, since it's quite straightforward to implement in GLSL.  After many pains in the neck and aches in the head from GL (though not from GLSL; nice little language!), I got ... weird results on the type=\"matrix\" example filter from [1].  At first I only got fully-transparent pixels, even though the shader seemed to be computing sane values.  It seems like there's some problem with unpremultiplied pixels in our webgl pipeline; or maybe I didn't set something up correctly.  Anyway, easy to hack around in GLSL.  After premultiplying the results, I got a rendering quite different from our current SVG impl: see attached screenshot.  Source image is at top-left, current SVG gives bottom right, and the shader gives top-right.  I picked a pixel somewhat randomly from the thick, dark-brownish outline making up the left side of hello kitty's head, color-picked the value in GIMP, and worked out what the value should be in theory composited on opaque white.  My calculator said ~<228,228,228>; current SVG gave <251,251,251>, and the shader gave <229,229,229>.  I tried getting a fourth guess from Inkscape, by applying a raw feColorMatrix to the source image.  Inkscape rendered the pixel as <229,229,229>; bottom-right in the screenshot.  (The inkscape and shader renderings are still quite different, but I haven't investigated more.)\n\nI'm mainly concerned that, is it really possible our current feColorMatrix impl has ~10% error, or am I just doing something wrong?  nsSVGFEColorMatrixElement::Filter() looks fine, but I didn't trace backwards or forwards from there.  If there really is a 10% error here, then that doesn't mean other filters have the same issue, but if it's relatively common, I almost wonder if we'd cause web compat problems by changing the impl :S.\n\nMy <filter>feColorMatrix</filter> didn't work in local versions of chrome or opera, sadly, although the GL stuff worked in chrome.  Probably worth investigating.\n\n[1] http://www.w3.org/TR/SVG/filters.html#feColorMatrixElement", "count": 1, "time": "2011-03-25T08:30:18Z", "tags": [], "is_private": false, "creation_time": "2011-03-25T08:30:18Z", "creator": "cjones.bugs@gmail.com", "text": "Created attachment 521751\nStrange result\n\nI hacked around with feColorMatrix this afternoon, since it's quite straightforward to implement in GLSL.  After many pains in the neck and aches in the head from GL (though not from GLSL; nice little language!), I got ... weird results on the type=\"matrix\" example filter from [1].  At first I only got fully-transparent pixels, even though the shader seemed to be computing sane values.  It seems like there's some problem with unpremultiplied pixels in our webgl pipeline; or maybe I didn't set something up correctly.  Anyway, easy to hack around in GLSL.  After premultiplying the results, I got a rendering quite different from our current SVG impl: see attached screenshot.  Source image is at top-left, current SVG gives bottom right, and the shader gives top-right.  I picked a pixel somewhat randomly from the thick, dark-brownish outline making up the left side of hello kitty's head, color-picked the value in GIMP, and worked out what the value should be in theory composited on opaque white.  My calculator said ~<228,228,228>; current SVG gave <251,251,251>, and the shader gave <229,229,229>.  I tried getting a fourth guess from Inkscape, by applying a raw feColorMatrix to the source image.  Inkscape rendered the pixel as <229,229,229>; bottom-right in the screenshot.  (The inkscape and shader renderings are still quite different, but I haven't investigated more.)\n\nI'm mainly concerned that, is it really possible our current feColorMatrix impl has ~10% error, or am I just doing something wrong?  nsSVGFEColorMatrixElement::Filter() looks fine, but I didn't trace backwards or forwards from there.  If there really is a 10% error here, then that doesn't mean other filters have the same issue, but if it's relatively common, I almost wonder if we'd cause web compat problems by changing the impl :S.\n\nMy <filter>feColorMatrix</filter> didn't work in local versions of chrome or opera, sadly, although the GL stuff worked in chrome.  Probably worth investigating.\n\n[1] http://www.w3.org/TR/SVG/filters.html#feColorMatrixElement", "attachment_id": 521751, "id": 5368662, "author": "cjones.bugs@gmail.com"}, {"time": "2011-03-25T08:37:08Z", "bug_id": 644368, "count": 2, "creator": "roc@ocallahan.org", "author": "roc@ocallahan.org", "tags": [], "is_private": false, "raw_text": "Could it be a color-space issue? Per spec, our current implementation would convert the input image from sRGB to linearRGB, apply the matrix, then convert back from linearRGB to sRGB:\nhttp://www.w3.org/TR/SVG/painting.html#ColorInterpolationProperties\n\nMonitoring nsSVGFilterInstance::EnsureColorModel would help you see what's going on.", "text": "Could it be a color-space issue? Per spec, our current implementation would convert the input image from sRGB to linearRGB, apply the matrix, then convert back from linearRGB to sRGB:\nhttp://www.w3.org/TR/SVG/painting.html#ColorInterpolationProperties\n\nMonitoring nsSVGFilterInstance::EnsureColorModel would help you see what's going on.", "id": 5368672, "attachment_id": null, "creation_time": "2011-03-25T08:37:08Z"}, {"creator": "cjones.bugs@gmail.com", "author": "cjones.bugs@gmail.com", "time": "2011-03-25T08:46:24Z", "bug_id": 644368, "count": 3, "attachment_id": null, "id": 5368684, "text": "Sounds plausible.  Is that something we'd expect Inkscape to be doing?  (I honestly don't know.)", "creation_time": "2011-03-25T08:46:24Z", "is_private": false, "tags": [], "raw_text": "Sounds plausible.  Is that something we'd expect Inkscape to be doing?  (I honestly don't know.)"}, {"author": "cjones.bugs@gmail.com", "creator": "cjones.bugs@gmail.com", "count": 4, "bug_id": 644368, "time": "2011-03-25T09:04:25Z", "creation_time": "2011-03-25T09:04:25Z", "text": "Bingo!  color-interpolation-filters=\"sRGB\" gave me <228,228,228> on my reference pixel.  The rendering was visually somewhere in between the Inkscape and shader ones.  Whew!", "attachment_id": null, "id": 5368713, "raw_text": "Bingo!  color-interpolation-filters=\"sRGB\" gave me <228,228,228> on my reference pixel.  The rendering was visually somewhere in between the Inkscape and shader ones.  Whew!", "tags": [], "is_private": false}, {"time": "2013-02-26T08:30:11Z", "tags": [], "is_private": false, "bug_id": 644368, "raw_text": "Optimization for important content use case.", "count": 5, "creator": "cjones.bugs@gmail.com", "text": "Optimization for important content use case.", "id": 7142822, "attachment_id": null, "author": "cjones.bugs@gmail.com", "creation_time": "2013-02-26T08:30:11Z"}]}}}