{"bugs": {"712442": {"comments": [{"creator": "mounir@lamouri.fr", "creation_time": "2011-12-20T22:30:50Z", "is_private": false, "attachment_id": 583299, "tags": [], "text": "Created attachment 583299\nPatch v1\n\nThis backend is using NetworkManager. I think we should probably extend it to also handle online/offline and get ride of the other NetworkManager service we have in the tree.\n\nThis is currently only working with NetworkManager 0.9. I will write another patch to make it work with NetworkManager 0.8. Depending on how much work it is, I will make it work with 0.7 or just make sure it doesn't run the instance with 0.7.", "count": 0, "author": "mounir@lamouri.fr", "bug_id": 712442, "id": 5931012, "time": "2011-12-20T22:30:50Z", "raw_text": "This backend is using NetworkManager. I think we should probably extend it to also handle online/offline and get ride of the other NetworkManager service we have in the tree.\n\nThis is currently only working with NetworkManager 0.9. I will write another patch to make it work with NetworkManager 0.8. Depending on how much work it is, I will make it work with 0.7 or just make sure it doesn't run the instance with 0.7."}, {"time": "2012-02-10T00:09:06Z", "raw_text": "Given the history of incompatible changes to the NetworkManager D-Bus\nInterface, I assume we need to check for the Interface version and only run\nthis code against that version, or other existing known compatible versions,\nperhaps with a simple change for:\n\n\"A few new device states have been added, and all device states have been renumbered for flexibility.\"\nhttp://projects.gnome.org/NetworkManager/developers/api/09/ref-migrating.html#id428973\n\nSome lines over 80 columns can be wrapped.\nSpaces around binary operators would make the code easier to read.\n\n>+void moz_ptr_array_unref(GPtrArray* ptr) {\n>+#if GLIB_MAJOR_VERSION >= 2 && GLIB_MINOR_VERSION >= 22\n>+  g_ptr_array_unref(ptr);\n>+#else\n>+  g_ptr_array_free(ptr, true);\n>+#endif\n>+}\n\nI don't think it is worth having this function.\n\ng_ptr_array_free will compile and run with the intended purpose on all\nversions.  The clients already assume they are the exclusive owners (because\nthey release the strings).  But a future user of the method may expect an\nunref, given the function name, but get a free.\n\nUse \"TRUE\" instead of \"true\" for gboolean parameters.\n\nI wonder whether DBusUtils.h should be called DBusGLibUtils.h.\n\n>+     * eDeviceState_Connected should have the same value as NM_DEVICE_STATE_ACTIVATED.\n>+     * TODO: We should include NetworkManager headers to do that cleanly.\n>+     *       That would require to have it installed in the build bots but\n>+     *       doesn't make it mandatory to run the build.\n>+     */\n>+    enum State {\n>+      eDeviceState_Disconnected,\n>+      eDeviceState_Connected = 100\n\nMention NM_DEVICE_STATE_ACTIVATED is 100 only for NM D-Bus Interface\nSpecification version 0.9.\n\n>+    char*       mPath;\n>+    DBusGProxy* mProxy;\n>+    Type        mType;\n>+    State       mState;\n>+    DBusGProxy* mSpecializedProxy;\n>+    double      mSpeed;\n\ndbus_g_proxy_get_path can be used instead of mPath, which would save some\nmemory management.\n\nPlease document the units of mSpeed.\n\nWould using nsAutoRef for mProxy and mSpecializedProxy simplify things?\n\nConsider an intelligent destructor for DeviceInfo and a copy constructor that\ntransfers ownership.\n\nAn object oriented design would have DeviceInfo listening for state and\nproperty changes.  Allocating each DeviceInfo separately could simplify some\nthings, removing the need for copying, but, if you prefer to coalesce into one\nallocation, the an array index could be passed through the signal handler user\ndata and GetInstance() used when needing to UpdateNetworkInfo().\n\nWhen a DBusGProxy object will be destroyed, there is no need to explicitly\ndisconnect from the signal.  Given the restriction that\ndbus_g_proxy_add_signal can only be called once on a proxy, it seems safe to\nassume that nothing else is holding references to the DBusGProxys.\n\n>+  enum Notify {\n>+    eNotify,\n>+    eDontNotify\n>+  };\n\nAvoiding boolean parameters is nice.\nSwapping the order of eNotify and eDontNotify would mean that eNotify is true.\n\n>+   * Clear mDevices and reset mDevicesCount. Disconnect to signal and free memory.\n\n\"Disconnect from signal\"\n\n>+   * The DBus proxy object to upower.\n\nNeeds updating for network manager.\n\n>+  /**\n>+   * Number of tracked devices.\n>+   */\n>+  guint mDevicesCount;\n>+\n>+  /**\n>+   * Information of all tracked devices.\n>+   */\n>+  DeviceInfo* mDevices;\n\nWould nsTArray be helpful here?\n\n>+    sInstance = new NetworkManagerClient();\n\nCan sInstance be deleted during shutdown?  Currently it is leaked.\n\n>+  nsAutoRef<GPtrArray> devicesNM;\n\n>+  if (!dbus_g_proxy_call(mNMProxy, \"GetDevices\", &error, G_TYPE_INVALID,\n>+                         typeGPtrArray, &devicesNM, G_TYPE_INVALID)) {\n\nThe implicit reinterpret casts from nsAutoRef<T> to GPtrArray* and GHashTable*\nto access the nsAutoRefs' private member variables is nasty.\nThe nsAutoRef is not really necessary for devicesNM, because there are no\nearly returns.  How about the approach proposed bug 698003 comment 1 for\nhashTable?\n\nThere is no need to release in the error patch as the documentation for\ndbus_g_proxy_end_call says:\n\n  All D-Bus method calls can fail with a remote error. If this occurs, the\n  error will be set and this function will return FALSE.\n\n  Otherwise, the \"out\" parameters and return value of the method are stored in\n  the provided varargs list.\n\n>+    guint type = g_value_get_uint(static_cast<const GValue*>(g_hash_table_lookup(hashTable, \"DeviceType\")));\n\ng_value_get_uint() does not necessarily check that the GValue is of type\nG_TYPE_UINT, so skipping the G_VALUE_HOLDS_UINT() check is placing some faith\nin the stability of the interface.  Given history, I'm not sure that is well\nplaced faith, but it looks like libnm-glib makes the same assumptions, and I\nguess we have to only run this code against version 0.9 anyway, so I guess\nthis is expected.\n\nI think it is still worth adding a null check for the GValue pointer, in case\nthe property is not there.\n\n>+      // Note: Bitrate is in Kb/s according to the doc but nm-applet itself\n>+      // shows it in Mb/s and does /1000 so there must be something wrong\n>+      // somewhere and it seems better to be consistent with what nm-applet\n>+      // shows.\n\nI don't follow this comment.  Is that about the K instead of k?\nThe documentation says kilobits so they mean kb/s.\nOr is there a 1024/1000 distinction somewhere?\n\n>+      devices[i].mSpeed = g_value_get_uint(&value) / 1000.0;\n\nUse mSpeed /= instead of a second g_value_get_uint call.\n\n>+    dbus_g_proxy_add_signal(devices[i].mSpecializedProxy, \"PropertiesChanged\",\n>+                            dbus_g_type_get_map(\"GHashTable\", G_TYPE_STRING, G_TYPE_VALUE),\n>+                            G_TYPE_INVALID);\n\ndbus_g_type_get_map(\"GHashTable\", G_TYPE_STRING, G_TYPE_VALUE) need only be\ncalled once in InitializeDeviceList, though this call would be\nappropriate if the DeviceInfo were managing the signals.\n\n>+NetworkManagerClient::GetSpeedForDevice(const DeviceInfo& aDevice) const\n\nThis contains duplicate code, but may not be necessary anyway.  See below.\n\n>+  // optimized sureley.\n\n\"surely\"\n\n>+    if (aNewState == DeviceInfo::eDeviceState_Connected) {\n>+      devices[i].mState = DeviceInfo::eDeviceState_Connected;\n>+    } else {\n>+      devices[i].mState = DeviceInfo::eDeviceState_Disconnected;\n>+      devices[i].mSpeed = 0;\n>+    }\n\nmSpeed is set to 0 on disconnect, but not explicitly reinstated on connect.\nApparently this is expecting a PropertyChanged on the specialized proxy.\nCan we be sure to get that?  It seems safe to me to not set the speed to 0, as\nwe check mState in UpdateNetworkInfo anyway.\n\n>+        if (!g_hash_table_lookup(aProperties, \"Speed\")) {\n>+          // That means we are not connected yet but it seems that sometimes\n>+          // we don't get \"Speed\" even when connected. In that case, reading\n>+          // the value is working as expected.\n\nI expect the non-existence of \"Speed\" in the hashtable should mean that the\nspeed didn't change, and there should be no need to get the speed again when\nthe property hasn't changed.  Is this fallout from setting speed to 0 above?\n\n>+        newSpeed = g_value_get_uint(static_cast<const GValue*>(g_hash_table_lookup(aProperties, \"Speed\")));\n\nPlease call g_hash_table_lookup once only for each property.", "id": 6048851, "bug_id": 712442, "count": 1, "text": "Comment on attachment 583299\nPatch v1\n\nGiven the history of incompatible changes to the NetworkManager D-Bus\nInterface, I assume we need to check for the Interface version and only run\nthis code against that version, or other existing known compatible versions,\nperhaps with a simple change for:\n\n\"A few new device states have been added, and all device states have been renumbered for flexibility.\"\nhttp://projects.gnome.org/NetworkManager/developers/api/09/ref-migrating.html#id428973\n\nSome lines over 80 columns can be wrapped.\nSpaces around binary operators would make the code easier to read.\n\n>+void moz_ptr_array_unref(GPtrArray* ptr) {\n>+#if GLIB_MAJOR_VERSION >= 2 && GLIB_MINOR_VERSION >= 22\n>+  g_ptr_array_unref(ptr);\n>+#else\n>+  g_ptr_array_free(ptr, true);\n>+#endif\n>+}\n\nI don't think it is worth having this function.\n\ng_ptr_array_free will compile and run with the intended purpose on all\nversions.  The clients already assume they are the exclusive owners (because\nthey release the strings).  But a future user of the method may expect an\nunref, given the function name, but get a free.\n\nUse \"TRUE\" instead of \"true\" for gboolean parameters.\n\nI wonder whether DBusUtils.h should be called DBusGLibUtils.h.\n\n>+     * eDeviceState_Connected should have the same value as NM_DEVICE_STATE_ACTIVATED.\n>+     * TODO: We should include NetworkManager headers to do that cleanly.\n>+     *       That would require to have it installed in the build bots but\n>+     *       doesn't make it mandatory to run the build.\n>+     */\n>+    enum State {\n>+      eDeviceState_Disconnected,\n>+      eDeviceState_Connected = 100\n\nMention NM_DEVICE_STATE_ACTIVATED is 100 only for NM D-Bus Interface\nSpecification version 0.9.\n\n>+    char*       mPath;\n>+    DBusGProxy* mProxy;\n>+    Type        mType;\n>+    State       mState;\n>+    DBusGProxy* mSpecializedProxy;\n>+    double      mSpeed;\n\ndbus_g_proxy_get_path can be used instead of mPath, which would save some\nmemory management.\n\nPlease document the units of mSpeed.\n\nWould using nsAutoRef for mProxy and mSpecializedProxy simplify things?\n\nConsider an intelligent destructor for DeviceInfo and a copy constructor that\ntransfers ownership.\n\nAn object oriented design would have DeviceInfo listening for state and\nproperty changes.  Allocating each DeviceInfo separately could simplify some\nthings, removing the need for copying, but, if you prefer to coalesce into one\nallocation, the an array index could be passed through the signal handler user\ndata and GetInstance() used when needing to UpdateNetworkInfo().\n\nWhen a DBusGProxy object will be destroyed, there is no need to explicitly\ndisconnect from the signal.  Given the restriction that\ndbus_g_proxy_add_signal can only be called once on a proxy, it seems safe to\nassume that nothing else is holding references to the DBusGProxys.\n\n>+  enum Notify {\n>+    eNotify,\n>+    eDontNotify\n>+  };\n\nAvoiding boolean parameters is nice.\nSwapping the order of eNotify and eDontNotify would mean that eNotify is true.\n\n>+   * Clear mDevices and reset mDevicesCount. Disconnect to signal and free memory.\n\n\"Disconnect from signal\"\n\n>+   * The DBus proxy object to upower.\n\nNeeds updating for network manager.\n\n>+  /**\n>+   * Number of tracked devices.\n>+   */\n>+  guint mDevicesCount;\n>+\n>+  /**\n>+   * Information of all tracked devices.\n>+   */\n>+  DeviceInfo* mDevices;\n\nWould nsTArray be helpful here?\n\n>+    sInstance = new NetworkManagerClient();\n\nCan sInstance be deleted during shutdown?  Currently it is leaked.\n\n>+  nsAutoRef<GPtrArray> devicesNM;\n\n>+  if (!dbus_g_proxy_call(mNMProxy, \"GetDevices\", &error, G_TYPE_INVALID,\n>+                         typeGPtrArray, &devicesNM, G_TYPE_INVALID)) {\n\nThe implicit reinterpret casts from nsAutoRef<T> to GPtrArray* and GHashTable*\nto access the nsAutoRefs' private member variables is nasty.\nThe nsAutoRef is not really necessary for devicesNM, because there are no\nearly returns.  How about the approach proposed bug 698003 comment 1 for\nhashTable?\n\nThere is no need to release in the error patch as the documentation for\ndbus_g_proxy_end_call says:\n\n  All D-Bus method calls can fail with a remote error. If this occurs, the\n  error will be set and this function will return FALSE.\n\n  Otherwise, the \"out\" parameters and return value of the method are stored in\n  the provided varargs list.\n\n>+    guint type = g_value_get_uint(static_cast<const GValue*>(g_hash_table_lookup(hashTable, \"DeviceType\")));\n\ng_value_get_uint() does not necessarily check that the GValue is of type\nG_TYPE_UINT, so skipping the G_VALUE_HOLDS_UINT() check is placing some faith\nin the stability of the interface.  Given history, I'm not sure that is well\nplaced faith, but it looks like libnm-glib makes the same assumptions, and I\nguess we have to only run this code against version 0.9 anyway, so I guess\nthis is expected.\n\nI think it is still worth adding a null check for the GValue pointer, in case\nthe property is not there.\n\n>+      // Note: Bitrate is in Kb/s according to the doc but nm-applet itself\n>+      // shows it in Mb/s and does /1000 so there must be something wrong\n>+      // somewhere and it seems better to be consistent with what nm-applet\n>+      // shows.\n\nI don't follow this comment.  Is that about the K instead of k?\nThe documentation says kilobits so they mean kb/s.\nOr is there a 1024/1000 distinction somewhere?\n\n>+      devices[i].mSpeed = g_value_get_uint(&value) / 1000.0;\n\nUse mSpeed /= instead of a second g_value_get_uint call.\n\n>+    dbus_g_proxy_add_signal(devices[i].mSpecializedProxy, \"PropertiesChanged\",\n>+                            dbus_g_type_get_map(\"GHashTable\", G_TYPE_STRING, G_TYPE_VALUE),\n>+                            G_TYPE_INVALID);\n\ndbus_g_type_get_map(\"GHashTable\", G_TYPE_STRING, G_TYPE_VALUE) need only be\ncalled once in InitializeDeviceList, though this call would be\nappropriate if the DeviceInfo were managing the signals.\n\n>+NetworkManagerClient::GetSpeedForDevice(const DeviceInfo& aDevice) const\n\nThis contains duplicate code, but may not be necessary anyway.  See below.\n\n>+  // optimized sureley.\n\n\"surely\"\n\n>+    if (aNewState == DeviceInfo::eDeviceState_Connected) {\n>+      devices[i].mState = DeviceInfo::eDeviceState_Connected;\n>+    } else {\n>+      devices[i].mState = DeviceInfo::eDeviceState_Disconnected;\n>+      devices[i].mSpeed = 0;\n>+    }\n\nmSpeed is set to 0 on disconnect, but not explicitly reinstated on connect.\nApparently this is expecting a PropertyChanged on the specialized proxy.\nCan we be sure to get that?  It seems safe to me to not set the speed to 0, as\nwe check mState in UpdateNetworkInfo anyway.\n\n>+        if (!g_hash_table_lookup(aProperties, \"Speed\")) {\n>+          // That means we are not connected yet but it seems that sometimes\n>+          // we don't get \"Speed\" even when connected. In that case, reading\n>+          // the value is working as expected.\n\nI expect the non-existence of \"Speed\" in the hashtable should mean that the\nspeed didn't change, and there should be no need to get the speed again when\nthe property hasn't changed.  Is this fallout from setting speed to 0 above?\n\n>+        newSpeed = g_value_get_uint(static_cast<const GValue*>(g_hash_table_lookup(aProperties, \"Speed\")));\n\nPlease call g_hash_table_lookup once only for each property.", "author": "karlt@mozbugz.karlt.net", "tags": [], "attachment_id": 583299, "creation_time": "2012-02-10T00:09:06Z", "is_private": false, "creator": "karlt@mozbugz.karlt.net"}, {"bug_id": 712442, "id": 6135793, "count": 2, "text": "Created attachment 605387\nInter diff", "author": "mounir@lamouri.fr", "time": "2012-03-13T14:34:31Z", "raw_text": "", "is_private": false, "creation_time": "2012-03-13T14:34:31Z", "creator": "mounir@lamouri.fr", "tags": [], "attachment_id": 605387}, {"tags": [], "attachment_id": 605389, "creation_time": "2012-03-13T14:35:01Z", "is_private": false, "creator": "mounir@lamouri.fr", "raw_text": "", "time": "2012-03-13T14:35:01Z", "bug_id": 712442, "id": 6135798, "count": 3, "text": "Created attachment 605389\nPatch v2", "author": "mounir@lamouri.fr"}, {"id": 6135809, "bug_id": 712442, "is_private": false, "creation_time": "2012-03-13T14:39:13Z", "creator": "mounir@lamouri.fr", "author": "mounir@lamouri.fr", "text": "Sorry for the time it took me to answer to that review. I had different stuff to do.\n\n(In reply to Karl Tomlinson (:karlt) from comment #1)\n> Would using nsAutoRef for mProxy and mSpecializedProxy simplify things?\n\nNot really. That would save us 2 lines in the dtor.\n\n> >+    sInstance = new NetworkManagerClient();\n> \n> Can sInstance be deleted during shutdown?  Currently it is leaked.\n\nIsn't that how all singleton are done? The memory is released during shutdown.\n\n> >+    if (aNewState == DeviceInfo::eDeviceState_Connected) {\n> >+      devices[i].mState = DeviceInfo::eDeviceState_Connected;\n> >+    } else {\n> >+      devices[i].mState = DeviceInfo::eDeviceState_Disconnected;\n> >+      devices[i].mSpeed = 0;\n> >+    }\n> \n> mSpeed is set to 0 on disconnect, but not explicitly reinstated on connect.\n> Apparently this is expecting a PropertyChanged on the specialized proxy.\n> Can we be sure to get that?  It seems safe to me to not set the speed to 0,\n> as\n> we check mState in UpdateNetworkInfo anyway.\n> \n> >+        if (!g_hash_table_lookup(aProperties, \"Speed\")) {\n> >+          // That means we are not connected yet but it seems that sometimes\n> >+          // we don't get \"Speed\" even when connected. In that case, reading\n> >+          // the value is working as expected.\n> \n> I expect the non-existence of \"Speed\" in the hashtable should mean that the\n> speed didn't change, and there should be no need to get the speed again when\n> the property hasn't changed.  Is this fallout from setting speed to 0 above?\n\nUnfortunately not. If I plug an ethernet cable, I don't get a change event unless I use that code. Even if I don't set mSpeed to 0.\n\nAll other comments have been applied in the recently attached patch.", "count": 4, "tags": [], "time": "2012-03-13T14:39:13Z", "attachment_id": null, "raw_text": "Sorry for the time it took me to answer to that review. I had different stuff to do.\n\n(In reply to Karl Tomlinson (:karlt) from comment #1)\n> Would using nsAutoRef for mProxy and mSpecializedProxy simplify things?\n\nNot really. That would save us 2 lines in the dtor.\n\n> >+    sInstance = new NetworkManagerClient();\n> \n> Can sInstance be deleted during shutdown?  Currently it is leaked.\n\nIsn't that how all singleton are done? The memory is released during shutdown.\n\n> >+    if (aNewState == DeviceInfo::eDeviceState_Connected) {\n> >+      devices[i].mState = DeviceInfo::eDeviceState_Connected;\n> >+    } else {\n> >+      devices[i].mState = DeviceInfo::eDeviceState_Disconnected;\n> >+      devices[i].mSpeed = 0;\n> >+    }\n> \n> mSpeed is set to 0 on disconnect, but not explicitly reinstated on connect.\n> Apparently this is expecting a PropertyChanged on the specialized proxy.\n> Can we be sure to get that?  It seems safe to me to not set the speed to 0,\n> as\n> we check mState in UpdateNetworkInfo anyway.\n> \n> >+        if (!g_hash_table_lookup(aProperties, \"Speed\")) {\n> >+          // That means we are not connected yet but it seems that sometimes\n> >+          // we don't get \"Speed\" even when connected. In that case, reading\n> >+          // the value is working as expected.\n> \n> I expect the non-existence of \"Speed\" in the hashtable should mean that the\n> speed didn't change, and there should be no need to get the speed again when\n> the property hasn't changed.  Is this fallout from setting speed to 0 above?\n\nUnfortunately not. If I plug an ethernet cable, I don't get a change event unless I use that code. Even if I don't set mSpeed to 0.\n\nAll other comments have been applied in the recently attached patch."}, {"is_private": false, "creation_time": "2012-03-13T15:36:09Z", "id": 6135974, "bug_id": 712442, "author": "mounir@lamouri.fr", "text": "Comment on attachment 605389\nPatch v2\n\nReview of attachment 605389:\n-----------------------------------------------------------------\n\n::: dom/base/nsDOMClassInfo.cpp\n@@ +4061,5 @@\n>    DOM_CLASSINFO_MAP_END\n>  \n>    DOM_CLASSINFO_MAP_BEGIN(MozConnection, nsIDOMMozConnection)\n>       DOM_CLASSINFO_MAP_ENTRY(nsIDOMMozConnection)\n> +     DOM_CLASSINFO_MAP_ENTRY(nsIDOMEventTarget)\n\nForget that part of the patch. It will be handled by bug 735261.", "count": 5, "creator": "mounir@lamouri.fr", "tags": [], "attachment_id": 605389, "raw_text": "Review of attachment 605389:\n-----------------------------------------------------------------\n\n::: dom/base/nsDOMClassInfo.cpp\n@@ +4061,5 @@\n>    DOM_CLASSINFO_MAP_END\n>  \n>    DOM_CLASSINFO_MAP_BEGIN(MozConnection, nsIDOMMozConnection)\n>       DOM_CLASSINFO_MAP_ENTRY(nsIDOMMozConnection)\n> +     DOM_CLASSINFO_MAP_ENTRY(nsIDOMEventTarget)\n\nForget that part of the patch. It will be handled by bug 735261.", "time": "2012-03-13T15:36:09Z"}, {"attachment_id": null, "raw_text": "(In reply to Mounir Lamouri (:volkmar) (:mounir) from comment #4)\n> > Can sInstance be deleted during shutdown?  Currently it is leaked.\n> \n> Isn't that how all singleton are done? The memory is released during\n> shutdown.\n\nSingletons are explicitly released during shutdown (at least in debug builds) before leak checks run before the program terminates.", "time": "2012-03-14T00:29:50Z", "tags": [], "author": "karlt@mozbugz.karlt.net", "count": 6, "text": "(In reply to Mounir Lamouri (:volkmar) (:mounir) from comment #4)\n> > Can sInstance be deleted during shutdown?  Currently it is leaked.\n> \n> Isn't that how all singleton are done? The memory is released during\n> shutdown.\n\nSingletons are explicitly released during shutdown (at least in debug builds) before leak checks run before the program terminates.", "creator": "karlt@mozbugz.karlt.net", "creation_time": "2012-03-14T00:29:50Z", "is_private": false, "bug_id": 712442, "id": 6137780}, {"creator": "mounir@lamouri.fr", "is_private": false, "creation_time": "2012-03-14T00:47:49Z", "attachment_id": null, "tags": [], "author": "mounir@lamouri.fr", "count": 7, "text": "(In reply to Karl Tomlinson (:karlt) from comment #6)\n> (In reply to Mounir Lamouri (:volkmar) (:mounir) from comment #4)\n> > > Can sInstance be deleted during shutdown?  Currently it is leaked.\n> > \n> > Isn't that how all singleton are done? The memory is released during\n> > shutdown.\n> \n> Singletons are explicitly released during shutdown (at least in debug\n> builds) before leak checks run before the program terminates.\n\nIsn't that for XPCOM objects? AFAIK we don't check other leaks (I might be wrong though). It's not the first singleton I write in m-c like that.", "bug_id": 712442, "id": 6137830, "time": "2012-03-14T00:47:49Z", "raw_text": "(In reply to Karl Tomlinson (:karlt) from comment #6)\n> (In reply to Mounir Lamouri (:volkmar) (:mounir) from comment #4)\n> > > Can sInstance be deleted during shutdown?  Currently it is leaked.\n> > \n> > Isn't that how all singleton are done? The memory is released during\n> > shutdown.\n> \n> Singletons are explicitly released during shutdown (at least in debug\n> builds) before leak checks run before the program terminates.\n\nIsn't that for XPCOM objects? AFAIK we don't check other leaks (I might be wrong though). It's not the first singleton I write in m-c like that."}, {"raw_text": "The Lk results use trace-malloc, which detects all leaks from malloc and memalign.  I assume this also includes new.\n(valgrind does something similar but I'm not sure of the state of our valgrind tests.)\nSee also NS_FREE_PERMANENT_DATA\nhttp://hg.mozilla.org/mozilla-central/annotate/c71845b3b2a6/xpcom/base/nscore.h#l318\n\nIf we don't try to free our data, then leak detection tools become unhelpful.", "attachment_id": null, "time": "2012-03-14T01:43:24Z", "tags": [], "count": 8, "text": "The Lk results use trace-malloc, which detects all leaks from malloc and memalign.  I assume this also includes new.\n(valgrind does something similar but I'm not sure of the state of our valgrind tests.)\nSee also NS_FREE_PERMANENT_DATA\nhttp://hg.mozilla.org/mozilla-central/annotate/c71845b3b2a6/xpcom/base/nscore.h#l318\n\nIf we don't try to free our data, then leak detection tools become unhelpful.", "author": "karlt@mozbugz.karlt.net", "creator": "karlt@mozbugz.karlt.net", "is_private": false, "creation_time": "2012-03-14T01:43:24Z", "id": 6137976, "bug_id": 712442}, {"creation_time": "2012-03-14T04:40:11Z", "is_private": false, "creator": "karlt@mozbugz.karlt.net", "tags": [], "attachment_id": null, "bug_id": 712442, "id": 6138147, "author": "karlt@mozbugz.karlt.net", "text": "(In reply to Mounir Lamouri (:volkmar) (:mounir) from comment #4)\n> > >+    if (aNewState == DeviceInfo::eDeviceState_Connected) {\n> > >+      devices[i].mState = DeviceInfo::eDeviceState_Connected;\n> > >+    } else {\n> > >+      devices[i].mState = DeviceInfo::eDeviceState_Disconnected;\n> > >+      devices[i].mSpeed = 0;\n> > >+    }\n> > \n> > mSpeed is set to 0 on disconnect, but not explicitly reinstated on connect.\n> > Apparently this is expecting a PropertyChanged on the specialized proxy.\n> > Can we be sure to get that?  It seems safe to me to not set the speed to 0,\n> > as\n> > we check mState in UpdateNetworkInfo anyway.\n\nI didn't find an answer to my question about the PropertyChanged event, but I\nguess there will be a corresponding PropertyChanged event for the property State.\n\nWhy is mSpeed set to zero here?\n\n> > \n> > >+        if (!g_hash_table_lookup(aProperties, \"Speed\")) {\n> > >+          // That means we are not connected yet but it seems that sometimes\n> > >+          // we don't get \"Speed\" even when connected. In that case, reading\n> > >+          // the value is working as expected.\n> > \n> > I expect the non-existence of \"Speed\" in the hashtable should mean that the\n> > speed didn't change, and there should be no need to get the speed again when\n> > the property hasn't changed.  Is this fallout from setting speed to 0 above?\n> \n> Unfortunately not. If I plug an ethernet cable, I don't get a change event\n> unless I use that code. Even if I don't set mSpeed to 0.\n\nI see nm-device-ethernet.c has no calls to g_object_notify for\nNM_DEVICE_ETHERNET_SPEED.\n\nHowever, nm-device-wifi.c has a call for NM_DEVICE_WIFI_BITRATE, so there\nshouldn't be a problem there.\n\nPerhaps this is because ethernet device speeds are not expected to change.\nI'm not sure.  On my system, this command returns 0 for my tg3 802-3-ethernet\ndevice until the cable is first plugged.  Then is continues to report 100\nafter unplugging the cable.\n\n> dbus-send --print-reply --system --dest=org.freedesktop.NetworkManager /org/freedesktop/NetworkManager/Devices/1 org.freedesktop.DBus.Properties.Get string:org.freedesktop.NetworkManager.Device.Wired string:Speed\n\nGetting the speed after every property change (which BTW includes\norg.freedesktop.NetworkManager.Device properties) seems a bit much.  How\nabout, for ethernet devices, getting the speed on StateChanged when new_state\nbecomes NM_DEVICE_STATE_ACTIVATED?", "count": 9, "raw_text": "(In reply to Mounir Lamouri (:volkmar) (:mounir) from comment #4)\n> > >+    if (aNewState == DeviceInfo::eDeviceState_Connected) {\n> > >+      devices[i].mState = DeviceInfo::eDeviceState_Connected;\n> > >+    } else {\n> > >+      devices[i].mState = DeviceInfo::eDeviceState_Disconnected;\n> > >+      devices[i].mSpeed = 0;\n> > >+    }\n> > \n> > mSpeed is set to 0 on disconnect, but not explicitly reinstated on connect.\n> > Apparently this is expecting a PropertyChanged on the specialized proxy.\n> > Can we be sure to get that?  It seems safe to me to not set the speed to 0,\n> > as\n> > we check mState in UpdateNetworkInfo anyway.\n\nI didn't find an answer to my question about the PropertyChanged event, but I\nguess there will be a corresponding PropertyChanged event for the property State.\n\nWhy is mSpeed set to zero here?\n\n> > \n> > >+        if (!g_hash_table_lookup(aProperties, \"Speed\")) {\n> > >+          // That means we are not connected yet but it seems that sometimes\n> > >+          // we don't get \"Speed\" even when connected. In that case, reading\n> > >+          // the value is working as expected.\n> > \n> > I expect the non-existence of \"Speed\" in the hashtable should mean that the\n> > speed didn't change, and there should be no need to get the speed again when\n> > the property hasn't changed.  Is this fallout from setting speed to 0 above?\n> \n> Unfortunately not. If I plug an ethernet cable, I don't get a change event\n> unless I use that code. Even if I don't set mSpeed to 0.\n\nI see nm-device-ethernet.c has no calls to g_object_notify for\nNM_DEVICE_ETHERNET_SPEED.\n\nHowever, nm-device-wifi.c has a call for NM_DEVICE_WIFI_BITRATE, so there\nshouldn't be a problem there.\n\nPerhaps this is because ethernet device speeds are not expected to change.\nI'm not sure.  On my system, this command returns 0 for my tg3 802-3-ethernet\ndevice until the cable is first plugged.  Then is continues to report 100\nafter unplugging the cable.\n\n> dbus-send --print-reply --system --dest=org.freedesktop.NetworkManager /org/freedesktop/NetworkManager/Devices/1 org.freedesktop.DBus.Properties.Get string:org.freedesktop.NetworkManager.Device.Wired string:Speed\n\nGetting the speed after every property change (which BTW includes\norg.freedesktop.NetworkManager.Device properties) seems a bit much.  How\nabout, for ethernet devices, getting the speed on StateChanged when new_state\nbecomes NM_DEVICE_STATE_ACTIVATED?", "time": "2012-03-14T04:40:11Z"}, {"author": "karlt@mozbugz.karlt.net", "text": "Perhaps PropertiesChanged could even handle changes to the State property and StateChanged would not be necessary, nor mProxy, nor the VOID:UINT,UINT,UINT marshall.", "count": 10, "creator": "karlt@mozbugz.karlt.net", "creation_time": "2012-03-14T05:55:07Z", "is_private": false, "id": 6138240, "bug_id": 712442, "attachment_id": null, "raw_text": "Perhaps PropertiesChanged could even handle changes to the State property and StateChanged would not be necessary, nor mProxy, nor the VOID:UINT,UINT,UINT marshall.", "time": "2012-03-14T05:55:07Z", "tags": []}, {"time": "2012-03-14T12:26:43Z", "attachment_id": 605717, "raw_text": "I will attach a new patch including some other changes (which will all be in inter diff).", "tags": [], "creator": "mounir@lamouri.fr", "author": "mounir@lamouri.fr", "count": 11, "text": "Created attachment 605717\nInter diff: make sure the memory is freed\n\nI will attach a new patch including some other changes (which will all be in inter diff).", "bug_id": 712442, "id": 6138694, "is_private": false, "creation_time": "2012-03-14T12:26:43Z"}, {"raw_text": "", "attachment_id": 605775, "time": "2012-03-14T15:44:15Z", "tags": [], "count": 12, "text": "Created attachment 605775\nInter diff: improve speed handling", "author": "mounir@lamouri.fr", "creator": "mounir@lamouri.fr", "creation_time": "2012-03-14T15:44:15Z", "is_private": false, "id": 6139093, "bug_id": 712442}, {"attachment_id": 605790, "raw_text": "I didn't know that was possible to get changes from properties the interface was inheriting from...", "time": "2012-03-14T16:15:38Z", "tags": [], "author": "mounir@lamouri.fr", "text": "Created attachment 605790\nInter diff: merge StateChanged into PropertiesChanged\n\nI didn't know that was possible to get changes from properties the interface was inheriting from...", "count": 13, "creator": "mounir@lamouri.fr", "is_private": false, "creation_time": "2012-03-14T16:15:38Z", "id": 6139203, "bug_id": 712442}, {"author": "mounir@lamouri.fr", "text": "Created attachment 605792\nPatch v3\n\nThat patch should include all the requested changes made after I've attached the version 2. See inter diffs for more details.", "count": 14, "creator": "mounir@lamouri.fr", "is_private": false, "creation_time": "2012-03-14T16:17:59Z", "bug_id": 712442, "id": 6139220, "attachment_id": 605792, "raw_text": "That patch should include all the requested changes made after I've attached the version 2. See inter diffs for more details.", "time": "2012-03-14T16:17:59Z", "tags": []}, {"is_private": false, "creation_time": "2012-03-14T16:22:21Z", "creator": "mounir@lamouri.fr", "tags": [], "attachment_id": null, "id": 6139241, "bug_id": 712442, "count": 15, "text": "(In reply to Karl Tomlinson (:karlt) from comment #9)\n> Perhaps this is because ethernet device speeds are not expected to change.\n> I'm not sure.  On my system, this command returns 0 for my tg3 802-3-ethernet\n> device until the cable is first plugged.  Then is continues to report 100\n> after unplugging the cable.\n> \n> > dbus-send --print-reply --system --dest=org.freedesktop.NetworkManager /org/freedesktop/NetworkManager/Devices/1 org.freedesktop.DBus.Properties.Get string:org.freedesktop.NetworkManager.Device.Wired string:Speed\n\nOn my system, after unplugging, this is returning 0. Anyway, the new version of the patch is reducing the number of explicit read of Speed/Bitrate and should handle both cases.", "author": "mounir@lamouri.fr", "raw_text": "(In reply to Karl Tomlinson (:karlt) from comment #9)\n> Perhaps this is because ethernet device speeds are not expected to change.\n> I'm not sure.  On my system, this command returns 0 for my tg3 802-3-ethernet\n> device until the cable is first plugged.  Then is continues to report 100\n> after unplugging the cable.\n> \n> > dbus-send --print-reply --system --dest=org.freedesktop.NetworkManager /org/freedesktop/NetworkManager/Devices/1 org.freedesktop.DBus.Properties.Get string:org.freedesktop.NetworkManager.Device.Wired string:Speed\n\nOn my system, after unplugging, this is returning 0. Anyway, the new version of the patch is reducing the number of explicit read of Speed/Bitrate and should handle both cases.", "time": "2012-03-14T16:22:21Z"}, {"author": "karlt@mozbugz.karlt.net", "text": "Comment on attachment 605792\nPatch v3\n\n>+  gpointer key, gvalue;\n>+  if (!g_hash_table_lookup_extended(aHashTable, aKey, &key, &gvalue)) {\n>+    return false;\n\nWhy use the the _extended function here?\nIs there a reason why there should be a null GValue* in the hash table?\n\nIf there is a reason for using the _extended function, then pass NULL for\nunused orig_key.\n\n>+#if GLIB_MAJOR_VERSION >= 2 && GLIB_MINOR_VERSION >= 22\n>+    g_ptr_array_unref(ptr);\n>+#else\n>+    g_ptr_array_free(ptr, TRUE);\n>+#endif\n\nWhy bother with g_ptr_array_unref here?  (Comment 1)\n\n>+NetworkManagerClient::DeviceInfo::DeviceInfo()\n>+  : mDBusConnection(nsnull)\n>+  , mType(eDeviceType_Unknown)\n>+  , mState(eDeviceState_Disconnected)\n>+  , mProxy(nsnull)\n>+  , mSpeed(0)\n\nmType and mState don't actually need to be initialized here.\n\n>+  // There is no reason why getting the DBus connection object should fail\n>+  // because the NetworkManagerClient already has a connection object if we\n>+  // happen to be here.\n>+  mDBusConnection = dbus_g_bus_get(DBUS_BUS_SYSTEM, nsnull);\n>+\n>+  // Make sure we do not exit the entire program if DBus connection get lost.\n>+  dbus_connection_set_exit_on_disconnect(\n>+      dbus_g_connection_get_connection(mDBusConnection), FALSE);\n\nGiven this is a preexisting connection, there is no need to call\ndbus_connection_set_exit_on_disconnect here.\n\n>+  nsAutoRef<DBusGProxy> proxy(dbus_g_proxy_new_for_name(\n>+                                mDBusConnection,\n>+                                NM_DBUS_SERVICE,\n>+                                dbus_g_proxy_get_path(mProxy),\n>+                                DBUS_INTERFACE_PROPERTIES));\n\nHow about dbus_g_proxy_new_from_proxy(mProxy, DBUS_INTERFACE_PROPERTIES, NULL)?\nThen mDBusConnection may be unnecessary.\n\n>+        // Sometimes, the hash table has a Speed or Bitrate field with the new\n>+        // speed but tests shows that it's not always the case so it's better to\n>+        // always explicitly request the speed instead of guessing when we\n>+        // should do that.\n\nIsn't this only an issue with the Wired Speed?  (Comment 9)\n\nThere should be notification for the wireless Bitrate, right?\n(even if it may not be delivered at the same time as the change to State.)\nThe get_property implementation returns priv->rate and rate is only set when\nnotifying NM_DEVICE_WIFI_BITRATE.\n\n>+    case DeviceInfo::eDeviceType_Ethernet: {\n>+      guint speed;\n>+      // If \"Speed\" is not in the hash table that means the speed didn't change.\n>+      if (GetValueFromHashTable<guint, g_value_get_uint>(aProperties, \"Speed\", &speed)) {\n>+        newSpeed = speed;\n\n\"Speed\" is never in the hashtable, so the comment is not accurate here.  The\nwhole case block is unnecessary, but I guess it could be kept in case NM\nimplements this one day.\n\n>+NetworkManagerClient::DeviceInfo::ListenForChanges()\n>+{\n\n>+  dbus_g_proxy_connect_signal(mProxy, \"PropertiesChanged\",\n>+                              G_CALLBACK (PropertiesChanged), this, nsnull);\n>+}\n\nPlease add some warnings that the copy constructor must not be used after this\nmethod is called, or find a way to remove the copy constructor\naltogether (and replace it with a private declaration).\n\n>+  GPtrArray* devicesNM = nsnull;\n\nI'm assuming devicesNM doesn't need to be initialized here.\n(GError and GValue seem to be special.)\n\nBut it still needs to be released.\n\n>+    nsAutoRef<DBusGProxy> deviceProxy(dbus_g_proxy_new_for_name(mDBusConnection,\n>+                                                                  NM_DBUS_SERVICE,\n>+                                                                  devicePath,\n>+                                                                  NM_DBUS_INTERFACE_DEVICE));\n\ndeviceProxy is not really used.\n\n>+    if (type != DeviceInfo::eDeviceType_Ethernet &&\n>+        type != DeviceInfo::eDeviceType_Wifi) {\n>+      continue;\n>+    }\n\n>+    const gchar* interface = nsnull;\n>+\n>+    switch (device.mType) {\n>+      case DeviceInfo::eDeviceType_Ethernet:\n>+        interface = NM_DBUS_INTERFACE_DEVICE_WIRED;\n>+        break;\n>+      case DeviceInfo::eDeviceType_Wifi:\n>+        interface = NM_DBUS_INTERFACE_DEVICE_WIRELESS;\n>+        break;\n>+      default:\n>+        MOZ_ASSERT(false);\n>+    }\n>+\n>+    device.mProxy = dbus_g_proxy_new_for_name(mDBusConnection,\n>+                                              NM_DBUS_SERVICE,\n>+                                              dbus_g_proxy_get_path(deviceProxy),\n>+                                              interface);\n\nBy moving the switch statement (and mProxy initialization) to the type check\nabove, they can merge into one test and |interface| need not be\nnull-initialized.\n\n>+  const gchar* version = g_value_get_string(&value);\n>+  return version[0] == '0' && version[1] == '.' && version[2] == '9';\n\nBetter to use a string comparison here.  This would match against 0.95 for\nexample.  There are also (possibly valid) assumptions here that the memory is\naccessible even if the version string is short, but that may flag\nuninitialized-read warnings in valgrind.\n\n>+  if (!IsVersionSupported()) {\n>+    // We do not support this version, we should stop here.\n>+    dbus_connection_remove_filter(\n>+        dbus_g_connection_get_connection(mDBusConnection),\n>+        ConnectionSignalFilter, this);\n\nLooks like there will be problems if ConnectionSignalFilter runs before this\npoint.\n\nWould it be better to call dbus_connection_add_filter after checking the\nversion?  Or is it necessary to add checks that the connection is still up?\n\n>+  // This should happen rarely enough to do something costly: we clear\n>+  // everything we know about devices and re-initialize this. That could be\n>+  // optimized surely.\n\nPerhaps add a comment here that mDevices can't be adjusted while the proxies\nhave offsets into the array.", "count": 16, "bug_id": 712442, "id": 6161441, "raw_text": ">+  gpointer key, gvalue;\n>+  if (!g_hash_table_lookup_extended(aHashTable, aKey, &key, &gvalue)) {\n>+    return false;\n\nWhy use the the _extended function here?\nIs there a reason why there should be a null GValue* in the hash table?\n\nIf there is a reason for using the _extended function, then pass NULL for\nunused orig_key.\n\n>+#if GLIB_MAJOR_VERSION >= 2 && GLIB_MINOR_VERSION >= 22\n>+    g_ptr_array_unref(ptr);\n>+#else\n>+    g_ptr_array_free(ptr, TRUE);\n>+#endif\n\nWhy bother with g_ptr_array_unref here?  (Comment 1)\n\n>+NetworkManagerClient::DeviceInfo::DeviceInfo()\n>+  : mDBusConnection(nsnull)\n>+  , mType(eDeviceType_Unknown)\n>+  , mState(eDeviceState_Disconnected)\n>+  , mProxy(nsnull)\n>+  , mSpeed(0)\n\nmType and mState don't actually need to be initialized here.\n\n>+  // There is no reason why getting the DBus connection object should fail\n>+  // because the NetworkManagerClient already has a connection object if we\n>+  // happen to be here.\n>+  mDBusConnection = dbus_g_bus_get(DBUS_BUS_SYSTEM, nsnull);\n>+\n>+  // Make sure we do not exit the entire program if DBus connection get lost.\n>+  dbus_connection_set_exit_on_disconnect(\n>+      dbus_g_connection_get_connection(mDBusConnection), FALSE);\n\nGiven this is a preexisting connection, there is no need to call\ndbus_connection_set_exit_on_disconnect here.\n\n>+  nsAutoRef<DBusGProxy> proxy(dbus_g_proxy_new_for_name(\n>+                                mDBusConnection,\n>+                                NM_DBUS_SERVICE,\n>+                                dbus_g_proxy_get_path(mProxy),\n>+                                DBUS_INTERFACE_PROPERTIES));\n\nHow about dbus_g_proxy_new_from_proxy(mProxy, DBUS_INTERFACE_PROPERTIES, NULL)?\nThen mDBusConnection may be unnecessary.\n\n>+        // Sometimes, the hash table has a Speed or Bitrate field with the new\n>+        // speed but tests shows that it's not always the case so it's better to\n>+        // always explicitly request the speed instead of guessing when we\n>+        // should do that.\n\nIsn't this only an issue with the Wired Speed?  (Comment 9)\n\nThere should be notification for the wireless Bitrate, right?\n(even if it may not be delivered at the same time as the change to State.)\nThe get_property implementation returns priv->rate and rate is only set when\nnotifying NM_DEVICE_WIFI_BITRATE.\n\n>+    case DeviceInfo::eDeviceType_Ethernet: {\n>+      guint speed;\n>+      // If \"Speed\" is not in the hash table that means the speed didn't change.\n>+      if (GetValueFromHashTable<guint, g_value_get_uint>(aProperties, \"Speed\", &speed)) {\n>+        newSpeed = speed;\n\n\"Speed\" is never in the hashtable, so the comment is not accurate here.  The\nwhole case block is unnecessary, but I guess it could be kept in case NM\nimplements this one day.\n\n>+NetworkManagerClient::DeviceInfo::ListenForChanges()\n>+{\n\n>+  dbus_g_proxy_connect_signal(mProxy, \"PropertiesChanged\",\n>+                              G_CALLBACK (PropertiesChanged), this, nsnull);\n>+}\n\nPlease add some warnings that the copy constructor must not be used after this\nmethod is called, or find a way to remove the copy constructor\naltogether (and replace it with a private declaration).\n\n>+  GPtrArray* devicesNM = nsnull;\n\nI'm assuming devicesNM doesn't need to be initialized here.\n(GError and GValue seem to be special.)\n\nBut it still needs to be released.\n\n>+    nsAutoRef<DBusGProxy> deviceProxy(dbus_g_proxy_new_for_name(mDBusConnection,\n>+                                                                  NM_DBUS_SERVICE,\n>+                                                                  devicePath,\n>+                                                                  NM_DBUS_INTERFACE_DEVICE));\n\ndeviceProxy is not really used.\n\n>+    if (type != DeviceInfo::eDeviceType_Ethernet &&\n>+        type != DeviceInfo::eDeviceType_Wifi) {\n>+      continue;\n>+    }\n\n>+    const gchar* interface = nsnull;\n>+\n>+    switch (device.mType) {\n>+      case DeviceInfo::eDeviceType_Ethernet:\n>+        interface = NM_DBUS_INTERFACE_DEVICE_WIRED;\n>+        break;\n>+      case DeviceInfo::eDeviceType_Wifi:\n>+        interface = NM_DBUS_INTERFACE_DEVICE_WIRELESS;\n>+        break;\n>+      default:\n>+        MOZ_ASSERT(false);\n>+    }\n>+\n>+    device.mProxy = dbus_g_proxy_new_for_name(mDBusConnection,\n>+                                              NM_DBUS_SERVICE,\n>+                                              dbus_g_proxy_get_path(deviceProxy),\n>+                                              interface);\n\nBy moving the switch statement (and mProxy initialization) to the type check\nabove, they can merge into one test and |interface| need not be\nnull-initialized.\n\n>+  const gchar* version = g_value_get_string(&value);\n>+  return version[0] == '0' && version[1] == '.' && version[2] == '9';\n\nBetter to use a string comparison here.  This would match against 0.95 for\nexample.  There are also (possibly valid) assumptions here that the memory is\naccessible even if the version string is short, but that may flag\nuninitialized-read warnings in valgrind.\n\n>+  if (!IsVersionSupported()) {\n>+    // We do not support this version, we should stop here.\n>+    dbus_connection_remove_filter(\n>+        dbus_g_connection_get_connection(mDBusConnection),\n>+        ConnectionSignalFilter, this);\n\nLooks like there will be problems if ConnectionSignalFilter runs before this\npoint.\n\nWould it be better to call dbus_connection_add_filter after checking the\nversion?  Or is it necessary to add checks that the connection is still up?\n\n>+  // This should happen rarely enough to do something costly: we clear\n>+  // everything we know about devices and re-initialize this. That could be\n>+  // optimized surely.\n\nPerhaps add a comment here that mDevices can't be adjusted while the proxies\nhave offsets into the array.", "time": "2012-03-22T05:47:50Z", "creator": "karlt@mozbugz.karlt.net", "is_private": false, "creation_time": "2012-03-22T05:47:50Z", "attachment_id": 605792, "tags": []}]}}, "comments": {}}