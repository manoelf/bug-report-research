{"bugs": {"661374": {"comments": [{"id": 5507281, "attachment_id": null, "raw_text": "In certain types of applications (games, for example), many common patterns are designed around the assumed presence of structured value types, used to represent things like locations, transformation matrices, etc. When these patterns are implemented in JavaScript, they end up creating large amounts of garbage in the form of Objects representing those structured value type.\n\nI believe that some degree of static analysis is possible in order to detect Objects that satisfy a set of requirements to be classified as a 'value type object' - they do not hold references to other objects within the GC heap and do not contain complex behavior; all their values are either primitives (like Number) or other value type objects. \n\nIf we can statically verify this, we can then optimize the use of these value types - they don't need to participate in cycle collection, and they may be able to be entirely ignored by the GC; we could heap-allocate them in cases where we are able to determine that they do not escape, and in cases where they escape, we can combine simple heap allocation along with naive refcounting since we know they will not participate in cycles. We can also potentially optimize their layout in memory since we know the exact shape of the object in advance.\n\ncdleary suggested that a good way to prototype this would be to implement a simple form of this analysis on spidermonkey bytecode, so that's probably my starting point.\n\nSome gotchas that might prevent this from being possible:\n\nNo matter what, you have Object.prototype involved, which means that value type objects can inherit references to other objects from their prototype, and can inherit references to functions that might allow the 'this'-reference to escape.\n\nWhile optimistically, emulating struct semantics should provide a performance win, it's possible that there are cases where objects are used like structs, but treating them like actual structs will make the resulting JS perform worse. If this is implemented, it will need some carefully tuned heuristics to ensure we don't regress performance on real-world applications.\n\nGenerational GCs reduce the cost associated with short-lived simple objects, so if we end up shipping a generational GC, this optimization might not be worthwhile anymore.", "creation_time": "2011-06-01T21:25:14Z", "author": "kg@luminance.org", "text": "In certain types of applications (games, for example), many common patterns are designed around the assumed presence of structured value types, used to represent things like locations, transformation matrices, etc. When these patterns are implemented in JavaScript, they end up creating large amounts of garbage in the form of Objects representing those structured value type.\n\nI believe that some degree of static analysis is possible in order to detect Objects that satisfy a set of requirements to be classified as a 'value type object' - they do not hold references to other objects within the GC heap and do not contain complex behavior; all their values are either primitives (like Number) or other value type objects. \n\nIf we can statically verify this, we can then optimize the use of these value types - they don't need to participate in cycle collection, and they may be able to be entirely ignored by the GC; we could heap-allocate them in cases where we are able to determine that they do not escape, and in cases where they escape, we can combine simple heap allocation along with naive refcounting since we know they will not participate in cycles. We can also potentially optimize their layout in memory since we know the exact shape of the object in advance.\n\ncdleary suggested that a good way to prototype this would be to implement a simple form of this analysis on spidermonkey bytecode, so that's probably my starting point.\n\nSome gotchas that might prevent this from being possible:\n\nNo matter what, you have Object.prototype involved, which means that value type objects can inherit references to other objects from their prototype, and can inherit references to functions that might allow the 'this'-reference to escape.\n\nWhile optimistically, emulating struct semantics should provide a performance win, it's possible that there are cases where objects are used like structs, but treating them like actual structs will make the resulting JS perform worse. If this is implemented, it will need some carefully tuned heuristics to ensure we don't regress performance on real-world applications.\n\nGenerational GCs reduce the cost associated with short-lived simple objects, so if we end up shipping a generational GC, this optimization might not be worthwhile anymore.", "time": "2011-06-01T21:25:14Z", "bug_id": 661374, "tags": [], "is_private": false, "creator": "kg@luminance.org", "count": 0}, {"count": 1, "bug_id": 661374, "is_private": false, "creator": "cdleary@acm.org", "creation_time": "2011-06-01T21:34:13Z", "author": "cdleary@acm.org", "text": "Well, as I mentioned in IRC, the analysis that's feasible with the current engine infrastructure is a function-local scope optimization. You can detect object literals that can be decomposed into fields, like so:\n\nfunction foo() {\n    var o = {a: 1, b: 2, c: 3};\n    o.c *= o.a;\n    print(o.a + o.b)\n}\n\nBecause you know that the property lookups are definitely going to o (and not something on the prototype chain) and you conservatively see that o can't escape from the local scope (no method calls or name uses) you can lower the properties of o into local slots, like vars.\n\nAs soon as multiple functions get involved you need to assume things about the identity of the function that gave you a new object; i.e.\n\nfunction Point(x, y) {\n     return {x: x, y: y};\n}\n\nfunction foo() {\n    var p = new Point(1, 2);\n    p.x *= p.y;\n    print(p.x + p.y);\n}\n\nThis is going to be tougher, because you can't reason about the object source locally, within a single function. I'd recommend that we start with the local one and then brainstorm how best to apply it to cross-function analysis (there are some possibilities there).", "tags": [], "time": "2011-06-01T21:34:13Z", "attachment_id": null, "raw_text": "Well, as I mentioned in IRC, the analysis that's feasible with the current engine infrastructure is a function-local scope optimization. You can detect object literals that can be decomposed into fields, like so:\n\nfunction foo() {\n    var o = {a: 1, b: 2, c: 3};\n    o.c *= o.a;\n    print(o.a + o.b)\n}\n\nBecause you know that the property lookups are definitely going to o (and not something on the prototype chain) and you conservatively see that o can't escape from the local scope (no method calls or name uses) you can lower the properties of o into local slots, like vars.\n\nAs soon as multiple functions get involved you need to assume things about the identity of the function that gave you a new object; i.e.\n\nfunction Point(x, y) {\n     return {x: x, y: y};\n}\n\nfunction foo() {\n    var p = new Point(1, 2);\n    p.x *= p.y;\n    print(p.x + p.y);\n}\n\nThis is going to be tougher, because you can't reason about the object source locally, within a single function. I'd recommend that we start with the local one and then brainstorm how best to apply it to cross-function analysis (there are some possibilities there).", "id": 5507318}, {"is_private": false, "creator": "bhackett1024@gmail.com", "creation_time": "2011-06-01T22:02:53Z", "author": "bhackett1024@gmail.com", "text": "There is a fair amount of overlap here with how property accesses are treated in the type inference branch (bug 608741, merging to TM hopefully within a week or so).  When constructing objects we analyze uses of 'this' to determine when it escapes and which properties are definitely added before it does so.  We then use that information at access sites to get to the property at a fixed offset into the object, a single dereference (if the type of the property is known statically) and no IC or branching.  This only covers accesses, not allocation or GC management --- you might want to look at the discussion in bug 642002 on escape analysis.", "tags": [], "time": "2011-06-01T22:02:53Z", "attachment_id": null, "raw_text": "There is a fair amount of overlap here with how property accesses are treated in the type inference branch (bug 608741, merging to TM hopefully within a week or so).  When constructing objects we analyze uses of 'this' to determine when it escapes and which properties are definitely added before it does so.  We then use that information at access sites to get to the property at a fixed offset into the object, a single dereference (if the type of the property is known statically) and no IC or branching.  This only covers accesses, not allocation or GC management --- you might want to look at the discussion in bug 642002 on escape analysis.", "id": 5507405, "count": 2, "bug_id": 661374}, {"is_private": false, "creator": "bzbarsky@mit.edu", "count": 3, "creation_time": "2011-06-02T02:44:09Z", "author": "bzbarsky@mit.edu", "text": "Note that all objects always hold references into the GC heap: to their proto and parent.\n\nWe're working on nixing the latter but the former is not going to go away...  now in the case of literals, the proto will be the default Object.prototype, which we can ensure lives long enough as long as there's no escaping.", "tags": [], "time": "2011-06-02T02:44:09Z", "bug_id": 661374, "attachment_id": null, "raw_text": "Note that all objects always hold references into the GC heap: to their proto and parent.\n\nWe're working on nixing the latter but the former is not going to go away...  now in the case of literals, the proto will be the default Object.prototype, which we can ensure lives long enough as long as there's no escaping.", "id": 5507937}, {"count": 4, "creator": "brendan@mozilla.org", "is_private": false, "bug_id": 661374, "time": "2011-06-02T22:58:30Z", "tags": [], "text": "See also\n\nhttp://wiki.ecmascript.org/doku.php?id=strawman:binary_data\n\nThis is approved for ES.next, should be getting implementation love soon I hear.\n\n/be", "author": "brendan@mozilla.org", "creation_time": "2011-06-02T22:58:30Z", "raw_text": "See also\n\nhttp://wiki.ecmascript.org/doku.php?id=strawman:binary_data\n\nThis is approved for ES.next, should be getting implementation love soon I hear.\n\n/be", "attachment_id": null, "id": 5509843}, {"bug_id": 661374, "count": 5, "id": 5509879, "attachment_id": null, "raw_text": "(In reply to comment #4)\n> See also\n> \n> http://wiki.ecmascript.org/doku.php?id=strawman:binary_data\n> \n> This is approved for ES.next, should be getting implementation love soon I\n> hear.\n> \n> /be\n\nThat is awesome, I hadn't realized Binary Data was already approved for ES.next. That proposal provides wins in a lot of the same cases I'm considering here. One thing that's unclear - I see mention of blocks living in the heap instead of being ECMAScript objects; does that mean that in practice, single Struct instances would not count as garbage? Or is that beyond the scope of the binary data proposal, and something the proposed optimization from this bug would still benefit?", "creation_time": "2011-06-02T23:09:13Z", "author": "kg@luminance.org", "text": "(In reply to comment #4)\n> See also\n> \n> http://wiki.ecmascript.org/doku.php?id=strawman:binary_data\n> \n> This is approved for ES.next, should be getting implementation love soon I\n> hear.\n> \n> /be\n\nThat is awesome, I hadn't realized Binary Data was already approved for ES.next. That proposal provides wins in a lot of the same cases I'm considering here. One thing that's unclear - I see mention of blocks living in the heap instead of being ECMAScript objects; does that mean that in practice, single Struct instances would not count as garbage? Or is that beyond the scope of the binary data proposal, and something the proposed optimization from this bug would still benefit?", "time": "2011-06-02T23:09:13Z", "tags": [], "is_private": false, "creator": "kg@luminance.org"}, {"count": 6, "bug_id": 661374, "raw_text": "> That is awesome, I hadn't realized Binary Data was already approved for\n> ES.next.\n\nWell, it's promoted to Harmony status, but nothing is officially \"approved\" yet. However, the committee is very supportive of the proposal, so we just have to do the work to finish it. This is high-priority and I need to get on this ASAP as Brendan says.\n\n> That proposal provides wins in a lot of the same cases I'm\n> considering here. One thing that's unclear - I see mention of blocks living\n> in the heap instead of being ECMAScript objects; does that mean that in\n> practice, single Struct instances would not count as garbage? Or is that\n> beyond the scope of the binary data proposal, and something the proposed\n> optimization from this bug would still benefit?\n\nHm, I didn't expect the spec to address garbage collection but I may not be understanding you. The internal binary data at least conceptually lives on the heap because there may be multiple Struct objects that point to shared data in a block (i.e., when you pull out a substruct it's pointing to the same mutable binary data). If you want to allocate data internally when you can prove it isn't shared, I think that should be fine.\n\nDave", "attachment_id": null, "id": 5509926, "creator": "david.herman@gmail.com", "is_private": false, "time": "2011-06-02T23:29:18Z", "tags": [], "text": "> That is awesome, I hadn't realized Binary Data was already approved for\n> ES.next.\n\nWell, it's promoted to Harmony status, but nothing is officially \"approved\" yet. However, the committee is very supportive of the proposal, so we just have to do the work to finish it. This is high-priority and I need to get on this ASAP as Brendan says.\n\n> That proposal provides wins in a lot of the same cases I'm\n> considering here. One thing that's unclear - I see mention of blocks living\n> in the heap instead of being ECMAScript objects; does that mean that in\n> practice, single Struct instances would not count as garbage? Or is that\n> beyond the scope of the binary data proposal, and something the proposed\n> optimization from this bug would still benefit?\n\nHm, I didn't expect the spec to address garbage collection but I may not be understanding you. The internal binary data at least conceptually lives on the heap because there may be multiple Struct objects that point to shared data in a block (i.e., when you pull out a substruct it's pointing to the same mutable binary data). If you want to allocate data internally when you can prove it isn't shared, I think that should be fine.\n\nDave", "author": "david.herman@gmail.com", "creation_time": "2011-06-02T23:29:18Z"}, {"attachment_id": null, "raw_text": "In particular, an ArrayType containing StructType elements is one contiguous allocation -- not a Java-esque vector of pointers to the heap, where the vector is itself heap-allocated.\n\nAnd yeah, this bug wants to do stack allocation transparently too, but that should be doable with binary data as well as with other JS data.\n\n/be", "id": 5510082, "creator": "brendan@mozilla.org", "is_private": false, "count": 7, "author": "brendan@mozilla.org", "creation_time": "2011-06-03T00:34:17Z", "time": "2011-06-03T00:34:17Z", "tags": [], "bug_id": 661374, "text": "In particular, an ArrayType containing StructType elements is one contiguous allocation -- not a Java-esque vector of pointers to the heap, where the vector is itself heap-allocated.\n\nAnd yeah, this bug wants to do stack allocation transparently too, but that should be doable with binary data as well as with other JS data.\n\n/be"}, {"time": "2011-06-03T21:05:07Z", "bug_id": 661374, "tags": [], "text": "Kevin, if you want to defer working on this until type inference comes online or if you're interested in working on the binary data strawman implementation instead of a bytecode-oriented analysis in the near-term, let's close this bug out.", "author": "cdleary@acm.org", "creation_time": "2011-06-03T21:05:07Z", "count": 8, "creator": "cdleary@acm.org", "is_private": false, "id": 5511803, "raw_text": "Kevin, if you want to defer working on this until type inference comes online or if you're interested in working on the binary data strawman implementation instead of a bytecode-oriented analysis in the near-term, let's close this bug out.", "attachment_id": null}, {"count": 9, "creator": "brendan@mozilla.org", "is_private": false, "bug_id": 661374, "time": "2011-06-04T17:34:24Z", "tags": [], "text": "This bug seems worth keeping unless we know TI subsumes it -- and even then, if there's a unit of TI work summarized with words close to this bug's summary.\n\nOr close it, if there's a better bug, but my main point is that implementing the binary data strawman is a fine thing, but it is not the same bug as this one, so filing and fixing it should not close this one.\n\n/be", "author": "brendan@mozilla.org", "creation_time": "2011-06-04T17:34:24Z", "raw_text": "This bug seems worth keeping unless we know TI subsumes it -- and even then, if there's a unit of TI work summarized with words close to this bug's summary.\n\nOr close it, if there's a better bug, but my main point is that implementing the binary data strawman is a fine thing, but it is not the same bug as this one, so filing and fixing it should not close this one.\n\n/be", "attachment_id": null, "id": 5513474}, {"attachment_id": null, "raw_text": "I think we should keep this bug.  TI doesn't subsume this, but this should definitely be implemented on top of the analyses available with TI --- escape analysis becomes much simpler working on SSA rather than the raw bytecode, and cross-script analysis becomes much more tractable with a callgraph and other type info available.", "id": 5513479, "creator": "bhackett1024@gmail.com", "is_private": false, "count": 10, "author": "bhackett1024@gmail.com", "creation_time": "2011-06-04T17:39:31Z", "tags": [], "bug_id": 661374, "time": "2011-06-04T17:39:31Z", "text": "I think we should keep this bug.  TI doesn't subsume this, but this should definitely be implemented on top of the analyses available with TI --- escape analysis becomes much simpler working on SSA rather than the raw bytecode, and cross-script analysis becomes much more tractable with a callgraph and other type info available."}, {"creator": "kg@luminance.org", "is_private": false, "author": "kg@luminance.org", "creation_time": "2011-06-04T18:22:16Z", "tags": [], "time": "2011-06-04T18:22:16Z", "text": "I'll be discussing whether this makes sense in the short term with Taras, but in the long term I still plan to do it. I'm going to be researching the bytecode analysis part of it anyway since it overlaps with a personal project, so if that research is fruitful it'll provide a starting point for this bug (whenever the work actually gets done).", "attachment_id": null, "raw_text": "I'll be discussing whether this makes sense in the short term with Taras, but in the long term I still plan to do it. I'm going to be researching the bytecode analysis part of it anyway since it overlaps with a personal project, so if that research is fruitful it'll provide a starting point for this bug (whenever the work actually gets done).", "id": 5513495, "count": 11, "bug_id": 661374}, {"creator": "till@tillschneidereit.net", "is_private": false, "count": 12, "author": "till@tillschneidereit.net", "creation_time": "2013-04-01T16:25:41Z", "bug_id": 661374, "time": "2013-04-01T16:25:41Z", "tags": [], "text": "Is this still relevant, or is nbp's work on Ion escape analysis in bug 856533 all that should be done here?", "attachment_id": null, "raw_text": "Is this still relevant, or is nbp's work on Ion escape analysis in bug 856533 all that should be done here?", "id": 7262896}, {"is_private": false, "creator": "kvijayan@mozilla.com", "creation_time": "2013-06-07T20:12:01Z", "author": "kvijayan@mozilla.com", "text": "Escape analysis in bytecode is not a good idea.  Figuring out whether values escape the context at a bytecode level is simply too weak for most of the perf gains we're looking to get from this analysis.\n\nConsider the following simple case:\n\nfunction addVec(a, b) {\n  return [a[0] + b[0], a[1] + b[1]];\n}\nfunction scaleVec(a, scale) {\n  return [a[0] * scale, b[0] * scale];\n}\nfunction addScaleVec(a, b, scale) {\n  return addVec(a, scaleVec(b, scale)); \n}\n\nThis kind of code can be seen in v8/raytrace, and on the web in situations where objects are used as structured arguments.  Looking above, just at the bytecode, does |scaleVec(b, scale)| escape the scope of the |addScaleVec| call?\n\nWell, to do that, we need to figure out whether the second argument of |addVec| escapes addVec, which is not immediately available when analyzing addScaleVec.\n\nThese kinds of problems abound when analyzing bytecode.  There's just not enough information to be able to conclude anything about escaping values.\n\nA much more workable plan for escape analysis is to investigate a completed IonGraph after construction.\n\n1. At that time, type-information will tell us what functions are called.\n\n2. TI will also tell us whether or not some innocuous looking assignment to a slot in a non-escaping object is actually a call to a setter that may make the assigned value escape, or whether it can be guaranteed to be a plain set.\n\n3. Inlining will expand the scope of analysis \"for free\".\n\n\nBasically, bytecode analysis is close to useless for figuring out escape properties.  It'll give us a very limited amount of information that'll allow for meager optimizations only.\n\nIt's better to move this work to bug 856533.", "time": "2013-06-07T20:12:01Z", "tags": [], "attachment_id": null, "raw_text": "Escape analysis in bytecode is not a good idea.  Figuring out whether values escape the context at a bytecode level is simply too weak for most of the perf gains we're looking to get from this analysis.\n\nConsider the following simple case:\n\nfunction addVec(a, b) {\n  return [a[0] + b[0], a[1] + b[1]];\n}\nfunction scaleVec(a, scale) {\n  return [a[0] * scale, b[0] * scale];\n}\nfunction addScaleVec(a, b, scale) {\n  return addVec(a, scaleVec(b, scale)); \n}\n\nThis kind of code can be seen in v8/raytrace, and on the web in situations where objects are used as structured arguments.  Looking above, just at the bytecode, does |scaleVec(b, scale)| escape the scope of the |addScaleVec| call?\n\nWell, to do that, we need to figure out whether the second argument of |addVec| escapes addVec, which is not immediately available when analyzing addScaleVec.\n\nThese kinds of problems abound when analyzing bytecode.  There's just not enough information to be able to conclude anything about escaping values.\n\nA much more workable plan for escape analysis is to investigate a completed IonGraph after construction.\n\n1. At that time, type-information will tell us what functions are called.\n\n2. TI will also tell us whether or not some innocuous looking assignment to a slot in a non-escaping object is actually a call to a setter that may make the assigned value escape, or whether it can be guaranteed to be a plain set.\n\n3. Inlining will expand the scope of analysis \"for free\".\n\n\nBasically, bytecode analysis is close to useless for figuring out escape properties.  It'll give us a very limited amount of information that'll allow for meager optimizations only.\n\nIt's better to move this work to bug 856533.", "id": 7511464, "count": 13, "bug_id": 661374}]}}, "comments": {}}