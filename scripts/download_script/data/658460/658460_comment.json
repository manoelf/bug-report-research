{"comments": {}, "bugs": {"658460": {"comments": [{"author": "jan@majutsushi.net", "raw_text": "User-Agent:       Mozilla/5.0 (X11; Linux i686; rv:2.0) Gecko/20100101 Firefox/4.0\nBuild Identifier: \n\nThreadPool threads that are in waiting in nsThreadPool::Run() are waiting on the ThreadPool monitor. ShutdownXPCOM tries to explicitly shut down all threads through the ThreadManager, but the shutdown is posted to the thread directly and thus bypasses the ThreadPool Monitor, thus failing to wake up the responsible thread to handle the event. So if for example the ThreadPool timeout is very high Firefox will hang on shutdown until the timeout expires.\n\nReproducible: Always", "id": 5481931, "text": "User-Agent:       Mozilla/5.0 (X11; Linux i686; rv:2.0) Gecko/20100101 Firefox/4.0\nBuild Identifier: \n\nThreadPool threads that are in waiting in nsThreadPool::Run() are waiting on the ThreadPool monitor. ShutdownXPCOM tries to explicitly shut down all threads through the ThreadManager, but the shutdown is posted to the thread directly and thus bypasses the ThreadPool Monitor, thus failing to wake up the responsible thread to handle the event. So if for example the ThreadPool timeout is very high Firefox will hang on shutdown until the timeout expires.\n\nReproducible: Always", "creation_time": "2011-05-20T04:38:28Z", "bug_id": 658460, "count": 0, "creator": "jan@majutsushi.net", "tags": [], "attachment_id": null, "is_private": false, "time": "2011-05-20T04:38:28Z"}, {"is_private": false, "time": "2011-05-20T06:04:28Z", "attachment_id": null, "raw_text": "I am currently experimenting with making the ThreadPool more deterministic by setting low thread limits and high timeouts so the number of thread creation/destruction events get reduced. However, on shutdown the ThreadPool that is used by the nsParser component is only explicitly shut down after the ThreadManager. This causes the main thread to continuously generate dummy events while it is waiting for the ThreadPool threads to shut down.\n\nI'll try to make the ThreadPool explicitly observe the XPCOM shutdown event so it can shut down all of its threads directly.", "id": 5482012, "text": "I am currently experimenting with making the ThreadPool more deterministic by setting low thread limits and high timeouts so the number of thread creation/destruction events get reduced. However, on shutdown the ThreadPool that is used by the nsParser component is only explicitly shut down after the ThreadManager. This causes the main thread to continuously generate dummy events while it is waiting for the ThreadPool threads to shut down.\n\nI'll try to make the ThreadPool explicitly observe the XPCOM shutdown event so it can shut down all of its threads directly.", "creation_time": "2011-05-20T06:04:28Z", "bug_id": 658460, "count": 1, "tags": [], "creator": "jan@majutsushi.net", "author": "jan@majutsushi.net"}, {"time": "2011-05-20T16:10:33Z", "is_private": false, "attachment_id": null, "bug_id": 658460, "count": 2, "creator": "bent.mozilla@gmail.com", "tags": [], "text": "All threads are supposed to be joined during the \"shutdown-threads\" observer notification, and the thread pool must be shut down manually. See, for example:\n\nhttps://mxr.mozilla.org/mozilla-central/source/dom/indexedDB/IndexedDatabaseManager.cpp#265", "creation_time": "2011-05-20T16:10:33Z", "raw_text": "All threads are supposed to be joined during the \"shutdown-threads\" observer notification, and the thread pool must be shut down manually. See, for example:\n\nhttps://mxr.mozilla.org/mozilla-central/source/dom/indexedDB/IndexedDatabaseManager.cpp#265", "id": 5482819, "author": "bent.mozilla@gmail.com"}, {"author": "jan@majutsushi.net", "bug_id": 658460, "creator": "jan@majutsushi.net", "count": 3, "tags": [], "text": "The \"shutdown-threads\" notification seems to only be observed in a few places, and notably not in the thread pools (or the threads themselves). I don't know if that's intentional (as your comment seems to suggest), but it leads to this case where threads can't be shut down properly. I've written a patch that makes the thread pools observe the \"shutdown-threads\" notification, and it solves the problem for me. It does have the slight side effect that the Shutdown() method gets called twice for thread pools that still exist after the notification, but since the only thing that method does is shut down all the pool's threads it shouldn't do any harm.\n\nNote that if the HTML5 parser is enabled the problem currently doesn't show itself since that parser doesn't use a thread pool, but if any other component starts using one it would appear again.", "creation_time": "2011-05-29T06:13:56Z", "raw_text": "The \"shutdown-threads\" notification seems to only be observed in a few places, and notably not in the thread pools (or the threads themselves). I don't know if that's intentional (as your comment seems to suggest), but it leads to this case where threads can't be shut down properly. I've written a patch that makes the thread pools observe the \"shutdown-threads\" notification, and it solves the problem for me. It does have the slight side effect that the Shutdown() method gets called twice for thread pools that still exist after the notification, but since the only thing that method does is shut down all the pool's threads it shouldn't do any harm.\n\nNote that if the HTML5 parser is enabled the problem currently doesn't show itself since that parser doesn't use a thread pool, but if any other component starts using one it would appear again.", "id": 5500296, "attachment_id": null, "time": "2011-05-29T06:13:56Z", "is_private": false}, {"text": "Created attachment 535903\nMake nsThreadPool observe xpcom-shutdown-threads notification", "creation_time": "2011-05-29T06:28:48Z", "raw_text": "", "id": 5500300, "bug_id": 658460, "tags": [], "count": 4, "creator": "jan@majutsushi.net", "author": "jan@majutsushi.net", "is_private": false, "time": "2011-05-29T06:28:48Z", "attachment_id": 535903}, {"text": "Comment on attachment 535903\nMake nsThreadPool observe xpcom-shutdown-threads notification\n\nYou never clear the observer anywhere. Assuming there are any thread pools which may not live as long as the app, you'd be holding those alive until shutdown.\n\nIs there a reason why we want threadpools to automagically shut themselves down, instead of requiring (asserting) that clients which create thread pools shut them down properly, just as clients who create individual threads are suppose to do?", "creation_time": "2011-05-31T16:41:24Z", "raw_text": "You never clear the observer anywhere. Assuming there are any thread pools which may not live as long as the app, you'd be holding those alive until shutdown.\n\nIs there a reason why we want threadpools to automagically shut themselves down, instead of requiring (asserting) that clients which create thread pools shut them down properly, just as clients who create individual threads are suppose to do?", "id": 5503579, "bug_id": 658460, "tags": [], "count": 5, "creator": "benjamin@smedbergs.us", "author": "benjamin@smedbergs.us", "is_private": false, "time": "2011-05-31T16:41:24Z", "attachment_id": 535903}, {"time": "2011-06-03T03:33:14Z", "is_private": false, "attachment_id": null, "count": 6, "creator": "jan@majutsushi.net", "tags": [], "bug_id": 658460, "creation_time": "2011-06-03T03:33:14Z", "text": "The reason is that ShutdownXPCOM tries to shut down all remaining threads (here: http://mxr.mozilla.org/mozilla-central/source/xpcom/build/nsXPComInit.cpp#625 ) before the components (that could use a threadpool, like with the old html parser) (here: http://mxr.mozilla.org/mozilla-central/source/xpcom/build/nsXPComInit.cpp#694 ). But the threadmanager can't notify threadpool threads of the shutdown event since they are blocked on the threadpool monitor, which is out of the threadmanager's reach. So the shutdown event will only get processed once the thread's timeout is reached, which could potentially be a while. Therefore I think that shutting down the threads during the normal shutdown-threads notification makes sense since then the the threadmanager doesn't have to wait for those threads (since the notification happens earlier).\n\nAs for clearing the observer, I guess the only reasonable place to put it would be the nsThreadPool::Shutdown() method, even though it is called from the destructor. Would calling RemoveObserver() twice be a problem?", "id": 5510308, "raw_text": "The reason is that ShutdownXPCOM tries to shut down all remaining threads (here: http://mxr.mozilla.org/mozilla-central/source/xpcom/build/nsXPComInit.cpp#625 ) before the components (that could use a threadpool, like with the old html parser) (here: http://mxr.mozilla.org/mozilla-central/source/xpcom/build/nsXPComInit.cpp#694 ). But the threadmanager can't notify threadpool threads of the shutdown event since they are blocked on the threadpool monitor, which is out of the threadmanager's reach. So the shutdown event will only get processed once the thread's timeout is reached, which could potentially be a while. Therefore I think that shutting down the threads during the normal shutdown-threads notification makes sense since then the the threadmanager doesn't have to wait for those threads (since the notification happens earlier).\n\nAs for clearing the observer, I guess the only reasonable place to put it would be the nsThreadPool::Shutdown() method, even though it is called from the destructor. Would calling RemoveObserver() twice be a problem?", "author": "jan@majutsushi.net"}, {"time": "2011-06-03T03:46:26Z", "is_private": false, "attachment_id": null, "bug_id": 658460, "tags": [], "creator": "roc@ocallahan.org", "count": 7, "text": "(In reply to comment #6)\n> As for clearing the observer, I guess the only reasonable place to put it\n> would be the nsThreadPool::Shutdown() method, even though it is called from\n> the destructor. Would calling RemoveObserver() twice be a problem?\n\nI don't think so, but you can store a flag to indicate whether you've called it or not. Or you could just remomve it from the destructor and require Shutdown to be called.", "creation_time": "2011-06-03T03:46:26Z", "raw_text": "(In reply to comment #6)\n> As for clearing the observer, I guess the only reasonable place to put it\n> would be the nsThreadPool::Shutdown() method, even though it is called from\n> the destructor. Would calling RemoveObserver() twice be a problem?\n\nI don't think so, but you can store a flag to indicate whether you've called it or not. Or you could just remomve it from the destructor and require Shutdown to be called.", "id": 5510315, "author": "roc@ocallahan.org"}, {"creator": "jan@majutsushi.net", "count": 8, "tags": [], "bug_id": 658460, "creation_time": "2011-06-03T04:50:37Z", "text": "Created attachment 537077\nUpdated patch that removes the observer on shutdown\n\nOK, I'm now checking the mShutdown member which gets set during (threadpool) shutdown anyway so the observer will only be removed once. I've left the call from the destructor in since it doesn't seem to have caused any problems so far, and the observer is now guarded.", "id": 5510358, "raw_text": "OK, I'm now checking the mShutdown member which gets set during (threadpool) shutdown anyway so the observer will only be removed once. I've left the call from the destructor in since it doesn't seem to have caused any problems so far, and the observer is now guarded.", "author": "jan@majutsushi.net", "time": "2011-06-03T04:50:37Z", "is_private": false, "attachment_id": 537077}, {"author": "bent.mozilla@gmail.com", "creation_time": "2011-06-14T03:44:00Z", "text": "You still haven't addressed comment 5:\n\n> Is there a reason why we want threadpools to automagically shut themselves\n> down, instead of requiring (asserting) that clients which create thread\n> pools shut them down properly, just as clients who create individual threads\n> are suppose to do?", "id": 5530621, "raw_text": "You still haven't addressed comment 5:\n\n> Is there a reason why we want threadpools to automagically shut themselves\n> down, instead of requiring (asserting) that clients which create thread\n> pools shut them down properly, just as clients who create individual threads\n> are suppose to do?", "tags": [], "count": 9, "creator": "bent.mozilla@gmail.com", "bug_id": 658460, "attachment_id": null, "is_private": false, "time": "2011-06-14T03:44:00Z"}, {"attachment_id": null, "time": "2011-06-14T07:28:36Z", "is_private": false, "author": "jan@majutsushi.net", "bug_id": 658460, "tags": [], "count": 10, "creator": "jan@majutsushi.net", "text": "(In reply to comment #9)\n\nI thought I already explained it in comment 6. Threads in threadpools can only be shut down from inside the pool, so ShutdownXPCOM can't do that explicitly from the outside using the thread manager in http://mxr.mozilla.org/mozilla-central/source/xpcom/build/nsXPComInit.cpp#625 , meaning that this call will hang until all threadpool threads that still exist at this point have timed out. This can happen if a component uses a threadpool with a long thread timeout, since components are only shut down *after* that call, so they can't shut down the threadpools before it. Or did you mean something else?", "creation_time": "2011-06-14T07:28:36Z", "raw_text": "(In reply to comment #9)\n\nI thought I already explained it in comment 6. Threads in threadpools can only be shut down from inside the pool, so ShutdownXPCOM can't do that explicitly from the outside using the thread manager in http://mxr.mozilla.org/mozilla-central/source/xpcom/build/nsXPComInit.cpp#625 , meaning that this call will hang until all threadpool threads that still exist at this point have timed out. This can happen if a component uses a threadpool with a long thread timeout, since components are only shut down *after* that call, so they can't shut down the threadpools before it. Or did you mean something else?", "id": 5530875}, {"attachment_id": null, "author": "bent.mozilla@gmail.com", "is_private": false, "creation_time": "2011-06-14T15:12:17Z", "text": "(In reply to comment #10)\n\nThe question is *why* do we want this to happen automatically. You've explained *how* it can happen, but the situation you describe would be a bug in my view. Users of the threadpool can and should take responsibility to clean up after themselves in my opinion.\n\nI can think of at least one scenario where having a threadpool stop accepting events at some random time could cause real problems. Imagine some threadpool that is being used for a map/reduce operation, where the final reduce step is to be run on one of the pool's threads. That reduce can't begin until all the map threads have returned results, but if we hit ShutdownXPCOM before the final map has completed then the reduce step will not ever happen. If the reduce was supposed to write data to the disk or something then we'd be talking about data loss.\n\nI don't think that the benefits of your patch (faster shutdown if some developer uses threadpools incorrectly) outweigh the hazards (threads magically dying) here.", "id": 5531399, "raw_text": "(In reply to comment #10)\n\nThe question is *why* do we want this to happen automatically. You've explained *how* it can happen, but the situation you describe would be a bug in my view. Users of the threadpool can and should take responsibility to clean up after themselves in my opinion.\n\nI can think of at least one scenario where having a threadpool stop accepting events at some random time could cause real problems. Imagine some threadpool that is being used for a map/reduce operation, where the final reduce step is to be run on one of the pool's threads. That reduce can't begin until all the map threads have returned results, but if we hit ShutdownXPCOM before the final map has completed then the reduce step will not ever happen. If the reduce was supposed to write data to the disk or something then we'd be talking about data loss.\n\nI don't think that the benefits of your patch (faster shutdown if some developer uses threadpools incorrectly) outweigh the hazards (threads magically dying) here.", "creator": "bent.mozilla@gmail.com", "count": 11, "time": "2011-06-14T15:12:17Z", "tags": [], "bug_id": 658460}, {"author": "bug-husbandry-bot@mozilla.bugs", "attachment_id": null, "bug_id": 658460, "tags": [], "count": 12, "creator": "bug-husbandry-bot@mozilla.bugs", "time": "2018-04-30T20:12:14Z", "text": "Moving to Core:XUL per https://bugzilla.mozilla.org/show_bug.cgi?id=1455336", "creation_time": "2018-04-30T20:12:14Z", "is_private": false, "raw_text": "Moving to Core:XUL per https://bugzilla.mozilla.org/show_bug.cgi?id=1455336", "id": 13244403}]}}}