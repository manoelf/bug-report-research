{"comments": {}, "bugs": {"1644187": {"comments": [{"text": "The goal here is to implement the `CSS_MESSAGE` resource from the actor side.\nThis is about replicating the current behavior, implemented in bug 1625910.\nBut instead of having a wrapper on the client side to morph the legacy WebConsoleActor methods (i.e. the legacy listener code),\nwe would implement an actor API matching ResourceWatcher API (i.e. watch and unwatch).\n\nThis would be about implementing a server side equivalent of this legacy listener code:\nhttps://searchfox.org/mozilla-central/source/devtools/shared/resources/legacy-listeners/css-messages.js\nIn a new server side module:\nhttps://searchfox.org/mozilla-central/source/devtools/server/actors/resources/css-messages.js\n\nThis module would typicaly look like this:\n```\nconst { TYPES } = require(\"devtools/server/actors/resources/index\");\n\nclass MyResourceWatcher {\n  /**\n   * Start watching for all ${MY_RESOURCE_TYPE} related to a given Target Actor.\n   * This will notify about existing ${MY_RESOURCE_TYPE}, but also the one created in future.\n   *\n   * @param TargetActor targetActor\n   *        The target actor from which we should observe console messages\n   * @param Object options\n   *        Dictionary object with following attributes:\n   *        - onAvailable: mandatory function\n   *          This will be called for each resource.\n   */\n  constructor(targetActor, { onAvailable }) {\n    // In most cases, we already have some helper class which helps observing one resource\n    // that we can spawn like this:\n    // Note that it may often be easier to merge such `MyResourceListener` into this `MyResourceWatcher` class!\n    const listener = new MyResourceListener(\n      targetActor.browsingContextID,\n      targetActor.window,\n      ...  /* whatever is useful for your observation */\n    );\n    \n    // Forward all future resources being observed to the upper layer calling this module,\n    // via `onAvailable` callback argument.\n    // I'm using EventEmitter API here, but the API may different,\n    // based on the platform API we have to use to observe the resource.\n    listener.on(\"one-of-my-resource-is-created\", resource => {\n      // We have to ensure that each resource object has a valid `resourceType` attribute\n      resource.resourceType = TYPES.MY_RESOURCE_TYPE;\n      onAvailable([resource]);\n    });\n    \n    // Also forward all resources which already exist when we are calling this method\n    // (if any exists)\n    const cachedResources = listener.getAllAlreadyExistingOrCachedResources();\n    for(const resource of cachedResources) {\n      resource.resourceType = TYPES.MY_RESOURCE_TYPE;\n    }\n    onAvailable(cachedResources);\n    \n    // Save the listener in order to destroy/stop watching later on.\n    this.listener = listener;\n  }\n\n  /**\n   * Stop watching for ${MY_RESOURCE_TYPE}.\n   */\n  destroy() {\n    if (this.listener) {\n      this.listener.destroy();\n    }\n  }\n}\nmodule.exports = MyResourceWatcher;\n```\n\nAn important goal here is to emit the exact same `resource` object that the legacy listener is passing to its `onAvailable` callback.\nSame attributes, same values, ...\n\nBug 1644185 could be used as a template. As it did this work for `PLATFORM_MESSAGE` resource type.\n\nThe main reason to do this is to be able to start listening to the resource before the page starts loading.\nThanks to the framework work done in bug 1620243, this `MyResourceWatcher` class will be instantiated before the page starts \nloading and possibly as early as the content process just started. \nThis wasn't the case with legacy actor APIs like `WebConsoleActor.startListeners`, `ThreadActor.attachThread`, ...\nWe were calling these methods too late, only after the frontend is notify about the existance of the target, so, late after the page started loading.\n\nYou will also have to register this new module in this registry:\nhttps://searchfox.org/mozilla-central/source/devtools/server/actors/resources/index.js\n* Add a new entry in `TYPES` object.\n* Register your new resource watcher module into `Resources` object.\n\nLast but not least, it is probably a good time to review the existing tests for this Resource:\nhttps://searchfox.org/mozilla-central/source/devtools/shared/resources/tests\nAnd ensure that it has a good coverage.\nYou would especially have to migrate all Client/Front tests, which were testing the backend behavior via `targetFront.getFront(\"myfront\")`.\nAll these tests will be removed, once we drop the legacy listeners. Because we are going to drop the server API that we no longer use.\nLike WebConsoleActor/Front.getCachedMessage(), WebConsoleActor/Front.startListeners(), ThreadActor/Front.sources(), ThreadActor/Front.new-source, ...", "author": "poirot.alex@gmail.com", "id": 14869903, "attachment_id": null, "bug_id": 1644187, "is_private": false, "count": 0, "creation_time": "2020-06-08T16:50:11Z", "raw_text": "The goal here is to implement the `CSS_MESSAGE` resource from the actor side.\nThis is about replicating the current behavior, implemented in bug 1625910.\nBut instead of having a wrapper on the client side to morph the legacy WebConsoleActor methods (i.e. the legacy listener code),\nwe would implement an actor API matching ResourceWatcher API (i.e. watch and unwatch).\n\nThis would be about implementing a server side equivalent of this legacy listener code:\nhttps://searchfox.org/mozilla-central/source/devtools/shared/resources/legacy-listeners/css-messages.js\nIn a new server side module:\nhttps://searchfox.org/mozilla-central/source/devtools/server/actors/resources/css-messages.js\n\nThis module would typicaly look like this:\n```\nconst { TYPES } = require(\"devtools/server/actors/resources/index\");\n\nclass MyResourceWatcher {\n  /**\n   * Start watching for all ${MY_RESOURCE_TYPE} related to a given Target Actor.\n   * This will notify about existing ${MY_RESOURCE_TYPE}, but also the one created in future.\n   *\n   * @param TargetActor targetActor\n   *        The target actor from which we should observe console messages\n   * @param Object options\n   *        Dictionary object with following attributes:\n   *        - onAvailable: mandatory function\n   *          This will be called for each resource.\n   */\n  constructor(targetActor, { onAvailable }) {\n    // In most cases, we already have some helper class which helps observing one resource\n    // that we can spawn like this:\n    // Note that it may often be easier to merge such `MyResourceListener` into this `MyResourceWatcher` class!\n    const listener = new MyResourceListener(\n      targetActor.browsingContextID,\n      targetActor.window,\n      ...  /* whatever is useful for your observation */\n    );\n    \n    // Forward all future resources being observed to the upper layer calling this module,\n    // via `onAvailable` callback argument.\n    // I'm using EventEmitter API here, but the API may different,\n    // based on the platform API we have to use to observe the resource.\n    listener.on(\"one-of-my-resource-is-created\", resource => {\n      // We have to ensure that each resource object has a valid `resourceType` attribute\n      resource.resourceType = TYPES.MY_RESOURCE_TYPE;\n      onAvailable([resource]);\n    });\n    \n    // Also forward all resources which already exist when we are calling this method\n    // (if any exists)\n    const cachedResources = listener.getAllAlreadyExistingOrCachedResources();\n    for(const resource of cachedResources) {\n      resource.resourceType = TYPES.MY_RESOURCE_TYPE;\n    }\n    onAvailable(cachedResources);\n    \n    // Save the listener in order to destroy/stop watching later on.\n    this.listener = listener;\n  }\n\n  /**\n   * Stop watching for ${MY_RESOURCE_TYPE}.\n   */\n  destroy() {\n    if (this.listener) {\n      this.listener.destroy();\n    }\n  }\n}\nmodule.exports = MyResourceWatcher;\n```\n\nAn important goal here is to emit the exact same `resource` object that the legacy listener is passing to its `onAvailable` callback.\nSame attributes, same values, ...\n\nBug 1644185 could be used as a template. As it did this work for `PLATFORM_MESSAGE` resource type.\n\nThe main reason to do this is to be able to start listening to the resource before the page starts loading.\nThanks to the framework work done in bug 1620243, this `MyResourceWatcher` class will be instantiated before the page starts \nloading and possibly as early as the content process just started. \nThis wasn't the case with legacy actor APIs like `WebConsoleActor.startListeners`, `ThreadActor.attachThread`, ...\nWe were calling these methods too late, only after the frontend is notify about the existance of the target, so, late after the page started loading.\n\nYou will also have to register this new module in this registry:\nhttps://searchfox.org/mozilla-central/source/devtools/server/actors/resources/index.js\n* Add a new entry in `TYPES` object.\n* Register your new resource watcher module into `Resources` object.\n\nLast but not least, it is probably a good time to review the existing tests for this Resource:\nhttps://searchfox.org/mozilla-central/source/devtools/shared/resources/tests\nAnd ensure that it has a good coverage.\nYou would especially have to migrate all Client/Front tests, which were testing the backend behavior via `targetFront.getFront(\"myfront\")`.\nAll these tests will be removed, once we drop the legacy listeners. Because we are going to drop the server API that we no longer use.\nLike WebConsoleActor/Front.getCachedMessage(), WebConsoleActor/Front.startListeners(), ThreadActor/Front.sources(), ThreadActor/Front.new-source, ...", "time": "2020-06-08T16:50:11Z", "creator": "poirot.alex@gmail.com", "tags": []}, {"author": "cpeterson@mozilla.com", "id": 14875650, "attachment_id": null, "text": "Tracking dt-fission-m2 bugs for Fission Nightly (M6c)", "is_private": false, "bug_id": 1644187, "raw_text": "Tracking dt-fission-m2 bugs for Fission Nightly (M6c)", "count": 1, "creation_time": "2020-06-11T06:22:54Z", "tags": [], "time": "2020-06-11T06:22:54Z", "creator": "cpeterson@mozilla.com"}, {"text": "Created attachment 9162725\nBug 1644187 - Add server support for CSS warning resources. r=jdescottes.\n\n\nThis is quite similar to the error messages watcher, except that we call\nensureCSSErrorReportingEnabled after retrieving the cached messages.\n\nResource no longer includes `errorMessageName` and `isPromiseRejection` as it\nmakes little sense for the CSS warning.\n\nThe existing resource test is updated to run with and without the server support.", "id": 14929220, "author": "nchevobbe@mozilla.com", "attachment_id": 9162725, "is_private": false, "bug_id": 1644187, "count": 2, "creation_time": "2020-07-10T07:56:44Z", "raw_text": "\nThis is quite similar to the error messages watcher, except that we call\nensureCSSErrorReportingEnabled after retrieving the cached messages.\n\nResource no longer includes `errorMessageName` and `isPromiseRejection` as it\nmakes little sense for the CSS warning.\n\nThe existing resource test is updated to run with and without the server support.", "time": "2020-07-10T07:56:44Z", "creator": "nchevobbe@mozilla.com", "tags": []}, {"bug_id": 1644187, "is_private": false, "text": "Pushed by nchevobbe@mozilla.com:\nhttps://hg.mozilla.org/integration/autoland/rev/f5e323468860\nAdd server support for CSS warning resources. r=jdescottes.", "attachment_id": null, "id": 14942666, "author": "pulsebot@bots.tld", "creator": "pulsebot@bots.tld", "time": "2020-07-17T15:00:07Z", "tags": [], "creation_time": "2020-07-17T15:00:07Z", "count": 3, "raw_text": "Pushed by nchevobbe@mozilla.com:\nhttps://hg.mozilla.org/integration/autoland/rev/f5e323468860\nAdd server support for CSS warning resources. r=jdescottes."}, {"tags": ["bugherder"], "creator": "abutkovits@mozilla.com", "time": "2020-07-17T21:32:10Z", "raw_text": "https://hg.mozilla.org/mozilla-central/rev/f5e323468860", "count": 4, "creation_time": "2020-07-17T21:32:10Z", "bug_id": 1644187, "is_private": false, "author": "abutkovits@mozilla.com", "id": 14943321, "attachment_id": null, "text": "https://hg.mozilla.org/mozilla-central/rev/f5e323468860"}]}}}