{"comments": {}, "bugs": {"639085": {"comments": [{"author": "mail@lukewagner.name", "bug_id": 639085, "count": 0, "tags": [], "creator": "mail@lukewagner.name", "raw_text": "This tool has the initial goal of getting some understanding of the potential speedup from DOM-bindings, but I also think it is useful for getting getting a quick and easy coarse answer to \"why is this slow?\" or \"where is all the time going?\"  The tool is just a hacked-up browser that spits out rdtsc times to a log whenever control flow enters/leaves various components of the JS engine and XPConnect.\n\nOther than running fast, the reason for making a tool vs. just using automated profiling like normal is that it allows ad hoc customization of what component is blamed for what time.  For example: with the exception of the NS_InvokeByIndex/JS_CallFunctionValue at the heart of CallMethod, one would want to \"charge\" any JS engine time under CallMethod to CallMethod.\n\nThe tool is very much incomplete (only works on x86 linux) and immature (need to do more work verifying results) and primitive (it just spits out results for the entire lifetime of the browser main thread), but initial results (posted shortly) are interesting.\n\nThe code is in a user repo:\n  http://hg.mozilla.org/users/lwagner_mozilla.com/measure\nIts diff vs. TM is attached for reference.\n\nA readme for building and interpreting the results:\n  http://hg.mozilla.org/users/lwagner_mozilla.com/measure/file/53b547dfe953/js/timelog/README", "id": 5323432, "text": "Created attachment 517067\ninitial patch\n\nThis tool has the initial goal of getting some understanding of the potential speedup from DOM-bindings, but I also think it is useful for getting getting a quick and easy coarse answer to \"why is this slow?\" or \"where is all the time going?\"  The tool is just a hacked-up browser that spits out rdtsc times to a log whenever control flow enters/leaves various components of the JS engine and XPConnect.\n\nOther than running fast, the reason for making a tool vs. just using automated profiling like normal is that it allows ad hoc customization of what component is blamed for what time.  For example: with the exception of the NS_InvokeByIndex/JS_CallFunctionValue at the heart of CallMethod, one would want to \"charge\" any JS engine time under CallMethod to CallMethod.\n\nThe tool is very much incomplete (only works on x86 linux) and immature (need to do more work verifying results) and primitive (it just spits out results for the entire lifetime of the browser main thread), but initial results (posted shortly) are interesting.\n\nThe code is in a user repo:\n  http://hg.mozilla.org/users/lwagner_mozilla.com/measure\nIts diff vs. TM is attached for reference.\n\nA readme for building and interpreting the results:\n  http://hg.mozilla.org/users/lwagner_mozilla.com/measure/file/53b547dfe953/js/timelog/README", "creation_time": "2011-03-05T02:19:47Z", "attachment_id": 517067, "time": "2011-03-05T02:19:47Z", "is_private": false}, {"author": "mail@lukewagner.name", "tags": [], "creator": "mail@lukewagner.name", "count": 1, "bug_id": 639085, "creation_time": "2011-03-05T02:27:06Z", "text": "Created attachment 517068\ninitial results\n\nInitial results are attached.  (See README for interpreting rows/columns.)  Here's a summary though (that is, only for the \"groups\", not individual components):\n\nDromaeo:\nJS          39% ( 59169ms)\nXPC         16% ( 24737ms)\nGC           4% (  6440ms)\nOther       40% ( 60847ms)\n\nFluid sim \nJS          56% ( 25240ms)\nXPC          0% (   251ms)\nGC           0% (   126ms)\nOther       42% ( 18725ms)\n\nhttp://mootools.net/slickspeed/\nJS          25% (  3614ms)\nXPC         16% (  2327ms)\nGC           3% (   457ms)\nOther       54% (  7564ms)\n\nhttp://blog.frontendforce.com/2010/05/jquery-vs-mootools-nightly-benchmark/\nJS          27% (  4475ms)\nXPC         12% (  2095ms)\nGC           4% (   728ms)\nOther       55% (  9224ms)\n\nhttp://andrewdupont.net/test/double-dollar/\nJS          11% (   962ms)\nXPC          4% (   334ms)\nGC           1% (   143ms)\nOther       82% (  6724ms)\n\nPeacekeeper\nJS          40% ( 70272ms)\nXPC          4% (  7791ms)\nGC           1% (  3314ms)\nOther       53% ( 92839ms)\n\nFacebook session\nJS           5% (  3038ms)\nXPC          2% (  1336ms)\nGC           2% (  1442ms)\nOther       89% ( 49872ms)\n\nFF, mostly using chrome\nJS           5% (  1454ms)\nXPC          7% (  1864ms)\nGC           2% (   739ms)\nOther       84% ( 21705ms)\n\nSo (and again, I need to do a bit more work to verify the measurements) it seems like XPC generally consumes a small total percentage of browser time.  Its worse case is, not surprisingly, in DOM/JS benchmarks, but even then, it tops out at 16%.\n\nLet me know if there are any more interesting benchmarks.  dvander suggested bug 638328 (which means I'll need to get this working on Windows since WebGL doesn't seem to initialize on my Linux machine).", "id": 5323441, "raw_text": "Initial results are attached.  (See README for interpreting rows/columns.)  Here's a summary though (that is, only for the \"groups\", not individual components):\n\nDromaeo:\nJS          39% ( 59169ms)\nXPC         16% ( 24737ms)\nGC           4% (  6440ms)\nOther       40% ( 60847ms)\n\nFluid sim \nJS          56% ( 25240ms)\nXPC          0% (   251ms)\nGC           0% (   126ms)\nOther       42% ( 18725ms)\n\nhttp://mootools.net/slickspeed/\nJS          25% (  3614ms)\nXPC         16% (  2327ms)\nGC           3% (   457ms)\nOther       54% (  7564ms)\n\nhttp://blog.frontendforce.com/2010/05/jquery-vs-mootools-nightly-benchmark/\nJS          27% (  4475ms)\nXPC         12% (  2095ms)\nGC           4% (   728ms)\nOther       55% (  9224ms)\n\nhttp://andrewdupont.net/test/double-dollar/\nJS          11% (   962ms)\nXPC          4% (   334ms)\nGC           1% (   143ms)\nOther       82% (  6724ms)\n\nPeacekeeper\nJS          40% ( 70272ms)\nXPC          4% (  7791ms)\nGC           1% (  3314ms)\nOther       53% ( 92839ms)\n\nFacebook session\nJS           5% (  3038ms)\nXPC          2% (  1336ms)\nGC           2% (  1442ms)\nOther       89% ( 49872ms)\n\nFF, mostly using chrome\nJS           5% (  1454ms)\nXPC          7% (  1864ms)\nGC           2% (   739ms)\nOther       84% ( 21705ms)\n\nSo (and again, I need to do a bit more work to verify the measurements) it seems like XPC generally consumes a small total percentage of browser time.  Its worse case is, not surprisingly, in DOM/JS benchmarks, but even then, it tops out at 16%.\n\nLet me know if there are any more interesting benchmarks.  dvander suggested bug 638328 (which means I'll need to get this working on Windows since WebGL doesn't seem to initialize on my Linux machine).", "attachment_id": 517068, "time": "2011-03-05T02:27:06Z", "is_private": false}, {"time": "2011-03-05T02:40:28Z", "is_private": false, "attachment_id": null, "creator": "dmandelin@mozilla.com", "count": 2, "tags": [], "bug_id": 639085, "creation_time": "2011-03-05T02:40:28Z", "text": "Can you try these out? These are some good interactive pages that require really good browser perf:\n\nhttp://dougx.net/plunder/plunder.html\nhttp://www.paulbrunt.co.uk/steamcube/\nhttp://marblerun.at/tracks/new\nhttp://alteredqualia.com/visualization/evolve/\nhttp://beadsjs.chrismorgan.info/bugzilla-clock.html\nhttp://webglsamples.googlecode.com/hg/blob/blob.html", "id": 5323458, "raw_text": "Can you try these out? These are some good interactive pages that require really good browser perf:\n\nhttp://dougx.net/plunder/plunder.html\nhttp://www.paulbrunt.co.uk/steamcube/\nhttp://marblerun.at/tracks/new\nhttp://alteredqualia.com/visualization/evolve/\nhttp://beadsjs.chrismorgan.info/bugzilla-clock.html\nhttp://webglsamples.googlecode.com/hg/blob/blob.html", "author": "dmandelin@mozilla.com"}, {"author": "bzbarsky@mit.edu", "attachment_id": null, "raw_text": "You probably need to instrument the code generated by writaTraceableStub in qsgen.py too, though I wonder how much we're on trace nowadays... :(\n\nThe number for XPCWN_Ops on http://mootools.net/slickspeed/ is disturbing, though that may be all the DOM0 crap the libraries love.  Could we differentiate between the various stuff going through nsIXPCScriptable and the actual overhead of XPConnect on paths from JS into idl-defined C++ methods?\n\nIn general, 10-15% XPC+quickstub stuff on things that are touching the DOM a lot sounds about right.", "id": 5323647, "text": "You probably need to instrument the code generated by writaTraceableStub in qsgen.py too, though I wonder how much we're on trace nowadays... :(\n\nThe number for XPCWN_Ops on http://mootools.net/slickspeed/ is disturbing, though that may be all the DOM0 crap the libraries love.  Could we differentiate between the various stuff going through nsIXPCScriptable and the actual overhead of XPConnect on paths from JS into idl-defined C++ methods?\n\nIn general, 10-15% XPC+quickstub stuff on things that are touching the DOM a lot sounds about right.", "is_private": false, "creation_time": "2011-03-05T05:53:51Z", "bug_id": 639085, "time": "2011-03-05T05:53:51Z", "creator": "bzbarsky@mit.edu", "tags": [], "count": 3}, {"attachment_id": null, "is_private": false, "time": "2011-03-05T08:39:35Z", "author": "mail@lukewagner.name", "text": "(In reply to comment #3)\n> You probably need to instrument the code generated by writaTraceableStub in\n> qsgen.py too\n\nI originally did just that.  However the average number of cycles under a traceable native (minus the time under the C++ target of course) was low enough that the rdtsc overhead (~30 cycles from my measurements x 4 (enter,pause,resume,leave)) was substantial.\n\nAlso, at an intuitive level, if we are on trace, life is generally good, so I was happy to lump that all together.\n\n> though I wonder how much we're on trace nowadays... :(\n\nYou can see the answer in the detailed output in the attachment to comment 1: 9% of Dromaeo, 44% of V8, 7% SS, 49% fluid sim, 3% double dollar, 19% peacekeeper.\n\n> The number for XPCWN_Ops on http://mootools.net/slickspeed/ is disturbing,\n> though that may be all the DOM0 crap the libraries love.  Could we\n> differentiate between the various stuff going through nsIXPCScriptable and the\n> actual overhead of XPConnect on paths from JS into idl-defined C++ methods?\n\nYou bet.  Would that be simply time in XPC.*Helper.*Ops or is it something else?", "creation_time": "2011-03-05T08:39:35Z", "raw_text": "(In reply to comment #3)\n> You probably need to instrument the code generated by writaTraceableStub in\n> qsgen.py too\n\nI originally did just that.  However the average number of cycles under a traceable native (minus the time under the C++ target of course) was low enough that the rdtsc overhead (~30 cycles from my measurements x 4 (enter,pause,resume,leave)) was substantial.\n\nAlso, at an intuitive level, if we are on trace, life is generally good, so I was happy to lump that all together.\n\n> though I wonder how much we're on trace nowadays... :(\n\nYou can see the answer in the detailed output in the attachment to comment 1: 9% of Dromaeo, 44% of V8, 7% SS, 49% fluid sim, 3% double dollar, 19% peacekeeper.\n\n> The number for XPCWN_Ops on http://mootools.net/slickspeed/ is disturbing,\n> though that may be all the DOM0 crap the libraries love.  Could we\n> differentiate between the various stuff going through nsIXPCScriptable and the\n> actual overhead of XPConnect on paths from JS into idl-defined C++ methods?\n\nYou bet.  Would that be simply time in XPC.*Helper.*Ops or is it something else?", "id": 5323757, "bug_id": 639085, "creator": "mail@lukewagner.name", "count": 4, "tags": []}, {"is_private": false, "time": "2011-03-05T13:59:46Z", "attachment_id": null, "raw_text": "Ah.  So the thing is, the quickstub cost is pretty similar both on and off trace.  So if we're measuring one but not the other we're under-estimating the cost of the quickstubs; how much depends on how much time we spend on trace.  We're underestimating it by no more than the time spent on trace in the data here.\n\n30*4 is definitely comparable to the cost of an entire quickstub in many cases, for both the traceable and fastnative cases.\n\n> Would that be simply time in XPC.*Helper.*Ops or is it something else?\n\nFor the classinfo stuff, I _think_ so.  \n\nI guess you already differentiate that from the CallMethod stuff; that might be all we really need.  I admit I no longer remember that much about the non-quickstub stuff here.  ;)", "id": 5323959, "text": "Ah.  So the thing is, the quickstub cost is pretty similar both on and off trace.  So if we're measuring one but not the other we're under-estimating the cost of the quickstubs; how much depends on how much time we spend on trace.  We're underestimating it by no more than the time spent on trace in the data here.\n\n30*4 is definitely comparable to the cost of an entire quickstub in many cases, for both the traceable and fastnative cases.\n\n> Would that be simply time in XPC.*Helper.*Ops or is it something else?\n\nFor the classinfo stuff, I _think_ so.  \n\nI guess you already differentiate that from the CallMethod stuff; that might be all we really need.  I admit I no longer remember that much about the non-quickstub stuff here.  ;)", "creation_time": "2011-03-05T13:59:46Z", "bug_id": 639085, "creator": "bzbarsky@mit.edu", "tags": [], "count": 5, "author": "bzbarsky@mit.edu"}, {"bug_id": 639085, "count": 6, "creator": "mail@lukewagner.name", "tags": [], "raw_text": "(In reply to comment #5)\n> Ah.  So the thing is, the quickstub cost is pretty similar both on and off\n> trace.  So if we're measuring one but not the other we're under-estimating the\n> cost of the quickstubs; how much depends on how much time we spend on trace. \n> We're underestimating it by no more than the time spent on trace in the data\n> here.\n\nOh duh, you're right.  My mind was falsely dichtomizing trace+traceable-natives and not-trace+quickstubs.  I'll re-run with that and post with the next batch including dmandelin's benchmarks.\n\n> 30*4 is definitely comparable to the cost of an entire quickstub in many cases,\n> for both the traceable and fastnative cases.\n\nI measured the average number of cycles in a quickstub and it varies (surprisingly much) between 300 and 1000.  So 120 cycles could really be noticeable.  Actually, assuming that roughly 1/2 of those cycles should be attributed to the \"other\" guy (i.e., code calling the quick stub and code called by the quick stubb), its more like 60.\n \n> > Would that be simply time in XPC.*Helper.*Ops or is it something else?\n> \n> For the classinfo stuff, I _think_ so.  \n\nCool, will split those from the rest.", "id": 5325425, "text": "(In reply to comment #5)\n> Ah.  So the thing is, the quickstub cost is pretty similar both on and off\n> trace.  So if we're measuring one but not the other we're under-estimating the\n> cost of the quickstubs; how much depends on how much time we spend on trace. \n> We're underestimating it by no more than the time spent on trace in the data\n> here.\n\nOh duh, you're right.  My mind was falsely dichtomizing trace+traceable-natives and not-trace+quickstubs.  I'll re-run with that and post with the next batch including dmandelin's benchmarks.\n\n> 30*4 is definitely comparable to the cost of an entire quickstub in many cases,\n> for both the traceable and fastnative cases.\n\nI measured the average number of cycles in a quickstub and it varies (surprisingly much) between 300 and 1000.  So 120 cycles could really be noticeable.  Actually, assuming that roughly 1/2 of those cycles should be attributed to the \"other\" guy (i.e., code calling the quick stub and code called by the quick stubb), its more like 60.\n \n> > Would that be simply time in XPC.*Helper.*Ops or is it something else?\n> \n> For the classinfo stuff, I _think_ so.  \n\nCool, will split those from the rest.", "creation_time": "2011-03-06T08:24:26Z", "author": "mail@lukewagner.name", "time": "2011-03-06T08:24:26Z", "is_private": false, "attachment_id": null}, {"attachment_id": null, "time": "2011-03-06T17:33:22Z", "is_private": false, "author": "bzbarsky@mit.edu", "bug_id": 639085, "creator": "bzbarsky@mit.edu", "count": 7, "tags": [], "text": "> it varies (surprisingly much) between 300 and 1000.\n\nRight; the exact number would depend on the number of arguments, on whether |this| and the arguments implement fast unwrapping paths, on whether there's a return value and the type of the return value.  A quickstub with slow this and argument conversions and several arguments would take a lot longer than a quickstub for nodeType.", "creation_time": "2011-03-06T17:33:22Z", "raw_text": "> it varies (surprisingly much) between 300 and 1000.\n\nRight; the exact number would depend on the number of arguments, on whether |this| and the arguments implement fast unwrapping paths, on whether there's a return value and the type of the return value.  A quickstub with slow this and argument conversions and several arguments would take a lot longer than a quickstub for nodeType.", "id": 5325840}, {"id": 5326380, "raw_text": "(In reply to comment #7)\nWhat I meant was that the *average* (of all quickstub calls in a given benchmark) varied between benchmarks.  But now I see (in attachment 517068) that I understated the difference: Dromaeo had an average of 200 cycles; a Facebook session had an average of 1900, and just messing around with FF UI had an average of 2100!", "is_private": false, "creation_time": "2011-03-07T03:04:28Z", "text": "(In reply to comment #7)\nWhat I meant was that the *average* (of all quickstub calls in a given benchmark) varied between benchmarks.  But now I see (in attachment 517068) that I understated the difference: Dromaeo had an average of 200 cycles; a Facebook session had an average of 1900, and just messing around with FF UI had an average of 2100!", "time": "2011-03-07T03:04:28Z", "count": 8, "creator": "mail@lukewagner.name", "tags": [], "bug_id": 639085, "attachment_id": null, "author": "mail@lukewagner.name"}, {"id": 5327347, "raw_text": "Oh, that is _very_ interesting.  Ignoring the Fx UI for the moment, I wonder whether the difference is that Dromaeo calls \"simpler\" quickstubs or that Facebook does stuff we don't have optimized very well.\n\nAs long as you're in there, want to log data on _which_ quickstubs are being called how many times in the two cases (and probably file a separate bug with that data)?", "creation_time": "2011-03-07T16:52:23Z", "text": "Oh, that is _very_ interesting.  Ignoring the Fx UI for the moment, I wonder whether the difference is that Dromaeo calls \"simpler\" quickstubs or that Facebook does stuff we don't have optimized very well.\n\nAs long as you're in there, want to log data on _which_ quickstubs are being called how many times in the two cases (and probably file a separate bug with that data)?", "tags": [], "creator": "bzbarsky@mit.edu", "count": 9, "bug_id": 639085, "author": "bzbarsky@mit.edu", "is_private": false, "time": "2011-03-07T16:52:23Z", "attachment_id": null}, {"author": "mail@lukewagner.name", "creation_time": "2011-03-09T03:34:38Z", "text": "Created attachment 517962\nfixed, XPCWN_SH category added\n\nI gave trace a lower priority than XPC code so XPC-from-trace now counts as such, but it mostly didn't change things (the biggest change was from Dromaeo spending 13% in QS to 14%).  I also added a category XPCWN_SH for the XPC WN ops that call scriptable helpers.  I ran the non-WebGL-requiring demos dmandelin suggested, there summaries are below (full results in the attachment, summaries below).  Next I need to get this working on Windows so I can run WebGL stuff (its also interesting to see if accelerated rending has a big effect on the \"other\" category).\n\nGalactic Plunder (http://dougx.net/plunder/plunder.html)\nJS           4% (  1098ms)\nXPC          2% (   771ms)\nGC           0% (   169ms)\nOther       92% ( 24332ms)\n\nMarble Run (http://marblerun.at/tracks/new)\nJS          11% (  3689ms)\nXPC          1% (   401ms)\nGC           1% (   332ms)\nOther       86% ( 28150ms)\n\nhttp://alteredqualia.com/visualization/evolve\nJS          80% ( 22592ms)\nXPC          0% (   178ms)\nGC           0% (    88ms)\nOther       18% (  5150ms)\n\nhttp://beadsjs.chrismorgan.info/bugzilla-clock.html\nJS          72% ( 26218ms)\nXPC          0% (   333ms)\nGC           0% (   284ms)\nOther       25% (  9398ms)", "id": 5332255, "raw_text": "I gave trace a lower priority than XPC code so XPC-from-trace now counts as such, but it mostly didn't change things (the biggest change was from Dromaeo spending 13% in QS to 14%).  I also added a category XPCWN_SH for the XPC WN ops that call scriptable helpers.  I ran the non-WebGL-requiring demos dmandelin suggested, there summaries are below (full results in the attachment, summaries below).  Next I need to get this working on Windows so I can run WebGL stuff (its also interesting to see if accelerated rending has a big effect on the \"other\" category).\n\nGalactic Plunder (http://dougx.net/plunder/plunder.html)\nJS           4% (  1098ms)\nXPC          2% (   771ms)\nGC           0% (   169ms)\nOther       92% ( 24332ms)\n\nMarble Run (http://marblerun.at/tracks/new)\nJS          11% (  3689ms)\nXPC          1% (   401ms)\nGC           1% (   332ms)\nOther       86% ( 28150ms)\n\nhttp://alteredqualia.com/visualization/evolve\nJS          80% ( 22592ms)\nXPC          0% (   178ms)\nGC           0% (    88ms)\nOther       18% (  5150ms)\n\nhttp://beadsjs.chrismorgan.info/bugzilla-clock.html\nJS          72% ( 26218ms)\nXPC          0% (   333ms)\nGC           0% (   284ms)\nOther       25% (  9398ms)", "creator": "mail@lukewagner.name", "tags": [], "count": 10, "bug_id": 639085, "attachment_id": 517962, "is_private": false, "time": "2011-03-09T03:34:38Z"}, {"author": "mail@lukewagner.name", "attachment_id": 519497, "bug_id": 639085, "creator": "mail@lukewagner.name", "tags": [], "time": "2011-03-15T20:42:32Z", "count": 11, "text": "Created attachment 519497\nGMail session\n\nHere is an interesting session we just measured (when considering how much time GMail actually spent in JS).\n\nXPC time shows up higher than the other non-benchmark webapps at 10% of which half is quickstubs.  Bytecode compile time is a full half second.  Most interesting, though, is that for the one 839ms interval (that is, time between pumping the event queue), quickstub accounted for 84% of the time!  The average number for cycles per quickstub here is 27K cycles.  Note that the measurement includes all time in a quickstub minus the time in the target DOM call, so perhaps we are hitting some crazy object->native conversion path.", "is_private": false, "creation_time": "2011-03-15T20:42:32Z", "raw_text": "Here is an interesting session we just measured (when considering how much time GMail actually spent in JS).\n\nXPC time shows up higher than the other non-benchmark webapps at 10% of which half is quickstubs.  Bytecode compile time is a full half second.  Most interesting, though, is that for the one 839ms interval (that is, time between pumping the event queue), quickstub accounted for 84% of the time!  The average number for cycles per quickstub here is 27K cycles.  Note that the measurement includes all time in a quickstub minus the time in the target DOM call, so perhaps we are hitting some crazy object->native conversion path.", "id": 5346648}, {"bug_id": 639085, "creator": "bzbarsky@mit.edu", "tags": [], "count": 12, "raw_text": "Hmm.  Or native->object, triggering a GC?  Or do the measurements exclude that sort of thing?", "id": 5347260, "text": "Hmm.  Or native->object, triggering a GC?  Or do the measurements exclude that sort of thing?", "creation_time": "2011-03-16T00:26:03Z", "author": "bzbarsky@mit.edu", "time": "2011-03-16T00:26:03Z", "is_private": false, "attachment_id": null}, {"bug_id": 639085, "tags": [], "creator": "mail@lukewagner.name", "count": 13, "text": "GC has the highest priority (http://bit.ly/gwT2lr) so that wouldn't count against XPC/Quickstubs.", "creation_time": "2011-03-16T00:31:35Z", "raw_text": "GC has the highest priority (http://bit.ly/gwT2lr) so that wouldn't count against XPC/Quickstubs.", "id": 5347276, "author": "mail@lukewagner.name", "time": "2011-03-16T00:31:35Z", "is_private": false, "attachment_id": null}, {"is_private": false, "time": "2011-03-16T01:15:32Z", "attachment_id": null, "text": "Hrm.  In that case I can't think of a way this can possibly happen.  27k is just an insane number of cycles...\n\nIs this at all reproducible?  Could we have quickstubs log the name of the quickstub any time the cycle count for the quickstub is > 10,000 or something?\n\nFor that matter, logging when it's > 1000 might be nice too.  Give us an idea of which stubs are slow.", "creation_time": "2011-03-16T01:15:32Z", "raw_text": "Hrm.  In that case I can't think of a way this can possibly happen.  27k is just an insane number of cycles...\n\nIs this at all reproducible?  Could we have quickstubs log the name of the quickstub any time the cycle count for the quickstub is > 10,000 or something?\n\nFor that matter, logging when it's > 1000 might be nice too.  Give us an idea of which stubs are slow.", "id": 5347379, "bug_id": 639085, "creator": "bzbarsky@mit.edu", "count": 14, "tags": [], "author": "bzbarsky@mit.edu"}, {"is_private": false, "creation_time": "2011-03-26T01:08:34Z", "text": "Created attachment 522043\nWindows resuts\n\nI got the measurement working on Windows last week, but I just got around to actually running it today.  As predicted, some of the graphics tests spend proportionately more time in JS and less in FF-other, but no sea change in the results.  For the other tests, there was actually a surprising parity in the relative percentages between the very different machines.\n\nSome overall results concerning time spent in XPConnect:\n- The DOM/JS benchmarks have the highest XPC times, at around 14-17%.\n- Other tests that use the DOM, but not as a benchmark, seem to top out at 6% (gmail).\n- The \"FF chrome session\" test (which was me just clicking around FF chrome, no addons installed) spends 4%/3% of the total time in XPCWrappedNative::CallMethod/XPCWrappedJSClass::CallMethod, respectively, which are our two mega-slow XPC paths.  Nothing else spent much time in these.", "id": 5371279, "raw_text": "I got the measurement working on Windows last week, but I just got around to actually running it today.  As predicted, some of the graphics tests spend proportionately more time in JS and less in FF-other, but no sea change in the results.  For the other tests, there was actually a surprising parity in the relative percentages between the very different machines.\n\nSome overall results concerning time spent in XPConnect:\n- The DOM/JS benchmarks have the highest XPC times, at around 14-17%.\n- Other tests that use the DOM, but not as a benchmark, seem to top out at 6% (gmail).\n- The \"FF chrome session\" test (which was me just clicking around FF chrome, no addons installed) spends 4%/3% of the total time in XPCWrappedNative::CallMethod/XPCWrappedJSClass::CallMethod, respectively, which are our two mega-slow XPC paths.  Nothing else spent much time in these.", "creator": "mail@lukewagner.name", "time": "2011-03-26T01:08:34Z", "count": 15, "tags": [], "bug_id": 639085, "attachment_id": 522043, "author": "mail@lukewagner.name"}]}}}