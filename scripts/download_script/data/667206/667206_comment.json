{"bugs": {"667206": {"comments": [{"text": "Created attachment 541940\nDrawImage with MJPG test case (traffic web cam)\n\nUsing an image element with a mjpg as the source for a drawImage() call results in us silently doing nothing.  I think it's related to bug 667203, and how we consider the loading state of such images.  From nsCanvasRenderingContext2D::DrawImage, we bail in 3323:\n\n3315  if (!imgsurf) {\n3316    // The canvas spec says that drawImage should draw the first frame\n3317    // of animated images\n3318    PRUint32 sfeFlags = nsLayoutUtils::SFE_WANT_FIRST_FRAME;\n3319    nsLayoutUtils::SurfaceFromElementResult res =\n3320      nsLayoutUtils::SurfaceFromElement(imgElt, sfeFlags);\n3321    if (!res.mSurface) {\n3322      // Spec says to silently do nothing if the element is still loading.\n3323      return res.mIsStillLoading ? NS_OK : NS_ERROR_NOT_AVAILABLE;\n3324    }\n\nChrome and Safari happily draw the image into the canvas.  As I said in bug 667203, they also both consider the image loaded upon the first frame coming down.\n\nI've attached a test case.  If/when the network stream interrupts the transfer of frames, the canvas will suddenly get drawn, otherwise it remains white in Firefox.", "time": "2011-06-25T16:18:44Z", "tags": [], "bug_id": 667206, "creation_time": "2011-06-25T16:18:44Z", "author": "david.humphrey@senecacollege.ca", "count": 0, "is_private": false, "creator": "david.humphrey@senecacollege.ca", "id": 5556123, "raw_text": "Using an image element with a mjpg as the source for a drawImage() call results in us silently doing nothing.  I think it's related to bug 667203, and how we consider the loading state of such images.  From nsCanvasRenderingContext2D::DrawImage, we bail in 3323:\n\n3315  if (!imgsurf) {\n3316    // The canvas spec says that drawImage should draw the first frame\n3317    // of animated images\n3318    PRUint32 sfeFlags = nsLayoutUtils::SFE_WANT_FIRST_FRAME;\n3319    nsLayoutUtils::SurfaceFromElementResult res =\n3320      nsLayoutUtils::SurfaceFromElement(imgElt, sfeFlags);\n3321    if (!res.mSurface) {\n3322      // Spec says to silently do nothing if the element is still loading.\n3323      return res.mIsStillLoading ? NS_OK : NS_ERROR_NOT_AVAILABLE;\n3324    }\n\nChrome and Safari happily draw the image into the canvas.  As I said in bug 667203, they also both consider the image loaded upon the first frame coming down.\n\nI've attached a test case.  If/when the network stream interrupts the transfer of frames, the canvas will suddenly get drawn, otherwise it remains white in Firefox.", "attachment_id": 541940}, {"count": 1, "bug_id": 667206, "raw_text": "See bug 666855.", "attachment_id": null, "id": 5556142, "is_private": false, "creator": "Ms2ger@gmail.com", "text": "See bug 666855.", "tags": [], "time": "2011-06-25T16:37:56Z", "creation_time": "2011-06-25T16:37:56Z", "author": "Ms2ger@gmail.com"}, {"bug_id": 667206, "count": 2, "tags": [], "time": "2011-06-25T16:41:54Z", "text": "(In reply to comment #1)\n> See bug 666855.\n\nThe spec says Firefox is right (or trying to be right, I still don't get a poster frame or first frame drawn).  I've filed a bug on the spec:\n\nhttp://www.w3.org/Bugs/Public/show_bug.cgi?id=13060", "author": "david.humphrey@senecacollege.ca", "creation_time": "2011-06-25T16:41:54Z", "creator": "david.humphrey@senecacollege.ca", "is_private": false, "id": 5556146, "raw_text": "(In reply to comment #1)\n> See bug 666855.\n\nThe spec says Firefox is right (or trying to be right, I still don't get a poster frame or first frame drawn).  I've filed a bug on the spec:\n\nhttp://www.w3.org/Bugs/Public/show_bug.cgi?id=13060", "attachment_id": null}, {"count": 3, "creator": "bzbarsky@mit.edu", "is_private": false, "tags": [], "time": "2011-06-26T15:11:16Z", "bug_id": 667206, "text": "This is a different situation from the animated gif situation.\n\nThe issue here is that the spec says:\n\n  If the image argument is an HTMLImageElement object that is not fully\n  decodable then the implementation must return without drawing anything.\n\nwhere \"fully decodable\" is defined as:\n\n  When an img element is in the completely available state and the user agent\n  can completely decode the media data without errors, then the img element is\n  said to be fully decodable.\n\nand \"Completely available\" is defined as:\n\n  The user agent has obtained all of the image data.\n\nwhereas the test we use internally is:\n\n  (status & imgIRequest::STATUS_LOAD_COMPLETE) == 0\n\nwhich is not true for an mjpeg while a new frame is loading.... so if frames are coming down the wire continuously, this will never test true.", "author": "bzbarsky@mit.edu", "creation_time": "2011-06-26T15:11:16Z", "raw_text": "This is a different situation from the animated gif situation.\n\nThe issue here is that the spec says:\n\n  If the image argument is an HTMLImageElement object that is not fully\n  decodable then the implementation must return without drawing anything.\n\nwhere \"fully decodable\" is defined as:\n\n  When an img element is in the completely available state and the user agent\n  can completely decode the media data without errors, then the img element is\n  said to be fully decodable.\n\nand \"Completely available\" is defined as:\n\n  The user agent has obtained all of the image data.\n\nwhereas the test we use internally is:\n\n  (status & imgIRequest::STATUS_LOAD_COMPLETE) == 0\n\nwhich is not true for an mjpeg while a new frame is loading.... so if frames are coming down the wire continuously, this will never test true.", "attachment_id": null, "id": 5557115}]}}, "comments": {}}