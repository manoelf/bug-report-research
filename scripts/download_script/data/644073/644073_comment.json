{"comments": {}, "bugs": {"644073": {"comments": [{"author": "ehsan.akhgari@gmail.com", "attachment_id": null, "bug_id": 644073, "count": 0, "time": "2011-03-23T07:49:08Z", "tags": [], "creator": "ehsan.akhgari@gmail.com", "raw_text": "The OS X leaks tool tells me that we're leaking a shader here:\n\nCall stack: [thread 0x7fff7110eca0]: | start | main | XRE_main | nsAppStartup::Run() | nsAppShell::Run() | -[NSApplication run] | -[NSApplication nextEventMatchin\n    gMask:untilDate:inMode:dequeue:] | _DPSNextEvent | BlockUntilNextEventMatchingListInMode | ReceiveNextEventCommon | RunCurrentEventLoopInMode | CFRunLoopRunSpecific | __C\n    FRunLoopRun | __CFRunLoopDoSources0 | nsAppShell::ProcessGeckoEvents(void*) | nsBaseAppShell::NativeEventCallback() | NS_ProcessPendingEvents_P(nsIThread*, unsigned int)     | nsThread::ProcessNextEvent(int, int*) | nsRunnableMethodImpl<void (nsDocument::*)(), true>::Run() | nsDocument::DispatchContentLoadedEvents() | nsDocument::DoUnblockOnl    oad() | nsLoadGroup::RemoveRequest(nsIRequest*, nsISupports*, unsigned int) | nsDocLoader::OnStopRequest(nsIRequest*, nsISupports*, unsigned int) | nsDocLoader::DocLoader\n    IsEmpty(int) | nsDocLoader::DocLoaderIsEmpty(int) | nsDocLoader::FireOnStateChange(nsIWebProgress*, nsIRequest*, int, unsigned int) | nsWebShellWindow::OnStateChange(nsIW\n    ebProgress*, nsIRequest*, unsigned int, unsigned int) | nsXULWindow::OnChromeLoaded() | nsXULWindow::SetVisibility(int) | nsCocoaWindow::Show(int) | -[NSWindow makeKeyAnd\n    OrderFront:] | -[NSWindow orderWindow:relativeTo:] | -[NSWindow _reallyDoOrderWindow:relativeTo:findKey:forCounter:force:isModal:] | -[NSView displayIfNeeded] | -[NSView     _displayRectIgnoringOpacity:isVisibleRect:rectIsVisibleRectForView:] | -[NSThemeFrame _recursiveDisplayRectIfNeededIgnoringOpacity:isVisibleRect:rectIsVisibleRectForView:\n    topView:] | -[NSView _recursiveDisplayRectIfNeededIgnoringOpacity:isVisibleRect:rectIsVisibleRectForView:topView:] | -[NSView _recursiveDisplayAllDirtyWithLockFocus:visRe\n    ct:] | -[NSView _recursiveDisplayAllDirtyWithLockFocus:visRect:] | -[NSView _recursiveDisplayAllDirtyWithLockFocus:visRect:] | -[NSView _drawRect:clip:] | -[ChildView dra    wRect:] | -[ChildView drawRect:inContext:] | nsBaseWidget::GetLayerManager(nsIWidget_MOZILLA_2_0_BRANCH::LayerManagerPersistence, bool*) | mozilla::layers::LayerManagerOG    L::Initialize(nsRefPtr<mozilla::gl::GLContext>) | mozilla::layers::ColorTextureLayerProgram::Initialize(char const*, char const*) | mozilla::layers::LayerManagerOGLProgra    m::CreateProgram(char const*, char const*) | glCompileShaderARB_Exec | gleShaderParse | ShCompile | generateBuiltInSymbolTable(glslResources const*, TInfoSink&, TSymbolTa\n    ble*, EShLanguage) | initializeSymbolTable(TBuiltIns&, EShLanguage, TInfoSink&, glslResources const*, TSymbolTable*) | operator new(unsigned long) | malloc | malloc_zone_\n    malloc\u00b7\n\nLooking at the code, I think I believe it.  We're just bailing out if any of the two shaders have not been created successfully, which makes me think that the theory that I put in the summary field happens in practice.\n\nI'd write a patch, but I don't know what's the correct way to free this shader.", "id": 5361958, "text": "The OS X leaks tool tells me that we're leaking a shader here:\n\nCall stack: [thread 0x7fff7110eca0]: | start | main | XRE_main | nsAppStartup::Run() | nsAppShell::Run() | -[NSApplication run] | -[NSApplication nextEventMatchin\n    gMask:untilDate:inMode:dequeue:] | _DPSNextEvent | BlockUntilNextEventMatchingListInMode | ReceiveNextEventCommon | RunCurrentEventLoopInMode | CFRunLoopRunSpecific | __C\n    FRunLoopRun | __CFRunLoopDoSources0 | nsAppShell::ProcessGeckoEvents(void*) | nsBaseAppShell::NativeEventCallback() | NS_ProcessPendingEvents_P(nsIThread*, unsigned int)     | nsThread::ProcessNextEvent(int, int*) | nsRunnableMethodImpl<void (nsDocument::*)(), true>::Run() | nsDocument::DispatchContentLoadedEvents() | nsDocument::DoUnblockOnl    oad() | nsLoadGroup::RemoveRequest(nsIRequest*, nsISupports*, unsigned int) | nsDocLoader::OnStopRequest(nsIRequest*, nsISupports*, unsigned int) | nsDocLoader::DocLoader\n    IsEmpty(int) | nsDocLoader::DocLoaderIsEmpty(int) | nsDocLoader::FireOnStateChange(nsIWebProgress*, nsIRequest*, int, unsigned int) | nsWebShellWindow::OnStateChange(nsIW\n    ebProgress*, nsIRequest*, unsigned int, unsigned int) | nsXULWindow::OnChromeLoaded() | nsXULWindow::SetVisibility(int) | nsCocoaWindow::Show(int) | -[NSWindow makeKeyAnd\n    OrderFront:] | -[NSWindow orderWindow:relativeTo:] | -[NSWindow _reallyDoOrderWindow:relativeTo:findKey:forCounter:force:isModal:] | -[NSView displayIfNeeded] | -[NSView     _displayRectIgnoringOpacity:isVisibleRect:rectIsVisibleRectForView:] | -[NSThemeFrame _recursiveDisplayRectIfNeededIgnoringOpacity:isVisibleRect:rectIsVisibleRectForView:\n    topView:] | -[NSView _recursiveDisplayRectIfNeededIgnoringOpacity:isVisibleRect:rectIsVisibleRectForView:topView:] | -[NSView _recursiveDisplayAllDirtyWithLockFocus:visRe\n    ct:] | -[NSView _recursiveDisplayAllDirtyWithLockFocus:visRect:] | -[NSView _recursiveDisplayAllDirtyWithLockFocus:visRect:] | -[NSView _drawRect:clip:] | -[ChildView dra    wRect:] | -[ChildView drawRect:inContext:] | nsBaseWidget::GetLayerManager(nsIWidget_MOZILLA_2_0_BRANCH::LayerManagerPersistence, bool*) | mozilla::layers::LayerManagerOG    L::Initialize(nsRefPtr<mozilla::gl::GLContext>) | mozilla::layers::ColorTextureLayerProgram::Initialize(char const*, char const*) | mozilla::layers::LayerManagerOGLProgra    m::CreateProgram(char const*, char const*) | glCompileShaderARB_Exec | gleShaderParse | ShCompile | generateBuiltInSymbolTable(glslResources const*, TInfoSink&, TSymbolTa\n    ble*, EShLanguage) | initializeSymbolTable(TBuiltIns&, EShLanguage, TInfoSink&, glslResources const*, TSymbolTable*) | operator new(unsigned long) | malloc | malloc_zone_\n    malloc\u00b7\n\nLooking at the code, I think I believe it.  We're just bailing out if any of the two shaders have not been created successfully, which makes me think that the theory that I put in the summary field happens in practice.\n\nI'd write a patch, but I don't know what's the correct way to free this shader.", "is_private": false, "creation_time": "2011-03-23T07:49:08Z"}, {"bug_id": 644073, "tags": [], "time": "2012-01-08T08:46:19Z", "count": 1, "creator": "n.nethercote@gmail.com", "raw_text": "I'm downgrading to a MemShrink:P3 because the leak only happens in the error (shader failed to create) case.", "id": 5963706, "text": "I'm downgrading to a MemShrink:P3 because the leak only happens in the error (shader failed to create) case.", "creation_time": "2012-01-08T08:46:19Z", "is_private": false, "author": "n.nethercote@gmail.com", "attachment_id": null}]}}}