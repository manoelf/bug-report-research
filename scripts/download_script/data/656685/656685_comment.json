{"comments": {}, "bugs": {"656685": {"comments": [{"is_private": false, "tags": [], "bug_id": 656685, "creation_time": "2011-05-12T17:51:00Z", "raw_text": "User-Agent:       Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.30 Safari/534.30\nBuild Identifier: Firefox 4.0.1\n\nIt's possible to flood {local,session}Storage with data, which leads to a DoS. There seems to be no quota (however, my dom.storage.default_quota = 5120).\nMemory usage goes up to 2 GB in approx. 3 seconds on both Windows 7 and Fedora 15.\n\n\nReproducible: Always\n\nSteps to Reproduce:\nlocalStorage[\"a\"] = \"1337\";\nwhile(1) localStorage[\"a\"] += \"1337\";\n\nActual Results:  \nMemory usage goes up to 2 GB in approx. 3 seconds on both Windows 7 and Fedora 15, Firefox process needs to be killed or system stops responding.\n\n\nExpected Results:  \nDOM exception when exceeding quota.\n\nTested on: Windows 7 SP1 and Fedora 15 Beta, both with FF 4.0.1", "id": 5465995, "time": "2011-05-12T17:51:00Z", "attachment_id": null, "creator": "maciej.malecki@notimplemented.org", "author": "maciej.malecki@notimplemented.org", "count": 0, "text": "User-Agent:       Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.30 Safari/534.30\nBuild Identifier: Firefox 4.0.1\n\nIt's possible to flood {local,session}Storage with data, which leads to a DoS. There seems to be no quota (however, my dom.storage.default_quota = 5120).\nMemory usage goes up to 2 GB in approx. 3 seconds on both Windows 7 and Fedora 15.\n\n\nReproducible: Always\n\nSteps to Reproduce:\nlocalStorage[\"a\"] = \"1337\";\nwhile(1) localStorage[\"a\"] += \"1337\";\n\nActual Results:  \nMemory usage goes up to 2 GB in approx. 3 seconds on both Windows 7 and Fedora 15, Firefox process needs to be killed or system stops responding.\n\n\nExpected Results:  \nDOM exception when exceeding quota.\n\nTested on: Windows 7 SP1 and Fedora 15 Beta, both with FF 4.0.1"}, {"time": "2011-05-12T18:46:25Z", "id": 5466158, "raw_text": "Honza?", "creation_time": "2011-05-12T18:46:25Z", "bug_id": 656685, "tags": [], "is_private": false, "text": "Honza?", "count": 1, "author": "bzbarsky@mit.edu", "creator": "bzbarsky@mit.edu", "attachment_id": null}, {"creator": "honzab.moz@firemni.cz", "attachment_id": null, "count": 2, "text": "The quota is 5 MB.  The preference is in kilobytes.  With your test case it takes a very long time to reach it.\n\nAnyway, when I get to usage of about 50kB with your test case, memory is at 2,5 GB.  This is strange, looks like we don't GC or release something we should or whatever...\n\nI pushed the script to continue through the \"Non-responsive script dialog\" to see what happens:\n\non a first try (clean profile): when I got to 3,8 GB memory allocation, Firefox died completely unresponsive, 0% CPU activity.\n\non a second try (almost clean profile): I reached less memory, then Fx released it, but left unresponsive.\n\nIt deadlocks in (probably a different bug):\n \tnspr4.dll!_PR_WaitCondVar(PRThread * thread=0x007facf0, PRCondVar * cvar=0x06c4ac68, PRLock * lock=0x06c4aae8, unsigned int timeout=4294967295)  Line 204 + 0x17 bytes\t\n \tnspr4.dll!PR_WaitCondVar(PRCondVar * cvar=0x06c4ac68, unsigned int timeout=4294967295)  Line 547 + 0x17 bytes\t\n \tmozjs.dll!AutoGCSession::AutoGCSession(JSContext * cx=0x07c175f8)  Line 2598 + 0x12 bytes\t\n \tmozjs.dll!GCCycle(JSContext * cx=0x07c175f8, JSCompartment * comp=0x00000000, JSGCInvocationKind gckind=GC_NORMAL)  Line 2661\t\n \tmozjs.dll!js_GC(JSContext * cx=0x07c175f8, JSCompartment * comp=0x00000000, JSGCInvocationKind gckind=GC_NORMAL)  Line 2753 + 0x11 bytes\t\n \tmozjs.dll!JS_GC(JSContext * cx=0x07c175f8)  Line 2601 + 0xd bytes\t\n \txul.dll!nsXPConnect::Collect()  Line 406 + 0xa bytes\t\n \txul.dll!nsXPConnect::GarbageCollect()  Line 415\t\n \txul.dll!nsJSContext::GarbageCollectNow()  Line 3252\t\n \txul.dll!nsMemoryPressureObserver::Observe(nsISupports * aSubject=0x07d5edb0, const char * aTopic=0x615689e4, const wchar_t * aData=0x61568a6c)  Line 202\t\n \txul.dll!nsMemoryImpl::RunFlushers(const wchar_t * aReason=0x61568a6c)  Line 163\t\n \txul.dll!nsMemoryImpl::FlushEvent::Run()  Line 180\t\n \txul.dll!nsThread::ProcessNextEvent(int mayWait=1, int * result=0x0040d180)  Line 618 + 0x19 bytes\t\n \txul.dll!NS_ProcessNextEvent_P(nsIThread * thread=0x01dd1330, int mayWait=1)  Line 250 + 0x16 bytes\t\n \txul.dll!nsThread::Shutdown()  Line 481 + 0xb bytes\t\n \txul.dll!NS_InvokeByIndex_P(nsISupports * that=0x07c07688, unsigned int methodIndex=6, unsigned int paramCount=0, nsXPTCVariant * params=0x00000000)  Line 103\t\n \txul.dll!nsProxyObjectCallInfo::Run()  Line 182 + 0x2d bytes\t\n \txul.dll!nsThread::ProcessNextEvent(int mayWait=0, int * result=0x0040d270)  Line 618 + 0x19 bytes\t\n \txul.dll!NS_ProcessNextEvent_P(nsIThread * thread=0x01dd1330, int mayWait=0)  Line 250 + 0x16 bytes\t\n \txul.dll!mozilla::ipc::MessagePump::Run(base::MessagePump::Delegate * aDelegate=0x01dcdb30)  Line 110 + 0xe bytes\t\n \txul.dll!MessageLoop::RunInternal()  Line 219\t\n \txul.dll!MessageLoop::RunHandler()  Line 203\t\n \txul.dll!MessageLoop::Run()  Line 177\t\n \txul.dll!nsBaseAppShell::Run()  Line 191\t\n \txul.dll!nsAppShell::Run()  Line 248 + 0x9 bytes\t\n \txul.dll!nsAppStartup::Run()  Line 224 + 0x1c bytes\t\n \txul.dll!XRE_main(int argc=3, char * * argv=0x01dc3ca0, const nsXREAppData * aAppData=0x01dc4480)  Line 3698 + 0x25 bytes\t\n\n\nI'll look deeper into this tomorrow.  This is a very interesting bug.", "author": "honzab.moz@firemni.cz", "creation_time": "2011-05-12T20:23:20Z", "bug_id": 656685, "raw_text": "The quota is 5 MB.  The preference is in kilobytes.  With your test case it takes a very long time to reach it.\n\nAnyway, when I get to usage of about 50kB with your test case, memory is at 2,5 GB.  This is strange, looks like we don't GC or release something we should or whatever...\n\nI pushed the script to continue through the \"Non-responsive script dialog\" to see what happens:\n\non a first try (clean profile): when I got to 3,8 GB memory allocation, Firefox died completely unresponsive, 0% CPU activity.\n\non a second try (almost clean profile): I reached less memory, then Fx released it, but left unresponsive.\n\nIt deadlocks in (probably a different bug):\n \tnspr4.dll!_PR_WaitCondVar(PRThread * thread=0x007facf0, PRCondVar * cvar=0x06c4ac68, PRLock * lock=0x06c4aae8, unsigned int timeout=4294967295)  Line 204 + 0x17 bytes\t\n \tnspr4.dll!PR_WaitCondVar(PRCondVar * cvar=0x06c4ac68, unsigned int timeout=4294967295)  Line 547 + 0x17 bytes\t\n \tmozjs.dll!AutoGCSession::AutoGCSession(JSContext * cx=0x07c175f8)  Line 2598 + 0x12 bytes\t\n \tmozjs.dll!GCCycle(JSContext * cx=0x07c175f8, JSCompartment * comp=0x00000000, JSGCInvocationKind gckind=GC_NORMAL)  Line 2661\t\n \tmozjs.dll!js_GC(JSContext * cx=0x07c175f8, JSCompartment * comp=0x00000000, JSGCInvocationKind gckind=GC_NORMAL)  Line 2753 + 0x11 bytes\t\n \tmozjs.dll!JS_GC(JSContext * cx=0x07c175f8)  Line 2601 + 0xd bytes\t\n \txul.dll!nsXPConnect::Collect()  Line 406 + 0xa bytes\t\n \txul.dll!nsXPConnect::GarbageCollect()  Line 415\t\n \txul.dll!nsJSContext::GarbageCollectNow()  Line 3252\t\n \txul.dll!nsMemoryPressureObserver::Observe(nsISupports * aSubject=0x07d5edb0, const char * aTopic=0x615689e4, const wchar_t * aData=0x61568a6c)  Line 202\t\n \txul.dll!nsMemoryImpl::RunFlushers(const wchar_t * aReason=0x61568a6c)  Line 163\t\n \txul.dll!nsMemoryImpl::FlushEvent::Run()  Line 180\t\n \txul.dll!nsThread::ProcessNextEvent(int mayWait=1, int * result=0x0040d180)  Line 618 + 0x19 bytes\t\n \txul.dll!NS_ProcessNextEvent_P(nsIThread * thread=0x01dd1330, int mayWait=1)  Line 250 + 0x16 bytes\t\n \txul.dll!nsThread::Shutdown()  Line 481 + 0xb bytes\t\n \txul.dll!NS_InvokeByIndex_P(nsISupports * that=0x07c07688, unsigned int methodIndex=6, unsigned int paramCount=0, nsXPTCVariant * params=0x00000000)  Line 103\t\n \txul.dll!nsProxyObjectCallInfo::Run()  Line 182 + 0x2d bytes\t\n \txul.dll!nsThread::ProcessNextEvent(int mayWait=0, int * result=0x0040d270)  Line 618 + 0x19 bytes\t\n \txul.dll!NS_ProcessNextEvent_P(nsIThread * thread=0x01dd1330, int mayWait=0)  Line 250 + 0x16 bytes\t\n \txul.dll!mozilla::ipc::MessagePump::Run(base::MessagePump::Delegate * aDelegate=0x01dcdb30)  Line 110 + 0xe bytes\t\n \txul.dll!MessageLoop::RunInternal()  Line 219\t\n \txul.dll!MessageLoop::RunHandler()  Line 203\t\n \txul.dll!MessageLoop::Run()  Line 177\t\n \txul.dll!nsBaseAppShell::Run()  Line 191\t\n \txul.dll!nsAppShell::Run()  Line 248 + 0x9 bytes\t\n \txul.dll!nsAppStartup::Run()  Line 224 + 0x1c bytes\t\n \txul.dll!XRE_main(int argc=3, char * * argv=0x01dc3ca0, const nsXREAppData * aAppData=0x01dc4480)  Line 3698 + 0x25 bytes\t\n\n\nI'll look deeper into this tomorrow.  This is a very interesting bug.", "tags": [], "is_private": false, "time": "2011-05-12T20:23:20Z", "id": 5466409}, {"creator": "bzbarsky@mit.edu", "tags": [], "raw_text": "Hmm.  I would fully expect us to generate garbage for all those intermediate strings.  In particular, growing at 5 chars each time (10 bytes, I assume) to get up to 50KB requires 5,000 sets.\n\nThat means we should generate about 10,000 strings (each += generates a string on get and another string on concatenate+set) of average length 2,500 chars or 5000 bytes, for a total of 50,000,000 bytes.... which is a long shot away from a few gigabytes.  Would be interesting to see why we're using so much more memory than that.", "creation_time": "2011-05-12T20:42:51Z", "bug_id": 656685, "is_private": false, "attachment_id": null, "text": "Hmm.  I would fully expect us to generate garbage for all those intermediate strings.  In particular, growing at 5 chars each time (10 bytes, I assume) to get up to 50KB requires 5,000 sets.\n\nThat means we should generate about 10,000 strings (each += generates a string on get and another string on concatenate+set) of average length 2,500 chars or 5000 bytes, for a total of 50,000,000 bytes.... which is a long shot away from a few gigabytes.  Would be interesting to see why we're using so much more memory than that.", "count": 3, "id": 5466475, "author": "bzbarsky@mit.edu", "time": "2011-05-12T20:42:51Z"}, {"is_private": false, "bug_id": 656685, "creation_time": "2011-05-12T23:59:02Z", "raw_text": "I checked out nsStorage2SH::GetProperty and, based on the JS_NewUCStringCopyN, we will not be accumulating a giant rope.  My guess is that perhaps we have a leak and thus we are keeping alive all the old strings?", "tags": [], "time": "2011-05-12T23:59:02Z", "id": 5467076, "attachment_id": null, "creator": "mail@lukewagner.name", "author": "mail@lukewagner.name", "count": 4, "text": "I checked out nsStorage2SH::GetProperty and, based on the JS_NewUCStringCopyN, we will not be accumulating a giant rope.  My guess is that perhaps we have a leak and thus we are keeping alive all the old strings?"}, {"attachment_id": null, "creator": "bzbarsky@mit.edu", "author": "bzbarsky@mit.edu", "text": "Even if we were, it seems to me that unless I miscounted in comment 3 the _total_ allocations should be only 50MB.", "count": 5, "is_private": false, "tags": [], "bug_id": 656685, "creation_time": "2011-05-13T01:06:18Z", "raw_text": "Even if we were, it seems to me that unless I miscounted in comment 3 the _total_ allocations should be only 50MB.", "id": 5467182, "time": "2011-05-13T01:06:18Z"}, {"attachment_id": null, "creator": "mail@lukewagner.name", "author": "mail@lukewagner.name", "text": "My guess in comment 4 was that, if every intermediate string (every result of a set) was accidentally being rooted but (perhaps due to the same bug) not counted in the quota, then we'd have quadratic total space growth which could produce the explosive numbers in comment 2.", "count": 6, "is_private": false, "tags": [], "bug_id": 656685, "creation_time": "2011-05-13T02:29:57Z", "raw_text": "My guess in comment 4 was that, if every intermediate string (every result of a set) was accidentally being rooted but (perhaps due to the same bug) not counted in the quota, then we'd have quadratic total space growth which could produce the explosive numbers in comment 2.", "id": 5467307, "time": "2011-05-13T02:29:57Z"}, {"creation_time": "2011-05-13T02:34:51Z", "bug_id": 656685, "raw_text": "Sure; I'm positing quadratic growth, but comment 2 says that we get to 2.5GB of heap when the string length is only 50KB...", "tags": [], "creator": "bzbarsky@mit.edu", "is_private": false, "attachment_id": null, "text": "Sure; I'm positing quadratic growth, but comment 2 says that we get to 2.5GB of heap when the string length is only 50KB...", "count": 7, "time": "2011-05-13T02:34:51Z", "author": "bzbarsky@mit.edu", "id": 5467318}, {"id": 5467343, "time": "2011-05-13T03:02:57Z", "is_private": false, "tags": [], "creation_time": "2011-05-13T03:02:57Z", "bug_id": 656685, "raw_text": "setting localStorage is going to write to mozstorage. It's unlikely to be javascript string memory but leaked mozstorage or sqlite objects would have much more overhead and might be what we're seeing.", "author": "dveditz@mozilla.com", "count": 8, "text": "setting localStorage is going to write to mozstorage. It's unlikely to be javascript string memory but leaked mozstorage or sqlite objects would have much more overhead and might be what we're seeing.", "attachment_id": null, "creator": "dveditz@mozilla.com"}, {"creator": "n.nethercote@gmail.com", "attachment_id": 532114, "count": 9, "text": "Created attachment 532114\nHTML test file\n\nHere's the exact test file I used for a Massif run (results shortly).  When not running under Massif I got much worse than quadratic behaviour -- eg. doing 14000 iterations took a few seconds, but 25000 iterations took long enough that I killed Firefox.  Maybe this was due to paging, though.", "author": "n.nethercote@gmail.com", "tags": [], "raw_text": "Here's the exact test file I used for a Massif run (results shortly).  When not running under Massif I got much worse than quadratic behaviour -- eg. doing 14000 iterations took a few seconds, but 25000 iterations took long enough that I killed Firefox.  Maybe this was due to paging, though.", "bug_id": 656685, "creation_time": "2011-05-13T03:57:45Z", "is_private": false, "id": 5467420, "time": "2011-05-13T03:57:45Z"}, {"is_private": false, "raw_text": "You can see from Massif's graph that the memory usage spikes enormously but\nthen drops again very quickly.  This matched what I saw just when I was\nwatching 'top':\n\n    GB\n4.303^                                                       #                \n     |                                                       #::              \n     |                                                      @#:               \n     |                                                      @#:               \n     |                                                    ::@#:               \n     |                                                  @@: @#: :             \n     |                                                  @ : @#: :             \n     |                                                  @ : @#: :             \n     |                                                 :@ : @#: :             \n     |                                              @@::@ : @#: :             \n     |                                              @ ::@ : @#: :             \n     |                                              @ ::@ : @#: :             \n     |                                             :@ ::@ : @#: :             \n     |                                           @@:@ ::@ : @#: :             \n     |                                           @ :@ ::@ : @#: :             \n     |                                          @@ :@ ::@ : @#: :             \n     |                                         @@@ :@ ::@ : @#: :        :::: \n     |                                         @@@ :@ ::@ : @#: :::::::::: :@ \n     |                 @::@:::@::::::::::@:::@@@@@ :@ ::@ : @#: :: :  : :: :@@\n     |         @:::::@:@: @:: @: :: ::: :@: :@ @@@ :@ ::@ : @#: :: :  : :: :@@\n   0 +----------------------------------------------------------------------->s\n     0                                                                   92.40\n\nThe peak snapshot was #39 (search for \"^ 39\" in the file).  It's definitely\nstring-related.  The top-level culprits:\n\no1o> 55.14% (2,547,972,408B): nsStringBuffer::Alloc() (nsSubstring.cpp:209)\no1o> 18.41% (850,436,732B): JSRope::flatten() (jsutil.h:239)\no1o> 13.76% (635,982,888B): js_NewStringCopyN() (jsutil.h:239)\n\nLook at the file for the detailed call stacks.  I'm not sure what to make of\nthem, but nsStorage2SH::SetProperty and nsStorage2SH::GetProperty look very\nguilty.  Maybe putting some logging code into them will be instructive?", "bug_id": 656685, "creation_time": "2011-05-13T04:04:06Z", "tags": [], "time": "2011-05-13T04:04:06Z", "id": 5467426, "attachment_id": 532115, "creator": "n.nethercote@gmail.com", "author": "n.nethercote@gmail.com", "text": "Created attachment 532115\nMassif results\n\nYou can see from Massif's graph that the memory usage spikes enormously but\nthen drops again very quickly.  This matched what I saw just when I was\nwatching 'top':\n\n    GB\n4.303^                                                       #                \n     |                                                       #::              \n     |                                                      @#:               \n     |                                                      @#:               \n     |                                                    ::@#:               \n     |                                                  @@: @#: :             \n     |                                                  @ : @#: :             \n     |                                                  @ : @#: :             \n     |                                                 :@ : @#: :             \n     |                                              @@::@ : @#: :             \n     |                                              @ ::@ : @#: :             \n     |                                              @ ::@ : @#: :             \n     |                                             :@ ::@ : @#: :             \n     |                                           @@:@ ::@ : @#: :             \n     |                                           @ :@ ::@ : @#: :             \n     |                                          @@ :@ ::@ : @#: :             \n     |                                         @@@ :@ ::@ : @#: :        :::: \n     |                                         @@@ :@ ::@ : @#: :::::::::: :@ \n     |                 @::@:::@::::::::::@:::@@@@@ :@ ::@ : @#: :: :  : :: :@@\n     |         @:::::@:@: @:: @: :: ::: :@: :@ @@@ :@ ::@ : @#: :: :  : :: :@@\n   0 +----------------------------------------------------------------------->s\n     0                                                                   92.40\n\nThe peak snapshot was #39 (search for \"^ 39\" in the file).  It's definitely\nstring-related.  The top-level culprits:\n\no1o> 55.14% (2,547,972,408B): nsStringBuffer::Alloc() (nsSubstring.cpp:209)\no1o> 18.41% (850,436,732B): JSRope::flatten() (jsutil.h:239)\no1o> 13.76% (635,982,888B): js_NewStringCopyN() (jsutil.h:239)\n\nLook at the file for the detailed call stacks.  I'm not sure what to make of\nthem, but nsStorage2SH::SetProperty and nsStorage2SH::GetProperty look very\nguilty.  Maybe putting some logging code into them will be instructive?", "count": 10}, {"id": 5467450, "time": "2011-05-13T04:35:03Z", "tags": [], "creation_time": "2011-05-13T04:35:03Z", "bug_id": 656685, "raw_text": "In nsDOMStorageEvent::InitStorageEvent the key string, old data string, and new data string all get assigned... does that make a copy of the strings?  And a similar question for nsDOMStorageItem::SetValue.\n\nIn my example there are 784,000,000 bytes of string values that get set.  If each one is copied a few times unnecessarily, that would get up to multiple GC quickly.", "is_private": false, "text": "In nsDOMStorageEvent::InitStorageEvent the key string, old data string, and new data string all get assigned... does that make a copy of the strings?  And a similar question for nsDOMStorageItem::SetValue.\n\nIn my example there are 784,000,000 bytes of string values that get set.  If each one is copied a few times unnecessarily, that would get up to multiple GC quickly.", "count": 11, "author": "n.nethercote@gmail.com", "creator": "n.nethercote@gmail.com", "attachment_id": null}, {"time": "2011-05-13T04:37:04Z", "id": 5467452, "is_private": false, "raw_text": "(In reply to comment #11)\n> that would get up to multiple GC quickly.\n\nI meant \"multiple GB\", of course.", "bug_id": 656685, "creation_time": "2011-05-13T04:37:04Z", "tags": [], "author": "n.nethercote@gmail.com", "text": "(In reply to comment #11)\n> that would get up to multiple GC quickly.\n\nI meant \"multiple GB\", of course.", "count": 12, "attachment_id": null, "creator": "n.nethercote@gmail.com"}, {"id": 5467480, "time": "2011-05-13T05:06:25Z", "tags": [], "raw_text": "> does that make a copy of the strings? \n\nAt least for the new data string, I believe it does, since the incoming string is a JSString in disguise.  See bug 585656.\n\nIt looks like under nsDOMStorage::SetItem we actually copy twice: once for the event and once for the actual set in the storage.  The latter I would think goes away pretty quickly, though (on the very next set).... except the next event will hold on to it.  So we are in fact creating two copies of the string there.  We can avoid that by just creating an nsString for the given nsAString up front in SetItem and then passing _that_ down to both BroadcastChangeNotification and SetValue.\n\nThere's not much we can do about the JSRope::flatten.\n\nFor the js_NewStringCopyN, nsStorage2SH::GetProperty should just be using our normal XPConnect string-to-JSString conversion stuff instead of copying.  Taht would create an external string.\n\nAll of this would reduce memory usage by 3x, which is nice and we should do it but doesn't solve the real problem.  The real problem is that there's an event for each change and they can't go away until that script finishes running.  Honza, does the spec really require us to queue up all those events?  Can we just start dropping them on the floor?", "creation_time": "2011-05-13T05:06:25Z", "bug_id": 656685, "is_private": false, "count": 13, "text": "> does that make a copy of the strings? \n\nAt least for the new data string, I believe it does, since the incoming string is a JSString in disguise.  See bug 585656.\n\nIt looks like under nsDOMStorage::SetItem we actually copy twice: once for the event and once for the actual set in the storage.  The latter I would think goes away pretty quickly, though (on the very next set).... except the next event will hold on to it.  So we are in fact creating two copies of the string there.  We can avoid that by just creating an nsString for the given nsAString up front in SetItem and then passing _that_ down to both BroadcastChangeNotification and SetValue.\n\nThere's not much we can do about the JSRope::flatten.\n\nFor the js_NewStringCopyN, nsStorage2SH::GetProperty should just be using our normal XPConnect string-to-JSString conversion stuff instead of copying.  Taht would create an external string.\n\nAll of this would reduce memory usage by 3x, which is nice and we should do it but doesn't solve the real problem.  The real problem is that there's an event for each change and they can't go away until that script finishes running.  Honza, does the spec really require us to queue up all those events?  Can we just start dropping them on the floor?", "author": "bzbarsky@mit.edu", "creator": "bzbarsky@mit.edu", "attachment_id": null}, {"time": "2011-05-13T05:07:58Z", "id": 5467481, "bug_id": 656685, "creation_time": "2011-05-13T05:07:58Z", "raw_text": "It looks like the spec in fact requires that all those events exist.  We need to get that fixed, imo.", "tags": [], "is_private": false, "count": 14, "text": "It looks like the spec in fact requires that all those events exist.  We need to get that fixed, imo.", "author": "bzbarsky@mit.edu", "creator": "bzbarsky@mit.edu", "attachment_id": null}, {"time": "2011-05-13T10:40:16Z", "id": 5467787, "bug_id": 656685, "creation_time": "2011-05-13T10:40:16Z", "raw_text": "(In reply to comment #13)\n> \n> For the js_NewStringCopyN, nsStorage2SH::GetProperty should just be using\n> our normal XPConnect string-to-JSString conversion stuff instead of copying.\n> That would create an external string.\n\nMight there be other places where the same mistake is made?  Is there a way to detect them?", "tags": [], "is_private": false, "text": "(In reply to comment #13)\n> \n> For the js_NewStringCopyN, nsStorage2SH::GetProperty should just be using\n> our normal XPConnect string-to-JSString conversion stuff instead of copying.\n> That would create an external string.\n\nMight there be other places where the same mistake is made?  Is there a way to detect them?", "count": 15, "author": "n.nethercote@gmail.com", "creator": "n.nethercote@gmail.com", "attachment_id": null}, {"time": "2011-05-13T14:33:14Z", "id": 5468127, "bug_id": 656685, "creation_time": "2011-05-13T14:33:14Z", "raw_text": "I did some research using VC++ tracepoints in moz_alloc and moz_free, I have following stacks to actually prove boris' theory about the event not being released until the script exits:\n\n>>> called 43 times, bytes total 3928566\n\txul.dll!nsStringBuffer::Alloc() \n\txul.dll!nsAString_internal::MutatePrep() \n\txul.dll!nsAString_internal::ReplacePrepInternal() \n\txul.dll!nsAString_internal::ReplacePrep() \n\txul.dll!nsAString_internal::Assign() \n\txul.dll!nsAString_internal::Assign() \n\txul.dll!nsString::operator=() \n\txul.dll!nsDOMStorageItem::SetValueInternal() \n\txul.dll!DOMStorageImpl::SetValue() \n\txul.dll!nsDOMStorage::SetItem() \n\txul.dll!nsDOMStorage2::SetItem() \n\txul.dll!nsStorage2SH::SetProperty() \n\txul.dll!XPC_WN_Helper_SetProperty() \n\tmozjs.dll!js::CallJSPropertyOpSetter() \n\n>>> called 86 times, bytes total 3929082 (looks like this can be split to 43 allocations of 12 bytes and large rest)\n\txul.dll!nsStringBuffer::Alloc() \n\txul.dll!nsAString_internal::MutatePrep() \n\txul.dll!nsAString_internal::ReplacePrepInternal() \n\txul.dll!nsAString_internal::ReplacePrep() \n\txul.dll!nsAString_internal::Assign() \n\txul.dll!nsAString_internal::Assign() \n\txul.dll!nsString::operator=() \n\txul.dll!nsDOMStorageEvent::InitStorageEvent() \n\txul.dll!nsDOMStorage2::BroadcastChangeNotification() \n\txul.dll!nsDOMStorage::SetItem() \n\txul.dll!nsDOMStorage2::SetItem() \n\txul.dll!nsStorage2SH::SetProperty() \n\txul.dll!XPC_WN_Helper_SetProperty() \n\tmozjs.dll!js::CallJSPropertyOpSetter() \n\nI will attach the complete list of stacks I captured during a short period.", "tags": [], "is_private": false, "text": "I did some research using VC++ tracepoints in moz_alloc and moz_free, I have following stacks to actually prove boris' theory about the event not being released until the script exits:\n\n>>> called 43 times, bytes total 3928566\n\txul.dll!nsStringBuffer::Alloc() \n\txul.dll!nsAString_internal::MutatePrep() \n\txul.dll!nsAString_internal::ReplacePrepInternal() \n\txul.dll!nsAString_internal::ReplacePrep() \n\txul.dll!nsAString_internal::Assign() \n\txul.dll!nsAString_internal::Assign() \n\txul.dll!nsString::operator=() \n\txul.dll!nsDOMStorageItem::SetValueInternal() \n\txul.dll!DOMStorageImpl::SetValue() \n\txul.dll!nsDOMStorage::SetItem() \n\txul.dll!nsDOMStorage2::SetItem() \n\txul.dll!nsStorage2SH::SetProperty() \n\txul.dll!XPC_WN_Helper_SetProperty() \n\tmozjs.dll!js::CallJSPropertyOpSetter() \n\n>>> called 86 times, bytes total 3929082 (looks like this can be split to 43 allocations of 12 bytes and large rest)\n\txul.dll!nsStringBuffer::Alloc() \n\txul.dll!nsAString_internal::MutatePrep() \n\txul.dll!nsAString_internal::ReplacePrepInternal() \n\txul.dll!nsAString_internal::ReplacePrep() \n\txul.dll!nsAString_internal::Assign() \n\txul.dll!nsAString_internal::Assign() \n\txul.dll!nsString::operator=() \n\txul.dll!nsDOMStorageEvent::InitStorageEvent() \n\txul.dll!nsDOMStorage2::BroadcastChangeNotification() \n\txul.dll!nsDOMStorage::SetItem() \n\txul.dll!nsDOMStorage2::SetItem() \n\txul.dll!nsStorage2SH::SetProperty() \n\txul.dll!XPC_WN_Helper_SetProperty() \n\tmozjs.dll!js::CallJSPropertyOpSetter() \n\nI will attach the complete list of stacks I captured during a short period.", "count": 16, "author": "honzab.moz@firemni.cz", "creator": "honzab.moz@firemni.cz", "attachment_id": null}, {"id": 5468131, "time": "2011-05-13T14:35:17Z", "tags": [], "raw_text": "", "creation_time": "2011-05-13T14:35:17Z", "bug_id": 656685, "is_private": false, "count": 17, "text": "Created attachment 532223\nList of allocation stacks not released during the script run", "author": "honzab.moz@firemni.cz", "creator": "honzab.moz@firemni.cz", "attachment_id": 532223}, {"time": "2011-05-13T14:52:02Z", "author": "bzbarsky@mit.edu", "id": 5468166, "count": 18, "text": "> Might there be other places where the same mistake is made?\n\nYes, but only in places where people hand-write JS bindings (i.e. in nsIXPCScriptable callbacks like here or in places where jsval return values or out params are used).", "attachment_id": null, "is_private": false, "creation_time": "2011-05-13T14:52:02Z", "bug_id": 656685, "raw_text": "> Might there be other places where the same mistake is made?\n\nYes, but only in places where people hand-write JS bindings (i.e. in nsIXPCScriptable callbacks like here or in places where jsval return values or out params are used).", "tags": [], "creator": "bzbarsky@mit.edu"}, {"attachment_id": null, "is_private": false, "bug_id": 656685, "creation_time": "2011-05-13T15:08:29Z", "raw_text": "(In reply to comment #13)\n> We can avoid that by just creating an nsString for the given\n> nsAString up front in SetItem and then passing _that_ down to both\n> BroadcastChangeNotification and SetValue.\n\nWith this change I can reach 90kB of the storage usage while allocating 2,5 GB.  So a bit better, but not a solution.  I can see the new buffer for that string still unreleased.\n\nLooks like we need to limit the number of events or coalesce them to a single one until it is posted, that event would say OLD=\"\" NEW=\"the horribly long new string\".  I can try to have a patch for this.", "tags": [], "creator": "honzab.moz@firemni.cz", "time": "2011-05-13T15:08:29Z", "author": "honzab.moz@firemni.cz", "id": 5468213, "text": "(In reply to comment #13)\n> We can avoid that by just creating an nsString for the given\n> nsAString up front in SetItem and then passing _that_ down to both\n> BroadcastChangeNotification and SetValue.\n\nWith this change I can reach 90kB of the storage usage while allocating 2,5 GB.  So a bit better, but not a solution.  I can see the new buffer for that string still unreleased.\n\nLooks like we need to limit the number of events or coalesce them to a single one until it is posted, that event would say OLD=\"\" NEW=\"the horribly long new string\".  I can try to have a patch for this.", "count": 19}, {"is_private": false, "creation_time": "2011-05-13T15:15:45Z", "bug_id": 656685, "raw_text": "I don't believe the spec allows either of those behaviors.  We really need a spec change here.\n\nI also still don't understand why your allocations are an order of magnitude more than my calculation.  And also, since the allocation amount should be _quadratic_ in storage usage, halving allocations should not have allowed us to get to twice the storage usage....", "tags": [], "time": "2011-05-13T15:15:45Z", "id": 5468231, "attachment_id": null, "creator": "bzbarsky@mit.edu", "author": "bzbarsky@mit.edu", "text": "I don't believe the spec allows either of those behaviors.  We really need a spec change here.\n\nI also still don't understand why your allocations are an order of magnitude more than my calculation.  And also, since the allocation amount should be _quadratic_ in storage usage, halving allocations should not have allowed us to get to twice the storage usage....", "count": 20}, {"creator": "n.nethercote@gmail.com", "attachment_id": null, "text": "How does the fix for bug 656878 affect this?", "count": 21, "author": "n.nethercote@gmail.com", "tags": [], "creation_time": "2011-05-14T05:27:57Z", "bug_id": 656685, "raw_text": "How does the fix for bug 656878 affect this?", "is_private": false, "id": 5469865, "time": "2011-05-14T05:27:57Z"}, {"tags": [], "raw_text": "It just shows what the code in nsStorage2SH::GetProperty should look like to avoid the js_NewStringCopyN.", "creation_time": "2011-05-14T05:44:53Z", "bug_id": 656685, "is_private": false, "id": 5469876, "time": "2011-05-14T05:44:53Z", "creator": "bzbarsky@mit.edu", "attachment_id": null, "text": "It just shows what the code in nsStorage2SH::GetProperty should look like to avoid the js_NewStringCopyN.", "count": 22, "author": "bzbarsky@mit.edu"}, {"author": "jaas@kflag.net", "count": 23, "text": "Is there any reason to keep this hidden? This seems like a useful discussion to have public.", "attachment_id": null, "creator": "jaas@kflag.net", "time": "2012-03-05T04:54:26Z", "id": 6113506, "is_private": false, "bug_id": 656685, "creation_time": "2012-03-05T04:54:26Z", "raw_text": "Is there any reason to keep this hidden? This seems like a useful discussion to have public.", "tags": []}]}}}