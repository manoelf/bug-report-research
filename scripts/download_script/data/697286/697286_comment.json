{"comments": {}, "bugs": {"697286": {"comments": [{"id": 5804642, "tags": [], "count": 0, "is_private": false, "bug_id": 697286, "raw_text": "Right now most of our GCs are triggered by timers. I think this is good. However, these GCs only fire if we're allocating GC things (they don't run unless a new chunk has been allocated since the last GC) or if the CC found some objects to unlink.\n\nHowever, someone reported a bug to me recently where a bunch of canvas objects get allocated. We need a GC followed by a CC to deallocate them. But we never GC because no JS stuff gets allocated. We should have caught this via malloc counters, but they're not used in this case.\n\nThe immediate way to fix this bug is to call updateMallocCounter when the canvas is allocated. However, problems like this are going to continue to surface because it's so easy to forget updateMallocCounter.\n\nSo I'm thinking that a better way to do this is to GC every 10 or 20 seconds as long as the browser is active. I'm thinking that we can decide whether the browser is active by checking if the ScriptEvaluated callback has happened since the last GC. I'm a bit worried that ScriptEvaluated just gets called constantly, but I'll look into it.\n\nAt the same time, I think this would be a good opportunity to start triggering compartmental GCs from timers. The hard part is deciding which compartment to GC, and whether to do a full GC or not. Maybe we could see what compartments we executed scripts in since the last GC, and collect those. This would require us to be able to GC multiple compartments during a compartment GC, but that should be pretty easy.\n\nOne important factor is the interaction with the cycle collector. I might be mistaken, but I think this interaction is pretty messed up right now: if we do a compartment GC followed by a CC, then the CC will see objects in non-collected compartments as white. This is okay, because it will just ignore them. But it sucks.\n\nOne way to fix this would be to clear the mark bits only for compartments being collected. I think this is sound, but I'm not sure. (We need to know if UnmarkGray still protects us even if there's an intervening GC.) Another way is to make sure that we still do enough full GCs that CCs will be effective. The latter solution is definitely less appealing.\n\nA final consideration is that we need an occasional full GC to clear out the cross compartment wrapper map. Eventually, we might be able to clean this up with the cycle collector.", "creation_time": "2011-10-25T22:29:31Z", "author": "bill.mccloskey@gmail.com", "attachment_id": null, "time": "2011-10-25T22:29:31Z", "creator": "bill.mccloskey@gmail.com", "text": "Right now most of our GCs are triggered by timers. I think this is good. However, these GCs only fire if we're allocating GC things (they don't run unless a new chunk has been allocated since the last GC) or if the CC found some objects to unlink.\n\nHowever, someone reported a bug to me recently where a bunch of canvas objects get allocated. We need a GC followed by a CC to deallocate them. But we never GC because no JS stuff gets allocated. We should have caught this via malloc counters, but they're not used in this case.\n\nThe immediate way to fix this bug is to call updateMallocCounter when the canvas is allocated. However, problems like this are going to continue to surface because it's so easy to forget updateMallocCounter.\n\nSo I'm thinking that a better way to do this is to GC every 10 or 20 seconds as long as the browser is active. I'm thinking that we can decide whether the browser is active by checking if the ScriptEvaluated callback has happened since the last GC. I'm a bit worried that ScriptEvaluated just gets called constantly, but I'll look into it.\n\nAt the same time, I think this would be a good opportunity to start triggering compartmental GCs from timers. The hard part is deciding which compartment to GC, and whether to do a full GC or not. Maybe we could see what compartments we executed scripts in since the last GC, and collect those. This would require us to be able to GC multiple compartments during a compartment GC, but that should be pretty easy.\n\nOne important factor is the interaction with the cycle collector. I might be mistaken, but I think this interaction is pretty messed up right now: if we do a compartment GC followed by a CC, then the CC will see objects in non-collected compartments as white. This is okay, because it will just ignore them. But it sucks.\n\nOne way to fix this would be to clear the mark bits only for compartments being collected. I think this is sound, but I'm not sure. (We need to know if UnmarkGray still protects us even if there's an intervening GC.) Another way is to make sure that we still do enough full GCs that CCs will be effective. The latter solution is definitely less appealing.\n\nA final consideration is that we need an occasional full GC to clear out the cross compartment wrapper map. Eventually, we might be able to clean this up with the cycle collector."}, {"creator": "gal@uci.edu", "author": "gal@uci.edu", "raw_text": "We have to make sure we don't cause long pause times. We tried a similar strategy before and it was messing with flash videos playing.", "creation_time": "2011-10-25T22:32:56Z", "text": "We have to make sure we don't cause long pause times. We tried a similar strategy before and it was messing with flash videos playing.", "time": "2011-10-25T22:32:56Z", "attachment_id": null, "count": 1, "is_private": false, "tags": [], "id": 5804650, "bug_id": 697286}, {"text": "(In reply to Bill McCloskey (:billm) from comment #0) \n> The immediate way to fix this bug is to call updateMallocCounter when the\n> canvas is allocated. However, problems like this are going to continue to\n> surface because it's so easy to forget updateMallocCounter.\n\nOther option is to tweak CC/GC handling in nsJSEnvironment.cpp.\nRight now if after running a task there are >1000 suspected CC objects, we\nmay trigger CC. Then, if the CC has run one or more times, and CC has collected >250 object,\nyet GC hasn't run, we trigger GC.\nThese numbers are sort of random, though they worked reasonable well with certain testcases.\nMaybe CC should collect the size of suspected and/or collected objects, and we wouldn't \nrely on the number of objects, but size.\n\n\n> At the same time, I think this would be a good opportunity to start\n> triggering compartmental GCs from timers. The hard part is deciding which\n> compartment to GC, and whether to do a full GC or not. Maybe we could see\n> what compartments we executed scripts in since the last GC, and collect\n> those. This would require us to be able to GC multiple compartments during a\n> compartment GC, but that should be pretty easy.\nIt would be better to run GC for different compartments in different tasks.\nSo there could be a queue of compartments which need GC, and an interval timer active as long\nas the queue is not empty. The timer would then call compartment timer. (Full GC should clear the queue.)\n\n\n> One important factor is the interaction with the cycle collector. I might be\n> mistaken, but I think this interaction is pretty messed up right now: if we\n> do a compartment GC followed by a CC, then the CC will see objects in\n> non-collected compartments as white. This is okay, because it will just\n> ignore them. But it sucks.\nWell, CC sees the objects in other compartments in whatever color they happen to have.\n(Why would the objects be marked white in non-collected compartments?)", "time": "2011-10-26T11:07:51Z", "attachment_id": null, "creation_time": "2011-10-26T11:07:51Z", "raw_text": "(In reply to Bill McCloskey (:billm) from comment #0) \n> The immediate way to fix this bug is to call updateMallocCounter when the\n> canvas is allocated. However, problems like this are going to continue to\n> surface because it's so easy to forget updateMallocCounter.\n\nOther option is to tweak CC/GC handling in nsJSEnvironment.cpp.\nRight now if after running a task there are >1000 suspected CC objects, we\nmay trigger CC. Then, if the CC has run one or more times, and CC has collected >250 object,\nyet GC hasn't run, we trigger GC.\nThese numbers are sort of random, though they worked reasonable well with certain testcases.\nMaybe CC should collect the size of suspected and/or collected objects, and we wouldn't \nrely on the number of objects, but size.\n\n\n> At the same time, I think this would be a good opportunity to start\n> triggering compartmental GCs from timers. The hard part is deciding which\n> compartment to GC, and whether to do a full GC or not. Maybe we could see\n> what compartments we executed scripts in since the last GC, and collect\n> those. This would require us to be able to GC multiple compartments during a\n> compartment GC, but that should be pretty easy.\nIt would be better to run GC for different compartments in different tasks.\nSo there could be a queue of compartments which need GC, and an interval timer active as long\nas the queue is not empty. The timer would then call compartment timer. (Full GC should clear the queue.)\n\n\n> One important factor is the interaction with the cycle collector. I might be\n> mistaken, but I think this interaction is pretty messed up right now: if we\n> do a compartment GC followed by a CC, then the CC will see objects in\n> non-collected compartments as white. This is okay, because it will just\n> ignore them. But it sucks.\nWell, CC sees the objects in other compartments in whatever color they happen to have.\n(Why would the objects be marked white in non-collected compartments?)", "bug_id": 697286, "count": 2, "is_private": false, "tags": [], "id": 5805785, "creator": "bugs@pettay.fi", "author": "bugs@pettay.fi"}, {"creator": "bugs@pettay.fi", "author": "bugs@pettay.fi", "count": 3, "is_private": false, "tags": [], "id": 5805789, "bug_id": 697286, "creation_time": "2011-10-26T11:13:41Z", "raw_text": "(In general we seem to trigger compartment GC very rarely)", "text": "(In general we seem to trigger compartment GC very rarely)", "time": "2011-10-26T11:13:41Z", "attachment_id": null}, {"author": "continuation@gmail.com", "time": "2011-10-26T12:51:21Z", "attachment_id": null, "creator": "continuation@gmail.com", "text": "(In reply to Olli Pettay [:smaug] from comment #2)\n> Well, CC sees the objects in other compartments in whatever color they\n> happen to have.\n> (Why would the objects be marked white in non-collected compartments?)\n\nI believe that a compartmental GC clears the mark bits in all other compartments, making them white.  In turn, the CC will treat them as marked and not actually collect cycles that pass through other compartments until the next GC computes accurate mark bits.", "creation_time": "2011-10-26T12:51:21Z", "raw_text": "(In reply to Olli Pettay [:smaug] from comment #2)\n> Well, CC sees the objects in other compartments in whatever color they\n> happen to have.\n> (Why would the objects be marked white in non-collected compartments?)\n\nI believe that a compartmental GC clears the mark bits in all other compartments, making them white.  In turn, the CC will treat them as marked and not actually collect cycles that pass through other compartments until the next GC computes accurate mark bits.", "bug_id": 697286, "id": 5805885, "tags": [], "is_private": false, "count": 4}, {"author": "bugs@pettay.fi", "creator": "bugs@pettay.fi", "raw_text": "uh, that sounds strange. Why would compartmental gc change the state of some objects in\nother compartments. I must have misunderstood what compartment GC is about, or it is not\ndoing at all what it should do. Or both :)", "creation_time": "2011-10-26T13:09:30Z", "attachment_id": null, "time": "2011-10-26T13:09:30Z", "text": "uh, that sounds strange. Why would compartmental gc change the state of some objects in\nother compartments. I must have misunderstood what compartment GC is about, or it is not\ndoing at all what it should do. Or both :)", "id": 5805912, "tags": [], "count": 5, "is_private": false, "bug_id": 697286}, {"bug_id": 697286, "tags": [], "is_private": false, "count": 6, "id": 5806522, "text": "(In reply to Olli Pettay [:smaug] from comment #2)\n> Maybe CC should collect the size of suspected and/or collected objects, and\n> we wouldn't \n> rely on the number of objects, but size.\n\nThis won't work in the case I described. We need a GC to mark the canvas stuff gray and then a CC to collect it. If we do a CC alone, it won't be able to collect anything, and so it won't trigger a GC.\n\n(In reply to Olli Pettay [:smaug] from comment #5)\n> uh, that sounds strange. Why would compartmental gc change the state of some\n> objects in\n> other compartments. I must have misunderstood what compartment GC is about,\n> or it is not\n> doing at all what it should do. Or both :)\n\nThe GC is broken here. It shouldn't be too hard to fix, but we need to make sure to test thoroughly.", "attachment_id": null, "time": "2011-10-26T17:04:33Z", "creation_time": "2011-10-26T17:04:33Z", "raw_text": "(In reply to Olli Pettay [:smaug] from comment #2)\n> Maybe CC should collect the size of suspected and/or collected objects, and\n> we wouldn't \n> rely on the number of objects, but size.\n\nThis won't work in the case I described. We need a GC to mark the canvas stuff gray and then a CC to collect it. If we do a CC alone, it won't be able to collect anything, and so it won't trigger a GC.\n\n(In reply to Olli Pettay [:smaug] from comment #5)\n> uh, that sounds strange. Why would compartmental gc change the state of some\n> objects in\n> other compartments. I must have misunderstood what compartment GC is about,\n> or it is not\n> doing at all what it should do. Or both :)\n\nThe GC is broken here. It shouldn't be too hard to fix, but we need to make sure to test thoroughly.", "creator": "bill.mccloskey@gmail.com", "author": "bill.mccloskey@gmail.com"}, {"raw_text": "(In reply to Bill McCloskey (:billm) from comment #6)\n> The GC is broken here. It shouldn't be too hard to fix, but we need to make\n> sure to test thoroughly.\nHow would you fix that?  Can you have a cross-compartment gray edge?  In that case, a cross-compartment gray edge could become black, but there would be no ungraying.", "creation_time": "2011-10-26T17:09:36Z", "attachment_id": null, "time": "2011-10-26T17:09:36Z", "text": "(In reply to Bill McCloskey (:billm) from comment #6)\n> The GC is broken here. It shouldn't be too hard to fix, but we need to make\n> sure to test thoroughly.\nHow would you fix that?  Can you have a cross-compartment gray edge?  In that case, a cross-compartment gray edge could become black, but there would be no ungraying.", "id": 5806540, "tags": [], "count": 7, "is_private": false, "bug_id": 697286, "author": "continuation@gmail.com", "creator": "continuation@gmail.com"}]}}}