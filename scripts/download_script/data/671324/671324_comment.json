{"comments": {}, "bugs": {"671324": {"comments": [{"creation_time": "2011-07-13T17:13:30Z", "time": "2011-07-13T17:13:30Z", "creator": "david.humphrey@senecacollege.ca", "author": "david.humphrey@senecacollege.ca", "count": 0, "id": 5589282, "is_private": false, "tags": [], "bug_id": 671324, "text": "This small test is a lot slower in Firefox (4 through 8) than Chrome or other browsers.  On Firefox I get ~5-10 fps, and on Chrome it's more like ~40.  I don't think the canvas pixel flipping is affecting this that much, and it looks like it's just the cost of doing noise(), however I can't seem to get a shark build working here to know for sure.\n\nI think that the relevant bits of code are:\n\nProcessing Code:\n----------------\n\nfloat increment = 0.04;\nfloat zoff = 0.0;\nfloat zincrement = 0.08;\n\nvoid setup() {\n  size(100,100);\n}\n\nvoid draw() {\n  background(0);\n\n  // Optional: adjust noise detail here\n  // noiseDetail(8,0.65f);\n\n  loadPixels();\n\n  float xoff = 0.0; // Start xoff at 0\n\n  // For every x,y coordinate in a 2D space, calculate a noise value and produce a brightness value\n  for (int x = 0; x < width; x++) {\n    xoff += increment;   // Increment xoff\n    float yoff = 0.0f;   // For every xoff, start yoff at 0\n    for (int y = 0; y < height; y++) {\n      yoff += increment; // Increment yoff\n\n      // Calculate noise and scale by 255\n      float bright = noise(xoff,yoff,zoff)*255;\n\n      // Set each pixel onscreen to a grayscale value\n      pixels[x+y*width] = color(bright,bright,bright);\n    }\n  }\n  updatePixels();\n\n  zoff += zincrement; // Increment zoff\n}\n\n\nRelevant JavaScript Code:\n-------------------------\n\n// Noise functions and helpers\nfunction PerlinNoise(seed) {\n  var rnd = seed !== undef ? new Marsaglia(seed) : Marsaglia.createRandomized();\n  var i, j;\n  // http://www.noisemachine.com/talk1/17b.html\n  // http://mrl.nyu.edu/~perlin/noise/\n  // generate permutation\n  var perm = new Uint8Array(512);\n  for(i=0;i<256;++i) { perm[i] = i; }\n  for(i=0;i<256;++i) { var t = perm[j = rnd.nextInt() & 0xFF]; perm[j] = perm[i]; perm[i] = t; }\n  // copy to avoid taking mod in perm[0];\n  for(i=0;i<256;++i) { perm[i + 256] = perm[i]; }\n\n  function grad3d(i,x,y,z) {\n    var h = i & 15; // convert into 12 gradient directions\n    var u = h<8 ? x : y,\n        v = h<4 ? y : h===12||h===14 ? x : z;\n    return ((h&1) === 0 ? u : -u) + ((h&2) === 0 ? v : -v);\n  }\n\n  function grad2d(i,x,y) {\n    var v = (i & 1) === 0 ? x : y;\n    return (i&2) === 0 ? -v : v;\n  }\n\n  function grad1d(i,x) {\n    return (i&1) === 0 ? -x : x;\n  }\n\n  function lerp(t,a,b) { return a + t * (b - a); }\n\n  this.noise3d = function(x, y, z) {\n    var X = Math.floor(x)&255, Y = Math.floor(y)&255, Z = Math.floor(z)&255;\n    x -= Math.floor(x); y -= Math.floor(y); z -= Math.floor(z);\n    var fx = (3-2*x)*x*x, fy = (3-2*y)*y*y, fz = (3-2*z)*z*z;\n    var p0 = perm[X]+Y, p00 = perm[p0] + Z, p01 = perm[p0 + 1] + Z,\n        p1 = perm[X + 1] + Y, p10 = perm[p1] + Z, p11 = perm[p1 + 1] + Z;\n    return lerp(fz,\n      lerp(fy, lerp(fx, grad3d(perm[p00], x, y, z), grad3d(perm[p10], x-1, y, z)),\n               lerp(fx, grad3d(perm[p01], x, y-1, z), grad3d(perm[p11], x-1, y-1,z))),\n      lerp(fy, lerp(fx, grad3d(perm[p00 + 1], x, y, z-1), grad3d(perm[p10 + 1], x-1, y, z-1)),\n               lerp(fx, grad3d(perm[p01 + 1], x, y-1, z-1), grad3d(perm[p11 + 1], x-1, y-1,z-1))));\n    };\n\n    this.noise2d = function(x, y) {\n      var X = Math.floor(x)&255, Y = Math.floor(y)&255;\n      x -= Math.floor(x); y -= Math.floor(y);\n      var fx = (3-2*x)*x*x, fy = (3-2*y)*y*y;\n      var p0 = perm[X]+Y, p1 = perm[X + 1] + Y;\n      return lerp(fy,\n        lerp(fx, grad2d(perm[p0], x, y), grad2d(perm[p1], x-1, y)),\n        lerp(fx, grad2d(perm[p0 + 1], x, y-1), grad2d(perm[p1 + 1], x-1, y-1)));\n    };\n\n    this.noise1d = function(x) {\n      var X = Math.floor(x)&255;\n      x -= Math.floor(x);\n      var fx = (3-2*x)*x*x;\n      return lerp(fx, grad1d(perm[X], x), grad1d(perm[X+1], x-1));\n    };\n  }\n\np.noise = function(x, y, z) {\n  if(noiseProfile.generator === undef) {\n    // caching\n    noiseProfile.generator = new PerlinNoise(noiseProfile.seed);\n  }\n  var generator = noiseProfile.generator;\n  var effect = 1, k = 1, sum = 0, al = arguments.length, f;\n\n  if (al === 1) {\n    f = function(k, effect) { return effect * (1 + generator.noise1d(k*x))/2; };\n  } else if (al === 2) {\n    f = function(k, effect) { return effect * (1 + generator.noise2d(k*x, k*y))/2; };\n  } else if (al === 3) {\n    f = function(k, effect) { return effect * (1 + generator.noise3d(k*x, k*y, k*z))/2; };\n  }\n\n  for (var i=0, o = noiseProfile.octaves; i < o; ++i) {\n    effect *= noiseProfile.fallout;\n    sum += f(k, effect);\n    k *= 2;\n  }\n\n  return sum;\n};", "attachment_id": null, "raw_text": "This small test is a lot slower in Firefox (4 through 8) than Chrome or other browsers.  On Firefox I get ~5-10 fps, and on Chrome it's more like ~40.  I don't think the canvas pixel flipping is affecting this that much, and it looks like it's just the cost of doing noise(), however I can't seem to get a shark build working here to know for sure.\n\nI think that the relevant bits of code are:\n\nProcessing Code:\n----------------\n\nfloat increment = 0.04;\nfloat zoff = 0.0;\nfloat zincrement = 0.08;\n\nvoid setup() {\n  size(100,100);\n}\n\nvoid draw() {\n  background(0);\n\n  // Optional: adjust noise detail here\n  // noiseDetail(8,0.65f);\n\n  loadPixels();\n\n  float xoff = 0.0; // Start xoff at 0\n\n  // For every x,y coordinate in a 2D space, calculate a noise value and produce a brightness value\n  for (int x = 0; x < width; x++) {\n    xoff += increment;   // Increment xoff\n    float yoff = 0.0f;   // For every xoff, start yoff at 0\n    for (int y = 0; y < height; y++) {\n      yoff += increment; // Increment yoff\n\n      // Calculate noise and scale by 255\n      float bright = noise(xoff,yoff,zoff)*255;\n\n      // Set each pixel onscreen to a grayscale value\n      pixels[x+y*width] = color(bright,bright,bright);\n    }\n  }\n  updatePixels();\n\n  zoff += zincrement; // Increment zoff\n}\n\n\nRelevant JavaScript Code:\n-------------------------\n\n// Noise functions and helpers\nfunction PerlinNoise(seed) {\n  var rnd = seed !== undef ? new Marsaglia(seed) : Marsaglia.createRandomized();\n  var i, j;\n  // http://www.noisemachine.com/talk1/17b.html\n  // http://mrl.nyu.edu/~perlin/noise/\n  // generate permutation\n  var perm = new Uint8Array(512);\n  for(i=0;i<256;++i) { perm[i] = i; }\n  for(i=0;i<256;++i) { var t = perm[j = rnd.nextInt() & 0xFF]; perm[j] = perm[i]; perm[i] = t; }\n  // copy to avoid taking mod in perm[0];\n  for(i=0;i<256;++i) { perm[i + 256] = perm[i]; }\n\n  function grad3d(i,x,y,z) {\n    var h = i & 15; // convert into 12 gradient directions\n    var u = h<8 ? x : y,\n        v = h<4 ? y : h===12||h===14 ? x : z;\n    return ((h&1) === 0 ? u : -u) + ((h&2) === 0 ? v : -v);\n  }\n\n  function grad2d(i,x,y) {\n    var v = (i & 1) === 0 ? x : y;\n    return (i&2) === 0 ? -v : v;\n  }\n\n  function grad1d(i,x) {\n    return (i&1) === 0 ? -x : x;\n  }\n\n  function lerp(t,a,b) { return a + t * (b - a); }\n\n  this.noise3d = function(x, y, z) {\n    var X = Math.floor(x)&255, Y = Math.floor(y)&255, Z = Math.floor(z)&255;\n    x -= Math.floor(x); y -= Math.floor(y); z -= Math.floor(z);\n    var fx = (3-2*x)*x*x, fy = (3-2*y)*y*y, fz = (3-2*z)*z*z;\n    var p0 = perm[X]+Y, p00 = perm[p0] + Z, p01 = perm[p0 + 1] + Z,\n        p1 = perm[X + 1] + Y, p10 = perm[p1] + Z, p11 = perm[p1 + 1] + Z;\n    return lerp(fz,\n      lerp(fy, lerp(fx, grad3d(perm[p00], x, y, z), grad3d(perm[p10], x-1, y, z)),\n               lerp(fx, grad3d(perm[p01], x, y-1, z), grad3d(perm[p11], x-1, y-1,z))),\n      lerp(fy, lerp(fx, grad3d(perm[p00 + 1], x, y, z-1), grad3d(perm[p10 + 1], x-1, y, z-1)),\n               lerp(fx, grad3d(perm[p01 + 1], x, y-1, z-1), grad3d(perm[p11 + 1], x-1, y-1,z-1))));\n    };\n\n    this.noise2d = function(x, y) {\n      var X = Math.floor(x)&255, Y = Math.floor(y)&255;\n      x -= Math.floor(x); y -= Math.floor(y);\n      var fx = (3-2*x)*x*x, fy = (3-2*y)*y*y;\n      var p0 = perm[X]+Y, p1 = perm[X + 1] + Y;\n      return lerp(fy,\n        lerp(fx, grad2d(perm[p0], x, y), grad2d(perm[p1], x-1, y)),\n        lerp(fx, grad2d(perm[p0 + 1], x, y-1), grad2d(perm[p1 + 1], x-1, y-1)));\n    };\n\n    this.noise1d = function(x) {\n      var X = Math.floor(x)&255;\n      x -= Math.floor(x);\n      var fx = (3-2*x)*x*x;\n      return lerp(fx, grad1d(perm[X], x), grad1d(perm[X+1], x-1));\n    };\n  }\n\np.noise = function(x, y, z) {\n  if(noiseProfile.generator === undef) {\n    // caching\n    noiseProfile.generator = new PerlinNoise(noiseProfile.seed);\n  }\n  var generator = noiseProfile.generator;\n  var effect = 1, k = 1, sum = 0, al = arguments.length, f;\n\n  if (al === 1) {\n    f = function(k, effect) { return effect * (1 + generator.noise1d(k*x))/2; };\n  } else if (al === 2) {\n    f = function(k, effect) { return effect * (1 + generator.noise2d(k*x, k*y))/2; };\n  } else if (al === 3) {\n    f = function(k, effect) { return effect * (1 + generator.noise3d(k*x, k*y, k*z))/2; };\n  }\n\n  for (var i=0, o = noiseProfile.octaves; i < o; ++i) {\n    effect *= noiseProfile.fallout;\n    sum += f(k, effect);\n    k *= 2;\n  }\n\n  return sum;\n};"}, {"raw_text": "Shark says 85% of the time is in mjit-generated code.  If I turn off mjit, we're 65% interp, which is never a good sign.  ;)\n\nOther than the mjit-generated code, there's 4% of math_floor, and then stub calls: Lambda, CreateFuncCallObject, StrictNe, ArgCnt, BitAnd, StrictEq.\n\nIt's interesting that JM stubs StrictNe and StrictEq; I'd think those would be easy to inline (except for NaN and int-vs-double representations of the same number, just a jsval equality compare would do the trick).  The Lambda and CreateFuncCallObject is presumably due to the fact that every call to PerlinNoise creates several new function objects.  The ArgCnt is the arguments.length in p.noise, I bet.\n\nJM+TI spends a bit less time in mjit-generated code, but 5% under the Arguments stubcall (which JM without TI seems to avoid?).  Other than that, looks about the same.  The visual look is a little better in JM+TI, though it starts off pretty quick and then slows down as time goes on...  Objectively, the profiler shows 2% of time spent outside JS under JM, and 5.5% under JM+TI, so JM+TI is about 2-3x faster, presumably.", "count": 1, "id": 5594682, "attachment_id": null, "is_private": false, "text": "Shark says 85% of the time is in mjit-generated code.  If I turn off mjit, we're 65% interp, which is never a good sign.  ;)\n\nOther than the mjit-generated code, there's 4% of math_floor, and then stub calls: Lambda, CreateFuncCallObject, StrictNe, ArgCnt, BitAnd, StrictEq.\n\nIt's interesting that JM stubs StrictNe and StrictEq; I'd think those would be easy to inline (except for NaN and int-vs-double representations of the same number, just a jsval equality compare would do the trick).  The Lambda and CreateFuncCallObject is presumably due to the fact that every call to PerlinNoise creates several new function objects.  The ArgCnt is the arguments.length in p.noise, I bet.\n\nJM+TI spends a bit less time in mjit-generated code, but 5% under the Arguments stubcall (which JM without TI seems to avoid?).  Other than that, looks about the same.  The visual look is a little better in JM+TI, though it starts off pretty quick and then slows down as time goes on...  Objectively, the profiler shows 2% of time spent outside JS under JM, and 5.5% under JM+TI, so JM+TI is about 2-3x faster, presumably.", "bug_id": 671324, "tags": [], "author": "bzbarsky@mit.edu", "creation_time": "2011-07-16T06:18:47Z", "time": "2011-07-16T06:18:47Z", "creator": "bzbarsky@mit.edu"}, {"time": "2011-07-16T07:57:41Z", "creation_time": "2011-07-16T07:57:41Z", "creator": "jdemooij@mozilla.com", "author": "jdemooij@mozilla.com", "count": 2, "id": 5594724, "is_private": false, "bug_id": 671324, "text": "(In reply to comment #1)\n> It's interesting that JM stubs StrictNe and StrictEq; I'd think those would\n> be easy to inline (except for NaN and int-vs-double representations of the\n> same number, just a jsval equality compare would do the trick).\n\nstricteq could be (much) more efficient in JM (the main benchmarks don't use it much...) Currently we inline int32 === int32 and inline if lhs or rhs has undefined/null type or is a true/false constant. For non-strict equality we fuse with branching ops and have an equality IC (with TI we can probably do without the IC). Will fix bug 590161 when I return. There's no reason for stricteq to be slower than non-strict eq, we should at least also handle double, objects and booleans inline. We could even compare strings inline. Or at least their lengths...", "tags": [], "attachment_id": null, "raw_text": "(In reply to comment #1)\n> It's interesting that JM stubs StrictNe and StrictEq; I'd think those would\n> be easy to inline (except for NaN and int-vs-double representations of the\n> same number, just a jsval equality compare would do the trick).\n\nstricteq could be (much) more efficient in JM (the main benchmarks don't use it much...) Currently we inline int32 === int32 and inline if lhs or rhs has undefined/null type or is a true/false constant. For non-strict equality we fuse with branching ops and have an equality IC (with TI we can probably do without the IC). Will fix bug 590161 when I return. There's no reason for stricteq to be slower than non-strict eq, we should at least also handle double, objects and booleans inline. We could even compare strings inline. Or at least their lengths..."}, {"is_private": false, "id": 5813593, "count": 3, "author": "david.humphrey@senecacollege.ca", "creator": "david.humphrey@senecacollege.ca", "time": "2011-10-30T00:34:45Z", "creation_time": "2011-10-30T00:34:45Z", "raw_text": "Any thoughts on who might be able to work on this?", "attachment_id": null, "tags": [], "bug_id": 671324, "text": "Any thoughts on who might be able to work on this?"}, {"bug_id": 671324, "text": "For a start, we should remeasure now that TI is on.\n\nAlso, sfink is working on a profiler which might be of use here...", "tags": [], "attachment_id": null, "raw_text": "For a start, we should remeasure now that TI is on.\n\nAlso, sfink is working on a profiler which might be of use here...", "creation_time": "2011-10-30T03:14:27Z", "time": "2011-10-30T03:14:27Z", "creator": "bzbarsky@mit.edu", "author": "bzbarsky@mit.edu", "count": 4, "id": 5813655, "is_private": false}]}}}