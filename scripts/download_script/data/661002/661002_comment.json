{"comments": {}, "bugs": {"661002": {"comments": [{"text": "Running with the current patch queue,\nhttp://hg.mozilla.org/users/florian.haenel_heeen.de/GLES_layers/\n\nI get a GL_INVALID_OPERATION with this trace:\n\n#4  0x84c8273c in mozilla::gl::GLContext::AfterGLCall (this=0x48845c00, \n    glFunction=0x86a93288 \"void mozilla::gl::GLContext::fTexSubImage2D(GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, const GLvoid*)\") at ../../../dist/include/GLContext.h:1110\n#5  0x84cb7ec8 in mozilla::gl::GLContext::fTexSubImage2D (this=0x48845c00, target=3553, level=0, \n    xoffset=0, yoffset=0, width=320, height=508, format=6407, type=33635, pixels=0x494a9000)\n    at ../../../dist/include/GLContext.h:1775\n#6  0x860c3ba0 in mozilla::gl::GLContext::UploadSurfaceToTexture (this=0x48845c00, aSurface=\n    0x48e66740, aDstRegion=..., aTexture=@0x48f0a50c, aOverwrite=false, aSrcPoint=..., \n    aPixelBuffer=false) at /home/bjacob/mozilla-central-mobile/gfx/thebes/GLContext.cpp:1738\n#7  0x860de2c4 in mozilla::gl::TextureImageEGL::DirectUpdate (this=0x48f0a4c0, aSurf=0x48e66740, \n    aRegion=..., aFrom=...)\n    at /home/bjacob/mozilla-central-mobile/gfx/thebes/GLContextProviderEGL.cpp:1264\n#8  0x860bff80 in mozilla::gl::TiledTextureImage::DirectUpdate (this=0x4aa90580, \n    aSurf=0x48e66740, aRegion=..., aFrom=...)\n    at /home/bjacob/mozilla-central-mobile/gfx/thebes/GLContext.cpp:738\n#9  0x8611796c in mozilla::layers::ShadowBufferOGL::Upload (this=0x48df3280, aUpdate=0x48e66740, \n    aUpdated=..., aRect=..., aRotation=...)\n    at /home/bjacob/mozilla-central-mobile/gfx/layers/opengl/ThebesLayerOGL.cpp:981\n\n\n\nThe reason for this error becomes apparent with the patch from bug 654424: this texture was created by a glTexImage2D call with format=GL_RGBA, and is now getting updated by a glTexSubImage2D call with format=GL_RGB:\n\nI/Gecko   (16157): [gl:0x48845c00] > void mozilla::gl::GLContext::fBindTexture(GLenum, GLuint)\nI/Gecko   (16157): parameters:\nI/Gecko   (16157):   target = de1\nI/Gecko   (16157):   texture = 490007\nI/Gecko   (16157): [gl:0x48845c00] < void mozilla::gl::GLContext::fBindTexture(GLenum, GLuint) [0x0000]\nI/Gecko   (16157): [gl:0x48845c00] > void mozilla::gl::GLContext::fTexImage2D(GLenum, GLint, GLint, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid*)\nI/Gecko   (16157): parameters:\nI/Gecko   (16157):   target = de1\nI/Gecko   (16157):   level = 0\nI/Gecko   (16157):   width = 320\nI/Gecko   (16157):  height = 508\nI/Gecko   (16157):   format = 1908\nI/Gecko   (16157): , type = 1401\nI/Gecko   (16157): [gl:0x48845c00] < void mozilla::gl::GLContext::fTexImage2D(GLenum, GLint, GLint, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid*) [0x0000]\nI/Gecko   (16157): [gl:0x48845c00] > void mozilla::gl::GLContext::fTexParameteri(GLenum, GLenum, GLint)\nI/Gecko   (16157): [gl:0x48845c00] < void mozilla::gl::GLContext::fTexParameteri(GLenum, GLenum, GLint) [0x0000]\nI/Gecko   (16157): [gl:0x48845c00] > void mozilla::gl::GLContext::fTexParameteri(GLenum, GLenum, GLint)\nI/Gecko   (16157): [gl:0x48845c00] < void mozilla::gl::GLContext::fTexParameteri(GLenum, GLenum, GLint) [0x0000]\nI/Gecko   (16157): [gl:0x48845c00] > void mozilla::gl::GLContext::fTexParameteri(GLenum, GLenum, GLint)\nI/Gecko   (16157): [gl:0x48845c00] < void mozilla::gl::GLContext::fTexParameteri(GLenum, GLenum, GLint) [0x0000]\nI/Gecko   (16157): [gl:0x48845c00] > void mozilla::gl::GLContext::fTexParameteri(GLenum, GLenum, GLint)\nI/Gecko   (16157): [gl:0x48845c00] < void mozilla::gl::GLContext::fTexParameteri(GLenum, GLenum, GLint) [0x0000]\nI/Gecko   (16157): [gl:0x48845c00] > void mozilla::gl::GLContext::fActiveTexture(GLenum)\nI/Gecko   (16157): parameters:\nI/Gecko   (16157):  textureunit = 33984\nI/Gecko   (16157): [gl:0x48845c00] < void mozilla::gl::GLContext::fActiveTexture(GLenum) [0x0000]\nI/Gecko   (16157): [gl:0x48845c00] > void mozilla::gl::GLContext::fBindTexture(GLenum, GLuint)\nI/Gecko   (16157): parameters:\nI/Gecko   (16157):   target = de1\nI/Gecko   (16157):   texture = 490007\nI/Gecko   (16157): [gl:0x48845c00] < void mozilla::gl::GLContext::fBindTexture(GLenum, GLuint) [0x0000]\nI/Gecko   (16157): [gl:0x48845c00] > void mozilla::gl::GLContext::fTexSubImage2D(GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, const GLvoid*)\nI/Gecko   (16157): parameters:\nI/Gecko   (16157):   target = de1\nI/Gecko   (16157):   level = 0\nI/Gecko   (16157):   xoffset = 0\nI/Gecko   (16157):  yoffset = 0\nI/Gecko   (16157):   width = 320\nI/Gecko   (16157):  height = 508\nI/Gecko   (16157):   format = 1907\nI/Gecko   (16157): , type = 8363\nI/Gecko   (16157): [gl:0x48845c00] < void mozilla::gl::GLContext::fTexSubImage2D(GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, const GLvoid*) [0x0502]\nI/Gecko   (16157): GL ERROR: void mozilla::gl::GLContext::fTexSubImage2D(GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, const GLvoid*) generated GL error GL_INVALID_OPERATION(0x0502)\nI/Gecko   (16157): ###!!! ABORT: file ../../../dist/include/GLContext.h, line 1110\n\n\nWe need to figure which of these two format values is wrong, factor out the code that finds the correct format and let both sides use it.", "bug_id": 661002, "tags": [], "attachment_id": null, "raw_text": "Running with the current patch queue,\nhttp://hg.mozilla.org/users/florian.haenel_heeen.de/GLES_layers/\n\nI get a GL_INVALID_OPERATION with this trace:\n\n#4  0x84c8273c in mozilla::gl::GLContext::AfterGLCall (this=0x48845c00, \n    glFunction=0x86a93288 \"void mozilla::gl::GLContext::fTexSubImage2D(GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, const GLvoid*)\") at ../../../dist/include/GLContext.h:1110\n#5  0x84cb7ec8 in mozilla::gl::GLContext::fTexSubImage2D (this=0x48845c00, target=3553, level=0, \n    xoffset=0, yoffset=0, width=320, height=508, format=6407, type=33635, pixels=0x494a9000)\n    at ../../../dist/include/GLContext.h:1775\n#6  0x860c3ba0 in mozilla::gl::GLContext::UploadSurfaceToTexture (this=0x48845c00, aSurface=\n    0x48e66740, aDstRegion=..., aTexture=@0x48f0a50c, aOverwrite=false, aSrcPoint=..., \n    aPixelBuffer=false) at /home/bjacob/mozilla-central-mobile/gfx/thebes/GLContext.cpp:1738\n#7  0x860de2c4 in mozilla::gl::TextureImageEGL::DirectUpdate (this=0x48f0a4c0, aSurf=0x48e66740, \n    aRegion=..., aFrom=...)\n    at /home/bjacob/mozilla-central-mobile/gfx/thebes/GLContextProviderEGL.cpp:1264\n#8  0x860bff80 in mozilla::gl::TiledTextureImage::DirectUpdate (this=0x4aa90580, \n    aSurf=0x48e66740, aRegion=..., aFrom=...)\n    at /home/bjacob/mozilla-central-mobile/gfx/thebes/GLContext.cpp:738\n#9  0x8611796c in mozilla::layers::ShadowBufferOGL::Upload (this=0x48df3280, aUpdate=0x48e66740, \n    aUpdated=..., aRect=..., aRotation=...)\n    at /home/bjacob/mozilla-central-mobile/gfx/layers/opengl/ThebesLayerOGL.cpp:981\n\n\n\nThe reason for this error becomes apparent with the patch from bug 654424: this texture was created by a glTexImage2D call with format=GL_RGBA, and is now getting updated by a glTexSubImage2D call with format=GL_RGB:\n\nI/Gecko   (16157): [gl:0x48845c00] > void mozilla::gl::GLContext::fBindTexture(GLenum, GLuint)\nI/Gecko   (16157): parameters:\nI/Gecko   (16157):   target = de1\nI/Gecko   (16157):   texture = 490007\nI/Gecko   (16157): [gl:0x48845c00] < void mozilla::gl::GLContext::fBindTexture(GLenum, GLuint) [0x0000]\nI/Gecko   (16157): [gl:0x48845c00] > void mozilla::gl::GLContext::fTexImage2D(GLenum, GLint, GLint, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid*)\nI/Gecko   (16157): parameters:\nI/Gecko   (16157):   target = de1\nI/Gecko   (16157):   level = 0\nI/Gecko   (16157):   width = 320\nI/Gecko   (16157):  height = 508\nI/Gecko   (16157):   format = 1908\nI/Gecko   (16157): , type = 1401\nI/Gecko   (16157): [gl:0x48845c00] < void mozilla::gl::GLContext::fTexImage2D(GLenum, GLint, GLint, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid*) [0x0000]\nI/Gecko   (16157): [gl:0x48845c00] > void mozilla::gl::GLContext::fTexParameteri(GLenum, GLenum, GLint)\nI/Gecko   (16157): [gl:0x48845c00] < void mozilla::gl::GLContext::fTexParameteri(GLenum, GLenum, GLint) [0x0000]\nI/Gecko   (16157): [gl:0x48845c00] > void mozilla::gl::GLContext::fTexParameteri(GLenum, GLenum, GLint)\nI/Gecko   (16157): [gl:0x48845c00] < void mozilla::gl::GLContext::fTexParameteri(GLenum, GLenum, GLint) [0x0000]\nI/Gecko   (16157): [gl:0x48845c00] > void mozilla::gl::GLContext::fTexParameteri(GLenum, GLenum, GLint)\nI/Gecko   (16157): [gl:0x48845c00] < void mozilla::gl::GLContext::fTexParameteri(GLenum, GLenum, GLint) [0x0000]\nI/Gecko   (16157): [gl:0x48845c00] > void mozilla::gl::GLContext::fTexParameteri(GLenum, GLenum, GLint)\nI/Gecko   (16157): [gl:0x48845c00] < void mozilla::gl::GLContext::fTexParameteri(GLenum, GLenum, GLint) [0x0000]\nI/Gecko   (16157): [gl:0x48845c00] > void mozilla::gl::GLContext::fActiveTexture(GLenum)\nI/Gecko   (16157): parameters:\nI/Gecko   (16157):  textureunit = 33984\nI/Gecko   (16157): [gl:0x48845c00] < void mozilla::gl::GLContext::fActiveTexture(GLenum) [0x0000]\nI/Gecko   (16157): [gl:0x48845c00] > void mozilla::gl::GLContext::fBindTexture(GLenum, GLuint)\nI/Gecko   (16157): parameters:\nI/Gecko   (16157):   target = de1\nI/Gecko   (16157):   texture = 490007\nI/Gecko   (16157): [gl:0x48845c00] < void mozilla::gl::GLContext::fBindTexture(GLenum, GLuint) [0x0000]\nI/Gecko   (16157): [gl:0x48845c00] > void mozilla::gl::GLContext::fTexSubImage2D(GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, const GLvoid*)\nI/Gecko   (16157): parameters:\nI/Gecko   (16157):   target = de1\nI/Gecko   (16157):   level = 0\nI/Gecko   (16157):   xoffset = 0\nI/Gecko   (16157):  yoffset = 0\nI/Gecko   (16157):   width = 320\nI/Gecko   (16157):  height = 508\nI/Gecko   (16157):   format = 1907\nI/Gecko   (16157): , type = 8363\nI/Gecko   (16157): [gl:0x48845c00] < void mozilla::gl::GLContext::fTexSubImage2D(GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, const GLvoid*) [0x0502]\nI/Gecko   (16157): GL ERROR: void mozilla::gl::GLContext::fTexSubImage2D(GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, const GLvoid*) generated GL error GL_INVALID_OPERATION(0x0502)\nI/Gecko   (16157): ###!!! ABORT: file ../../../dist/include/GLContext.h, line 1110\n\n\nWe need to figure which of these two format values is wrong, factor out the code that finds the correct format and let both sides use it.", "creation_time": "2011-05-31T22:06:51Z", "time": "2011-05-31T22:06:51Z", "creator": "jacob.benoit.1@gmail.com", "author": "jacob.benoit.1@gmail.com", "count": 0, "id": 5504579, "is_private": false}, {"count": 1, "id": 5504620, "is_private": false, "creation_time": "2011-05-31T22:19:10Z", "time": "2011-05-31T22:19:10Z", "creator": "jacob.benoit.1@gmail.com", "author": "jacob.benoit.1@gmail.com", "attachment_id": null, "raw_text": "The first time (in texImage2D), we have format=GL_RGBA, type=GL_UNSIGNED_BYTE; this is computed in GLFormatForImage() and GLTypeForImage() in GLContextProviderEGL.cpp, this means that the image's format is either gfxASurface::ImageFormatARGB32 or gfxASurface::ImageFormatRGB24.\n\nThe second time (in texSubImage2D), we have format=GL_RGB, type=GL_UNSIGNED_SHORT_5_6_5; this is computed in GLContext::UploadSurfaceToTexture(); this means that the image's format is gfxASurface::ImageFormatRGB16_565.\n\nSo the image's format changed between these two points; the bug is either that fact, or the fact that the GL texture wasn't updated accordingly.", "tags": [], "text": "The first time (in texImage2D), we have format=GL_RGBA, type=GL_UNSIGNED_BYTE; this is computed in GLFormatForImage() and GLTypeForImage() in GLContextProviderEGL.cpp, this means that the image's format is either gfxASurface::ImageFormatARGB32 or gfxASurface::ImageFormatRGB24.\n\nThe second time (in texSubImage2D), we have format=GL_RGB, type=GL_UNSIGNED_SHORT_5_6_5; this is computed in GLContext::UploadSurfaceToTexture(); this means that the image's format is gfxASurface::ImageFormatRGB16_565.\n\nSo the image's format changed between these two points; the bug is either that fact, or the fact that the GL texture wasn't updated accordingly.", "bug_id": 661002}, {"creator": "jacob.benoit.1@gmail.com", "creation_time": "2011-05-31T22:19:57Z", "time": "2011-05-31T22:19:57Z", "author": "jacob.benoit.1@gmail.com", "is_private": false, "id": 5504629, "count": 2, "bug_id": 661002, "text": "... or perhaps we're just missing a glBindTexture call somewhere between these two points.", "tags": [], "attachment_id": null, "raw_text": "... or perhaps we're just missing a glBindTexture call somewhere between these two points."}, {"text": "(In reply to comment #2)\n> ... or perhaps we're just missing a glBindTexture call somewhere between\n> these two points.\n\nAh no, forget that, we're specifically calling glBindTexture on the same texture.", "bug_id": 661002, "tags": [], "attachment_id": null, "raw_text": "(In reply to comment #2)\n> ... or perhaps we're just missing a glBindTexture call somewhere between\n> these two points.\n\nAh no, forget that, we're specifically calling glBindTexture on the same texture.", "creator": "jacob.benoit.1@gmail.com", "creation_time": "2011-05-31T22:21:05Z", "time": "2011-05-31T22:21:05Z", "author": "jacob.benoit.1@gmail.com", "is_private": false, "id": 5504632, "count": 3}, {"bug_id": 661002, "text": "Created attachment 536683\nhelper to log nested (function, etc) scopes\n\nWith this patch we get a log of the main relevant function calls around here.", "tags": [], "raw_text": "With this patch we get a log of the main relevant function calls around here.", "attachment_id": 536683, "author": "jacob.benoit.1@gmail.com", "time": "2011-06-01T18:55:50Z", "creation_time": "2011-06-01T18:55:50Z", "creator": "jacob.benoit.1@gmail.com", "count": 4, "id": 5506863, "is_private": false}, {"is_private": false, "id": 5506896, "count": 5, "creator": "jacob.benoit.1@gmail.com", "time": "2011-06-01T19:03:36Z", "creation_time": "2011-06-01T19:03:36Z", "author": "jacob.benoit.1@gmail.com", "attachment_id": 536689, "raw_text": "Here's the log of relevant function calls, obtained with above patch.\n\nWe get:\n\n  ShadowBufferOGL::Upload {\n    CreateClampOrRepeatTextureImage {\n      GLContextEGL::CreateTextureImage {\n         TextureImageEGL::TextureImageEGL {\n           TextureImageEGL::Resize {\n             glTexImage2D with GL_RGBA, GL_UNSIGNED_BYTE\n           }\n         }\n      }\n    }\n    TextureImageEGL::DirectUpdate {\n      glTexSubImage2D with GL_RGB, GL_UNSIGNED_SHORT_5_6_5\n    }\n  }\n\nSo the format change occurs inside of ShadowBufferOGL::Upload(), after the CreateClampOrRepeatTextureImage() call and before the TextureImageEGL::DirectUpdate() call.", "text": "Created attachment 536689\nlog with function scopes\n\nHere's the log of relevant function calls, obtained with above patch.\n\nWe get:\n\n  ShadowBufferOGL::Upload {\n    CreateClampOrRepeatTextureImage {\n      GLContextEGL::CreateTextureImage {\n         TextureImageEGL::TextureImageEGL {\n           TextureImageEGL::Resize {\n             glTexImage2D with GL_RGBA, GL_UNSIGNED_BYTE\n           }\n         }\n      }\n    }\n    TextureImageEGL::DirectUpdate {\n      glTexSubImage2D with GL_RGB, GL_UNSIGNED_SHORT_5_6_5\n    }\n  }\n\nSo the format change occurs inside of ShadowBufferOGL::Upload(), after the CreateClampOrRepeatTextureImage() call and before the TextureImageEGL::DirectUpdate() call.", "bug_id": 661002, "tags": []}, {"id": 5507092, "count": 6, "is_private": false, "time": "2011-06-01T20:16:53Z", "creation_time": "2011-06-01T20:16:53Z", "creator": "jacob.benoit.1@gmail.com", "author": "jacob.benoit.1@gmail.com", "attachment_id": null, "raw_text": "ShadowBufferOGL::Upload is called here with a surface whose format is ImageFormatRGB16_565.\n\nSo the real error is that the glTexImage2D call creates a RGBA32 texture. The subsequent glTexSubImage2D call (where the error occurs) is correct in trying to update the texture as RGB16.", "tags": [], "bug_id": 661002, "text": "ShadowBufferOGL::Upload is called here with a surface whose format is ImageFormatRGB16_565.\n\nSo the real error is that the glTexImage2D call creates a RGBA32 texture. The subsequent glTexSubImage2D call (where the error occurs) is correct in trying to update the texture as RGB16."}, {"time": "2011-06-01T20:43:47Z", "creation_time": "2011-06-01T20:43:47Z", "creator": "jacob.benoit.1@gmail.com", "author": "jacob.benoit.1@gmail.com", "count": 7, "id": 5507156, "is_private": false, "tags": [], "text": "In TextureImageEGL::TextureImageEGL(), we initially have mUpdateFormat==ImageFormatRGB24 and we then adjust it to ImageFormatARGB32.\n\nBoth are wrong. The correct format, that was passed to ShadowBuffer::Upload(), was never propagated to here.", "bug_id": 661002, "attachment_id": null, "raw_text": "In TextureImageEGL::TextureImageEGL(), we initially have mUpdateFormat==ImageFormatRGB24 and we then adjust it to ImageFormatARGB32.\n\nBoth are wrong. The correct format, that was passed to ShadowBuffer::Upload(), was never propagated to here."}, {"raw_text": "Does anyone know this code? It is necessary to rewrite this code in such a way that the texture format is computed once and for all in one place, and use that for both the texture creation (glTexImage2D) and the texture update (glTexSubImage2D).\n\nI don't understand this optimization in TextureImageEGL::TextureImageEGL, where we change the mUpdateFormat. Even though this isn't what's causing this error here, it's going to cause similar errors whenever it results in a different format being picked than what TextureImageEGL::DirectUpdate() picks.", "attachment_id": null, "text": "Does anyone know this code? It is necessary to rewrite this code in such a way that the texture format is computed once and for all in one place, and use that for both the texture creation (glTexImage2D) and the texture update (glTexSubImage2D).\n\nI don't understand this optimization in TextureImageEGL::TextureImageEGL, where we change the mUpdateFormat. Even though this isn't what's causing this error here, it's going to cause similar errors whenever it results in a different format being picked than what TextureImageEGL::DirectUpdate() picks.", "bug_id": 661002, "tags": [], "count": 8, "id": 5507172, "is_private": false, "author": "jacob.benoit.1@gmail.com", "creation_time": "2011-06-01T20:48:14Z", "time": "2011-06-01T20:48:14Z", "creator": "jacob.benoit.1@gmail.com"}, {"tags": [], "bug_id": 661002, "text": "After IRC discussion with romaxa and mattwoodrow, it's confirmed we should honor the format of the surface passed to ShadowBuffer::Upload(), instead of only passing its contentType which doesn't have enough information.", "attachment_id": null, "raw_text": "After IRC discussion with romaxa and mattwoodrow, it's confirmed we should honor the format of the surface passed to ShadowBuffer::Upload(), instead of only passing its contentType which doesn't have enough information.", "time": "2011-06-01T21:35:44Z", "creation_time": "2011-06-01T21:35:44Z", "creator": "jacob.benoit.1@gmail.com", "author": "jacob.benoit.1@gmail.com", "count": 9, "id": 5507326, "is_private": false}, {"attachment_id": 537245, "raw_text": "This patch makes thing work nicely without GL errors on my Nexus S.\n\nNot yet asking for review as I would first like to get confirmation that I'm not breaking stuff on other platforms. Please check on Meego. This also needs to be checked on GLX and on CGL.\n\nHere's what the patch is doing. TextureImage used to store two members giving some information about its format: mContentType and mIsRGBFormat. mContentType said whether we had color, alpha, or both. mIsRGBFormat said whether we have RGB or BGR order.\n\nThe first problem was that that wasn't enough information, since it didn't tell the difference between RGB16_565 and RGB24 for example. That's the bug I experienced above. This patch replaces mContentType by mImageFormat everywhere, so TextureImage knows its gfxImageFormat.\n\nThis made a second problem surface, as mIsRGBFormat was now redundant. Indeed, my understanding is that Cairo surfaces have BGR order, unless the format is RGB565, and then when using hw surfaces on Meego we always have RGB order. So I removed the mIsRGBFormat member, the IsRGB() method is now implementing the above logic (has to be checked by romaxa/heeen), so there's no redundancy anymore, and also I *think* we had bugs where we were not correctly updating mIsRGBFormat and these would now be fixed (in any case some code blocks got removed which is always nice).", "tags": [], "text": "Created attachment 537245\nFix TextureImage format handling\n\nThis patch makes thing work nicely without GL errors on my Nexus S.\n\nNot yet asking for review as I would first like to get confirmation that I'm not breaking stuff on other platforms. Please check on Meego. This also needs to be checked on GLX and on CGL.\n\nHere's what the patch is doing. TextureImage used to store two members giving some information about its format: mContentType and mIsRGBFormat. mContentType said whether we had color, alpha, or both. mIsRGBFormat said whether we have RGB or BGR order.\n\nThe first problem was that that wasn't enough information, since it didn't tell the difference between RGB16_565 and RGB24 for example. That's the bug I experienced above. This patch replaces mContentType by mImageFormat everywhere, so TextureImage knows its gfxImageFormat.\n\nThis made a second problem surface, as mIsRGBFormat was now redundant. Indeed, my understanding is that Cairo surfaces have BGR order, unless the format is RGB565, and then when using hw surfaces on Meego we always have RGB order. So I removed the mIsRGBFormat member, the IsRGB() method is now implementing the above logic (has to be checked by romaxa/heeen), so there's no redundancy anymore, and also I *think* we had bugs where we were not correctly updating mIsRGBFormat and these would now be fixed (in any case some code blocks got removed which is always nice).", "bug_id": 661002, "id": 5511968, "count": 10, "is_private": false, "time": "2011-06-03T22:14:07Z", "creation_time": "2011-06-03T22:14:07Z", "creator": "jacob.benoit.1@gmail.com", "author": "jacob.benoit.1@gmail.com"}, {"author": "matt.woodrow@gmail.com", "creator": "matt.woodrow@gmail.com", "creation_time": "2011-06-03T23:40:11Z", "time": "2011-06-03T23:40:11Z", "is_private": false, "count": 11, "id": 5512178, "text": "I haven't gone through this fully yet, but I can see at least one problem.\n\nGetAsImageSurface won't always succeed (at least for XlibSurfaces on GLX), so we might want to try handle this case too.\n\nCan we avoid allocating the texture until the first BeginUpdate/DirectUpdate and use the surface format at that point. If the surface is one that doesn't support GetAsImageSurface, then we need to allocate a temporary buffer and we control the source format.\n\nAlternatively we could just block GL layers on GLX when we don't have texture_from_pixmap (The only case where this would actually matter), throw lots of assertions in all over the place and hope we never need to support a platform that doesn't handle GetAsImageSurface().", "bug_id": 661002, "tags": [], "raw_text": "I haven't gone through this fully yet, but I can see at least one problem.\n\nGetAsImageSurface won't always succeed (at least for XlibSurfaces on GLX), so we might want to try handle this case too.\n\nCan we avoid allocating the texture until the first BeginUpdate/DirectUpdate and use the surface format at that point. If the surface is one that doesn't support GetAsImageSurface, then we need to allocate a temporary buffer and we control the source format.\n\nAlternatively we could just block GL layers on GLX when we don't have texture_from_pixmap (The only case where this would actually matter), throw lots of assertions in all over the place and hope we never need to support a platform that doesn't handle GetAsImageSurface().", "attachment_id": null}, {"attachment_id": null, "raw_text": "CocoaChildView.mm  change also needed here:\nhttp://mxr.mozilla.org/mozilla-central/source/widget/src/cocoa/nsChildView.mm#2036\notherwise it fail to compile on mac:\nhttp://tinderbox.mozilla.org/showlog.cgi?log=Try/1307216058.1307221722.5492.gz", "text": "CocoaChildView.mm  change also needed here:\nhttp://mxr.mozilla.org/mozilla-central/source/widget/src/cocoa/nsChildView.mm#2036\notherwise it fail to compile on mac:\nhttp://tinderbox.mozilla.org/showlog.cgi?log=Try/1307216058.1307221722.5492.gz", "bug_id": 661002, "tags": [], "count": 12, "id": 5514086, "is_private": false, "time": "2011-06-05T15:46:06Z", "creation_time": "2011-06-05T15:46:06Z", "creator": "romaxa@gmail.com", "author": "romaxa@gmail.com"}, {"author": "romaxa@gmail.com", "creator": "romaxa@gmail.com", "creation_time": "2011-06-05T15:50:36Z", "time": "2011-06-05T15:50:36Z", "is_private": false, "id": 5514088, "count": 13, "tags": [], "text": "GetAsImageSurface - will be a huge problem, because you call it just for ImageFormat extraction... but if that is XSurface, then it will cause alloc -> X->image copy -> dealloc", "bug_id": 661002, "raw_text": "GetAsImageSurface - will be a huge problem, because you call it just for ImageFormat extraction... but if that is XSurface, then it will cause alloc -> X->image copy -> dealloc", "attachment_id": null}, {"attachment_id": null, "raw_text": "would it be better to tweak gfxASurface::FormatFromContent function and make it return 24 or 16 depends on MOBILE_GFX define?", "bug_id": 661002, "text": "would it be better to tweak gfxASurface::FormatFromContent function and make it return 24 or 16 depends on MOBILE_GFX define?", "tags": [], "is_private": false, "count": 14, "id": 5514089, "creator": "romaxa@gmail.com", "creation_time": "2011-06-05T15:52:39Z", "time": "2011-06-05T15:52:39Z", "author": "romaxa@gmail.com"}, {"author": "romaxa@gmail.com", "time": "2011-06-05T15:56:00Z", "creation_time": "2011-06-05T15:56:00Z", "creator": "romaxa@gmail.com", "id": 5514091, "count": 15, "is_private": false, "text": "Or we can do it even this way:\ngfxASurface::gfxImageFormat\ngfxASurface::FormatFromContent(gfxASurface::gfxContentType type)\n{\n    switch (type) {\n        case CONTENT_COLOR_ALPHA:\n            return ImageFormatARGB32;\n        case CONTENT_ALPHA:\n            return ImageFormatA8;\n        case CONTENT_COLOR:\n        default:\n            return gfxPlatform::GetOffscreenFormat();\n    }\n}", "bug_id": 661002, "tags": [], "raw_text": "Or we can do it even this way:\ngfxASurface::gfxImageFormat\ngfxASurface::FormatFromContent(gfxASurface::gfxContentType type)\n{\n    switch (type) {\n        case CONTENT_COLOR_ALPHA:\n            return ImageFormatARGB32;\n        case CONTENT_ALPHA:\n            return ImageFormatA8;\n        case CONTENT_COLOR:\n        default:\n            return gfxPlatform::GetOffscreenFormat();\n    }\n}", "attachment_id": null}, {"raw_text": "(In reply to comment #13)\n> GetAsImageSurface - will be a huge problem, because you call it just for\n> ImageFormat extraction... but if that is XSurface, then it will cause alloc\n> -> X->image copy -> dealloc\n\nAh OK. What is the right way of getting the format of a gfxASurface?", "attachment_id": null, "tags": [], "text": "(In reply to comment #13)\n> GetAsImageSurface - will be a huge problem, because you call it just for\n> ImageFormat extraction... but if that is XSurface, then it will cause alloc\n> -> X->image copy -> dealloc\n\nAh OK. What is the right way of getting the format of a gfxASurface?", "bug_id": 661002, "is_private": false, "count": 16, "id": 5514367, "author": "jacob.benoit.1@gmail.com", "creator": "jacob.benoit.1@gmail.com", "creation_time": "2011-06-05T22:48:32Z", "time": "2011-06-05T22:48:32Z"}, {"count": 17, "id": 5514368, "is_private": false, "author": "jacob.benoit.1@gmail.com", "creation_time": "2011-06-05T22:49:52Z", "time": "2011-06-05T22:49:52Z", "creator": "jacob.benoit.1@gmail.com", "raw_text": "(In reply to comment #14)\n> would it be better to tweak gfxASurface::FormatFromContent function and make\n> it return 24 or 16 depends on MOBILE_GFX define?\n\nThat sure sounds like the right way, but do you know if gfxASurface::FormatFromContent has other users who might be broken by such a change?\n\nMXR search:\nhttp://mxr.mozilla.org/mozilla-central/ident?i=FormatFromContent&tree=mozilla-central&filter=", "attachment_id": null, "tags": [], "bug_id": 661002, "text": "(In reply to comment #14)\n> would it be better to tweak gfxASurface::FormatFromContent function and make\n> it return 24 or 16 depends on MOBILE_GFX define?\n\nThat sure sounds like the right way, but do you know if gfxASurface::FormatFromContent has other users who might be broken by such a change?\n\nMXR search:\nhttp://mxr.mozilla.org/mozilla-central/ident?i=FormatFromContent&tree=mozilla-central&filter="}, {"bug_id": 661002, "text": "(In reply to comment #16)\n> (In reply to comment #13)\n> > GetAsImageSurface - will be a huge problem, because you call it just for\n> > ImageFormat extraction... but if that is XSurface, then it will cause alloc\n> > -> X->image copy -> dealloc\n> \n> Ah OK. What is the right way of getting the format of a gfxASurface?\n\nThere doesn't seem to exist a way, is there?\n\nWe could query the surface type with GetType() and handle the few cases that we need manually, if we only need a few. How would we get the format of a gfxXlibSurface? Already that seems hard.", "tags": [], "attachment_id": null, "raw_text": "(In reply to comment #16)\n> (In reply to comment #13)\n> > GetAsImageSurface - will be a huge problem, because you call it just for\n> > ImageFormat extraction... but if that is XSurface, then it will cause alloc\n> > -> X->image copy -> dealloc\n> \n> Ah OK. What is the right way of getting the format of a gfxASurface?\n\nThere doesn't seem to exist a way, is there?\n\nWe could query the surface type with GetType() and handle the few cases that we need manually, if we only need a few. How would we get the format of a gfxXlibSurface? Already that seems hard.", "creation_time": "2011-06-06T02:01:27Z", "time": "2011-06-06T02:01:27Z", "creator": "jacob.benoit.1@gmail.com", "author": "jacob.benoit.1@gmail.com", "count": 18, "id": 5514469, "is_private": false}, {"is_private": false, "count": 19, "id": 5514476, "creator": "matt.woodrow@gmail.com", "time": "2011-06-06T02:09:24Z", "creation_time": "2011-06-06T02:09:24Z", "author": "matt.woodrow@gmail.com", "attachment_id": null, "raw_text": "There isn't necessarily an answer, which is why there's no defined method to retrieve it.\n\nFor surfaces that don't support GetAsImageSurface (gfxXlibSurface will return nsnull), the format isn't relevant as we need to do a manual copy to an image surface to access the pixel data. The internal data format could be (theoretically) something completely different and not even covered by the gfxImageFormat enum.\n\nThe only accurate way is to call GetAsImageSurface and use the format of that pointer. If that call returns nsnull, then we need to allocate a temporary image surface and make a copy, and we can get the format of the temporary.\n\nAs I said before, we can probably just avoid cases where this will actually happen and rely on GetAsImageSurface succeeding.", "bug_id": 661002, "text": "There isn't necessarily an answer, which is why there's no defined method to retrieve it.\n\nFor surfaces that don't support GetAsImageSurface (gfxXlibSurface will return nsnull), the format isn't relevant as we need to do a manual copy to an image surface to access the pixel data. The internal data format could be (theoretically) something completely different and not even covered by the gfxImageFormat enum.\n\nThe only accurate way is to call GetAsImageSurface and use the format of that pointer. If that call returns nsnull, then we need to allocate a temporary image surface and make a copy, and we can get the format of the temporary.\n\nAs I said before, we can probably just avoid cases where this will actually happen and rely on GetAsImageSurface succeeding.", "tags": []}, {"raw_text": "Here's a new version, see in GLContext.h the TextureImageFormatForSurface checking if GetAsImageSurface returned null, and OptimizedTextureImageFormat doing the 24bpp->16bpp optimization on mobile.", "attachment_id": 537598, "text": "Created attachment 537598\nFix TextureImage format handling\n\nHere's a new version, see in GLContext.h the TextureImageFormatForSurface checking if GetAsImageSurface returned null, and OptimizedTextureImageFormat doing the 24bpp->16bpp optimization on mobile.", "bug_id": 661002, "tags": [], "is_private": false, "id": 5515559, "count": 20, "author": "jacob.benoit.1@gmail.com", "creator": "jacob.benoit.1@gmail.com", "time": "2011-06-06T18:23:09Z", "creation_time": "2011-06-06T18:23:09Z"}, {"raw_text": "Here's the patch rebased on today's mozilla-central, in case it's useful to anyone.", "attachment_id": 542668, "tags": [], "bug_id": 661002, "text": "Created attachment 542668\nRebased patch\n\nHere's the patch rebased on today's mozilla-central, in case it's useful to anyone.", "id": 5563357, "count": 21, "is_private": false, "author": "chrislord.net@gmail.com", "time": "2011-06-28T23:58:06Z", "creation_time": "2011-06-28T23:58:06Z", "creator": "chrislord.net@gmail.com"}, {"raw_text": "I have a problem with red and blue being flipped occasionally with this patch. It apparently happens when a surface is resized or redrawn from RGB565 to RGBA32.\nI found that changing ShaderProgramTypeForImageFormat(gfxASurface::gfxImageFormat aFormat)\nfrom\n\ncase gfxASurface::ImageFormatARGB32:\n        return BGRALayerProgramType;\n\nto\n\ncase gfxASurface::ImageFormatARGB32:\n        return RGBALayerProgramType;\n\nfixes this problem, but I'm not sure if this solution also works on other platforms. It was mentioned that Meego hw surfaces have a different order than on android for example, I guess this is the cause.\nDoes that mean that our ImageFormat is actually wrong and should be something like gfxASurface::ImageFormatABGR32?", "attachment_id": null, "tags": [], "bug_id": 661002, "text": "I have a problem with red and blue being flipped occasionally with this patch. It apparently happens when a surface is resized or redrawn from RGB565 to RGBA32.\nI found that changing ShaderProgramTypeForImageFormat(gfxASurface::gfxImageFormat aFormat)\nfrom\n\ncase gfxASurface::ImageFormatARGB32:\n        return BGRALayerProgramType;\n\nto\n\ncase gfxASurface::ImageFormatARGB32:\n        return RGBALayerProgramType;\n\nfixes this problem, but I'm not sure if this solution also works on other platforms. It was mentioned that Meego hw surfaces have a different order than on android for example, I guess this is the cause.\nDoes that mean that our ImageFormat is actually wrong and should be something like gfxASurface::ImageFormatABGR32?", "is_private": false, "id": 5566789, "count": 22, "author": "florian.haenel@heeen.de", "creator": "florian.haenel@heeen.de", "time": "2011-06-30T10:51:47Z", "creation_time": "2011-06-30T10:51:47Z"}, {"author": "jmuizelaar@mozilla.com", "time": "2011-06-30T15:06:40Z", "creation_time": "2011-06-30T15:06:40Z", "creator": "jmuizelaar@mozilla.com", "id": 5567139, "count": 23, "is_private": false, "tags": [], "text": "(In reply to comment #22)\n> case gfxASurface::ImageFormatARGB32:\n>         return RGBALayerProgramType;\n\nThis is wrong. ImageFormatARGB32 is BGRALayerProgramType. It sounds like you're running into a either an extra swizzel or not enough swizzels.", "bug_id": 661002, "raw_text": "(In reply to comment #22)\n> case gfxASurface::ImageFormatARGB32:\n>         return RGBALayerProgramType;\n\nThis is wrong. ImageFormatARGB32 is BGRALayerProgramType. It sounds like you're running into a either an extra swizzel or not enough swizzels.", "attachment_id": null}, {"author": "jmuizelaar@mozilla.com", "time": "2011-06-30T19:03:58Z", "creation_time": "2011-06-30T19:03:58Z", "creator": "jmuizelaar@mozilla.com", "count": 24, "id": 5567833, "is_private": false, "tags": [], "bug_id": 661002, "text": "Here's a description of what happens normally:\n\ncairo's image surfaces are stored in memory as B,G,R,A. We upload these to texture with the format GL_RGBA and type of UNSIGNED_BYTE. These textures are\nstored in memory as R,G,B,A. So the data we pass in is technically wrong. However, when we use the BGRALayerProgramType we swap things back into place:\ngl_FragColor = color.bgra;\n\nPresumably, when using EGL surfaces this lie is not happening, and when we use the BGRALayerProgramType we do an extra swizzle.", "raw_text": "Here's a description of what happens normally:\n\ncairo's image surfaces are stored in memory as B,G,R,A. We upload these to texture with the format GL_RGBA and type of UNSIGNED_BYTE. These textures are\nstored in memory as R,G,B,A. So the data we pass in is technically wrong. However, when we use the BGRALayerProgramType we swap things back into place:\ngl_FragColor = color.bgra;\n\nPresumably, when using EGL surfaces this lie is not happening, and when we use the BGRALayerProgramType we do an extra swizzle.", "attachment_id": null}, {"is_private": false, "id": 5567865, "count": 25, "author": "jmuizelaar@mozilla.com", "creator": "jmuizelaar@mozilla.com", "time": "2011-06-30T19:17:44Z", "creation_time": "2011-06-30T19:17:44Z", "raw_text": "For what it's worth, BGRALayerProgramType should probably be rename to BGRAasRGBALayerProgramType", "attachment_id": null, "text": "For what it's worth, BGRALayerProgramType should probably be rename to BGRAasRGBALayerProgramType", "bug_id": 661002, "tags": []}, {"author": "florian.haenel@heeen.de", "time": "2011-07-04T13:34:58Z", "creation_time": "2011-07-04T13:34:58Z", "creator": "florian.haenel@heeen.de", "id": 5572550, "count": 26, "is_private": false, "bug_id": 661002, "text": "Created attachment 543759\nfixed red-blue flip\n\nI fixed the red-blue swizzle by overriding the mShaderType to the non-swizzling version if our Image has been acquired through locking.", "tags": [], "raw_text": "I fixed the red-blue swizzle by overriding the mShaderType to the non-swizzling version if our Image has been acquired through locking.", "attachment_id": 543759}, {"bug_id": 661002, "text": "Doing a rebase I noticed that there is now support for a luminance channel image in code that this patch ewplaces. Do we also support this?", "tags": [], "raw_text": "Doing a rebase I noticed that there is now support for a luminance channel image in code that this patch ewplaces. Do we also support this?", "attachment_id": null, "author": "florian.haenel@heeen.de", "creator": "florian.haenel@heeen.de", "creation_time": "2011-07-06T13:25:29Z", "time": "2011-07-06T13:25:29Z", "is_private": false, "id": 5576184, "count": 27}, {"count": 28, "id": 5578482, "is_private": false, "attachment_id": null, "raw_text": "After fixing it for egl locked surfaces this problem resurfaced on GLX. in the current code we have:\n\n606         if (aSurface->GetContentType() == gfxASurface::CONTENT_COLOR_ALPHA) {  \n607             mShaderType = gl::RGBALayerProgramType;                            \n608         } else {                                                               \n609             mShaderType = gl::RGBXLayerProgramType;                            \n610         \n}                                                                      \n\nwhile the patch changes this to:\n\n    case gfxASurface::ImageFormatARGB32:\n        return BGRALayerProgramType;\n    case gfxASurface::ImageFormatRGB24:\n        return BGRXLayerProgramType;\n\nSo we return BGRA shaders when we used to use RGBA shaders. Clearly we need to add a flag to the function telling it which order our channels are in.", "creation_time": "2011-07-07T13:23:59Z", "time": "2011-07-07T13:23:59Z", "creator": "florian.haenel@heeen.de", "tags": [], "text": "After fixing it for egl locked surfaces this problem resurfaced on GLX. in the current code we have:\n\n606         if (aSurface->GetContentType() == gfxASurface::CONTENT_COLOR_ALPHA) {  \n607             mShaderType = gl::RGBALayerProgramType;                            \n608         } else {                                                               \n609             mShaderType = gl::RGBXLayerProgramType;                            \n610         \n}                                                                      \n\nwhile the patch changes this to:\n\n    case gfxASurface::ImageFormatARGB32:\n        return BGRALayerProgramType;\n    case gfxASurface::ImageFormatRGB24:\n        return BGRXLayerProgramType;\n\nSo we return BGRA shaders when we used to use RGBA shaders. Clearly we need to add a flag to the function telling it which order our channels are in.", "bug_id": 661002, "author": "florian.haenel@heeen.de"}, {"bug_id": 661002, "text": "I can't see why you need to change this much.\n\nGetShaderProgramType should be the definitive check for a given TextureImage. UploadSurfaceForTexture will return the correct value to return here for all normal cairo surfaces. The only change that should be needed is to override the value of mShaderType when using a backing surface instead.\n\nRemoving IsRGB() seems worthwhile as it shouldn't actually be needed for anything.", "tags": [], "attachment_id": null, "raw_text": "I can't see why you need to change this much.\n\nGetShaderProgramType should be the definitive check for a given TextureImage. UploadSurfaceForTexture will return the correct value to return here for all normal cairo surfaces. The only change that should be needed is to override the value of mShaderType when using a backing surface instead.\n\nRemoving IsRGB() seems worthwhile as it shouldn't actually be needed for anything.", "time": "2011-07-07T14:03:03Z", "creation_time": "2011-07-07T14:03:03Z", "creator": "matt.woodrow@gmail.com", "author": "matt.woodrow@gmail.com", "count": 29, "id": 5578546, "is_private": false}, {"author": "chrislord.net@gmail.com", "time": "2011-07-07T15:01:06Z", "creation_time": "2011-07-07T15:01:06Z", "creator": "chrislord.net@gmail.com", "count": 30, "id": 5578666, "is_private": false, "bug_id": 661002, "text": "Created attachment 544488\nfixed red-blue flip (rebased)\n\nJust the most recent patch rebased onto more recent mozilla-central", "tags": [], "raw_text": "Just the most recent patch rebased onto more recent mozilla-central", "attachment_id": 544488}, {"raw_text": "I still think Comment 11 is the better approach here.\n\nThe specific pixel format should stay as implementation detail of each TextureImage subclass, and this can be communicated to shaders through GetShaderType().\n\nThe main issue is guessing an appropriate format in the constructor without knowing the format of the upload surfaces. If we delay texture creation until the first surface is available we fix this problem without extra code.", "attachment_id": null, "is_private": false, "id": 5578696, "count": 31, "author": "matt.woodrow@gmail.com", "bug_id": 661002, "text": "I still think Comment 11 is the better approach here.\n\nThe specific pixel format should stay as implementation detail of each TextureImage subclass, and this can be communicated to shaders through GetShaderType().\n\nThe main issue is guessing an appropriate format in the constructor without knowing the format of the upload surfaces. If we delay texture creation until the first surface is available we fix this problem without extra code.", "tags": [], "creator": "matt.woodrow@gmail.com", "time": "2011-07-07T15:14:43Z", "creation_time": "2011-07-07T15:14:43Z"}, {"tags": [], "text": "Created attachment 544499\nfixed red-blue flip (rebased)\n\nWhoops, actually make sure it builds this time.", "bug_id": 661002, "raw_text": "Whoops, actually make sure it builds this time.", "attachment_id": 544499, "author": "chrislord.net@gmail.com", "creation_time": "2011-07-07T15:34:14Z", "time": "2011-07-07T15:34:14Z", "creator": "chrislord.net@gmail.com", "id": 5578734, "count": 32, "is_private": false}, {"creation_time": "2011-07-07T16:30:16Z", "time": "2011-07-07T16:30:16Z", "creator": "matt.woodrow@gmail.com", "author": "matt.woodrow@gmail.com", "count": 33, "id": 5578849, "is_private": false, "tags": [], "text": "Does this bug still exist without the patch? The trace log above shows us calling Resize from the TextureImageEGL ctor, but I can't see that in the current code.\n\nWe still guess the mUpdateFormat incorrectly on android, but unless we call Resize or {Begin|End}Update this shouldn't ever be used.\n\nWith mobile (and a separate content process), we should only ever be doing texture updating via DirectUpdate. Is there ever a case where this isn't true?\n\nWe seem to have an inconsistent API for TextureImages:\n\nResize (used for copying pixel data from one image to another) assumes that the TextureImage will decide it's own pixel format, as was the case when only the {Being|End}Update calls existed.\n\nWith DirectUpdate we generally want to copy the pixel format of the passed surface to avoid needing to make an extra copy.\n\nI'll have a think about possible solutions for this.", "bug_id": 661002, "attachment_id": null, "raw_text": "Does this bug still exist without the patch? The trace log above shows us calling Resize from the TextureImageEGL ctor, but I can't see that in the current code.\n\nWe still guess the mUpdateFormat incorrectly on android, but unless we call Resize or {Begin|End}Update this shouldn't ever be used.\n\nWith mobile (and a separate content process), we should only ever be doing texture updating via DirectUpdate. Is there ever a case where this isn't true?\n\nWe seem to have an inconsistent API for TextureImages:\n\nResize (used for copying pixel data from one image to another) assumes that the TextureImage will decide it's own pixel format, as was the case when only the {Being|End}Update calls existed.\n\nWith DirectUpdate we generally want to copy the pixel format of the passed surface to avoid needing to make an extra copy.\n\nI'll have a think about possible solutions for this."}, {"author": "b56girard@gmail.com", "creation_time": "2011-07-25T20:09:29Z", "time": "2011-07-25T20:09:29Z", "creator": "b56girard@gmail.com", "count": 34, "id": 5611921, "is_private": false, "text": "This bug needs an owner, I will take it for now.", "bug_id": 661002, "tags": [], "raw_text": "This bug needs an owner, I will take it for now.", "attachment_id": null}, {"count": 35, "id": 5612422, "is_private": false, "author": "matt.woodrow@gmail.com", "time": "2011-07-25T22:14:40Z", "creation_time": "2011-07-25T22:14:40Z", "creator": "matt.woodrow@gmail.com", "raw_text": "(In reply to comment #33)\n> Does this bug still exist without the patch? The trace log above shows us\n> calling Resize from the TextureImageEGL ctor, but I can't see that in the\n> current code.\n\nLooks like this is only added in bug 660090. Might be better to change that patch to defer creation of the texture until we know an appropriate surface type to use.", "attachment_id": null, "tags": [], "bug_id": 661002, "text": "(In reply to comment #33)\n> Does this bug still exist without the patch? The trace log above shows us\n> calling Resize from the TextureImageEGL ctor, but I can't see that in the\n> current code.\n\nLooks like this is only added in bug 660090. Might be better to change that patch to defer creation of the texture until we know an appropriate surface type to use."}, {"text": "###!!! ASSERTION: Unknown GL type for Image format: 'Error', file /home/fhae/upstream/mozilla-central/gfx/thebes/GLContext.h, line 2297\n###!!! ASSERTION: Unknown GL shader type for Image format: 'Error', file /home/fhae/upstream/mozilla-central/gfx/thebes/GLContext.h, line 2321\n\non http://camendesign.com/code/video_for_everybody/test.html on meego/harmattan", "bug_id": 661002, "tags": [], "raw_text": "###!!! ASSERTION: Unknown GL type for Image format: 'Error', file /home/fhae/upstream/mozilla-central/gfx/thebes/GLContext.h, line 2297\n###!!! ASSERTION: Unknown GL shader type for Image format: 'Error', file /home/fhae/upstream/mozilla-central/gfx/thebes/GLContext.h, line 2321\n\non http://camendesign.com/code/video_for_everybody/test.html on meego/harmattan", "attachment_id": null, "author": "florian.haenel@heeen.de", "creator": "florian.haenel@heeen.de", "time": "2011-07-26T13:25:13Z", "creation_time": "2011-07-26T13:25:13Z", "is_private": false, "id": 5613625, "count": 36}, {"tags": [], "text": "Created attachment 548464\nfix luminance-only channel\n\nI added a fix for the the single channel textures used by video frames.\nMatt, you said you had bigger plans for this patch... do you have a rough idea so someone else could start with it? Or can we work on this patch?", "bug_id": 661002, "attachment_id": 548464, "raw_text": "I added a fix for the the single channel textures used by video frames.\nMatt, you said you had bigger plans for this patch... do you have a rough idea so someone else could start with it? Or can we work on this patch?", "creation_time": "2011-07-26T15:15:48Z", "time": "2011-07-26T15:15:48Z", "creator": "florian.haenel@heeen.de", "author": "florian.haenel@heeen.de", "id": 5613867, "count": 37, "is_private": false}, {"author": "ajuma.bugzilla@alijuma.com", "creation_time": "2011-08-02T15:35:29Z", "time": "2011-08-02T15:35:29Z", "creator": "ajuma.bugzilla@alijuma.com", "id": 5627811, "count": 38, "is_private": false, "text": "(In reply to comment #33)\n> With mobile (and a separate content process), we should only ever be doing\n> texture updating via DirectUpdate. Is there ever a case where this isn't\n> true?\n\nYes, we do still have texture updates occurring in EndUpdate (when Thebes layers are being rendered).", "bug_id": 661002, "tags": [], "raw_text": "(In reply to comment #33)\n> With mobile (and a separate content process), we should only ever be doing\n> texture updating via DirectUpdate. Is there ever a case where this isn't\n> true?\n\nYes, we do still have texture updates occurring in EndUpdate (when Thebes layers are being rendered).", "attachment_id": null}, {"is_private": false, "count": 39, "id": 5633624, "creator": "b56girard@gmail.com", "creation_time": "2011-08-04T17:34:23Z", "time": "2011-08-04T17:34:23Z", "author": "b56girard@gmail.com", "attachment_id": null, "raw_text": "Is this fixed by Bug 675210?", "bug_id": 661002, "text": "Is this fixed by Bug 675210?", "tags": []}, {"raw_text": "(In reply to comment #39)\n> Is this fixed by Bug 675210?\n\nWait, there's a real problem here which is that TextureImage doesn't know its precise format, despite having a precise format (since it holds a GL texture which has one). As a result we make bogus texImage2D/texSubImage2D calls as we have to guess the format, and we do that guesswork in 2 different ways that disagree with each other at least on mobile. This is a real problem that needs to be fixed, and I'm not sure how it can be fixed just by deferring allocation of textures? Even if that somehow made the bug disappear in practice we shouldn't rely on guesswork for our texImage2D/texSubImage2D calls so TextureImage should really know about its format.", "attachment_id": null, "tags": [], "text": "(In reply to comment #39)\n> Is this fixed by Bug 675210?\n\nWait, there's a real problem here which is that TextureImage doesn't know its precise format, despite having a precise format (since it holds a GL texture which has one). As a result we make bogus texImage2D/texSubImage2D calls as we have to guess the format, and we do that guesswork in 2 different ways that disagree with each other at least on mobile. This is a real problem that needs to be fixed, and I'm not sure how it can be fixed just by deferring allocation of textures? Even if that somehow made the bug disappear in practice we shouldn't rely on guesswork for our texImage2D/texSubImage2D calls so TextureImage should really know about its format.", "bug_id": 661002, "id": 5634257, "count": 40, "is_private": false, "author": "jacob.benoit.1@gmail.com", "creation_time": "2011-08-04T20:57:30Z", "time": "2011-08-04T20:57:30Z", "creator": "jacob.benoit.1@gmail.com"}, {"bug_id": 661002, "text": "In the case of DirectUpdate, the result of deferring allocation is that the texture is now allocated within GLContext::UploadSurfaceToTexture, where the correct format for the texture is chosen based on the format of the surface (that is, there is no guesswork here).\n\nSo the question then is if we also get format mismatches that do not involve DirectUpdate.", "tags": [], "raw_text": "In the case of DirectUpdate, the result of deferring allocation is that the texture is now allocated within GLContext::UploadSurfaceToTexture, where the correct format for the texture is chosen based on the format of the surface (that is, there is no guesswork here).\n\nSo the question then is if we also get format mismatches that do not involve DirectUpdate.", "attachment_id": null, "author": "ajuma.bugzilla@alijuma.com", "creator": "ajuma.bugzilla@alijuma.com", "creation_time": "2011-08-04T21:13:34Z", "time": "2011-08-04T21:13:34Z", "is_private": false, "count": 41, "id": 5634303}, {"is_private": false, "id": 5634364, "count": 42, "creator": "jacob.benoit.1@gmail.com", "creation_time": "2011-08-04T21:32:43Z", "time": "2011-08-04T21:32:43Z", "author": "jacob.benoit.1@gmail.com", "attachment_id": null, "raw_text": "OK but there's also a basic design issue here. If TextureImage holds a GL texture that has a precise format, why not store that format info in TextureImage? Why instead store a ContentType and have to rely on a function to deduce the format from it? Even if we get this deduction completely right and safe, that still looks like bad design to me.", "tags": [], "text": "OK but there's also a basic design issue here. If TextureImage holds a GL texture that has a precise format, why not store that format info in TextureImage? Why instead store a ContentType and have to rely on a function to deduce the format from it? Even if we get this deduction completely right and safe, that still looks like bad design to me.", "bug_id": 661002}]}}}