{"comments": {}, "bugs": {"697645": {"comments": [{"creator": "roc@ocallahan.org", "author": "roc@ocallahan.org", "creation_time": "2011-10-27T02:30:45Z", "raw_text": "The structure of our current border-rendering code leaves much to be desired. It's complicated, and it's also quite slow when combining complex features. In bug 696248, we see GMail combining border-radius and -moz-border-colors, as well as varying the colors by border side. It's slow because we use groups and paths and operator ADD, and try to get antialiasing right. There's a lot of overhead because these operations require graphics memory allocation and context state changes. However, a lot of the borders we draw are very thin and we're not actually rendering many pixels.\n\nSo an alternative would be to use a shader-like approach, where we directly compute for each pixel in the border what the rendered color should be. Here's an outline of how that might work:\nhttps://wiki.mozilla.org/Gecko:CSSBorderRenderingWithShaders\nMy hope is that that approach could be fast and accurate when using GPU rendering. It might even be fast(er) for our non-fast-path cases when using the CPU, especially if we specialize well for the sides. For the CPU case we would run the shader to generate a gfxImageSurface (or maybe four gfxImageSurfaces, to avoid allocating and filling a surface for the interior of a large element) and then draw those surfaces.", "text": "The structure of our current border-rendering code leaves much to be desired. It's complicated, and it's also quite slow when combining complex features. In bug 696248, we see GMail combining border-radius and -moz-border-colors, as well as varying the colors by border side. It's slow because we use groups and paths and operator ADD, and try to get antialiasing right. There's a lot of overhead because these operations require graphics memory allocation and context state changes. However, a lot of the borders we draw are very thin and we're not actually rendering many pixels.\n\nSo an alternative would be to use a shader-like approach, where we directly compute for each pixel in the border what the rendered color should be. Here's an outline of how that might work:\nhttps://wiki.mozilla.org/Gecko:CSSBorderRenderingWithShaders\nMy hope is that that approach could be fast and accurate when using GPU rendering. It might even be fast(er) for our non-fast-path cases when using the CPU, especially if we specialize well for the sides. For the CPU case we would run the shader to generate a gfxImageSurface (or maybe four gfxImageSurfaces, to avoid allocating and filling a surface for the interior of a large element) and then draw those surfaces.", "time": "2011-10-27T02:30:45Z", "attachment_id": null, "tags": [], "is_private": false, "count": 0, "id": 5808095, "bug_id": 697645}, {"bug_id": 697645, "tags": [], "count": 1, "is_private": false, "id": 5926495, "text": "Created attachment 582803\nWIP 1\n\nHere's what I have so far, some parts of it don't work and is not optimised yet (I use thebes to draw each pixel individually in corners!). Mostly what I want is feedback on the overall approach. The interesting code starts in nsCSSBorderShader.cpp under debugDrawDot().\n\nYou'll also notice that all borders have been hardcoded as solid red-blue in this patch for easy testing.", "attachment_id": 582803, "time": "2011-12-19T13:59:47Z", "creation_time": "2011-12-19T13:59:47Z", "raw_text": "Here's what I have so far, some parts of it don't work and is not optimised yet (I use thebes to draw each pixel individually in corners!). Mostly what I want is feedback on the overall approach. The interesting code starts in nsCSSBorderShader.cpp under debugDrawDot().\n\nYou'll also notice that all borders have been hardcoded as solid red-blue in this patch for easy testing.", "creator": "ventnor.bugzilla@gmail.com", "author": "ventnor.bugzilla@gmail.com"}, {"text": "Comment on attachment 582803\nWIP 1\n\nReview of attachment 582803:\n-----------------------------------------------------------------\n\nThe solid-color code looks like it's going in the right direction. Of course the dotted/dashed masking code has to be added, because the code you have only handles solid. The dotted/dashed masking computation should be cleanly separable.\n\nIt's probably worth ripping out all the parts of the old code that you aren't going to need.\n\n::: layout/base/nsCSSBorderShader.cpp\n@@ +88,5 @@\n> + *            |- DrawBorderSides with one side\n> + *         |- PopGroup\n> + *      |- for each side\n> + *         |- DoSideClipWithoutCornersSubPath\n> + *         |- DrawDashedSide || DrawBorderSides with one side\n\nThis comment is bogus, remove it.\n\nIt might have been better to not start by copying nsCSSBorderRendering. There's stuff in here that you don't need :-(.\n\n@@ +274,5 @@\n> +  return true;\n> +}\n> +\n> +gfxRect\n> +nsCSSBorderShader::GetCornerBounds(mozilla::css::Corner aCorner)\n\nPut \"using namespace mozilla::css;\" somewhere to avoid all this prefixing.\n\n@@ +372,5 @@\n> +\n> +\n> +static gfxRGBA\n> +RGBAFromTexture(const gfxImageSurface* aSurface,\n> +                const PRInt32 aPixel)\n\nI suggest working in ARGB PRUint32s instead of gfxRGBAs (which are expensive 4-doubles).\n\n@@ +375,5 @@\n> +RGBAFromTexture(const gfxImageSurface* aSurface,\n> +                const PRInt32 aPixel)\n> +{\n> +  if (aSurface->GetDataSize() == 0)\n> +    return gfxRGBA(0, 0, 0, 0);\n\nThis special case should not be needed. If necessary create a length-1 array with RGBA(0,0,0,0) in it and use that for zero-width borders.\n\n@@ +379,5 @@\n> +    return gfxRGBA(0, 0, 0, 0);\n> +\n> +  // We need to handle out-of-bounds pixels in this way,\n> +  // rather than simply returning transparent black, otherwise\n> +  // if we interpolate this color then we will move towards black.\n\nWhy would we interpolate the returned color? I would think that returning RGBA(0,0,0,0) for out-of-bounds colors is fine.\n\n@@ +391,5 @@\n> +    return closestPixel;\n> +  }\n> +\n> +  const PRUint32* packedData = (PRUint32*)aSurface->Data();\n> +  return gfxRGBA(packedData[aPixel], gfxRGBA::PACKED_ARGB_PREMULTIPLIED);\n\nWith the above changes this function can just be a very simple array lookup with bounds checks that return RGBA(0,0,0,0) for out of bounds. In fact you can optimize that by doing something like\n  PRUint32 index = PRUint32(aPixel);\n  return index < arrayLength ? array[index] : RGBA(0,0,0,0);\n\n@@ +414,5 @@\n> +\n> +  result.r = floorCol.r + (ceilCol.r - floorCol.r) * difference;\n> +  result.g = floorCol.g + (ceilCol.g - floorCol.g) * difference;\n> +  result.b = floorCol.b + (ceilCol.b - floorCol.b) * difference;\n> +  result.a = floorCol.a + (ceilCol.a - floorCol.a) * difference;\n\nRight idea, but as above I think you should work in PRUint32s here instead of gfxRGBAs.\n\n@@ +427,5 @@\n> +                                        const gfxRect& aCurvedBounds,\n> +                                        const gfxRect& aPixel)\n> +{\n> +  // Convert our pixel coords to cartesian coords.\n> +  // The ellipse origin is the corner of aCurvedBounds closest to the inner rect.\n\nI haven't checked the math in this function but the structure seems like the right idea.\n\n@@ +439,5 @@\n> +  if (mInnerRadii[aCorner].width > 0.0f && mInnerRadii[aCorner].height > 0.0f) {\n> +    innerE = (offsetFromOrigin.x * offsetFromOrigin.x) /\n> +               (mInnerRadii[aCorner].width * mInnerRadii[aCorner].width) +\n> +             (offsetFromOrigin.y * offsetFromOrigin.y) / \n> +               (mInnerRadii[aCorner].height * mInnerRadii[aCorner].height);\n\nThere are common subexpressions here independent of aPixel, so eventually we'll be able to speed this up by factoring them out of the per-pixel loop. For now, factoring them out in this function would simplify code as well as speeding things up, so do that too.\n\n@@ +488,5 @@\n> +                                      (mBorderRadii[aCorner].width * mBorderRadii[aCorner].width) +\n> +                                    (innerIntersect.y * innerIntersect.y) /\n> +                                      (mBorderRadii[aCorner].height * mBorderRadii[aCorner].height);\n> +\n> +    // We can now get a value within [0.0, 1.0] representing where the pixel is\n\nIt's not guaranteed to be within 0.0/1.0 right?\n\n@@ +546,5 @@\n> +    // number of pixels apart and should stay that way after\n> +    // rounding. We don't do this if there's a scale in the current transform\n> +    // since this loses information that might be relevant when we're scaling.\n> +    mOuterRect.Round();\n> +    mInnerRect.Round();\n\nI don't know that you really need to do this anymore...\n\n@@ +563,5 @@\n> +    imgCtx->Fill();\n> +    imgCtx->NewPath();\n> +    imgCtx->SetColor(gfxRGBA(0.0, 0.0, 1.0));\n> +    imgCtx->Rectangle(gfxRect(mBorderWidths[side] / 2, 0, mBorderWidths[side] / 2, 1));\n> +    imgCtx->Fill();\n\nYou don't need to use image surfaces to sample here. You could just use an array of PRUint32s. I recommend nsAutoTArray<PRUint32,3> say. And you shouldn't need to use Thebes to fill them.\n\n@@ +566,5 @@\n> +    imgCtx->Rectangle(gfxRect(mBorderWidths[side] / 2, 0, mBorderWidths[side] / 2, 1));\n> +    imgCtx->Fill();\n> +  }\n> +\n> +  NS_FOR_CSS_SIDES (side) {\n\nIt might be a good idea to put this entire loop body into a helper member function which is templated using the side value as a template parameter, and just call it four times. The compiler will probably be able to generate much better code that way.\n\n@@ +573,5 @@\n> +\n> +    // Begin painting from the inner edge, wherever that is\n> +    // TODO optimize this so we don't draw 1 pixel row at a time\n> +    gfxRect paintRect = GetSideBounds(side);\n> +    gfxFloat offsetCoefficient = 1; // Either 1 or -1, representing which direction we are going\n\nDocument what this actually means\n\n@@ +607,5 @@\n> +      mContext->Fill();\n> +\n> +      *offsetToChange += (1 * offsetCoefficient);\n> +\n> +      mContext->Restore();\n\nDon't need the save/restore pair.\n\nThis is heading in the right direction. One thing is that you can just loop over the border colors filling a rect for each one (as I'm sure you're aware). You don't need to use the texture image for that, just pull the color from a border colors array (see below for suggested interface changes).\n\n@@ +612,5 @@\n> +    }\n> +  }\n> +\n> +  NS_FOR_CSS_CORNERS (corner) {\n> +    // Draw corners pixel-by-pixel.\n\nIt might be a good idea to put this entire loop body into a templated member function and call it four times. That will let the compiler generate better code.\n\n@@ +656,5 @@\n> +        // (x1, y1) = separatorOuter, (x2, y2) = separatorInner, (x3, y3) = current pixel\n> +        triangleMatrix._32 = pixelRect.x;\n> +        triangleMatrix._33 = pixelRect.y;\n> +        mozilla::css::Side samplerSide;\n> +        if (triangleMatrix.Determinant() < 0) {\n\nYou can (and should) optimize this since you know what some of the entries are.\n\n@@ +662,5 @@\n> +          samplerSide = (mozilla::css::Side)corner;\n> +        } else {\n> +          // Go counter-clockwise (ie, in the top-left corner, look at the left side)\n> +          samplerSide = (mozilla::css::Side)((corner + 3) % 4);\n> +        }\n\nYou'll need to do something here to handle cases on the edge where we want to sample both sides and mix them (to get the antialising right where two sides have different colors). It probably makes sense to put the rest of this loop body into a helper function to which you can pass samplerSide as a parameter. Then when you're right in the middle you can call that function twice and average the values.\n\nOr, you can always call it twice and interpolate based on how far around the corner we are, to get a nice gradient effect.\n\n@@ +676,5 @@\n> +          // looking at.\n> +          switch (samplerSide) {\n> +            case NS_SIDE_TOP:\n> +              if (y >= mBorderWidths[samplerSide])\n> +                continue;\n\nMight be better to skip this early-exit check. RGBAFromTexture should quickly return RGBA(0,0,0,0) which gets cheaply stored in the output image (see below).\n\n@@ +700,5 @@\n> +\n> +        mContext->NewPath();\n> +        mContext->Rectangle(pixelRect);\n> +        mContext->SetColor(pixelResult);\n> +        mContext->Fill();\n\nDon't do this, doing cairo operations per pixel will be incredibly slow for any non-tiny corners. Instead, outside the per-corner loop create a gfxImageSurface that's big enough for each of the four corners, and in the per-pixel loop just set the image surface data value for that pixel. Then for each corner, draw the gfxImageSurface to mContext.\n\n::: layout/base/nsCSSBorderShader.h\n@@ +73,5 @@\n> + *\n> + * For any parameter where an array of side values is passed in,\n> + * they are in top, right, bottom, left order.\n> + *\n> + * borderStyles -- one border style enum per side\n\nYou'll want to document that this can only be one of SOLID, DOTTED or DASHED. The other styles can be converted to SOLID style with multiple border colors.\n\n@@ +105,5 @@\n> +                      const gfxFloat* aBorderWidths,\n> +                      gfxCornerSizes& aBorderRadii,\n> +                      const nscolor* aBorderColors,\n> +                      nsBorderColors* const* aCompositeColors,\n> +                      PRIntn aSkipSides,\n\nI think aSkipSides can be removed and we can just use a zero width on the sides that are to be skipped.\n\nI think aBorderColors and aCompositeColors should be combined into a single array of 4 structs, each of which is a pair of nscolor* mColors, PRUint32* mWidths, PRUint32 mColorCount. We do need a width to be specified separately for each border color. These widths will always be integer device pixels.\n\n@@ +106,5 @@\n> +                      gfxCornerSizes& aBorderRadii,\n> +                      const nscolor* aBorderColors,\n> +                      nsBorderColors* const* aCompositeColors,\n> +                      PRIntn aSkipSides,\n> +                      nscolor aBackgroundColor);\n\nNot sure why the background color is needed. It shouldn't be. Styles that depend on the background color should adjust the colors that get passed into nsCSSBorderShader. Basically we want to simplify the interface to nsCSSBorderShader as much as possible (and no more!).", "time": "2011-12-20T04:05:09Z", "attachment_id": 582803, "raw_text": "Review of attachment 582803:\n-----------------------------------------------------------------\n\nThe solid-color code looks like it's going in the right direction. Of course the dotted/dashed masking code has to be added, because the code you have only handles solid. The dotted/dashed masking computation should be cleanly separable.\n\nIt's probably worth ripping out all the parts of the old code that you aren't going to need.\n\n::: layout/base/nsCSSBorderShader.cpp\n@@ +88,5 @@\n> + *            |- DrawBorderSides with one side\n> + *         |- PopGroup\n> + *      |- for each side\n> + *         |- DoSideClipWithoutCornersSubPath\n> + *         |- DrawDashedSide || DrawBorderSides with one side\n\nThis comment is bogus, remove it.\n\nIt might have been better to not start by copying nsCSSBorderRendering. There's stuff in here that you don't need :-(.\n\n@@ +274,5 @@\n> +  return true;\n> +}\n> +\n> +gfxRect\n> +nsCSSBorderShader::GetCornerBounds(mozilla::css::Corner aCorner)\n\nPut \"using namespace mozilla::css;\" somewhere to avoid all this prefixing.\n\n@@ +372,5 @@\n> +\n> +\n> +static gfxRGBA\n> +RGBAFromTexture(const gfxImageSurface* aSurface,\n> +                const PRInt32 aPixel)\n\nI suggest working in ARGB PRUint32s instead of gfxRGBAs (which are expensive 4-doubles).\n\n@@ +375,5 @@\n> +RGBAFromTexture(const gfxImageSurface* aSurface,\n> +                const PRInt32 aPixel)\n> +{\n> +  if (aSurface->GetDataSize() == 0)\n> +    return gfxRGBA(0, 0, 0, 0);\n\nThis special case should not be needed. If necessary create a length-1 array with RGBA(0,0,0,0) in it and use that for zero-width borders.\n\n@@ +379,5 @@\n> +    return gfxRGBA(0, 0, 0, 0);\n> +\n> +  // We need to handle out-of-bounds pixels in this way,\n> +  // rather than simply returning transparent black, otherwise\n> +  // if we interpolate this color then we will move towards black.\n\nWhy would we interpolate the returned color? I would think that returning RGBA(0,0,0,0) for out-of-bounds colors is fine.\n\n@@ +391,5 @@\n> +    return closestPixel;\n> +  }\n> +\n> +  const PRUint32* packedData = (PRUint32*)aSurface->Data();\n> +  return gfxRGBA(packedData[aPixel], gfxRGBA::PACKED_ARGB_PREMULTIPLIED);\n\nWith the above changes this function can just be a very simple array lookup with bounds checks that return RGBA(0,0,0,0) for out of bounds. In fact you can optimize that by doing something like\n  PRUint32 index = PRUint32(aPixel);\n  return index < arrayLength ? array[index] : RGBA(0,0,0,0);\n\n@@ +414,5 @@\n> +\n> +  result.r = floorCol.r + (ceilCol.r - floorCol.r) * difference;\n> +  result.g = floorCol.g + (ceilCol.g - floorCol.g) * difference;\n> +  result.b = floorCol.b + (ceilCol.b - floorCol.b) * difference;\n> +  result.a = floorCol.a + (ceilCol.a - floorCol.a) * difference;\n\nRight idea, but as above I think you should work in PRUint32s here instead of gfxRGBAs.\n\n@@ +427,5 @@\n> +                                        const gfxRect& aCurvedBounds,\n> +                                        const gfxRect& aPixel)\n> +{\n> +  // Convert our pixel coords to cartesian coords.\n> +  // The ellipse origin is the corner of aCurvedBounds closest to the inner rect.\n\nI haven't checked the math in this function but the structure seems like the right idea.\n\n@@ +439,5 @@\n> +  if (mInnerRadii[aCorner].width > 0.0f && mInnerRadii[aCorner].height > 0.0f) {\n> +    innerE = (offsetFromOrigin.x * offsetFromOrigin.x) /\n> +               (mInnerRadii[aCorner].width * mInnerRadii[aCorner].width) +\n> +             (offsetFromOrigin.y * offsetFromOrigin.y) / \n> +               (mInnerRadii[aCorner].height * mInnerRadii[aCorner].height);\n\nThere are common subexpressions here independent of aPixel, so eventually we'll be able to speed this up by factoring them out of the per-pixel loop. For now, factoring them out in this function would simplify code as well as speeding things up, so do that too.\n\n@@ +488,5 @@\n> +                                      (mBorderRadii[aCorner].width * mBorderRadii[aCorner].width) +\n> +                                    (innerIntersect.y * innerIntersect.y) /\n> +                                      (mBorderRadii[aCorner].height * mBorderRadii[aCorner].height);\n> +\n> +    // We can now get a value within [0.0, 1.0] representing where the pixel is\n\nIt's not guaranteed to be within 0.0/1.0 right?\n\n@@ +546,5 @@\n> +    // number of pixels apart and should stay that way after\n> +    // rounding. We don't do this if there's a scale in the current transform\n> +    // since this loses information that might be relevant when we're scaling.\n> +    mOuterRect.Round();\n> +    mInnerRect.Round();\n\nI don't know that you really need to do this anymore...\n\n@@ +563,5 @@\n> +    imgCtx->Fill();\n> +    imgCtx->NewPath();\n> +    imgCtx->SetColor(gfxRGBA(0.0, 0.0, 1.0));\n> +    imgCtx->Rectangle(gfxRect(mBorderWidths[side] / 2, 0, mBorderWidths[side] / 2, 1));\n> +    imgCtx->Fill();\n\nYou don't need to use image surfaces to sample here. You could just use an array of PRUint32s. I recommend nsAutoTArray<PRUint32,3> say. And you shouldn't need to use Thebes to fill them.\n\n@@ +566,5 @@\n> +    imgCtx->Rectangle(gfxRect(mBorderWidths[side] / 2, 0, mBorderWidths[side] / 2, 1));\n> +    imgCtx->Fill();\n> +  }\n> +\n> +  NS_FOR_CSS_SIDES (side) {\n\nIt might be a good idea to put this entire loop body into a helper member function which is templated using the side value as a template parameter, and just call it four times. The compiler will probably be able to generate much better code that way.\n\n@@ +573,5 @@\n> +\n> +    // Begin painting from the inner edge, wherever that is\n> +    // TODO optimize this so we don't draw 1 pixel row at a time\n> +    gfxRect paintRect = GetSideBounds(side);\n> +    gfxFloat offsetCoefficient = 1; // Either 1 or -1, representing which direction we are going\n\nDocument what this actually means\n\n@@ +607,5 @@\n> +      mContext->Fill();\n> +\n> +      *offsetToChange += (1 * offsetCoefficient);\n> +\n> +      mContext->Restore();\n\nDon't need the save/restore pair.\n\nThis is heading in the right direction. One thing is that you can just loop over the border colors filling a rect for each one (as I'm sure you're aware). You don't need to use the texture image for that, just pull the color from a border colors array (see below for suggested interface changes).\n\n@@ +612,5 @@\n> +    }\n> +  }\n> +\n> +  NS_FOR_CSS_CORNERS (corner) {\n> +    // Draw corners pixel-by-pixel.\n\nIt might be a good idea to put this entire loop body into a templated member function and call it four times. That will let the compiler generate better code.\n\n@@ +656,5 @@\n> +        // (x1, y1) = separatorOuter, (x2, y2) = separatorInner, (x3, y3) = current pixel\n> +        triangleMatrix._32 = pixelRect.x;\n> +        triangleMatrix._33 = pixelRect.y;\n> +        mozilla::css::Side samplerSide;\n> +        if (triangleMatrix.Determinant() < 0) {\n\nYou can (and should) optimize this since you know what some of the entries are.\n\n@@ +662,5 @@\n> +          samplerSide = (mozilla::css::Side)corner;\n> +        } else {\n> +          // Go counter-clockwise (ie, in the top-left corner, look at the left side)\n> +          samplerSide = (mozilla::css::Side)((corner + 3) % 4);\n> +        }\n\nYou'll need to do something here to handle cases on the edge where we want to sample both sides and mix them (to get the antialising right where two sides have different colors). It probably makes sense to put the rest of this loop body into a helper function to which you can pass samplerSide as a parameter. Then when you're right in the middle you can call that function twice and average the values.\n\nOr, you can always call it twice and interpolate based on how far around the corner we are, to get a nice gradient effect.\n\n@@ +676,5 @@\n> +          // looking at.\n> +          switch (samplerSide) {\n> +            case NS_SIDE_TOP:\n> +              if (y >= mBorderWidths[samplerSide])\n> +                continue;\n\nMight be better to skip this early-exit check. RGBAFromTexture should quickly return RGBA(0,0,0,0) which gets cheaply stored in the output image (see below).\n\n@@ +700,5 @@\n> +\n> +        mContext->NewPath();\n> +        mContext->Rectangle(pixelRect);\n> +        mContext->SetColor(pixelResult);\n> +        mContext->Fill();\n\nDon't do this, doing cairo operations per pixel will be incredibly slow for any non-tiny corners. Instead, outside the per-corner loop create a gfxImageSurface that's big enough for each of the four corners, and in the per-pixel loop just set the image surface data value for that pixel. Then for each corner, draw the gfxImageSurface to mContext.\n\n::: layout/base/nsCSSBorderShader.h\n@@ +73,5 @@\n> + *\n> + * For any parameter where an array of side values is passed in,\n> + * they are in top, right, bottom, left order.\n> + *\n> + * borderStyles -- one border style enum per side\n\nYou'll want to document that this can only be one of SOLID, DOTTED or DASHED. The other styles can be converted to SOLID style with multiple border colors.\n\n@@ +105,5 @@\n> +                      const gfxFloat* aBorderWidths,\n> +                      gfxCornerSizes& aBorderRadii,\n> +                      const nscolor* aBorderColors,\n> +                      nsBorderColors* const* aCompositeColors,\n> +                      PRIntn aSkipSides,\n\nI think aSkipSides can be removed and we can just use a zero width on the sides that are to be skipped.\n\nI think aBorderColors and aCompositeColors should be combined into a single array of 4 structs, each of which is a pair of nscolor* mColors, PRUint32* mWidths, PRUint32 mColorCount. We do need a width to be specified separately for each border color. These widths will always be integer device pixels.\n\n@@ +106,5 @@\n> +                      gfxCornerSizes& aBorderRadii,\n> +                      const nscolor* aBorderColors,\n> +                      nsBorderColors* const* aCompositeColors,\n> +                      PRIntn aSkipSides,\n> +                      nscolor aBackgroundColor);\n\nNot sure why the background color is needed. It shouldn't be. Styles that depend on the background color should adjust the colors that get passed into nsCSSBorderShader. Basically we want to simplify the interface to nsCSSBorderShader as much as possible (and no more!).", "creation_time": "2011-12-20T04:05:09Z", "bug_id": 697645, "count": 2, "is_private": false, "tags": [], "id": 5928762, "creator": "roc@ocallahan.org", "author": "roc@ocallahan.org"}, {"creator": "ventnor.bugzilla@gmail.com", "author": "ventnor.bugzilla@gmail.com", "raw_text": "(In reply to Robert O'Callahan (:roc) (Mozilla Corporation) from comment #2)\n> @@ +372,5 @@\n> > +\n> > +\n> > +static gfxRGBA\n> > +RGBAFromTexture(const gfxImageSurface* aSurface,\n> > +                const PRInt32 aPixel)\n> \n> I suggest working in ARGB PRUint32s instead of gfxRGBAs (which are expensive\n> 4-doubles).\n\nWon't this cause endianness problems? Cairo may use BGRA instead of ARGB. I use gfxRGBA because it deals with endianness and because that's also what thebes uses.\n\n> @@ +379,5 @@\n> > +    return gfxRGBA(0, 0, 0, 0);\n> > +\n> > +  // We need to handle out-of-bounds pixels in this way,\n> > +  // rather than simply returning transparent black, otherwise\n> > +  // if we interpolate this color then we will move towards black.\n> \n> Why would we interpolate the returned color? I would think that returning\n> RGBA(0,0,0,0) for out-of-bounds colors is fine.\n\nThis is how we do texture sampling and is also how we get antialiasing along the edges. We do need to interpolate in this way otherwise the antialiased pixels on the edges will be darker than they should (because they are being interpolated towards black).\n\n> @@ +566,5 @@\n> > +    imgCtx->Rectangle(gfxRect(mBorderWidths[side] / 2, 0, mBorderWidths[side] / 2, 1));\n> > +    imgCtx->Fill();\n> > +  }\n> > +\n> > +  NS_FOR_CSS_SIDES (side) {\n> \n> It might be a good idea to put this entire loop body into a helper member\n> function which is templated using the side value as a template parameter,\n> and just call it four times. The compiler will probably be able to generate\n> much better code that way.\n\nTemplated? You mean passing in the side as a parameter, right? Because side values are the same type.\n\nAlso, I used to have an array of gfxRGBAs but I changed it to a texture because I thought that's what you wanted. I can go back to an array but using a custom struct for colours might cause endianness problems as I mentioned before.", "creation_time": "2011-12-20T05:55:25Z", "text": "(In reply to Robert O'Callahan (:roc) (Mozilla Corporation) from comment #2)\n> @@ +372,5 @@\n> > +\n> > +\n> > +static gfxRGBA\n> > +RGBAFromTexture(const gfxImageSurface* aSurface,\n> > +                const PRInt32 aPixel)\n> \n> I suggest working in ARGB PRUint32s instead of gfxRGBAs (which are expensive\n> 4-doubles).\n\nWon't this cause endianness problems? Cairo may use BGRA instead of ARGB. I use gfxRGBA because it deals with endianness and because that's also what thebes uses.\n\n> @@ +379,5 @@\n> > +    return gfxRGBA(0, 0, 0, 0);\n> > +\n> > +  // We need to handle out-of-bounds pixels in this way,\n> > +  // rather than simply returning transparent black, otherwise\n> > +  // if we interpolate this color then we will move towards black.\n> \n> Why would we interpolate the returned color? I would think that returning\n> RGBA(0,0,0,0) for out-of-bounds colors is fine.\n\nThis is how we do texture sampling and is also how we get antialiasing along the edges. We do need to interpolate in this way otherwise the antialiased pixels on the edges will be darker than they should (because they are being interpolated towards black).\n\n> @@ +566,5 @@\n> > +    imgCtx->Rectangle(gfxRect(mBorderWidths[side] / 2, 0, mBorderWidths[side] / 2, 1));\n> > +    imgCtx->Fill();\n> > +  }\n> > +\n> > +  NS_FOR_CSS_SIDES (side) {\n> \n> It might be a good idea to put this entire loop body into a helper member\n> function which is templated using the side value as a template parameter,\n> and just call it four times. The compiler will probably be able to generate\n> much better code that way.\n\nTemplated? You mean passing in the side as a parameter, right? Because side values are the same type.\n\nAlso, I used to have an array of gfxRGBAs but I changed it to a texture because I thought that's what you wanted. I can go back to an array but using a custom struct for colours might cause endianness problems as I mentioned before.", "attachment_id": null, "time": "2011-12-20T05:55:25Z", "is_private": false, "count": 3, "tags": [], "id": 5928882, "bug_id": 697645}, {"creation_time": "2011-12-20T07:01:33Z", "raw_text": "(In reply to Michael Ventnor from comment #3)\n> (In reply to Robert O'Callahan (:roc) (Mozilla Corporation) from comment #2)\n> > I suggest working in ARGB PRUint32s instead of gfxRGBAs (which are expensive\n> > 4-doubles).\n> \n> Won't this cause endianness problems? Cairo may use BGRA instead of ARGB. I\n> use gfxRGBA because it deals with endianness and because that's also what\n> thebes uses.\n\nNo, gfxImageSurface pixel buffers are always ARGB PRUint32s. Endianness isn't a problem, v >> 24 is always the alpha value etc.\n\n> > @@ +379,5 @@\n> > > +    return gfxRGBA(0, 0, 0, 0);\n> > > +\n> > > +  // We need to handle out-of-bounds pixels in this way,\n> > > +  // rather than simply returning transparent black, otherwise\n> > > +  // if we interpolate this color then we will move towards black.\n> > \n> > Why would we interpolate the returned color? I would think that returning\n> > RGBA(0,0,0,0) for out-of-bounds colors is fine.\n> \n> This is how we do texture sampling and is also how we get antialiasing along\n> the edges.\n\nOK.\n\n> > @@ +566,5 @@\n> > > +    imgCtx->Rectangle(gfxRect(mBorderWidths[side] / 2, 0, mBorderWidths[side] / 2, 1));\n> > > +    imgCtx->Fill();\n> > > +  }\n> > > +\n> > > +  NS_FOR_CSS_SIDES (side) {\n> > \n> > It might be a good idea to put this entire loop body into a helper member\n> > function which is templated using the side value as a template parameter,\n> > and just call it four times. The compiler will probably be able to generate\n> > much better code that way.\n> \n> Templated? You mean passing in the side as a parameter, right? Because side\n> values are the same type.\n\nI mean like this:\ntemplate <Side aSide> DoStuff(...)\n{\n  ...\n  if (aSide == NS_SIDE_TOP)\n    ...\n  ...\n}\n...\nDoStuff<NS_SIDE_TOP>(...);\nDoStuff<NS_SIDE_RIGHT>(...);\nDoStuff<NS_SIDE_BOTTOM>(...);\nDoStuff<NS_SIDE_LEFT>(...);", "text": "(In reply to Michael Ventnor from comment #3)\n> (In reply to Robert O'Callahan (:roc) (Mozilla Corporation) from comment #2)\n> > I suggest working in ARGB PRUint32s instead of gfxRGBAs (which are expensive\n> > 4-doubles).\n> \n> Won't this cause endianness problems? Cairo may use BGRA instead of ARGB. I\n> use gfxRGBA because it deals with endianness and because that's also what\n> thebes uses.\n\nNo, gfxImageSurface pixel buffers are always ARGB PRUint32s. Endianness isn't a problem, v >> 24 is always the alpha value etc.\n\n> > @@ +379,5 @@\n> > > +    return gfxRGBA(0, 0, 0, 0);\n> > > +\n> > > +  // We need to handle out-of-bounds pixels in this way,\n> > > +  // rather than simply returning transparent black, otherwise\n> > > +  // if we interpolate this color then we will move towards black.\n> > \n> > Why would we interpolate the returned color? I would think that returning\n> > RGBA(0,0,0,0) for out-of-bounds colors is fine.\n> \n> This is how we do texture sampling and is also how we get antialiasing along\n> the edges.\n\nOK.\n\n> > @@ +566,5 @@\n> > > +    imgCtx->Rectangle(gfxRect(mBorderWidths[side] / 2, 0, mBorderWidths[side] / 2, 1));\n> > > +    imgCtx->Fill();\n> > > +  }\n> > > +\n> > > +  NS_FOR_CSS_SIDES (side) {\n> > \n> > It might be a good idea to put this entire loop body into a helper member\n> > function which is templated using the side value as a template parameter,\n> > and just call it four times. The compiler will probably be able to generate\n> > much better code that way.\n> \n> Templated? You mean passing in the side as a parameter, right? Because side\n> values are the same type.\n\nI mean like this:\ntemplate <Side aSide> DoStuff(...)\n{\n  ...\n  if (aSide == NS_SIDE_TOP)\n    ...\n  ...\n}\n...\nDoStuff<NS_SIDE_TOP>(...);\nDoStuff<NS_SIDE_RIGHT>(...);\nDoStuff<NS_SIDE_BOTTOM>(...);\nDoStuff<NS_SIDE_LEFT>(...);", "time": "2011-12-20T07:01:33Z", "attachment_id": null, "tags": [], "count": 4, "is_private": false, "id": 5928938, "bug_id": 697645, "creator": "roc@ocallahan.org", "author": "roc@ocallahan.org"}, {"creator": "roc@ocallahan.org", "text": "(In reply to Michael Ventnor from comment #3)\n> Also, I used to have an array of gfxRGBAs but I changed it to a texture\n> because I thought that's what you wanted.\n\nI want to use the *idea* of texture sampling, but the implementation should be whatever is simple and fast :-).", "attachment_id": null, "time": "2011-12-20T07:06:13Z", "author": "roc@ocallahan.org", "creation_time": "2011-12-20T07:06:13Z", "raw_text": "(In reply to Michael Ventnor from comment #3)\n> Also, I used to have an array of gfxRGBAs but I changed it to a texture\n> because I thought that's what you wanted.\n\nI want to use the *idea* of texture sampling, but the implementation should be whatever is simple and fast :-).", "bug_id": 697645, "count": 5, "is_private": false, "tags": [], "id": 5928940}, {"creator": "ventnor.bugzilla@gmail.com", "author": "ventnor.bugzilla@gmail.com", "raw_text": "", "creation_time": "2012-01-02T11:14:11Z", "text": "Created attachment 585270\nWIP2", "attachment_id": 585270, "time": "2012-01-02T11:14:11Z", "tags": [], "count": 6, "is_private": false, "id": 5949492, "bug_id": 697645}, {"creation_time": "2012-01-06T03:08:48Z", "raw_text": "OK, status update!\n\nI've fixed some of your comments, however I want to make the patch feature-complete before I start on the optimizations.\nI've got support for \"perfect\" dotted borders. This means that dotted border sides will fit within whatever space they have, dots are painted in a corner, and in a rectangular box you'll end up with a symmetrical border. However, if a corner has a border-radius I fall back to solid corners like before.\nI'm now starting on making dashed borders \"perfect\", this might be a bit harder but I'm thinking we should make the corners solid, and fit the dashes on each side.", "text": "OK, status update!\n\nI've fixed some of your comments, however I want to make the patch feature-complete before I start on the optimizations.\nI've got support for \"perfect\" dotted borders. This means that dotted border sides will fit within whatever space they have, dots are painted in a corner, and in a rectangular box you'll end up with a symmetrical border. However, if a corner has a border-radius I fall back to solid corners like before.\nI'm now starting on making dashed borders \"perfect\", this might be a bit harder but I'm thinking we should make the corners solid, and fit the dashes on each side.", "attachment_id": null, "time": "2012-01-06T03:08:48Z", "tags": [], "is_private": false, "count": 7, "id": 5959504, "bug_id": 697645, "creator": "ventnor.bugzilla@gmail.com", "author": "ventnor.bugzilla@gmail.com"}, {"creation_time": "2012-01-06T03:16:57Z", "raw_text": "(In reply to Michael Ventnor from comment #7)\n> I've got support for \"perfect\" dotted borders. This means that dotted border\n> sides will fit within whatever space they have, dots are painted in a\n> corner, and in a rectangular box you'll end up with a symmetrical border.\n> However, if a corner has a border-radius I fall back to solid corners like\n> before.\n\nGreat! When are you planning to fix that? Fixing that is an important part of this bug. (And a hard part.) I'd encourage you to fix that early since it's risky.\n\n> I'm now starting on making dashed borders \"perfect\", this might be a bit\n> harder but I'm thinking we should make the corners solid, and fit the dashes\n> on each side.\n\nThe middle of a dash should go in the corner. We don't want to have a single square sitting in the corner.", "text": "(In reply to Michael Ventnor from comment #7)\n> I've got support for \"perfect\" dotted borders. This means that dotted border\n> sides will fit within whatever space they have, dots are painted in a\n> corner, and in a rectangular box you'll end up with a symmetrical border.\n> However, if a corner has a border-radius I fall back to solid corners like\n> before.\n\nGreat! When are you planning to fix that? Fixing that is an important part of this bug. (And a hard part.) I'd encourage you to fix that early since it's risky.\n\n> I'm now starting on making dashed borders \"perfect\", this might be a bit\n> harder but I'm thinking we should make the corners solid, and fit the dashes\n> on each side.\n\nThe middle of a dash should go in the corner. We don't want to have a single square sitting in the corner.", "time": "2012-01-06T03:16:57Z", "attachment_id": null, "tags": [], "is_private": false, "count": 8, "id": 5959525, "bug_id": 697645, "creator": "roc@ocallahan.org", "author": "roc@ocallahan.org"}, {"author": "roc@ocallahan.org", "creator": "roc@ocallahan.org", "creation_time": "2012-01-06T03:23:53Z", "raw_text": "Basically I would say: put a dash centered in each corner (in other words, with the line defining the boundary between the two sides going straight through it). If a side doesn't have enough room for a reasonable-sized gap between those two dashes, just draw it solid. Otherwise make all dashes on the side the same length, and calculate how many dashes will fit with a minimum gap between each one. Then allow the gap between dashes to grow a bit if necessary to make the dashes evenly spaced.\n\nHaving dashes and dots centered on the side boundary is important if the style changes between dashed/dotted/solid at a corner. It means you'll get a half-dash/half-dot combination instead of a lone half-dot or half-dash, for example.", "attachment_id": null, "time": "2012-01-06T03:23:53Z", "text": "Basically I would say: put a dash centered in each corner (in other words, with the line defining the boundary between the two sides going straight through it). If a side doesn't have enough room for a reasonable-sized gap between those two dashes, just draw it solid. Otherwise make all dashes on the side the same length, and calculate how many dashes will fit with a minimum gap between each one. Then allow the gap between dashes to grow a bit if necessary to make the dashes evenly spaced.\n\nHaving dashes and dots centered on the side boundary is important if the style changes between dashed/dotted/solid at a corner. It means you'll get a half-dash/half-dot combination instead of a lone half-dot or half-dash, for example.", "id": 5959537, "is_private": false, "count": 9, "tags": [], "bug_id": 697645}, {"id": 5959594, "is_private": false, "count": 10, "tags": [], "bug_id": 697645, "creation_time": "2012-01-06T04:04:20Z", "raw_text": "(In reply to Robert O'Callahan (:roc) (Mozilla Corporation) from comment #8)\n> (In reply to Michael Ventnor from comment #7)\n> > I've got support for \"perfect\" dotted borders. This means that dotted border\n> > sides will fit within whatever space they have, dots are painted in a\n> > corner, and in a rectangular box you'll end up with a symmetrical border.\n> > However, if a corner has a border-radius I fall back to solid corners like\n> > before.\n> \n> Great! When are you planning to fix that? Fixing that is an important part\n> of this bug. (And a hard part.) I'd encourage you to fix that early since\n> it's risky.\n\nAdmittedly I wasn't planning on fixing it at first because in order to do so I'd need to juggle:\n1) Laying dots on the border curve\n2) Making sure a dot is on the border boundary\n3) And still make sure the dots are spaced pleasingly\n\nand I didn't think it'd be possible to do so with my current approach in a performant way. But, I'm thinking about it some more now. I'm getting somewhere, but not enough to get anything working yet.\n\n> > I'm now starting on making dashed borders \"perfect\", this might be a bit\n> > harder but I'm thinking we should make the corners solid, and fit the dashes\n> > on each side.\n> \n> The middle of a dash should go in the corner. We don't want to have a single\n> square sitting in the corner.\n\nYeah, that's what I was going to do. But I'll think about the dotted problem some more.", "attachment_id": null, "time": "2012-01-06T04:04:20Z", "author": "ventnor.bugzilla@gmail.com", "creator": "ventnor.bugzilla@gmail.com", "text": "(In reply to Robert O'Callahan (:roc) (Mozilla Corporation) from comment #8)\n> (In reply to Michael Ventnor from comment #7)\n> > I've got support for \"perfect\" dotted borders. This means that dotted border\n> > sides will fit within whatever space they have, dots are painted in a\n> > corner, and in a rectangular box you'll end up with a symmetrical border.\n> > However, if a corner has a border-radius I fall back to solid corners like\n> > before.\n> \n> Great! When are you planning to fix that? Fixing that is an important part\n> of this bug. (And a hard part.) I'd encourage you to fix that early since\n> it's risky.\n\nAdmittedly I wasn't planning on fixing it at first because in order to do so I'd need to juggle:\n1) Laying dots on the border curve\n2) Making sure a dot is on the border boundary\n3) And still make sure the dots are spaced pleasingly\n\nand I didn't think it'd be possible to do so with my current approach in a performant way. But, I'm thinking about it some more now. I'm getting somewhere, but not enough to get anything working yet.\n\n> > I'm now starting on making dashed borders \"perfect\", this might be a bit\n> > harder but I'm thinking we should make the corners solid, and fit the dashes\n> > on each side.\n> \n> The middle of a dash should go in the corner. We don't want to have a single\n> square sitting in the corner.\n\nYeah, that's what I was going to do. But I'll think about the dotted problem some more."}, {"bug_id": 697645, "tags": [], "is_private": false, "count": 11, "id": 5959601, "text": "(In reply to Michael Ventnor from comment #10)\n> Admittedly I wasn't planning on fixing it at first because in order to do so\n> I'd need to juggle:\n> 1) Laying dots on the border curve\n> 2) Making sure a dot is on the border boundary\n> 3) And still make sure the dots are spaced pleasingly\n> and I didn't think it'd be possible to do so with my current approach in a\n> performant way. But, I'm thinking about it some more now. I'm getting\n> somewhere, but not enough to get anything working yet.\n\nYou need to calculate for a given point, \"how far along\" the centerline of the border the pixel is, starting from the line that separates the two sides. That shouldn't be too hard to do. Then, assuming you've precalculated the distance between dot centers, you can figure out which dot the pixel is closest to, compute the center point for that dot, and check whether the pixel is inside it (or on the edge, for antialiasing).", "time": "2012-01-06T04:11:59Z", "attachment_id": null, "creation_time": "2012-01-06T04:11:59Z", "raw_text": "(In reply to Michael Ventnor from comment #10)\n> Admittedly I wasn't planning on fixing it at first because in order to do so\n> I'd need to juggle:\n> 1) Laying dots on the border curve\n> 2) Making sure a dot is on the border boundary\n> 3) And still make sure the dots are spaced pleasingly\n> and I didn't think it'd be possible to do so with my current approach in a\n> performant way. But, I'm thinking about it some more now. I'm getting\n> somewhere, but not enough to get anything working yet.\n\nYou need to calculate for a given point, \"how far along\" the centerline of the border the pixel is, starting from the line that separates the two sides. That shouldn't be too hard to do. Then, assuming you've precalculated the distance between dot centers, you can figure out which dot the pixel is closest to, compute the center point for that dot, and check whether the pixel is inside it (or on the edge, for antialiasing).", "creator": "roc@ocallahan.org", "author": "roc@ocallahan.org"}, {"id": 5959606, "tags": [], "is_private": false, "count": 12, "bug_id": 697645, "raw_text": "I forgot to mention, there's also the case where the two border sides are of different widths. I was planning on having a mid-sized dot centered on the border boundary.\nCurrently, I calculate a separate space size for each border side, and therefore I don't think every space in the corner can be uniform like your approach suggests AFAICT.", "creation_time": "2012-01-06T04:21:35Z", "attachment_id": null, "time": "2012-01-06T04:21:35Z", "text": "I forgot to mention, there's also the case where the two border sides are of different widths. I was planning on having a mid-sized dot centered on the border boundary.\nCurrently, I calculate a separate space size for each border side, and therefore I don't think every space in the corner can be uniform like your approach suggests AFAICT.", "author": "ventnor.bugzilla@gmail.com", "creator": "ventnor.bugzilla@gmail.com"}, {"creator": "roc@ocallahan.org", "text": "(In reply to Michael Ventnor from comment #12)\n> I forgot to mention, there's also the case where the two border sides are of\n> different widths. I was planning on having a mid-sized dot centered on the\n> border boundary.\n\nI'd just make half the dot bigger than the other half.", "author": "roc@ocallahan.org", "time": "2012-01-06T04:26:53Z", "attachment_id": null, "raw_text": "(In reply to Michael Ventnor from comment #12)\n> I forgot to mention, there's also the case where the two border sides are of\n> different widths. I was planning on having a mid-sized dot centered on the\n> border boundary.\n\nI'd just make half the dot bigger than the other half.", "creation_time": "2012-01-06T04:26:53Z", "bug_id": 697645, "tags": [], "count": 13, "is_private": false, "id": 5959608}, {"text": "(In reply to Robert O'Callahan (:roc) (Mozilla Corporation) from comment #13)\n> (In reply to Michael Ventnor from comment #12)\n> > I forgot to mention, there's also the case where the two border sides are of\n> > different widths. I was planning on having a mid-sized dot centered on the\n> > border boundary.\n> \n> I'd just make half the dot bigger than the other half.\n\nThat probably wouldn't look very nice, but I guess it's easier so I'll do that.\nAnother situation is where you have a corner with high width but small height, so the line boundary would be very close to the edge of the corner's temporary surface. The corner surface already been created by the time we realize this, so I don't think we can just change the size of the surface.", "time": "2012-01-06T04:32:10Z", "attachment_id": null, "creation_time": "2012-01-06T04:32:10Z", "raw_text": "(In reply to Robert O'Callahan (:roc) (Mozilla Corporation) from comment #13)\n> (In reply to Michael Ventnor from comment #12)\n> > I forgot to mention, there's also the case where the two border sides are of\n> > different widths. I was planning on having a mid-sized dot centered on the\n> > border boundary.\n> \n> I'd just make half the dot bigger than the other half.\n\nThat probably wouldn't look very nice, but I guess it's easier so I'll do that.\nAnother situation is where you have a corner with high width but small height, so the line boundary would be very close to the edge of the corner's temporary surface. The corner surface already been created by the time we realize this, so I don't think we can just change the size of the surface.", "bug_id": 697645, "tags": [], "is_private": false, "count": 14, "id": 5959617, "creator": "ventnor.bugzilla@gmail.com", "author": "ventnor.bugzilla@gmail.com"}, {"bug_id": 697645, "id": 5959650, "tags": [], "is_private": false, "count": 15, "attachment_id": null, "time": "2012-01-06T04:55:43Z", "text": "Hmm yeah, we don't want the border to stick out of the border-box! So we do want different sizes for the dots in the corner, and maybe you're right that we need per-dot sizes and spacing.\n\nOne way to do this would be to create a 1D-texture/array that maps \"distance along the border\" to the index of the nearest dot, and an extra 1D-texture/array that maps from the dot index to its center and radius. Then you can do an array lookup to find which dot the pixel belongs to, and another array lookup to find its center and radius.", "raw_text": "Hmm yeah, we don't want the border to stick out of the border-box! So we do want different sizes for the dots in the corner, and maybe you're right that we need per-dot sizes and spacing.\n\nOne way to do this would be to create a 1D-texture/array that maps \"distance along the border\" to the index of the nearest dot, and an extra 1D-texture/array that maps from the dot index to its center and radius. Then you can do an array lookup to find which dot the pixel belongs to, and another array lookup to find its center and radius.", "creation_time": "2012-01-06T04:55:43Z", "author": "roc@ocallahan.org", "creator": "roc@ocallahan.org"}, {"text": "(In reply to Robert O'Callahan (:roc) (Mozilla Corporation) from comment #15)\n> Hmm yeah, we don't want the border to stick out of the border-box! So we do\n> want different sizes for the dots in the corner, and maybe you're right that\n> we need per-dot sizes and spacing.\n> \n> One way to do this would be to create a 1D-texture/array that maps \"distance\n> along the border\" to the index of the nearest dot, and an extra\n> 1D-texture/array that maps from the dot index to its center and radius. Then\n> you can do an array lookup to find which dot the pixel belongs to, and\n> another array lookup to find its center and radius.\n\nWhat is this trying to solve? This seems awfully complicated and slow.\nOne solution i thought up: first precalculate the position of each dot. Then, for each pixel, test the distance between the pixel and the dot center is within the radius (this can be fast if we square the radius instead of using sqrt), if so then simply use that dot.", "time": "2012-01-06T05:07:27Z", "attachment_id": null, "raw_text": "(In reply to Robert O'Callahan (:roc) (Mozilla Corporation) from comment #15)\n> Hmm yeah, we don't want the border to stick out of the border-box! So we do\n> want different sizes for the dots in the corner, and maybe you're right that\n> we need per-dot sizes and spacing.\n> \n> One way to do this would be to create a 1D-texture/array that maps \"distance\n> along the border\" to the index of the nearest dot, and an extra\n> 1D-texture/array that maps from the dot index to its center and radius. Then\n> you can do an array lookup to find which dot the pixel belongs to, and\n> another array lookup to find its center and radius.\n\nWhat is this trying to solve? This seems awfully complicated and slow.\nOne solution i thought up: first precalculate the position of each dot. Then, for each pixel, test the distance between the pixel and the dot center is within the radius (this can be fast if we square the radius instead of using sqrt), if so then simply use that dot.", "creation_time": "2012-01-06T05:07:27Z", "bug_id": 697645, "is_private": false, "count": 16, "tags": [], "id": 5959664, "creator": "ventnor.bugzilla@gmail.com", "author": "ventnor.bugzilla@gmail.com"}, {"author": "roc@ocallahan.org", "creator": "roc@ocallahan.org", "creation_time": "2012-01-06T05:09:33Z", "raw_text": "(In reply to Michael Ventnor from comment #16)\n> What is this trying to solve? This seems awfully complicated and slow.\n> One solution i thought up: first precalculate the position of each dot.\n> Then, for each pixel, test the distance between the pixel and the dot center\n> is within the radius (this can be fast if we square the radius instead of\n> using sqrt), if so then simply use that dot.\n\nRight. But how do you calculate which dot to check, and what the radius and center of that dot is? With variable spacing etc it's going to be tricky. Hence I'm suggesting using array lookups to figure out which dot you're closest to and what its center and radius are.", "attachment_id": null, "time": "2012-01-06T05:09:33Z", "text": "(In reply to Michael Ventnor from comment #16)\n> What is this trying to solve? This seems awfully complicated and slow.\n> One solution i thought up: first precalculate the position of each dot.\n> Then, for each pixel, test the distance between the pixel and the dot center\n> is within the radius (this can be fast if we square the radius instead of\n> using sqrt), if so then simply use that dot.\n\nRight. But how do you calculate which dot to check, and what the radius and center of that dot is? With variable spacing etc it's going to be tricky. Hence I'm suggesting using array lookups to figure out which dot you're closest to and what its center and radius are.", "id": 5959669, "count": 17, "is_private": false, "tags": [], "bug_id": 697645}, {"author": "ventnor.bugzilla@gmail.com", "creator": "ventnor.bugzilla@gmail.com", "id": 5959681, "tags": [], "count": 18, "is_private": false, "bug_id": 697645, "raw_text": "(In reply to Robert O'Callahan (:roc) (Mozilla Corporation) from comment #17)\n> (In reply to Michael Ventnor from comment #16)\n> > What is this trying to solve? This seems awfully complicated and slow.\n> > One solution i thought up: first precalculate the position of each dot.\n> > Then, for each pixel, test the distance between the pixel and the dot center\n> > is within the radius (this can be fast if we square the radius instead of\n> > using sqrt), if so then simply use that dot.\n> \n> Right. But how do you calculate which dot to check, and what the radius and\n> center of that dot is? With variable spacing etc it's going to be tricky.\n> Hence I'm suggesting using array lookups to figure out which dot you're\n> closest to and what its center and radius are.\n\nBut I read your comment again and I don't understand how your approach solves those problems either.", "creation_time": "2012-01-06T05:18:16Z", "time": "2012-01-06T05:18:16Z", "attachment_id": null, "text": "(In reply to Robert O'Callahan (:roc) (Mozilla Corporation) from comment #17)\n> (In reply to Michael Ventnor from comment #16)\n> > What is this trying to solve? This seems awfully complicated and slow.\n> > One solution i thought up: first precalculate the position of each dot.\n> > Then, for each pixel, test the distance between the pixel and the dot center\n> > is within the radius (this can be fast if we square the radius instead of\n> > using sqrt), if so then simply use that dot.\n> \n> Right. But how do you calculate which dot to check, and what the radius and\n> center of that dot is? With variable spacing etc it's going to be tricky.\n> Hence I'm suggesting using array lookups to figure out which dot you're\n> closest to and what its center and radius are.\n\nBut I read your comment again and I don't understand how your approach solves those problems either."}, {"tags": [], "is_private": false, "count": 19, "id": 5959694, "bug_id": 697645, "raw_text": "(In reply to Michael Ventnor from comment #18)\n> (In reply to Robert O'Callahan (:roc) (Mozilla Corporation) from comment #17)\n> > (In reply to Michael Ventnor from comment #16)\n> > > What is this trying to solve? This seems awfully complicated and slow.\n> > > One solution i thought up: first precalculate the position of each dot.\n> > > Then, for each pixel, test the distance between the pixel and the dot center\n> > > is within the radius (this can be fast if we square the radius instead of\n> > > using sqrt), if so then simply use that dot.\n> > \n> > Right. But how do you calculate which dot to check, and what the radius and\n> > center of that dot is? With variable spacing etc it's going to be tricky.\n> > Hence I'm suggesting using array lookups to figure out which dot you're\n> > closest to and what its center and radius are.\n> \n> But I read your comment again and I don't understand how your approach\n> solves those problems either.\n\n(I mean in a way that my approach doesn't solve. What I do is precalculate where the dots should go, then test each pixel against every dot (optimizing this test as much as I can), and the first dot that the pixel falls within is the dot that is used to draw that pixel)", "creation_time": "2012-01-06T05:28:59Z", "text": "(In reply to Michael Ventnor from comment #18)\n> (In reply to Robert O'Callahan (:roc) (Mozilla Corporation) from comment #17)\n> > (In reply to Michael Ventnor from comment #16)\n> > > What is this trying to solve? This seems awfully complicated and slow.\n> > > One solution i thought up: first precalculate the position of each dot.\n> > > Then, for each pixel, test the distance between the pixel and the dot center\n> > > is within the radius (this can be fast if we square the radius instead of\n> > > using sqrt), if so then simply use that dot.\n> > \n> > Right. But how do you calculate which dot to check, and what the radius and\n> > center of that dot is? With variable spacing etc it's going to be tricky.\n> > Hence I'm suggesting using array lookups to figure out which dot you're\n> > closest to and what its center and radius are.\n> \n> But I read your comment again and I don't understand how your approach\n> solves those problems either.\n\n(I mean in a way that my approach doesn't solve. What I do is precalculate where the dots should go, then test each pixel against every dot (optimizing this test as much as I can), and the first dot that the pixel falls within is the dot that is used to draw that pixel)", "creator": "ventnor.bugzilla@gmail.com", "author": "ventnor.bugzilla@gmail.com", "attachment_id": null, "time": "2012-01-06T05:28:59Z"}, {"count": 20, "is_private": false, "tags": [], "id": 5959768, "bug_id": 697645, "creation_time": "2012-01-06T06:35:55Z", "raw_text": "(In reply to Michael Ventnor from comment #19)\n> (I mean in a way that my approach doesn't solve. What I do is precalculate\n> where the dots should go, then test each pixel against every dot (optimizing\n> this test as much as I can)\n\nHow? If there are 20 dots, comparing each pixel against each dot sounds bad.", "text": "(In reply to Michael Ventnor from comment #19)\n> (I mean in a way that my approach doesn't solve. What I do is precalculate\n> where the dots should go, then test each pixel against every dot (optimizing\n> this test as much as I can)\n\nHow? If there are 20 dots, comparing each pixel against each dot sounds bad.", "time": "2012-01-06T06:35:55Z", "attachment_id": null, "creator": "roc@ocallahan.org", "author": "roc@ocallahan.org"}, {"bug_id": 697645, "id": 5988534, "tags": [], "is_private": false, "count": 21, "time": "2012-01-18T13:39:21Z", "attachment_id": null, "text": "OK, I've been spending many days now trying to get a good approach for \"distance-along-curve\" going that I can use for dots and I still can't get it quite right.\n\n- To get a curve of a specified length, in order to place the dots, I use the elliptical integral, and approximate using a binary search. But it doesn't seem to measure length in a linear way, at least with curves that have a huge width and tiny height or vice-versa. It's tough to explain.\n\n- To find out how far along the curve a pixel is, I extrapolate the line from the corner point to the pixel, and see where that intersects the curve. That falls apart with pixels close to the corner, due to the angles between them being very wide and thus extrapolating to a point on the ellipse too far away. I haven't yet thought of a better approach.\n\nThis is taking far longer than even my pessimistic estimates. There are so many bugs and edge cases to deal with.", "creation_time": "2012-01-18T13:39:21Z", "raw_text": "OK, I've been spending many days now trying to get a good approach for \"distance-along-curve\" going that I can use for dots and I still can't get it quite right.\n\n- To get a curve of a specified length, in order to place the dots, I use the elliptical integral, and approximate using a binary search. But it doesn't seem to measure length in a linear way, at least with curves that have a huge width and tiny height or vice-versa. It's tough to explain.\n\n- To find out how far along the curve a pixel is, I extrapolate the line from the corner point to the pixel, and see where that intersects the curve. That falls apart with pixels close to the corner, due to the angles between them being very wide and thus extrapolating to a point on the ellipse too far away. I haven't yet thought of a better approach.\n\nThis is taking far longer than even my pessimistic estimates. There are so many bugs and edge cases to deal with.", "author": "ventnor.bugzilla@gmail.com", "creator": "ventnor.bugzilla@gmail.com"}, {"raw_text": "How can I help?", "creation_time": "2012-01-19T03:04:53Z", "text": "How can I help?", "time": "2012-01-19T03:04:53Z", "attachment_id": null, "tags": [], "is_private": false, "count": 22, "id": 5991081, "bug_id": 697645, "creator": "roc@ocallahan.org", "author": "roc@ocallahan.org"}, {"bug_id": 697645, "is_private": false, "count": 23, "tags": [], "id": 5991230, "text": "The biggest help would be more time ;) but what I need is a more foolproof way of approximating how far any pixel is along a given curve (even if said pixel doesn't lie on the curve), if the ellipse center is known.\n\nAn easier way would be to do what I said before, which is simply test against each dot's radius (which, looking at the code I have, may arguably be faster).\n\nBut then there's the problem with the dashes, where having this measure-distance-of-a-pixel function would be useful to determine whether a pixel is within a dash or space.", "attachment_id": null, "time": "2012-01-19T05:07:12Z", "creation_time": "2012-01-19T05:07:12Z", "raw_text": "The biggest help would be more time ;) but what I need is a more foolproof way of approximating how far any pixel is along a given curve (even if said pixel doesn't lie on the curve), if the ellipse center is known.\n\nAn easier way would be to do what I said before, which is simply test against each dot's radius (which, looking at the code I have, may arguably be faster).\n\nBut then there's the problem with the dashes, where having this measure-distance-of-a-pixel function would be useful to determine whether a pixel is within a dash or space.", "creator": "ventnor.bugzilla@gmail.com", "author": "ventnor.bugzilla@gmail.com"}, {"author": "ventnor.bugzilla@gmail.com", "creator": "ventnor.bugzilla@gmail.com", "creation_time": "2012-01-19T06:37:17Z", "raw_text": "This really is frustrating, because once again it's the situation where what I have works fine for circular borders but not for elliptical borders with non-equal axes.", "time": "2012-01-19T06:37:17Z", "attachment_id": 589787, "text": "Created attachment 589787\nWIP3\n\nThis really is frustrating, because once again it's the situation where what I have works fine for circular borders but not for elliptical borders with non-equal axes.", "id": 5991330, "tags": [], "is_private": false, "count": 24, "bug_id": 697645}, {"raw_text": "I've made a canvas-based prototype in JS that handles all the features. It behaves poorly in a few cases; one of them is fixable with some more computational geometry, and I think the other issues are tolerable. I think it can be implemented fairly efficiently. We should have done this sort of prototype at the beginning :-(.", "creation_time": "2012-01-21T14:16:01Z", "text": "I've made a canvas-based prototype in JS that handles all the features. It behaves poorly in a few cases; one of them is fixable with some more computational geometry, and I think the other issues are tolerable. I think it can be implemented fairly efficiently. We should have done this sort of prototype at the beginning :-(.", "time": "2012-01-21T14:16:01Z", "attachment_id": null, "count": 25, "is_private": false, "tags": [], "id": 5998069, "bug_id": 697645, "creator": "roc@ocallahan.org", "author": "roc@ocallahan.org"}, {"attachment_id": 590464, "time": "2012-01-21T14:22:34Z", "text": "Created attachment 590464\nthe prototype\n\nHave a play with this.", "creation_time": "2012-01-21T14:22:34Z", "raw_text": "Have a play with this.", "bug_id": 697645, "id": 5998082, "tags": [], "is_private": false, "count": 26, "author": "roc@ocallahan.org", "creator": "roc@ocallahan.org"}, {"author": "roc@ocallahan.org", "creator": "roc@ocallahan.org", "bug_id": 697645, "id": 5998471, "tags": [], "is_private": false, "count": 27, "time": "2012-01-21T20:22:18Z", "attachment_id": null, "text": "BTW I realize that for some cases (e.g. groove) we want an abrupt transition between the colors for each side, instead of the smooth transition that the prototype does. That's easy to change (or make optional).", "raw_text": "BTW I realize that for some cases (e.g. groove) we want an abrupt transition between the colors for each side, instead of the smooth transition that the prototype does. That's easy to change (or make optional).", "creation_time": "2012-01-21T20:22:18Z"}, {"id": 5998711, "tags": [], "is_private": false, "count": 28, "bug_id": 697645, "raw_text": "Add some comments, simplify some testcases, and fix some antialiasing failures.", "creation_time": "2012-01-22T02:38:08Z", "attachment_id": 590532, "time": "2012-01-22T02:38:08Z", "text": "Created attachment 590532\nupdated again\n\nAdd some comments, simplify some testcases, and fix some antialiasing failures.", "author": "roc@ocallahan.org", "creator": "roc@ocallahan.org"}, {"creator": "ventnor.bugzilla@gmail.com", "author": "ventnor.bugzilla@gmail.com", "text": "roc, I have made some progress since I made that last comment, sorry if I gave off the impression otherwise. I'll talk with you about this when you're available over email or IRC.", "attachment_id": null, "time": "2012-01-22T03:20:12Z", "raw_text": "roc, I have made some progress since I made that last comment, sorry if I gave off the impression otherwise. I'll talk with you about this when you're available over email or IRC.", "creation_time": "2012-01-22T03:20:12Z", "bug_id": 697645, "count": 29, "is_private": false, "tags": [], "id": 5998723}, {"author": "ventnor.bugzilla@gmail.com", "creator": "ventnor.bugzilla@gmail.com", "raw_text": "Ok, so an update. Sorry about the lack of communication, I've been really busy.\nI FINALLY fixed a crucial and difficult bug in my code, which has then allowed me to progress very rapidly. Dotted borders work, dashed borders work, and they are all calculated to fit within the sides and corners perfectly.\n\nWe're at the stage where we could ship this if we really wanted to. We're down to bug-hunting and polish and optimisations.\n\nSorry roc, I didn't use your prototype, it fell apart in too many areas (for example, straight sides within corner boundaries). Your prototype uses trigonometry whereas mine uses calculus, so I guess mine is a little slower however it seems much more robust from my testing.", "creation_time": "2012-02-02T11:46:59Z", "attachment_id": null, "time": "2012-02-02T11:46:59Z", "text": "Ok, so an update. Sorry about the lack of communication, I've been really busy.\nI FINALLY fixed a crucial and difficult bug in my code, which has then allowed me to progress very rapidly. Dotted borders work, dashed borders work, and they are all calculated to fit within the sides and corners perfectly.\n\nWe're at the stage where we could ship this if we really wanted to. We're down to bug-hunting and polish and optimisations.\n\nSorry roc, I didn't use your prototype, it fell apart in too many areas (for example, straight sides within corner boundaries). Your prototype uses trigonometry whereas mine uses calculus, so I guess mine is a little slower however it seems much more robust from my testing.", "id": 6028524, "count": 30, "is_private": false, "tags": [], "bug_id": 697645}, {"raw_text": "Can you put the code up so we can discuss it?", "creation_time": "2012-02-02T11:53:12Z", "attachment_id": null, "time": "2012-02-02T11:53:12Z", "text": "Can you put the code up so we can discuss it?", "id": 6028529, "count": 31, "is_private": false, "tags": [], "bug_id": 697645, "author": "roc@ocallahan.org", "creator": "roc@ocallahan.org"}, {"creation_time": "2012-02-02T23:37:00Z", "raw_text": "I didn't upload it last night because it was spread over two queue patches in a non-sensical way, I've merged it now.", "text": "Created attachment 593989\nWIP 4\n\nI didn't upload it last night because it was spread over two queue patches in a non-sensical way, I've merged it now.", "attachment_id": 593989, "time": "2012-02-02T23:37:00Z", "is_private": false, "count": 32, "tags": [], "id": 6030769, "bug_id": 697645, "creator": "ventnor.bugzilla@gmail.com", "author": "ventnor.bugzilla@gmail.com"}, {"creation_time": "2012-02-03T05:48:01Z", "raw_text": "This is a simple page that lets you edit border styles interactively.", "attachment_id": 594072, "time": "2012-02-03T05:48:01Z", "text": "Created attachment 594072\nsimple page for playing with borders\n\nThis is a simple page that lets you edit border styles interactively.", "id": 6031413, "tags": [], "is_private": false, "count": 33, "bug_id": 697645, "author": "roc@ocallahan.org", "creator": "roc@ocallahan.org"}, {"text": "With\n#d { border-radius:100px/200px; border-width:10px; border-style:dotted; border-color:black; }\nonly the top and bottom sides are dotted, for me.", "time": "2012-02-03T05:48:49Z", "attachment_id": null, "creation_time": "2012-02-03T05:48:49Z", "raw_text": "With\n#d { border-radius:100px/200px; border-width:10px; border-style:dotted; border-color:black; }\nonly the top and bottom sides are dotted, for me.", "bug_id": 697645, "tags": [], "count": 34, "is_private": false, "id": 6031414, "creator": "roc@ocallahan.org", "author": "roc@ocallahan.org"}, {"creator": "roc@ocallahan.org", "text": "Oops, that was me using the wrong build.", "time": "2012-02-03T05:59:13Z", "attachment_id": null, "author": "roc@ocallahan.org", "creation_time": "2012-02-03T05:59:13Z", "raw_text": "Oops, that was me using the wrong build.", "bug_id": 697645, "count": 35, "is_private": false, "tags": [], "id": 6031424}, {"creator": "roc@ocallahan.org", "author": "roc@ocallahan.org", "bug_id": 697645, "tags": [], "is_private": false, "count": 36, "id": 6036584, "text": "Created attachment 594622\ncomprehensive testcase\n\nI wrote this as a testcase to systematically test various combinations of border-width, border-radius, and border-style. When I load it with the patch, I get some kind of memory corruption. On Windows, in a debug build, I get alerts from the VC++ runtime about memory being modified beyond the end of the allocated block when it frees the pixel data block for one of the corner surfaces.", "attachment_id": 594622, "time": "2012-02-06T04:11:23Z", "raw_text": "I wrote this as a testcase to systematically test various combinations of border-width, border-radius, and border-style. When I load it with the patch, I get some kind of memory corruption. On Windows, in a debug build, I get alerts from the VC++ runtime about memory being modified beyond the end of the allocated block when it frees the pixel data block for one of the corner surfaces.", "creation_time": "2012-02-06T04:11:23Z"}, {"bug_id": 697645, "id": 6036585, "count": 37, "is_private": false, "tags": [], "attachment_id": 594623, "time": "2012-02-06T04:11:56Z", "text": "Created attachment 594623\nreduced testcase\n\nThe error reproduces with this testcase.", "creation_time": "2012-02-06T04:11:56Z", "raw_text": "The error reproduces with this testcase.", "author": "roc@ocallahan.org", "creator": "roc@ocallahan.org"}, {"creator": "ventnor.bugzilla@gmail.com", "author": "ventnor.bugzilla@gmail.com", "count": 38, "is_private": false, "tags": [], "id": 6039381, "bug_id": 697645, "creation_time": "2012-02-07T02:28:21Z", "raw_text": "Is this a crash or just a warning? Because I get no problems on Linux (and I don't have VC++ on Windows...)", "text": "Is this a crash or just a warning? Because I get no problems on Linux (and I don't have VC++ on Windows...)", "time": "2012-02-07T02:28:21Z", "attachment_id": null}, {"creator": "roc@ocallahan.org", "author": "roc@ocallahan.org", "text": "It's a warning, but it blocks my debug build, and maybe would crash anyway. Writing out of bounds is bad. Try using valgrind?", "attachment_id": null, "time": "2012-02-07T02:58:37Z", "raw_text": "It's a warning, but it blocks my debug build, and maybe would crash anyway. Writing out of bounds is bad. Try using valgrind?", "creation_time": "2012-02-07T02:58:37Z", "bug_id": 697645, "tags": [], "count": 39, "is_private": false, "id": 6039439}, {"author": "ventnor.bugzilla@gmail.com", "creator": "ventnor.bugzilla@gmail.com", "bug_id": 697645, "id": 6039767, "tags": [], "count": 40, "is_private": false, "time": "2012-02-07T06:44:02Z", "attachment_id": 594921, "text": "Created attachment 594921\nWIP5\n\nI think I know what was causing this. I'm comparing an int to a float in the for loops, but there could be some float errors that causes us to have one extra looping, and an out of bounds error.\n\nI used the same fix that I used for the 0-pixel corner surfaces on bugzilla.", "creation_time": "2012-02-07T06:44:02Z", "raw_text": "I think I know what was causing this. I'm comparing an int to a float in the for loops, but there could be some float errors that causes us to have one extra looping, and an out of bounds error.\n\nI used the same fix that I used for the 0-pixel corner surfaces on bugzilla."}, {"id": 6040133, "tags": [], "is_private": false, "count": 41, "bug_id": 697645, "raw_text": "Thanks, that seems to fix the memory corruption.\n\nLooking at the testcase in comment #36, some quick observations by section:\n\nwidth:100px; height:100px; border-width:18px; border-radius:0\nThese look great.\n\nwidth:100px; height:100px; border-width:18px; border-radius:40px\nThese look great, except for \"dotted none\" where there are half-dots.\n\nwidth:100px; height:100px; border-width:18px; border-radius:10px/50px\nwidth:100px; height:100px; border-width:18px; border-radius:0/50px\nwidth:100px; height:100px; border-width:18px; border-radius:50px/10px\nwidth:100px; height:100px; border-width:12px 48px; border-radius:0\nwidth:100px; height:100px; border-width:12px 48px; border-radius:40px\nwidth:100px; height:100px; border-width:12px 48px; border-radius:10px/50px\nwidth:100px; height:100px; border-width:12px 48px; border-radius:0/50px\nwidth:100px; height:100px; border-width:12px 48px; border-radius:50px/10px\nwidth:100px; height:100px; border-width:12px 48px; border-radius:0/10px\nUnfortunately, these mostly look terrible.", "creation_time": "2012-02-07T12:10:09Z", "attachment_id": null, "time": "2012-02-07T12:10:09Z", "text": "Thanks, that seems to fix the memory corruption.\n\nLooking at the testcase in comment #36, some quick observations by section:\n\nwidth:100px; height:100px; border-width:18px; border-radius:0\nThese look great.\n\nwidth:100px; height:100px; border-width:18px; border-radius:40px\nThese look great, except for \"dotted none\" where there are half-dots.\n\nwidth:100px; height:100px; border-width:18px; border-radius:10px/50px\nwidth:100px; height:100px; border-width:18px; border-radius:0/50px\nwidth:100px; height:100px; border-width:18px; border-radius:50px/10px\nwidth:100px; height:100px; border-width:12px 48px; border-radius:0\nwidth:100px; height:100px; border-width:12px 48px; border-radius:40px\nwidth:100px; height:100px; border-width:12px 48px; border-radius:10px/50px\nwidth:100px; height:100px; border-width:12px 48px; border-radius:0/50px\nwidth:100px; height:100px; border-width:12px 48px; border-radius:50px/10px\nwidth:100px; height:100px; border-width:12px 48px; border-radius:0/10px\nUnfortunately, these mostly look terrible.", "author": "roc@ocallahan.org", "creator": "roc@ocallahan.org"}, {"raw_text": "Adding a 5px border-radius. On the most recent patch, the radius looks more like 2px, and doesn't get antialiased. There are also some glitches in the corners with some of the border-style combinations.", "creation_time": "2012-02-08T03:18:43Z", "text": "Created attachment 595288\nadd 5px border-radius case\n\nAdding a 5px border-radius. On the most recent patch, the radius looks more like 2px, and doesn't get antialiased. There are also some glitches in the corners with some of the border-style combinations.", "attachment_id": 595288, "time": "2012-02-08T03:18:43Z", "count": 42, "is_private": false, "tags": [], "id": 6042722, "bug_id": 697645, "creator": "roc@ocallahan.org", "author": "roc@ocallahan.org"}, {"bug_id": 697645, "tags": [], "count": 43, "is_private": false, "id": 6042759, "text": "Created attachment 595292\nadd 4px border-width case\n\nThe 4px cases where the border-radii are greater than the width are not too bad. For highly elliptic radii, the boundary line between the colors is placed in a strange place.", "time": "2012-02-08T03:50:48Z", "attachment_id": 595292, "creation_time": "2012-02-08T03:50:48Z", "raw_text": "The 4px cases where the border-radii are greater than the width are not too bad. For highly elliptic radii, the boundary line between the colors is placed in a strange place.", "creator": "roc@ocallahan.org", "author": "roc@ocallahan.org"}, {"creator": "roc@ocallahan.org", "author": "roc@ocallahan.org", "bug_id": 697645, "tags": [], "is_private": false, "count": 44, "id": 6042761, "text": "Created attachment 595293\nadd border-width:4px 8px case\n\nFor width:100px; height:100px; border-width:4px 8px; border-radius:0, the junctions between solid and dashed sides aren't right.", "time": "2012-02-08T03:54:53Z", "attachment_id": 595293, "creation_time": "2012-02-08T03:54:53Z", "raw_text": "For width:100px; height:100px; border-width:4px 8px; border-radius:0, the junctions between solid and dashed sides aren't right."}, {"creator": "jmuizelaar@mozilla.com", "author": "jmuizelaar@mozilla.com", "creation_time": "2012-02-08T04:44:12Z", "raw_text": "Review of attachment 594921:\n-----------------------------------------------------------------\n\nSome thought spew (I've written it out of order so hopefully it makes some sense)\n\nI'd be very interested to see some performance numbers for this code.\n\nIt looks like one of the tricky bits is the lack of a parametrization of the ellipse by arc length. It's possible we can come up with a performant version of that runs well on the gpu (I've talked with bjacob about it), but if we can't I'm not sure the current approach is a good one. For example, with dotted borders, if we know all of the positions of the dots we are probably better of just drawing them explicitly instead of implicitly with a complicated pixel shader.\n\nThat being said, there's still value in a reference implementation of the border drawing that's easy to understand and show correct. If this code becomes that, I expect there are different tradeoffs that would be made. I think having good reference code would be a good place to start. Designing code like this to run in a GPU style looks pretty hard, so having a reference implementation would also make it easier to plan out the specifics of how it could run faster on the gpu. For example, the current approach of testing each pixel against each dash/dot doesn't map to a GPU very well and doesn't scale very well. I'm not sure if this would be a problem in practice but it's a bit scary.\n\nI realize the code is researchy so structuring the code well is likely pretty difficult. Anwways, I wasn't able to follow everything but I've added a couple additional comments inline.\n\n::: layout/base/nsCSSBorderShader.cpp\n@@ +446,5 @@\n> +\n> +  NS_NOTREACHED(\"Not a valid intersection type\");\n> +  return gfxPoint(0, 0);\n> +}\n> +\n\nReturning the color makes more sense.\n\n@@ +733,5 @@\n> +    return 0;\n> +\n> +  return mSideSamples[aSide][aPixel];\n> +}\n> +\n\nThis also not a great name.\nComputeSideColorAtPoint might be better?\n\n@@ +738,5 @@\n> +gfxPackedARGB\n> +nsCSSBorderShader::RGBAFromTextureCoord(const Side aSide,\n> +                                        const gfxFloat aCoord)\n> +{\n> +  // Given a texture coord (normally between [0.0, 1.0] but not always),\n\nwhen not?\n\n@@ +787,5 @@\n> +// The only way we can get a curve of a certain length is to approximate it.\n> +// In the field of maths, we do this by approximating with smaller segments\n> +// of known lengths.\n> +// In computing, we use a binary search, finding the parameter t which\n> +// gives us the length we want.\n\nI know this part isn't currently meant to run on the gpu but I didn't realize that immediately. Anyways, recursion is not well supported on GPUs (AFAIK only CUDA with Fermi hardware)\n\n@@ +1482,5 @@\n> +    *offsetWidth += currentColorWidth;\n> +  }\n> +}\n> +\n> +\n\nSolve what?", "text": "Comment on attachment 594921\nWIP5\n\nReview of attachment 594921:\n-----------------------------------------------------------------\n\nSome thought spew (I've written it out of order so hopefully it makes some sense)\n\nI'd be very interested to see some performance numbers for this code.\n\nIt looks like one of the tricky bits is the lack of a parametrization of the ellipse by arc length. It's possible we can come up with a performant version of that runs well on the gpu (I've talked with bjacob about it), but if we can't I'm not sure the current approach is a good one. For example, with dotted borders, if we know all of the positions of the dots we are probably better of just drawing them explicitly instead of implicitly with a complicated pixel shader.\n\nThat being said, there's still value in a reference implementation of the border drawing that's easy to understand and show correct. If this code becomes that, I expect there are different tradeoffs that would be made. I think having good reference code would be a good place to start. Designing code like this to run in a GPU style looks pretty hard, so having a reference implementation would also make it easier to plan out the specifics of how it could run faster on the gpu. For example, the current approach of testing each pixel against each dash/dot doesn't map to a GPU very well and doesn't scale very well. I'm not sure if this would be a problem in practice but it's a bit scary.\n\nI realize the code is researchy so structuring the code well is likely pretty difficult. Anwways, I wasn't able to follow everything but I've added a couple additional comments inline.\n\n::: layout/base/nsCSSBorderShader.cpp\n@@ +446,5 @@\n> +\n> +  NS_NOTREACHED(\"Not a valid intersection type\");\n> +  return gfxPoint(0, 0);\n> +}\n> +\n\nReturning the color makes more sense.\n\n@@ +733,5 @@\n> +    return 0;\n> +\n> +  return mSideSamples[aSide][aPixel];\n> +}\n> +\n\nThis also not a great name.\nComputeSideColorAtPoint might be better?\n\n@@ +738,5 @@\n> +gfxPackedARGB\n> +nsCSSBorderShader::RGBAFromTextureCoord(const Side aSide,\n> +                                        const gfxFloat aCoord)\n> +{\n> +  // Given a texture coord (normally between [0.0, 1.0] but not always),\n\nwhen not?\n\n@@ +787,5 @@\n> +// The only way we can get a curve of a certain length is to approximate it.\n> +// In the field of maths, we do this by approximating with smaller segments\n> +// of known lengths.\n> +// In computing, we use a binary search, finding the parameter t which\n> +// gives us the length we want.\n\nI know this part isn't currently meant to run on the gpu but I didn't realize that immediately. Anyways, recursion is not well supported on GPUs (AFAIK only CUDA with Fermi hardware)\n\n@@ +1482,5 @@\n> +    *offsetWidth += currentColorWidth;\n> +  }\n> +}\n> +\n> +\n\nSolve what?", "attachment_id": 594921, "time": "2012-02-08T04:44:12Z", "tags": [], "is_private": false, "count": 45, "id": 6042836, "bug_id": 697645}, {"author": "roc@ocallahan.org", "creator": "roc@ocallahan.org", "attachment_id": null, "time": "2012-02-08T05:03:37Z", "text": "Thanks Jeff!\n\nNone of this is meant to run on a GPU. At least, not immediately.\n\n> For example, with dotted borders, if we know all of the positions of the dots we\n> are probably better of just drawing them explicitly instead of implicitly with a\n> complicated pixel shader.\n\nMaybe, maybe not. We've had awful cairo performance in the past tesselating lots of tiny rectangles, and tiny dots would be even worse. And there are complicating factors here, like if we need to draw half a dot, or the dot needs to have multiple border colors in it, or different-colored sides meet in the dot and need to have a few antialiased pixels.", "raw_text": "Thanks Jeff!\n\nNone of this is meant to run on a GPU. At least, not immediately.\n\n> For example, with dotted borders, if we know all of the positions of the dots we\n> are probably better of just drawing them explicitly instead of implicitly with a\n> complicated pixel shader.\n\nMaybe, maybe not. We've had awful cairo performance in the past tesselating lots of tiny rectangles, and tiny dots would be even worse. And there are complicating factors here, like if we need to draw half a dot, or the dot needs to have multiple border colors in it, or different-colored sides meet in the dot and need to have a few antialiased pixels.", "creation_time": "2012-02-08T05:03:37Z", "bug_id": 697645, "id": 6042860, "count": 46, "is_private": false, "tags": []}, {"creator": "jmuizelaar@mozilla.com", "author": "jmuizelaar@mozilla.com", "creation_time": "2012-02-08T09:54:57Z", "raw_text": "(In reply to Robert O'Callahan (:roc) (Mozilla Corporation) from comment #46)\n> Thanks Jeff!\n> \n> None of this is meant to run on a GPU. At least, not immediately.\n> \n> > For example, with dotted borders, if we know all of the positions of the dots we\n> > are probably better of just drawing them explicitly instead of implicitly with a\n> > complicated pixel shader.\n> \n> Maybe, maybe not. We've had awful cairo performance in the past tesselating\n> lots of tiny rectangles, and tiny dots would be even worse. And there are\n> complicating factors here, like if we need to draw half a dot, or the dot\n> needs to have multiple border colors in it, or different-colored sides meet\n> in the dot and need to have a few antialiased pixels.\n\nWe don't need to tesselate these paths though because we can guarantee that there will be no intersections. i.e. a purpose built rasterizer should be able to do very at this kind of thing. Plus, if we did have such a thing we could probably build a texture that would let us draw the border with D2D using 4 draw image calls which could be coalesced into a single gpu draw call.", "text": "(In reply to Robert O'Callahan (:roc) (Mozilla Corporation) from comment #46)\n> Thanks Jeff!\n> \n> None of this is meant to run on a GPU. At least, not immediately.\n> \n> > For example, with dotted borders, if we know all of the positions of the dots we\n> > are probably better of just drawing them explicitly instead of implicitly with a\n> > complicated pixel shader.\n> \n> Maybe, maybe not. We've had awful cairo performance in the past tesselating\n> lots of tiny rectangles, and tiny dots would be even worse. And there are\n> complicating factors here, like if we need to draw half a dot, or the dot\n> needs to have multiple border colors in it, or different-colored sides meet\n> in the dot and need to have a few antialiased pixels.\n\nWe don't need to tesselate these paths though because we can guarantee that there will be no intersections. i.e. a purpose built rasterizer should be able to do very at this kind of thing. Plus, if we did have such a thing we could probably build a texture that would let us draw the border with D2D using 4 draw image calls which could be coalesced into a single gpu draw call.", "attachment_id": null, "time": "2012-02-08T09:54:57Z", "count": 47, "is_private": false, "tags": [], "id": 6043235, "bug_id": 697645}, {"id": 6043331, "tags": [], "is_private": false, "count": 48, "bug_id": 697645, "creation_time": "2012-02-08T10:55:24Z", "raw_text": "I'm not really sure what the boundary is between what we're doing here and a purpose-built rasterizer, or how the latter would integrate into Thebes or Azure API.\n\nI think this per-pixel color computation approach is a good way to structure the problem even if we end up taking shortcuts for speed.", "time": "2012-02-08T10:55:24Z", "attachment_id": null, "text": "I'm not really sure what the boundary is between what we're doing here and a purpose-built rasterizer, or how the latter would integrate into Thebes or Azure API.\n\nI think this per-pixel color computation approach is a good way to structure the problem even if we end up taking shortcuts for speed.", "author": "roc@ocallahan.org", "creator": "roc@ocallahan.org"}, {"text": "(In reply to Jeff Muizelaar [:jrmuizel] from comment #45)\n> It looks like one of the tricky bits is the lack of a parametrization of the\n> ellipse by arc length. \n\nBenoit and I looked at this a bit more. Benoit came up with http://people.mozilla.org/~bjacob/ellipse.html.\n\nThere's also code here http://code.google.com/p/elliptic/source/browse/trunk/inverselliptic2.m which implements \"J. P. Boyd, \"Numerical, Perturbative and Chebyshev Inversion of the Incomplete Elliptic Integral of the Second Kind\", Applied Mathematics and Computation (January 2012)\"", "attachment_id": null, "time": "2012-02-10T21:58:24Z", "creation_time": "2012-02-10T21:58:24Z", "raw_text": "(In reply to Jeff Muizelaar [:jrmuizel] from comment #45)\n> It looks like one of the tricky bits is the lack of a parametrization of the\n> ellipse by arc length. \n\nBenoit and I looked at this a bit more. Benoit came up with http://people.mozilla.org/~bjacob/ellipse.html.\n\nThere's also code here http://code.google.com/p/elliptic/source/browse/trunk/inverselliptic2.m which implements \"J. P. Boyd, \"Numerical, Perturbative and Chebyshev Inversion of the Incomplete Elliptic Integral of the Second Kind\", Applied Mathematics and Computation (January 2012)\"", "bug_id": 697645, "tags": [], "is_private": false, "count": 49, "id": 6051772, "creator": "jmuizelaar@mozilla.com", "author": "jmuizelaar@mozilla.com"}, {"text": "A question.  Would this approach help with seaming issues like the one on http://jsfiddle.net/tpDyA/ ?", "time": "2012-05-25T01:43:52Z", "attachment_id": null, "creation_time": "2012-05-25T01:43:52Z", "raw_text": "A question.  Would this approach help with seaming issues like the one on http://jsfiddle.net/tpDyA/ ?", "bug_id": 697645, "tags": [], "is_private": false, "count": 50, "id": 6337055, "creator": "bzbarsky@mit.edu", "author": "bzbarsky@mit.edu"}, {"author": "jmuizelaar@mozilla.com", "creator": "jmuizelaar@mozilla.com", "id": 6337140, "is_private": false, "count": 51, "tags": [], "bug_id": 697645, "creation_time": "2012-05-25T02:39:58Z", "raw_text": "(In reply to Boris Zbarsky (:bz) from comment #50)\n> A question.  Would this approach help with seaming issues like the one on\n> http://jsfiddle.net/tpDyA/ ?\n\nWe should be able to fix the seaming issues there without needing this.", "time": "2012-05-25T02:39:58Z", "attachment_id": null, "text": "(In reply to Boris Zbarsky (:bz) from comment #50)\n> A question.  Would this approach help with seaming issues like the one on\n> http://jsfiddle.net/tpDyA/ ?\n\nWe should be able to fix the seaming issues there without needing this."}, {"count": 52, "is_private": false, "tags": [], "id": 6337172, "bug_id": 697645, "creation_time": "2012-05-25T03:13:34Z", "raw_text": "Sure, for the single-color case.  We already do for the same-border-widths case....\n\nWorth filing a separate bug on it?", "creator": "bzbarsky@mit.edu", "text": "Sure, for the single-color case.  We already do for the same-border-widths case....\n\nWorth filing a separate bug on it?", "attachment_id": null, "time": "2012-05-25T03:13:34Z", "author": "bzbarsky@mit.edu"}, {"creation_time": "2012-05-25T03:26:41Z", "raw_text": "(In reply to Boris Zbarsky (:bz) from comment #52)\n> Sure, for the single-color case.  We already do for the same-border-widths\n> case....\n> \n> Worth filing a separate bug on it?\n\nSure.", "time": "2012-05-25T03:26:41Z", "attachment_id": null, "text": "(In reply to Boris Zbarsky (:bz) from comment #52)\n> Sure, for the single-color case.  We already do for the same-border-widths\n> case....\n> \n> Worth filing a separate bug on it?\n\nSure.", "id": 6337194, "tags": [], "is_private": false, "count": 53, "bug_id": 697645, "author": "jmuizelaar@mozilla.com", "creator": "jmuizelaar@mozilla.com"}, {"time": "2012-06-01T04:34:34Z", "attachment_id": null, "author": "bzbarsky@mit.edu", "creator": "bzbarsky@mit.edu", "text": "OK, filed bug 760358.", "creation_time": "2012-06-01T04:34:34Z", "raw_text": "OK, filed bug 760358.", "bug_id": 697645, "id": 6354617, "count": 54, "is_private": false, "tags": []}]}}}