{"comments": {}, "bugs": {"635309": {"comments": [{"time": "2011-02-18T19:03:34Z", "id": 5290150, "bug_id": 635309, "creation_time": "2011-02-18T19:03:34Z", "raw_text": "In order to test multipart range requests that plugins make (and which have really sucky code), I need httpd.js to be able to actually handle multiple range requests and return the data reasonably. Anyone on the cc list want to volunteer or know of somebody who would be willing?", "tags": [], "is_private": false, "text": "In order to test multipart range requests that plugins make (and which have really sucky code), I need httpd.js to be able to actually handle multiple range requests and return the data reasonably. Anyone on the cc list want to volunteer or know of somebody who would be willing?", "count": 0, "author": "benjamin@smedbergs.us", "creator": "benjamin@smedbergs.us", "attachment_id": null}, {"time": "2011-02-18T19:32:57Z", "id": 5290241, "raw_text": "ccing some neckoish folks.", "bug_id": 635309, "creation_time": "2011-02-18T19:32:57Z", "tags": [], "is_private": false, "text": "ccing some neckoish folks.", "count": 1, "author": "bzbarsky@mit.edu", "creator": "bzbarsky@mit.edu", "attachment_id": null}, {"attachment_id": 516010, "is_private": false, "creator": "cmtalbert@gmail.com", "tags": [], "raw_text": "So, here's a WIP patch to add this functionality.  I'm no HTTP expert, so someone needs to check if the actual protocol stuff is handled properly.  The other sticky bit is whether what I'm doing here (writing a temporary file to construct the multipart response body) is the right thing to do.\n\nBig changes:\n* tried to reuse a bunch of the existing range request code, that's going to allow multipart range requests like this: 10-15,17- and I don't know if that is per spec or not.\n* I'm detecting whether I have a multipart request or not based on whether the range part of the request contains commas.  Is that a valid way to do this?\n* Factored out the actual response writing out of writeFileResponse so that it could be used by the multipart writer as well (I needed a callback to clean things up).\n\nIt's not complete, but would this work for what you need Benjamin?  Waldo, is this a good approach (with the temp file and all that), or should I have done this a different way?  This is my first serious foray into httpd.js, so all feedback is welcome.", "creation_time": "2011-03-01T21:02:10Z", "bug_id": 635309, "id": 5312762, "author": "cmtalbert@gmail.com", "time": "2011-03-01T21:02:10Z", "text": "Created attachment 516010\nWIP patch, take 1\n\nSo, here's a WIP patch to add this functionality.  I'm no HTTP expert, so someone needs to check if the actual protocol stuff is handled properly.  The other sticky bit is whether what I'm doing here (writing a temporary file to construct the multipart response body) is the right thing to do.\n\nBig changes:\n* tried to reuse a bunch of the existing range request code, that's going to allow multipart range requests like this: 10-15,17- and I don't know if that is per spec or not.\n* I'm detecting whether I have a multipart request or not based on whether the range part of the request contains commas.  Is that a valid way to do this?\n* Factored out the actual response writing out of writeFileResponse so that it could be used by the multipart writer as well (I needed a callback to clean things up).\n\nIt's not complete, but would this work for what you need Benjamin?  Waldo, is this a good approach (with the temp file and all that), or should I have done this a different way?  This is my first serious foray into httpd.js, so all feedback is welcome.", "count": 2}, {"count": 3, "text": "Comment on attachment 516010\nWIP patch, take 1\n\nWriting to a temporary file won't be acceptable, no.\n\n>diff --git a/netwerk/test/httpserver/httpd.js b/netwerk/test/httpserver/httpd.js\n>     if (metadata._httpVersion.atLeast(nsHttpVersion.HTTP_1_1) &&\n>         metadata.hasHeader(\"Range\") &&\n>         this._getTypeFromFile(file) !== SJS_TYPE)\n>     {\n>-      var rangeMatch = metadata.getHeader(\"Range\").match(/^bytes=(\\d+)?-(\\d+)?$/);\n>+      // Not sure how to do this with one regex, so ensure we have bytes= as we expect\n>+      if (!metadata.getHeader(\"Range\").match(/^bytes=/))\n>+        throw HTTP_400;\n\nIf you're just testing, there's a test() (or search()?) method on regular expressions for that purpose.\n\nA first check here, then chopping off bytes=, splitting on ',', and pattern-checking each individual component seems like the right way to do this.\n\n\n>+      // Figure out if we have a multipart range or a single range request\n>+      // TODO: Better way to do this? I'm looking for commas in the request\n>+      var isMultipart = false;\n>+      var multipartBuffer = \"\";\n>+      var boundary = \"***\\n***\\n\";\n>+      if (metadata.getHeader(\"Range\").split(\",\").length > 1)\n\nGet the header once, then act on that single value -- no reason to be looking it up multiple times.\n\nI have not fully studied multipart format, but my recollection is that you need a boundary string that doesn't exist in any individual part of the response.  I would guess servers just generate some random characters and use that and \"hope\" there's no collision, but I don't actually know.  Anyone else know?  Hard-coding a boundary string is definitely not right.\n\n\n>+      {\n>+        isMultipart = true;\n>+\n>+        // Go ahead and set the outer headers\n>+        response.setStatusLine(metadata.httpVersion, 206, \"Partial Content\");\n>+        response.setHeader(\"Content-Type\", \"multipart/byteranges\", false);\n>+        multipartBuffer += \"boundary=\" + boundary;\n>+      }\n>+\n>+      rangeregex = /(\\d+)?-(\\d+)?/g;\n>+      rangeMatch = rangeregex.exec(metadata.getHeader(\"Range\"));\n\nAgain getting the header!  :-)\n\nThis confuses me.  Shouldn't you be doing this for every individual range in the header?  So shouldn't this be in a loop over a split?  Without investigating harder, I'm somewhat doubtful this really works.\n\nRegarding the questions:\n\n* tried to reuse a bunch of the existing range request code, that's going to\nallow multipart range requests like this: 10-15,17- and I don't know if that is\nper spec or not.\n\nI suspect it is, but I don't know offhand.\n\n* I'm detecting whether I have a multipart request or not based on whether the\nrange part of the request contains commas.  Is that a valid way to do this?\n\nI'd have to check spec whether bytes=1-3,4-6 is supposed to be a multipart or not, but that seems like the big case.  And I don't remember if ranges are allowed to overlap, and whether they should be combined if so, or whatever, another thing to check.\n\n* Factored out the actual response writing out of writeFileResponse so that it\ncould be used by the multipart writer as well (I needed a callback to clean\nthings up).\n\nI didn't look at this, so I don't have anything to say yet about it.\n\nHopefully that's a reasonable start on feedback, keep asking questions if you have them.", "id": 5312843, "author": "jwalden@mit.edu", "time": "2011-03-01T21:28:20Z", "creator": "jwalden@mit.edu", "tags": [], "raw_text": "Writing to a temporary file won't be acceptable, no.\n\n>diff --git a/netwerk/test/httpserver/httpd.js b/netwerk/test/httpserver/httpd.js\n>     if (metadata._httpVersion.atLeast(nsHttpVersion.HTTP_1_1) &&\n>         metadata.hasHeader(\"Range\") &&\n>         this._getTypeFromFile(file) !== SJS_TYPE)\n>     {\n>-      var rangeMatch = metadata.getHeader(\"Range\").match(/^bytes=(\\d+)?-(\\d+)?$/);\n>+      // Not sure how to do this with one regex, so ensure we have bytes= as we expect\n>+      if (!metadata.getHeader(\"Range\").match(/^bytes=/))\n>+        throw HTTP_400;\n\nIf you're just testing, there's a test() (or search()?) method on regular expressions for that purpose.\n\nA first check here, then chopping off bytes=, splitting on ',', and pattern-checking each individual component seems like the right way to do this.\n\n\n>+      // Figure out if we have a multipart range or a single range request\n>+      // TODO: Better way to do this? I'm looking for commas in the request\n>+      var isMultipart = false;\n>+      var multipartBuffer = \"\";\n>+      var boundary = \"***\\n***\\n\";\n>+      if (metadata.getHeader(\"Range\").split(\",\").length > 1)\n\nGet the header once, then act on that single value -- no reason to be looking it up multiple times.\n\nI have not fully studied multipart format, but my recollection is that you need a boundary string that doesn't exist in any individual part of the response.  I would guess servers just generate some random characters and use that and \"hope\" there's no collision, but I don't actually know.  Anyone else know?  Hard-coding a boundary string is definitely not right.\n\n\n>+      {\n>+        isMultipart = true;\n>+\n>+        // Go ahead and set the outer headers\n>+        response.setStatusLine(metadata.httpVersion, 206, \"Partial Content\");\n>+        response.setHeader(\"Content-Type\", \"multipart/byteranges\", false);\n>+        multipartBuffer += \"boundary=\" + boundary;\n>+      }\n>+\n>+      rangeregex = /(\\d+)?-(\\d+)?/g;\n>+      rangeMatch = rangeregex.exec(metadata.getHeader(\"Range\"));\n\nAgain getting the header!  :-)\n\nThis confuses me.  Shouldn't you be doing this for every individual range in the header?  So shouldn't this be in a loop over a split?  Without investigating harder, I'm somewhat doubtful this really works.\n\nRegarding the questions:\n\n* tried to reuse a bunch of the existing range request code, that's going to\nallow multipart range requests like this: 10-15,17- and I don't know if that is\nper spec or not.\n\nI suspect it is, but I don't know offhand.\n\n* I'm detecting whether I have a multipart request or not based on whether the\nrange part of the request contains commas.  Is that a valid way to do this?\n\nI'd have to check spec whether bytes=1-3,4-6 is supposed to be a multipart or not, but that seems like the big case.  And I don't remember if ranges are allowed to overlap, and whether they should be combined if so, or whatever, another thing to check.\n\n* Factored out the actual response writing out of writeFileResponse so that it\ncould be used by the multipart writer as well (I needed a callback to clean\nthings up).\n\nI didn't look at this, so I don't have anything to say yet about it.\n\nHopefully that's a reasonable start on feedback, keep asking questions if you have them.", "creation_time": "2011-03-01T21:28:20Z", "bug_id": 635309, "attachment_id": 516010, "is_private": false}, {"attachment_id": null, "is_private": false, "creator": "benjamin@smedbergs.us", "tags": [], "raw_text": "When I generate multipart/form-data requests, I generate a random boundary string but then search the data to see if it is present. If there's a conflict, I just regenerate a new random string.", "creation_time": "2011-03-01T21:30:36Z", "bug_id": 635309, "id": 5312856, "author": "benjamin@smedbergs.us", "time": "2011-03-01T21:30:36Z", "text": "When I generate multipart/form-data requests, I generate a random boundary string but then search the data to see if it is present. If there's a conflict, I just regenerate a new random string.", "count": 4}, {"tags": [], "bug_id": 635309, "creation_time": "2011-03-02T01:53:22Z", "raw_text": "(In reply to comment #4)\n> When I generate multipart/form-data requests, I generate a random boundary\n> string but then search the data to see if it is present. If there's a conflict,\n> I just regenerate a new random string.\n\nthis makes some good sense.  I was worried about this, but the spec is pretty light on the details.  I'll look into that.\n\nthanks for the feedback guys.", "is_private": false, "id": 5313823, "time": "2011-03-02T01:53:22Z", "creator": "cmtalbert@gmail.com", "attachment_id": null, "count": 5, "text": "(In reply to comment #4)\n> When I generate multipart/form-data requests, I generate a random boundary\n> string but then search the data to see if it is present. If there's a conflict,\n> I just regenerate a new random string.\n\nthis makes some good sense.  I was worried about this, but the spec is pretty light on the details.  I'll look into that.\n\nthanks for the feedback guys.", "author": "cmtalbert@gmail.com"}, {"time": "2011-03-02T18:15:50Z", "id": 5315694, "raw_text": "(In reply to comment #3)\n> Comment on attachment 516010 [details]\n> WIP patch, take 1\n> \n> Writing to a temporary file won't be acceptable, no.\nDo you have other ideas on how you'd like to see it implemented?  Is there a good cache I can use to construct the response in memory?\n\n> \n> >diff --git a/netwerk/test/httpserver/httpd.js b/netwerk/test/httpserver/httpd.js\n> >     if (metadata._httpVersion.atLeast(nsHttpVersion.HTTP_1_1) &&\n> >         metadata.hasHeader(\"Range\") &&\n> >         this._getTypeFromFile(file) !== SJS_TYPE)\n> >     {\n> >-      var rangeMatch = metadata.getHeader(\"Range\").match(/^bytes=(\\d+)?-(\\d+)?$/);\n> >+      // Not sure how to do this with one regex, so ensure we have bytes= as we expect\n> >+      if (!metadata.getHeader(\"Range\").match(/^bytes=/))\n> >+        throw HTTP_400;\n> \n> If you're just testing, there's a test() (or search()?) method on regular\n> expressions for that purpose.\ntrue, thx.\n> \n> A first check here, then chopping off bytes=, splitting on ',', and\n> pattern-checking each individual component seems like the right way to do this.\n> \ncool. I can modify it to do that.\n> \n> >+      // Figure out if we have a multipart range or a single range request\n> >+      // TODO: Better way to do this? I'm looking for commas in the request\n> >+      var isMultipart = false;\n> >+      var multipartBuffer = \"\";\n> >+      var boundary = \"***\\n***\\n\";\n> >+      if (metadata.getHeader(\"Range\").split(\",\").length > 1)\n> \n> Get the header once, then act on that single value -- no reason to be looking\n> it up multiple times.\nGotcha.\n> \n> I have not fully studied multipart format, but my recollection is that you need\n> a boundary string that doesn't exist in any individual part of the response.  I\n> would guess servers just generate some random characters and use that and\n> \"hope\" there's no collision, but I don't actually know.  Anyone else know? \n> Hard-coding a boundary string is definitely not right.\n> \n> \n> >+      {\n> >+        isMultipart = true;\n> >+\n> >+        // Go ahead and set the outer headers\n> >+        response.setStatusLine(metadata.httpVersion, 206, \"Partial Content\");\n> >+        response.setHeader(\"Content-Type\", \"multipart/byteranges\", false);\n> >+        multipartBuffer += \"boundary=\" + boundary;\n> >+      }\n> >+\n> >+      rangeregex = /(\\d+)?-(\\d+)?/g;\n> >+      rangeMatch = rangeregex.exec(metadata.getHeader(\"Range\"));\n> \n> Again getting the header!  :-)\n> \n> This confuses me.  Shouldn't you be doing this for every individual range in\n> the header?  So shouldn't this be in a loop over a split?  Without\n> investigating harder, I'm somewhat doubtful this really works.\n> \nSorta.  The header for the entire response needs to have certain parameters set.  It's a whole lot less clear to me what needs to be set in the headers on the individual ranges.  Also, I think calling this code multiple times will only reset the top header.  I did it this way, because in the IDL it doesn't appear that the response object can differentiate between the header for the entire response and the individual range headers.  Since both headers are using many of the same headers with different values, I was trying to work around that.\n\nMaybe I'm attacking this at the wrong level, and the right fix is to make the response object aware of ranges, and let the response object use it's code for setting the proper headers.\n\nWhat do you think?", "creation_time": "2011-03-02T18:15:50Z", "bug_id": 635309, "tags": [], "is_private": false, "count": 6, "text": "(In reply to comment #3)\n> Comment on attachment 516010 [details]\n> WIP patch, take 1\n> \n> Writing to a temporary file won't be acceptable, no.\nDo you have other ideas on how you'd like to see it implemented?  Is there a good cache I can use to construct the response in memory?\n\n> \n> >diff --git a/netwerk/test/httpserver/httpd.js b/netwerk/test/httpserver/httpd.js\n> >     if (metadata._httpVersion.atLeast(nsHttpVersion.HTTP_1_1) &&\n> >         metadata.hasHeader(\"Range\") &&\n> >         this._getTypeFromFile(file) !== SJS_TYPE)\n> >     {\n> >-      var rangeMatch = metadata.getHeader(\"Range\").match(/^bytes=(\\d+)?-(\\d+)?$/);\n> >+      // Not sure how to do this with one regex, so ensure we have bytes= as we expect\n> >+      if (!metadata.getHeader(\"Range\").match(/^bytes=/))\n> >+        throw HTTP_400;\n> \n> If you're just testing, there's a test() (or search()?) method on regular\n> expressions for that purpose.\ntrue, thx.\n> \n> A first check here, then chopping off bytes=, splitting on ',', and\n> pattern-checking each individual component seems like the right way to do this.\n> \ncool. I can modify it to do that.\n> \n> >+      // Figure out if we have a multipart range or a single range request\n> >+      // TODO: Better way to do this? I'm looking for commas in the request\n> >+      var isMultipart = false;\n> >+      var multipartBuffer = \"\";\n> >+      var boundary = \"***\\n***\\n\";\n> >+      if (metadata.getHeader(\"Range\").split(\",\").length > 1)\n> \n> Get the header once, then act on that single value -- no reason to be looking\n> it up multiple times.\nGotcha.\n> \n> I have not fully studied multipart format, but my recollection is that you need\n> a boundary string that doesn't exist in any individual part of the response.  I\n> would guess servers just generate some random characters and use that and\n> \"hope\" there's no collision, but I don't actually know.  Anyone else know? \n> Hard-coding a boundary string is definitely not right.\n> \n> \n> >+      {\n> >+        isMultipart = true;\n> >+\n> >+        // Go ahead and set the outer headers\n> >+        response.setStatusLine(metadata.httpVersion, 206, \"Partial Content\");\n> >+        response.setHeader(\"Content-Type\", \"multipart/byteranges\", false);\n> >+        multipartBuffer += \"boundary=\" + boundary;\n> >+      }\n> >+\n> >+      rangeregex = /(\\d+)?-(\\d+)?/g;\n> >+      rangeMatch = rangeregex.exec(metadata.getHeader(\"Range\"));\n> \n> Again getting the header!  :-)\n> \n> This confuses me.  Shouldn't you be doing this for every individual range in\n> the header?  So shouldn't this be in a loop over a split?  Without\n> investigating harder, I'm somewhat doubtful this really works.\n> \nSorta.  The header for the entire response needs to have certain parameters set.  It's a whole lot less clear to me what needs to be set in the headers on the individual ranges.  Also, I think calling this code multiple times will only reset the top header.  I did it this way, because in the IDL it doesn't appear that the response object can differentiate between the header for the entire response and the individual range headers.  Since both headers are using many of the same headers with different values, I was trying to work around that.\n\nMaybe I'm attacking this at the wrong level, and the right fix is to make the response object aware of ranges, and let the response object use it's code for setting the proper headers.\n\nWhat do you think?", "author": "cmtalbert@gmail.com", "creator": "cmtalbert@gmail.com", "attachment_id": null}, {"creator": "bug-husbandry-bot@mozilla.bugs", "attachment_id": null, "text": "Bulk change to priority: https://bugzilla.mozilla.org/show_bug.cgi?id=1399258", "count": 7, "author": "bug-husbandry-bot@mozilla.bugs", "tags": [], "raw_text": "Bulk change to priority: https://bugzilla.mozilla.org/show_bug.cgi?id=1399258", "bug_id": 635309, "creation_time": "2017-09-13T18:39:17Z", "is_private": false, "id": 12658761, "time": "2017-09-13T18:39:17Z"}]}}}