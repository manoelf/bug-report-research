{"bugs": {"682813": {"comments": [{"author": "asaf@sent.com", "creation_time": "2011-08-29T10:45:56Z", "time": "2011-08-29T10:45:56Z", "creator": "asaf@sent.com", "count": 0, "id": 5684472, "is_private": false, "tags": [], "bug_id": 682813, "text": "While working on bug 516753, I found out that setting a \"contextmenu\" listener in a content script only works in the first tab (main process).\n\nI used the global manager to load my content script, with allowDelayed. I do see the script loaded. I was also able to track other events (well - click). Yet again, I do see contextmenu dispatched in the first tab.", "raw_text": "While working on bug 516753, I found out that setting a \"contextmenu\" listener in a content script only works in the first tab (main process).\n\nI used the global manager to load my content script, with allowDelayed. I do see the script loaded. I was also able to track other events (well - click). Yet again, I do see contextmenu dispatched in the first tab.", "attachment_id": null}, {"is_private": false, "id": 5684476, "count": 1, "creator": "asaf@sent.com", "time": "2011-08-29T10:47:20Z", "creation_time": "2011-08-29T10:47:20Z", "author": "asaf@sent.com", "attachment_id": null, "raw_text": "I was able to reproduce this on current trunk (with --enable-e10s-compat), mac and windows.", "tags": [], "text": "I was able to reproduce this on current trunk (with --enable-e10s-compat), mac and windows.", "bug_id": 682813}, {"tags": [], "bug_id": 682813, "text": "I think we just don't forward contextmenu event atm.", "raw_text": "I think we just don't forward contextmenu event atm.", "attachment_id": null, "author": "bugs@pettay.fi", "creator": "bugs@pettay.fi", "time": "2011-08-29T14:57:04Z", "creation_time": "2011-08-29T14:57:04Z", "is_private": false, "id": 5684894, "count": 2}, {"is_private": false, "id": 5686517, "count": 3, "creator": "asaf@sent.com", "time": "2011-08-29T23:36:36Z", "creation_time": "2011-08-29T23:36:36Z", "author": "asaf@sent.com", "attachment_id": null, "raw_text": "Weird.\n\nPer Olli's suggestion I did the following change in eventstatemanager:\nPRBool\nnsEventStateManager::HandleCrossProcessEvent(nsEvent *aEvent,\n                                             nsIFrame* aTargetFrame,\n                                             nsEventStatus *aStatus) {\n  switch (aEvent->eventStructType) {\n...\n    case NS_MOUSE_EVENT:\n      if (... ||\n          aEvent->message == NS_CONTEXTMENU) {\n\n\nWe get there, yes. But the event isn't dispatched because, for some reason, nsEventStatus_eConsumeNoDefault is set. That fails here:\n\n  if (*aStatus == nsEventStatus_eConsumeNoDefault ||\n      !target ||\n      !IsRemoteTarget(target)) {\n...\n\n(There's a target, and it's, as expected, a remote target).\n\nI also verified that in the first tab (main process), getPreventDefault for the dispatched event returns false.", "text": "Weird.\n\nPer Olli's suggestion I did the following change in eventstatemanager:\nPRBool\nnsEventStateManager::HandleCrossProcessEvent(nsEvent *aEvent,\n                                             nsIFrame* aTargetFrame,\n                                             nsEventStatus *aStatus) {\n  switch (aEvent->eventStructType) {\n...\n    case NS_MOUSE_EVENT:\n      if (... ||\n          aEvent->message == NS_CONTEXTMENU) {\n\n\nWe get there, yes. But the event isn't dispatched because, for some reason, nsEventStatus_eConsumeNoDefault is set. That fails here:\n\n  if (*aStatus == nsEventStatus_eConsumeNoDefault ||\n      !target ||\n      !IsRemoteTarget(target)) {\n...\n\n(There's a target, and it's, as expected, a remote target).\n\nI also verified that in the first tab (main process), getPreventDefault for the dispatched event returns false.", "bug_id": 682813, "tags": []}, {"id": 5686571, "count": 4, "is_private": false, "time": "2011-08-29T23:55:03Z", "creation_time": "2011-08-29T23:55:03Z", "creator": "felipc@gmail.com", "author": "felipc@gmail.com", "attachment_id": null, "raw_text": "(In reply to Mano from comment #3)\n> Weird.\n> \n> Per Olli's suggestion I did the following change in eventstatemanager:\n> PRBool\n> nsEventStateManager::HandleCrossProcessEvent(nsEvent *aEvent,\n>                                              nsIFrame* aTargetFrame,\n>                                              nsEventStatus *aStatus) {\n>   switch (aEvent->eventStructType) {\n> ...\n>     case NS_MOUSE_EVENT:\n>       if (... ||\n>           aEvent->message == NS_CONTEXTMENU) {\n\nYeah. Also take a look at http://mxr.mozilla.org/mozilla-central/source/content/events/src/nsEventStateManager.cpp#1641 . I don't think you'll need to make any changes there because the eventStructType for the contextmenu is just a NS_MOUSE_EVENT, right?\n\nOh, and make sure the serializer (see nsMouseEvent and nsMouseEvent_base in http://mxr.mozilla.org/mozilla-central/source/widget/public/nsGUIEventIPC.h ) contains all the fields you need.\n\n> \n> \n> We get there, yes. But the event isn't dispatched because, for some reason,\n> nsEventStatus_eConsumeNoDefault is set. That fails here:\n> \n>   if (*aStatus == nsEventStatus_eConsumeNoDefault ||\n>       !target ||\n>       !IsRemoteTarget(target)) {\n> ...\n\nhmf, the preventDefault API makes this hard to track down because you can't easily tell who changed the status.. As a guess, it's _probably_ happening because the target now is a <browser> element rather than a node from content. Could it be this line?\nhttp://mxr.mozilla.org/mozilla-central/source/content/xul/content/src/nsXULPopupListener.cpp#230\n\nI also searched in nsContextMenu.js but didn't find anything.", "bug_id": 682813, "text": "(In reply to Mano from comment #3)\n> Weird.\n> \n> Per Olli's suggestion I did the following change in eventstatemanager:\n> PRBool\n> nsEventStateManager::HandleCrossProcessEvent(nsEvent *aEvent,\n>                                              nsIFrame* aTargetFrame,\n>                                              nsEventStatus *aStatus) {\n>   switch (aEvent->eventStructType) {\n> ...\n>     case NS_MOUSE_EVENT:\n>       if (... ||\n>           aEvent->message == NS_CONTEXTMENU) {\n\nYeah. Also take a look at http://mxr.mozilla.org/mozilla-central/source/content/events/src/nsEventStateManager.cpp#1641 . I don't think you'll need to make any changes there because the eventStructType for the contextmenu is just a NS_MOUSE_EVENT, right?\n\nOh, and make sure the serializer (see nsMouseEvent and nsMouseEvent_base in http://mxr.mozilla.org/mozilla-central/source/widget/public/nsGUIEventIPC.h ) contains all the fields you need.\n\n> \n> \n> We get there, yes. But the event isn't dispatched because, for some reason,\n> nsEventStatus_eConsumeNoDefault is set. That fails here:\n> \n>   if (*aStatus == nsEventStatus_eConsumeNoDefault ||\n>       !target ||\n>       !IsRemoteTarget(target)) {\n> ...\n\nhmf, the preventDefault API makes this hard to track down because you can't easily tell who changed the status.. As a guess, it's _probably_ happening because the target now is a <browser> element rather than a node from content. Could it be this line?\nhttp://mxr.mozilla.org/mozilla-central/source/content/xul/content/src/nsXULPopupListener.cpp#230\n\nI also searched in nsContextMenu.js but didn't find anything.", "tags": []}, {"creator": "asaf@sent.com", "time": "2011-08-30T00:16:51Z", "creation_time": "2011-08-30T00:16:51Z", "author": "asaf@sent.com", "is_private": false, "id": 5686614, "count": 5, "text": "Felipe! Hey, thanks for joining.\n\n1. Why did you search nsContextMenu.js? we sure don't get that far (and we're not expected to as the event cannot bubble)\n2. How would we get to popuplistener? there's no popup involved (yet).", "bug_id": 682813, "tags": [], "attachment_id": null, "raw_text": "Felipe! Hey, thanks for joining.\n\n1. Why did you search nsContextMenu.js? we sure don't get that far (and we're not expected to as the event cannot bubble)\n2. How would we get to popuplistener? there's no popup involved (yet)."}, {"tags": [], "text": "Hrm, actually, we might be able to get to xulpopuplistener, but isn't the xul element handled within the chrome process?", "bug_id": 682813, "attachment_id": null, "raw_text": "Hrm, actually, we might be able to get to xulpopuplistener, but isn't the xul element handled within the chrome process?", "creator": "asaf@sent.com", "time": "2011-08-30T00:18:55Z", "creation_time": "2011-08-30T00:18:55Z", "author": "asaf@sent.com", "is_private": false, "id": 5686618, "count": 6}, {"count": 7, "id": 5686633, "is_private": false, "creation_time": "2011-08-30T00:23:08Z", "time": "2011-08-30T00:23:08Z", "creator": "felipc@gmail.com", "author": "felipc@gmail.com", "attachment_id": null, "raw_text": "TBH I didn't think much of it, I just searched contextmenu-related code to see what could be calling preventDefault().. (or it might be some C++ code directly setting the status).\n\nNote that the event forwarding happens in PostHandleEvent, so any listeners for the contextmenu event in the parent process will already be run at that point.", "tags": [], "text": "TBH I didn't think much of it, I just searched contextmenu-related code to see what could be calling preventDefault().. (or it might be some C++ code directly setting the status).\n\nNote that the event forwarding happens in PostHandleEvent, so any listeners for the contextmenu event in the parent process will already be run at that point.", "bug_id": 682813}, {"tags": [], "bug_id": 682813, "text": "Created attachment 556759\nalong these lines...\n\nSo, yes, Felipe is right.\n\nThis is kind of a band-aid. I didn't want to rewrite the popup-listener.\n\nThere are still two issues though:\n1) We don't really want to filter out all contextmenu events dispatched on browser - even a remote one - given that's this only way to actually generate a context menu later. For tabbbrowser, we could (and will) dispatch it on the tabbrowser element, but that isn't really a solution for any other use case.  However, I could not find a way to distinguish the initial parent event from \"legitimate\" cases.\n2) The \"preventDefault\" handling later on in this function clearly doesn't make sense in e10s world. For now it's harmless, but ones e10s is on, this code should be removed.", "raw_text": "So, yes, Felipe is right.\n\nThis is kind of a band-aid. I didn't want to rewrite the popup-listener.\n\nThere are still two issues though:\n1) We don't really want to filter out all contextmenu events dispatched on browser - even a remote one - given that's this only way to actually generate a context menu later. For tabbbrowser, we could (and will) dispatch it on the tabbrowser element, but that isn't really a solution for any other use case.  However, I could not find a way to distinguish the initial parent event from \"legitimate\" cases.\n2) The \"preventDefault\" handling later on in this function clearly doesn't make sense in e10s world. For now it's harmless, but ones e10s is on, this code should be removed.", "attachment_id": 556759, "author": "asaf@sent.com", "creation_time": "2011-08-30T06:00:42Z", "time": "2011-08-30T06:00:42Z", "creator": "asaf@sent.com", "id": 5687018, "count": 8, "is_private": false}, {"tags": [], "bug_id": 682813, "text": "IGNORE THE DEBUG PRINTF\\n", "raw_text": "IGNORE THE DEBUG PRINTF\\n", "attachment_id": null, "author": "asaf@sent.com", "creator": "asaf@sent.com", "time": "2011-08-30T06:02:11Z", "creation_time": "2011-08-30T06:02:11Z", "is_private": false, "id": 5687021, "count": 9}, {"text": "The good news is that with this patch, I get the events in the right order - that is, if a site implemented its own context menu and set prevent-default, its context menu shows up first, and only then I get the event on TabChild (with prevent-default set)", "bug_id": 682813, "tags": [], "raw_text": "The good news is that with this patch, I get the events in the right order - that is, if a site implemented its own context menu and set prevent-default, its context menu shows up first, and only then I get the event on TabChild (with prevent-default set)", "attachment_id": null, "author": "asaf@sent.com", "creation_time": "2011-08-30T06:12:10Z", "time": "2011-08-30T06:12:10Z", "creator": "asaf@sent.com", "id": 5687029, "count": 10, "is_private": false}, {"raw_text": "\n>+  nsCOMPtr<nsIContent> targetContent = do_QueryInterface(targetNode);\n>+  if (!targetContent) {\n>+    return NS_OK;\n>+  }\n>+  if (targetContent->Tag() == nsGkAtoms::browser &&\n>+      targetContent->IsXUL() &&\n>+      targetContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::Remote,\n>+                                 nsGkAtoms::_true, eIgnoreCase)) {\n>+    printf(\"IGNORING CONTEXT MENU EVENT\");\n>+    return NS_OK;\n>+  }\n\n  nsCOMPtr<nsIContent> targetContent = do_QueryInterface(targetNode);\n  if (targetContent && \n      targetContent->Tag() == nsGkAtoms::browser &&\n      targetContent->IsXUL() &&\n      targetContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::Remote,\n                                 nsGkAtoms::_true, eIgnoreCase)) {\n    return NS_OK;\n  }", "attachment_id": 556759, "tags": [], "bug_id": 682813, "text": "Comment on attachment 556759\nalong these lines...\n\n\n>+  nsCOMPtr<nsIContent> targetContent = do_QueryInterface(targetNode);\n>+  if (!targetContent) {\n>+    return NS_OK;\n>+  }\n>+  if (targetContent->Tag() == nsGkAtoms::browser &&\n>+      targetContent->IsXUL() &&\n>+      targetContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::Remote,\n>+                                 nsGkAtoms::_true, eIgnoreCase)) {\n>+    printf(\"IGNORING CONTEXT MENU EVENT\");\n>+    return NS_OK;\n>+  }\n\n  nsCOMPtr<nsIContent> targetContent = do_QueryInterface(targetNode);\n  if (targetContent && \n      targetContent->Tag() == nsGkAtoms::browser &&\n      targetContent->IsXUL() &&\n      targetContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::Remote,\n                                 nsGkAtoms::_true, eIgnoreCase)) {\n    return NS_OK;\n  }", "is_private": false, "count": 11, "id": 5687236, "author": "bugs@pettay.fi", "creator": "bugs@pettay.fi", "creation_time": "2011-08-30T09:32:57Z", "time": "2011-08-30T09:32:57Z"}, {"tags": [], "text": "Not landing this patch as it's not really need anymore.", "bug_id": 682813, "raw_text": "Not landing this patch as it's not really need anymore.", "attachment_id": null, "author": "asaf@sent.com", "creation_time": "2011-12-31T17:07:32Z", "time": "2011-12-31T17:07:32Z", "creator": "asaf@sent.com", "count": 12, "id": 5948475, "is_private": false}, {"tags": [], "text": "We still support out-of-process content.  We'll probably need this patch for b2g.", "bug_id": 682813, "attachment_id": null, "raw_text": "We still support out-of-process content.  We'll probably need this patch for b2g.", "creation_time": "2012-01-03T21:15:53Z", "time": "2012-01-03T21:15:53Z", "creator": "cjones.bugs@gmail.com", "author": "cjones.bugs@gmail.com", "id": 5952005, "count": 13, "is_private": false}]}}, "comments": {}}