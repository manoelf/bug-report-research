{"bugs": {"686370": {"comments": [{"count": 0, "text": "There's a pretty stable and accepted specification at http://wiki.whatwg.org/wiki/Video_Metrics for stats to be presented for video/audio elements. They're similar to our existing stats.\n\nSee also http://openetherpad.org/ovc11-standards-for-browser-video-statistics for discussion, and http://www.w3.org/Bugs/Public/show_bug.cgi?id=12399 .", "author": "chris@pearce.org.nz", "bug_id": 686370, "id": 5714720, "time": "2011-09-12T22:43:41Z", "raw_text": "There's a pretty stable and accepted specification at http://wiki.whatwg.org/wiki/Video_Metrics for stats to be presented for video/audio elements. They're similar to our existing stats.\n\nSee also http://openetherpad.org/ovc11-standards-for-browser-video-statistics for discussion, and http://www.w3.org/Bugs/Public/show_bug.cgi?id=12399 .", "creator": "chris@pearce.org.nz", "creation_time": "2011-09-12T22:43:41Z", "is_private": false, "attachment_id": null, "tags": []}, {"creation_time": "2011-12-12T05:13:25Z", "is_private": false, "id": 5907879, "bug_id": 686370, "count": 1, "text": "I've got some students that might like to work on this in January if it's not done by then ;)", "author": "david.humphrey@senecacollege.ca", "creator": "david.humphrey@senecacollege.ca", "tags": [], "raw_text": "I've got some students that might like to work on this in January if it's not done by then ;)", "attachment_id": null, "time": "2011-12-12T05:13:25Z"}, {"tags": [], "time": "2012-01-12T18:32:17Z", "raw_text": "Hey Humph,\n\nAfter our discussion in class I'd like to work on this bug.  Mind assigning it to me?", "attachment_id": null, "bug_id": 686370, "id": 5975890, "creation_time": "2012-01-12T18:32:17Z", "is_private": false, "creator": "david.c.seifried@gmail.com", "text": "Hey Humph,\n\nAfter our discussion in class I'd like to work on this bug.  Mind assigning it to me?", "count": 2, "author": "david.c.seifried@gmail.com"}, {"creator": "chris@pearce.org.nz", "creation_time": "2012-01-12T19:54:47Z", "is_private": false, "attachment_id": null, "tags": [], "count": 3, "text": "David Seifried, my original implementation of this was done in bug 580531, my patches/changesets in that bug should give you an idea how to implement this.", "author": "chris@pearce.org.nz", "bug_id": 686370, "id": 5976252, "raw_text": "David Seifried, my original implementation of this was done in bug 580531, my patches/changesets in that bug should give you an idea how to implement this.", "time": "2012-01-12T19:54:47Z"}, {"tags": [], "raw_text": "Thanks Chris, I'll be sure to take a look.", "attachment_id": null, "time": "2012-01-12T19:59:01Z", "creation_time": "2012-01-12T19:59:01Z", "is_private": false, "id": 5976276, "bug_id": 686370, "count": 4, "text": "Thanks Chris, I'll be sure to take a look.", "author": "david.c.seifried@gmail.com", "creator": "david.c.seifried@gmail.com"}, {"tags": [], "attachment_id": 616157, "creation_time": "2012-04-18T15:37:44Z", "is_private": false, "creator": "schranz.m@gmail.com", "raw_text": "Couple of things:\n\n1. I'm fairly certain the data types I'm using the the attribute itself are screwed up. As far as I could tell in the spec it wasn't too specific on this front.\n2. As you will notice in the patch, I left a little \"thisWillNotPass\" hint for the Ogg stuff as I wasn't sure how to approach this from that end since it makes calls to this same function.\n\n\nAnyway, any suggestions/criticisms are welcome! Let me know how badly I screwed up :p", "time": "2012-04-18T15:37:44Z", "id": 6233783, "bug_id": 686370, "author": "schranz.m@gmail.com", "text": "Created attachment 616157\nInitial PlaybackJitter Patch\n\nCouple of things:\n\n1. I'm fairly certain the data types I'm using the the attribute itself are screwed up. As far as I could tell in the spec it wasn't too specific on this front.\n2. As you will notice in the patch, I left a little \"thisWillNotPass\" hint for the Ogg stuff as I wasn't sure how to approach this from that end since it makes calls to this same function.\n\n\nAnyway, any suggestions/criticisms are welcome! Let me know how badly I screwed up :p", "count": 5}, {"creation_time": "2012-04-20T02:20:58Z", "is_private": false, "id": 6239773, "bug_id": 686370, "text": "Comment on attachment 616157\nInitial PlaybackJitter Patch\n\nReview of attachment 616157:\n-----------------------------------------------------------------\n\nYou've made a good start, but there's still plenty to do, keep it up! :)\n\nAre you going to attempt to implement the other metrics (like bytesReceived etc)? You'd be best to tackle one at a time though.\n\n::: content/media/VideoFrameContainer.cpp\n@@ +17,5 @@\n>  \n>  void VideoFrameContainer::SetCurrentFrame(const gfxIntSize& aIntrinsicSize,\n>                                            Image* aImage,\n> +                                          TimeStamp aTargetTime,\n> +                                          PRInt64 aIntendedDuration)\n\naIntendedDuration should be a TimeDuration.\n\n@@ +38,5 @@\n>      mImageSizeChanged = true;\n>    }\n>  \n> +  if (!lastPaintTime.IsNull() && !aTargetTime.IsNull()) {\n> +    mPlaybackJitter += (aIntendedDuration - (aTargetTime - lastPaintTime).ToMilliseconds());\n\nSo playback jitter is defined at http://wiki.whatwg.org/wiki/Video_Metrics#playbackJitter as:\n\nplaybackJitter = sum(abs(Ei - Ai)) \n\nwhere:\nEi = Desired duration of frame i spent on the screen (to nearest microsecond?) \nAi = Actual duration frame i spent on the screen (if the frame is never presented to the user, then Ai == 0). \n\n(On most platforms we care about the timer resolution are limited to millisecond precision, so don't worry about microsecond position).\n\nAlso aTargetTime is the TimeStamp at which we should paint aImage, whereas lastPaintTime is the time at which the ImageContainer's *previous* image was painted. So the duration which the *previous* image was on screen for is (TimeStamp::Now() - lastPaintTime), and the previous image's duration was passed in last time this function was called.\n\nSo I think you should:\n1. Add a new field to VideoFrameContainer, TimeDuration mLastFrameIntendedDuration.\n2. When you enter SetCurrentFrame(), if we have a non-null mLastFrameIntendedDuration, then the jitter for the previous frame was:\nTimeDuration frameJitter = (TimeStamp::Now() - lastPaintTime) - mLastFrameIntendedDuration;\nCalculate this and add it to mPlaybackJitter (which can stay as a double, we return it to JS as a double).\n3. Set mLastFrameIntendedDuration to aIntendedDuration.\n\n::: content/media/VideoFrameContainer.h\n@@ +43,5 @@\n>      NS_ASSERTION(mImageContainer, \"aContainer must not be null\");\n>    }\n>    // Call on any thread\n>    void SetCurrentFrame(const gfxIntSize& aIntrinsicSize, Image* aImage,\n> +                       TimeStamp aTargetTime, PRInt64 aIntendedDuration);\n\naIntendedDuration should be a TimeDuration, not an PRInt64.\n\n@@ +48,5 @@\n>    // Time in seconds by which the last painted video frame was late by.\n>    // E.g. if the last painted frame should have been painted at time t,\n>    // but was actually painted at t+n, this returns n in seconds. Threadsafe.\n>    double GetFrameDelay();\n> +  // \n\nNeed a meaningful comment.\n\n@@ +76,5 @@\n>    // The delay between the last video frame being presented and it being\n>    // painted. This is time elapsed after mPaintTarget until the most recently\n>    // painted frame appeared on screen.\n>    TimeDuration mPaintDelay;\n> +  // TODO: Come up with a good comment.\n\nYes, you totally should. ;)\n\nA link to the wiki/spec would be good to include.\n\n::: content/media/nsBuiltinDecoderStateMachine.cpp\n@@ +1879,5 @@\n>      return;\n>    }\n>  \n> +  // Assuming that the times retrieved from the VideoData is the intended times for the frame\n> +  PRInt64 intendedDuration = aData->mEndTime - aData->mTime;\n\nI'd rather you used TimeDuration.\n\n::: content/media/ogg/nsOggReader.cpp\n@@ +272,4 @@\n>          container->SetCurrentFrame(gfxIntSize(displaySize.width, displaySize.height),\n>                                     nsnull,\n> +                                   TimeStamp::Now(),\n> +                                   thisWillNotPass);\n\nHmm, we'll need a way to not include video frame durations from frames that are displayed while we're not playing (paused, seeking etc). Otherwise they'll skew the jitter.\n\nHow about when we call SetCurrentFrame we pass in a boolean parameter to designate whether we paused since the last paint. We know if we were playing for the entire duration the previous frame was displayed; if we weren't, we shouldn't include its jitter in the jitter sum. You'll then need to figure out how to track this in the nsBuiltinDecoderStateMachine.", "count": 6, "author": "chris@pearce.org.nz", "creator": "chris@pearce.org.nz", "tags": [], "raw_text": "Review of attachment 616157:\n-----------------------------------------------------------------\n\nYou've made a good start, but there's still plenty to do, keep it up! :)\n\nAre you going to attempt to implement the other metrics (like bytesReceived etc)? You'd be best to tackle one at a time though.\n\n::: content/media/VideoFrameContainer.cpp\n@@ +17,5 @@\n>  \n>  void VideoFrameContainer::SetCurrentFrame(const gfxIntSize& aIntrinsicSize,\n>                                            Image* aImage,\n> +                                          TimeStamp aTargetTime,\n> +                                          PRInt64 aIntendedDuration)\n\naIntendedDuration should be a TimeDuration.\n\n@@ +38,5 @@\n>      mImageSizeChanged = true;\n>    }\n>  \n> +  if (!lastPaintTime.IsNull() && !aTargetTime.IsNull()) {\n> +    mPlaybackJitter += (aIntendedDuration - (aTargetTime - lastPaintTime).ToMilliseconds());\n\nSo playback jitter is defined at http://wiki.whatwg.org/wiki/Video_Metrics#playbackJitter as:\n\nplaybackJitter = sum(abs(Ei - Ai)) \n\nwhere:\nEi = Desired duration of frame i spent on the screen (to nearest microsecond?) \nAi = Actual duration frame i spent on the screen (if the frame is never presented to the user, then Ai == 0). \n\n(On most platforms we care about the timer resolution are limited to millisecond precision, so don't worry about microsecond position).\n\nAlso aTargetTime is the TimeStamp at which we should paint aImage, whereas lastPaintTime is the time at which the ImageContainer's *previous* image was painted. So the duration which the *previous* image was on screen for is (TimeStamp::Now() - lastPaintTime), and the previous image's duration was passed in last time this function was called.\n\nSo I think you should:\n1. Add a new field to VideoFrameContainer, TimeDuration mLastFrameIntendedDuration.\n2. When you enter SetCurrentFrame(), if we have a non-null mLastFrameIntendedDuration, then the jitter for the previous frame was:\nTimeDuration frameJitter = (TimeStamp::Now() - lastPaintTime) - mLastFrameIntendedDuration;\nCalculate this and add it to mPlaybackJitter (which can stay as a double, we return it to JS as a double).\n3. Set mLastFrameIntendedDuration to aIntendedDuration.\n\n::: content/media/VideoFrameContainer.h\n@@ +43,5 @@\n>      NS_ASSERTION(mImageContainer, \"aContainer must not be null\");\n>    }\n>    // Call on any thread\n>    void SetCurrentFrame(const gfxIntSize& aIntrinsicSize, Image* aImage,\n> +                       TimeStamp aTargetTime, PRInt64 aIntendedDuration);\n\naIntendedDuration should be a TimeDuration, not an PRInt64.\n\n@@ +48,5 @@\n>    // Time in seconds by which the last painted video frame was late by.\n>    // E.g. if the last painted frame should have been painted at time t,\n>    // but was actually painted at t+n, this returns n in seconds. Threadsafe.\n>    double GetFrameDelay();\n> +  // \n\nNeed a meaningful comment.\n\n@@ +76,5 @@\n>    // The delay between the last video frame being presented and it being\n>    // painted. This is time elapsed after mPaintTarget until the most recently\n>    // painted frame appeared on screen.\n>    TimeDuration mPaintDelay;\n> +  // TODO: Come up with a good comment.\n\nYes, you totally should. ;)\n\nA link to the wiki/spec would be good to include.\n\n::: content/media/nsBuiltinDecoderStateMachine.cpp\n@@ +1879,5 @@\n>      return;\n>    }\n>  \n> +  // Assuming that the times retrieved from the VideoData is the intended times for the frame\n> +  PRInt64 intendedDuration = aData->mEndTime - aData->mTime;\n\nI'd rather you used TimeDuration.\n\n::: content/media/ogg/nsOggReader.cpp\n@@ +272,4 @@\n>          container->SetCurrentFrame(gfxIntSize(displaySize.width, displaySize.height),\n>                                     nsnull,\n> +                                   TimeStamp::Now(),\n> +                                   thisWillNotPass);\n\nHmm, we'll need a way to not include video frame durations from frames that are displayed while we're not playing (paused, seeking etc). Otherwise they'll skew the jitter.\n\nHow about when we call SetCurrentFrame we pass in a boolean parameter to designate whether we paused since the last paint. We know if we were playing for the entire duration the previous frame was displayed; if we weren't, we shouldn't include its jitter in the jitter sum. You'll then need to figure out how to track this in the nsBuiltinDecoderStateMachine.", "attachment_id": 616157, "time": "2012-04-20T02:20:58Z"}, {"tags": [], "time": "2012-04-20T02:27:23Z", "attachment_id": 616157, "raw_text": "Review of attachment 616157:\n-----------------------------------------------------------------\n\n::: content/media/ogg/nsOggReader.cpp\n@@ +272,4 @@\n>          container->SetCurrentFrame(gfxIntSize(displaySize.width, displaySize.height),\n>                                     nsnull,\n> +                                   TimeStamp::Now(),\n> +                                   thisWillNotPass);\n\nArgh, was a but trigger happy on the review for this. What I meant to say is that you need to figure out if we were paused at some point during the last frame, and I think tracking whether we paused (whether nsBuiltinDecoderStateMachine::StopPlayback() was called) since the last call to SetCurrentFrame() is an easy way to achieve this.", "id": 6239785, "bug_id": 686370, "creation_time": "2012-04-20T02:27:23Z", "is_private": false, "creator": "chris@pearce.org.nz", "author": "chris@pearce.org.nz", "count": 7, "text": "Comment on attachment 616157\nInitial PlaybackJitter Patch\n\nReview of attachment 616157:\n-----------------------------------------------------------------\n\n::: content/media/ogg/nsOggReader.cpp\n@@ +272,4 @@\n>          container->SetCurrentFrame(gfxIntSize(displaySize.width, displaySize.height),\n>                                     nsnull,\n> +                                   TimeStamp::Now(),\n> +                                   thisWillNotPass);\n\nArgh, was a but trigger happy on the review for this. What I meant to say is that you need to figure out if we were paused at some point during the last frame, and I think tracking whether we paused (whether nsBuiltinDecoderStateMachine::StopPlayback() was called) since the last call to SetCurrentFrame() is an easy way to achieve this."}, {"attachment_id": null, "raw_text": "> Are you going to attempt to implement the other metrics (like bytesReceived\n> etc)? You'd be best to tackle one at a time though.\n\nYeap we plan on finishing them all :) I have bytesDecoded, bytesReceived, and droppedFrames ( this one only sort of ) working. Do you want me to put those up for review or wait until I get the others done as well?", "time": "2012-04-20T02:53:23Z", "tags": [], "author": "david.c.seifried@gmail.com", "count": 8, "text": "> Are you going to attempt to implement the other metrics (like bytesReceived\n> etc)? You'd be best to tackle one at a time though.\n\nYeap we plan on finishing them all :) I have bytesDecoded, bytesReceived, and droppedFrames ( this one only sort of ) working. Do you want me to put those up for review or wait until I get the others done as well?", "creator": "david.c.seifried@gmail.com", "creation_time": "2012-04-20T02:53:23Z", "is_private": false, "id": 6239815, "bug_id": 686370}, {"creator": "chris@pearce.org.nz", "is_private": false, "creation_time": "2012-04-20T02:56:19Z", "attachment_id": null, "tags": [], "text": "When you think they're ready for review put them up. That way you can parallelize; your work is less likely to be totally blocked waiting on me to review them all at once.", "count": 9, "author": "chris@pearce.org.nz", "bug_id": 686370, "id": 6239819, "raw_text": "When you think they're ready for review put them up. That way you can parallelize; your work is less likely to be totally blocked waiting on me to review them all at once.", "time": "2012-04-20T02:56:19Z"}, {"id": 6239822, "bug_id": 686370, "creation_time": "2012-04-20T02:59:13Z", "is_private": false, "creator": "david.c.seifried@gmail.com", "count": 10, "text": "Alright will do", "author": "david.c.seifried@gmail.com", "tags": [], "time": "2012-04-20T02:59:13Z", "raw_text": "Alright will do", "attachment_id": null}, {"attachment_id": null, "tags": [], "creator": "jdinbox@gmail.com", "is_private": false, "creation_time": "2012-04-20T06:50:31Z", "raw_text": "Would be nice to add these to the default videocontrol stats (as implemented in bug 669260). Followup?", "time": "2012-04-20T06:50:31Z", "text": "Would be nice to add these to the default videocontrol stats (as implemented in bug 669260). Followup?", "count": 11, "author": "jdinbox@gmail.com", "bug_id": 686370, "id": 6240111}, {"creation_time": "2013-06-27T20:27:51Z", "is_private": false, "creator": "alex_y_xu@yahoo.ca", "tags": [], "attachment_id": null, "bug_id": 686370, "id": 7582603, "count": 12, "text": "Pokey pokey. Progress?", "author": "alex_y_xu@yahoo.ca", "time": "2013-06-27T20:27:51Z", "raw_text": "Pokey pokey. Progress?"}]}}, "comments": {}}