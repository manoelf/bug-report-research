{"bugs": {"670462": {"comments": [{"is_private": false, "count": 0, "id": 5582954, "author": "brian@briansmith.org", "creator": "brian@briansmith.org", "creation_time": "2011-07-09T20:20:43Z", "time": "2011-07-09T20:20:43Z", "raw_text": "+++ This bug was initially created as a clone of Bug #640625 +++\n\nThe patch in bug 640625 will raise the default iteration count from 1 to thousands.  But, for many applications, the iteration count should be in the millions. (Though, PKCS#12 may not be appropriate at all for those applications.)\n\nThis will require a new API. I also noticed that the current API doesn't let the caller pass in Unicode passwords (we assume ASCII and convert to Unicode internally). The new API should accept a Unicode password as well as the iteration count, so that we don't have to introduce a Unicode-capable API later.", "attachment_id": null, "tags": [], "bug_id": 670462, "text": "+++ This bug was initially created as a clone of Bug #640625 +++\n\nThe patch in bug 640625 will raise the default iteration count from 1 to thousands.  But, for many applications, the iteration count should be in the millions. (Though, PKCS#12 may not be appropriate at all for those applications.)\n\nThis will require a new API. I also noticed that the current API doesn't let the caller pass in Unicode passwords (we assume ASCII and convert to Unicode internally). The new API should accept a Unicode password as well as the iteration count, so that we don't have to introduce a Unicode-capable API later."}, {"attachment_id": null, "raw_text": "more iterations will be more secure, but can't really say this bug itself is a vulnerability once bug 640625 patches the immediate problem.", "tags": [], "bug_id": 670462, "text": "more iterations will be more secure, but can't really say this bug itself is a vulnerability once bug 640625 patches the immediate problem.", "id": 5590308, "count": 1, "is_private": false, "time": "2011-07-13T23:58:28Z", "creation_time": "2011-07-13T23:58:28Z", "creator": "dveditz@mozilla.com", "author": "dveditz@mozilla.com"}, {"bug_id": 670462, "text": "(In reply to comment #0)\n> This will require a new API. I also noticed that the current API doesn't let\n> the caller pass in Unicode passwords (we assume ASCII and convert to Unicode\n> internally). The new API should accept a Unicode password as well as the\n> iteration count, so that we don't have to introduce a Unicode-capable API\n> later.\n\nThe old API did allow the caller to pass in Unicode in a quite roundabout way. Should the new APIs make this more straightforward?", "tags": [], "raw_text": "(In reply to comment #0)\n> This will require a new API. I also noticed that the current API doesn't let\n> the caller pass in Unicode passwords (we assume ASCII and convert to Unicode\n> internally). The new API should accept a Unicode password as well as the\n> iteration count, so that we don't have to introduce a Unicode-capable API\n> later.\n\nThe old API did allow the caller to pass in Unicode in a quite roundabout way. Should the new APIs make this more straightforward?", "attachment_id": null, "author": "brian@briansmith.org", "creation_time": "2011-07-14T00:44:49Z", "time": "2011-07-14T00:44:49Z", "creator": "brian@briansmith.org", "id": 5590406, "count": 2, "is_private": false}, {"creation_time": "2011-07-14T17:08:11Z", "time": "2011-07-14T17:08:11Z", "creator": "rrelyea@redhat.com", "author": "rrelyea@redhat.com", "id": 5591586, "count": 3, "is_private": false, "tags": [], "bug_id": 670462, "text": "Let's open another bug on the Unicode issue. It's not really a security sensitive issue.\n\nI have some question about what is the issue with unicode? There are more than one Unicode standard for encoding the unicode space:\n    UCS-1, UCS-2, UCS-4 are all fixed unicode values which can only encode a portion of the full 32-bit Unicode space. Usually when people talk about Unicode, they usually mean UCS-2, which can encode the full 16-bit Unicode space. I don't know of any code pages that are not encoded in the 16-bit space, so ofthen UCS-2 is considered sufficient. (1, 2, and 4 are number of 8-bit bytes in the standard). UCS-2, and UCS-4 usually have machine specific byte order.\n    UTF-8 and UTF-16 are 8-bit and 16-bit encodings that can map the entire UCS-4 name space at the coast of expanding the amount of space to map some of the code pages (for instance, Thai characters typically take 3 bytes in UTF-8 rather than 2 in UCS-2).\n\nAll of these are unicode encodings.\n\n The PCKS #12 interface is supposed to take UTF-8. Internally the PKCS #12 spec says the password needs to be in  UCS-2 format before the hashing. The question is are we properly converting UTF-8 to UCS-2, or just adding '0' to the bytes.\n\n I thought our conversion routines were proper. If they are not, then we may have an issue. That issue is that if you passed a UTF-8 password in when mozilla encoded the certs, then we won't be able to decode them once we handle UTF-8 properly. We will be able to decode PKCS #12 data written by other applications (and they will be able to decode our  PKCS #12 files with UTF-8 passwords). The down side is older versions of Netscape and Mozilla will not be able to decode UTF-8 encoded PKCS #12 files with the new encoding and we can't decode UTF-8 encoded older passwords.\n\nAnyway, to be clear, what is the issue. Is it that we aren't properly converting UTF-8, or is it that someone wants a UCS-2 interface. If it's the latter, then I would suggest it's very non-NSS like to provide that. NSS is very consistantly UTF-8 throughout.", "attachment_id": null, "raw_text": "Let's open another bug on the Unicode issue. It's not really a security sensitive issue.\n\nI have some question about what is the issue with unicode? There are more than one Unicode standard for encoding the unicode space:\n    UCS-1, UCS-2, UCS-4 are all fixed unicode values which can only encode a portion of the full 32-bit Unicode space. Usually when people talk about Unicode, they usually mean UCS-2, which can encode the full 16-bit Unicode space. I don't know of any code pages that are not encoded in the 16-bit space, so ofthen UCS-2 is considered sufficient. (1, 2, and 4 are number of 8-bit bytes in the standard). UCS-2, and UCS-4 usually have machine specific byte order.\n    UTF-8 and UTF-16 are 8-bit and 16-bit encodings that can map the entire UCS-4 name space at the coast of expanding the amount of space to map some of the code pages (for instance, Thai characters typically take 3 bytes in UTF-8 rather than 2 in UCS-2).\n\nAll of these are unicode encodings.\n\n The PCKS #12 interface is supposed to take UTF-8. Internally the PKCS #12 spec says the password needs to be in  UCS-2 format before the hashing. The question is are we properly converting UTF-8 to UCS-2, or just adding '0' to the bytes.\n\n I thought our conversion routines were proper. If they are not, then we may have an issue. That issue is that if you passed a UTF-8 password in when mozilla encoded the certs, then we won't be able to decode them once we handle UTF-8 properly. We will be able to decode PKCS #12 data written by other applications (and they will be able to decode our  PKCS #12 files with UTF-8 passwords). The down side is older versions of Netscape and Mozilla will not be able to decode UTF-8 encoded PKCS #12 files with the new encoding and we can't decode UTF-8 encoded older passwords.\n\nAnyway, to be clear, what is the issue. Is it that we aren't properly converting UTF-8, or is it that someone wants a UCS-2 interface. If it's the latter, then I would suggest it's very non-NSS like to provide that. NSS is very consistantly UTF-8 throughout."}, {"author": "kaie@kuix.de", "tags": [], "text": "Bob, in your comment, you had focussed on the unicode detail of the request, although I'd consider that just a secondary detail. Because Unicode can be converted to UTF-8, it should be acceptable to define that the input must be UTF-8.\n\nThe primary request here is to have a mechanism that controls the number of iterations used.\n\nIt seems the existing interfaces don't allow to do that, so we'd need a new API.\n\nHow about adding a new API, that allows to override the NSS built-in default, and will cause all future operations to use the configured number of iterations?", "bug_id": 670462, "creator": "kaie@kuix.de", "creation_time": "2017-06-21T16:53:47Z", "time": "2017-06-21T16:53:47Z", "raw_text": "Bob, in your comment, you had focussed on the unicode detail of the request, although I'd consider that just a secondary detail. Because Unicode can be converted to UTF-8, it should be acceptable to define that the input must be UTF-8.\n\nThe primary request here is to have a mechanism that controls the number of iterations used.\n\nIt seems the existing interfaces don't allow to do that, so we'd need a new API.\n\nHow about adding a new API, that allows to override the NSS built-in default, and will cause all future operations to use the configured number of iterations?", "is_private": false, "attachment_id": null, "id": 12418590, "count": 4}, {"tags": [], "text": "I'm OK with adding an interface to pass the iteration count. My comment was only a reply to comment 2 (asking if the interface should contain Unicode). The modern PBEs take UTF8 anyway. The interation count is already part of the low level NSS interface.", "bug_id": 670462, "attachment_id": null, "raw_text": "I'm OK with adding an interface to pass the iteration count. My comment was only a reply to comment 2 (asking if the interface should contain Unicode). The modern PBEs take UTF8 anyway. The interation count is already part of the low level NSS interface.", "time": "2017-08-16T22:03:13Z", "creation_time": "2017-08-16T22:03:13Z", "creator": "rrelyea@redhat.com", "author": "rrelyea@redhat.com", "count": 5, "id": 12573133, "is_private": false}]}}, "comments": {}}