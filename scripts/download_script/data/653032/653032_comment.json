{"comments": {}, "bugs": {"653032": {"comments": [{"count": 0, "text": "User-Agent:       Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.9.2.16) Gecko/20110319 Firefox/3.6.16 (.NET CLR 3.5.30729)\nBuild Identifier: nss-3.12.8-with-nspr-4.8.6.tar.gz\n\nI think I have found a particular set of inputs where the field_mod() functions for the NIST-P192 and NIST-P224 curves generates incorrect results. I have attached a sample C program that reproduces the error, and a patch that fixes the problem. This patch has only been tested on 64-bit platforms.\n\nThe problem seems to be caused by not implementing carries on the final reduction of the mod function. For P192, this bug should occur for both 32 and 64-bit builds, and for P224 this should occur for only 64-bit builds.\n\nAlso, the field_mod() functions for P192 and P224 were missing a call to s_mp_clamp() which causes problems when the result is close to zero.\n\nReproducible: Always\n\nSteps to Reproduce:\n1. Build the ECL and MPI libraries with NSS_ECC_MORE_THAN_SUITE_B defined.\n2. Build the sample program and run it from a Linux command line.\n\n\nActual Results:  \n[osk@rayon ecl] gcc modtest.c ../mpi/libmpi.a libecl.a ../mpi/mp_gf2m.o -I../mpi -O2 -Wall -o modtest\n[osk@rayon ecl] ./modtest\nfield_mod disagrees with mp_mod for p=NIST-P192!\nfield_mod disagrees with mp_mod for p=NIST-P224!\nfield_mod agrees with mp_mod for p=NIST-P256!", "time": "2011-04-27T02:03:15Z", "author": "osk@exegin.com", "id": 5433816, "creation_time": "2011-04-27T02:03:15Z", "bug_id": 653032, "raw_text": "User-Agent:       Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.9.2.16) Gecko/20110319 Firefox/3.6.16 (.NET CLR 3.5.30729)\nBuild Identifier: nss-3.12.8-with-nspr-4.8.6.tar.gz\n\nI think I have found a particular set of inputs where the field_mod() functions for the NIST-P192 and NIST-P224 curves generates incorrect results. I have attached a sample C program that reproduces the error, and a patch that fixes the problem. This patch has only been tested on 64-bit platforms.\n\nThe problem seems to be caused by not implementing carries on the final reduction of the mod function. For P192, this bug should occur for both 32 and 64-bit builds, and for P224 this should occur for only 64-bit builds.\n\nAlso, the field_mod() functions for P192 and P224 were missing a call to s_mp_clamp() which causes problems when the result is close to zero.\n\nReproducible: Always\n\nSteps to Reproduce:\n1. Build the ECL and MPI libraries with NSS_ECC_MORE_THAN_SUITE_B defined.\n2. Build the sample program and run it from a Linux command line.\n\n\nActual Results:  \n[osk@rayon ecl] gcc modtest.c ../mpi/libmpi.a libecl.a ../mpi/mp_gf2m.o -I../mpi -O2 -Wall -o modtest\n[osk@rayon ecl] ./modtest\nfield_mod disagrees with mp_mod for p=NIST-P192!\nfield_mod disagrees with mp_mod for p=NIST-P224!\nfield_mod agrees with mp_mod for p=NIST-P256!", "tags": [], "creator": "osk@exegin.com", "is_private": false, "attachment_id": null}, {"count": 1, "text": "Created attachment 528508\nC program which generates bad results from field_mod().\n\nI compiled this program as follows:\n[osk@rayon mpi]$ make libs\n[osk@rayon mpi]$ cd ../ecl\n[osk@rayon ecl]$ make libs CFLAGS=\"-DNSS_ECC_MORE_THAN_SUITE_B -DMP_API_COMPATIBLE -DMP_IOFUNC -I../mpi\"\n[osk@rayon ecl]$ gcc modtest.c ../mpi/libmpi.a libecl.a ../mpi/mp_gf2m.o -I../mpi -O2 -Wall -o modtest", "time": "2011-04-27T02:06:34Z", "author": "osk@exegin.com", "id": 5433822, "creation_time": "2011-04-27T02:06:34Z", "bug_id": 653032, "raw_text": "I compiled this program as follows:\n[osk@rayon mpi]$ make libs\n[osk@rayon mpi]$ cd ../ecl\n[osk@rayon ecl]$ make libs CFLAGS=\"-DNSS_ECC_MORE_THAN_SUITE_B -DMP_API_COMPATIBLE -DMP_IOFUNC -I../mpi\"\n[osk@rayon ecl]$ gcc modtest.c ../mpi/libmpi.a libecl.a ../mpi/mp_gf2m.o -I../mpi -O2 -Wall -o modtest", "tags": [], "creator": "osk@exegin.com", "attachment_id": 528508, "is_private": false}, {"id": 5433824, "time": "2011-04-27T02:10:08Z", "is_private": false, "tags": [], "raw_text": "", "bug_id": 653032, "creation_time": "2011-04-27T02:10:08Z", "author": "osk@exegin.com", "text": "Created attachment 528509\nPatch that fixes the final reduction and clamps the result.", "count": 2, "attachment_id": 528509, "creator": "osk@exegin.com"}, {"time": "2011-04-27T19:11:21Z", "id": 5435416, "raw_text": "What is the security impact of this bug for Mozilla?", "bug_id": 653032, "creation_time": "2011-04-27T19:11:21Z", "tags": [], "is_private": false, "count": 3, "text": "What is the security impact of this bug for Mozilla?", "author": "brian@briansmith.org", "creator": "brian@briansmith.org", "attachment_id": null}, {"is_private": false, "attachment_id": null, "creation_time": "2011-04-27T19:47:18Z", "bug_id": 653032, "raw_text": "The impact of this bug is that very rarely when using NIST-P192 or P224, ECDH and ECDSA operations will fail to agree.\n\nFor NIST-P192, this bug will only occur when the output of the mod function is equal to 1<<64, in which case the output will be zero instead. If an attacker were able to choose inputs such that any of the mod operations result in (1<<64), then the loss of entropy could allow an attacker to guess the result of a point multiplication.\n\nAs for NIST-P224, when this error occurs, there is no entropy lost, but some of the bits in the result have been inverted. If an attacker were able to choose inputs to trigger this bug, the result will be corrupted, but should still be unpredictable. However, hackers tend to be crafty people, and I could be proven wrong.", "tags": [], "creator": "osk@exegin.com", "time": "2011-04-27T19:47:18Z", "author": "osk@exegin.com", "id": 5435497, "text": "The impact of this bug is that very rarely when using NIST-P192 or P224, ECDH and ECDSA operations will fail to agree.\n\nFor NIST-P192, this bug will only occur when the output of the mod function is equal to 1<<64, in which case the output will be zero instead. If an attacker were able to choose inputs such that any of the mod operations result in (1<<64), then the loss of entropy could allow an attacker to guess the result of a point multiplication.\n\nAs for NIST-P224, when this error occurs, there is no entropy lost, but some of the bits in the result have been inverted. If an attacker were able to choose inputs to trigger this bug, the result will be corrupted, but should still be unpredictable. However, hackers tend to be crafty people, and I could be proven wrong.", "count": 4}, {"creator": "brian@briansmith.org", "attachment_id": null, "text": "To what extent are we confident that there aren't similar problems in the P-256, P-384, and P-521 implementations?", "count": 5, "author": "brian@briansmith.org", "creation_time": "2011-04-27T20:12:46Z", "bug_id": 653032, "raw_text": "To what extent are we confident that there aren't similar problems in the P-256, P-384, and P-521 implementations?", "tags": [], "is_private": false, "time": "2011-04-27T20:12:46Z", "id": 5435561}, {"time": "2011-04-27T20:34:22Z", "author": "osk@exegin.com", "id": 5435608, "count": 6, "text": "I have run my test program against all of the NIST prime fields, and P192 and P256 are the only two that give problems. A visual inspection of the final reduction code for P256 and P384 looks to be free of this bug (they use mp_sub() rather than guess at what the high-order bits should be). The mod function for P521 is completely different, and I can draw no parallels between the it and code for smaller primes.\n\nAnd completely off topic; why does the code for P384 call mp_submod(), doesn't that completely defeat the point of having an optimized mod function?", "attachment_id": null, "is_private": false, "bug_id": 653032, "creation_time": "2011-04-27T20:34:22Z", "raw_text": "I have run my test program against all of the NIST prime fields, and P192 and P256 are the only two that give problems. A visual inspection of the final reduction code for P256 and P384 looks to be free of this bug (they use mp_sub() rather than guess at what the high-order bits should be). The mod function for P521 is completely different, and I can draw no parallels between the it and code for smaller primes.\n\nAnd completely off topic; why does the code for P384 call mp_submod(), doesn't that completely defeat the point of having an optimized mod function?", "tags": [], "creator": "osk@exegin.com"}, {"author": "brian@briansmith.org", "count": 7, "text": "Thanks Owen. I filed Bug 653236 about your off-topic question. Please file bugs for inefficiencies you see in the code, especially for P256 and P384.", "attachment_id": null, "creator": "brian@briansmith.org", "id": 5435677, "time": "2011-04-27T20:55:23Z", "is_private": false, "tags": [], "raw_text": "Thanks Owen. I filed Bug 653236 about your off-topic question. Please file bugs for inefficiencies you see in the code, especially for P256 and P384.", "creation_time": "2011-04-27T20:55:23Z", "bug_id": 653032}, {"attachment_id": null, "creator": "osk@exegin.com", "author": "osk@exegin.com", "count": 8, "text": "(In reply to comment #6)\n> P192 and P256 are the only two that give problems.\n\nThat was a typo, I should have said that P192 and P224 are the only two that give problems.", "is_private": false, "creation_time": "2011-04-27T20:57:56Z", "bug_id": 653032, "raw_text": "(In reply to comment #6)\n> P192 and P256 are the only two that give problems.\n\nThat was a typo, I should have said that P192 and P224 are the only two that give problems.", "tags": [], "time": "2011-04-27T20:57:56Z", "id": 5435682}, {"attachment_id": 529160, "creator": "osk@exegin.com", "author": "osk@exegin.com", "count": 9, "text": "Created attachment 529160\nPatch to P192, P256, and P521 mod functions.\n\nMy original patch introduced a bug that would break the mod function when computing a result that was congruent with zero (eg: p mod p). Testing this also revealed that the mod function for P521 was broken for this case too, so it has also been fixed in this patch.", "is_private": false, "tags": [], "creation_time": "2011-04-29T18:58:00Z", "bug_id": 653032, "raw_text": "My original patch introduced a bug that would break the mod function when computing a result that was congruent with zero (eg: p mod p). Testing this also revealed that the mod function for P521 was broken for this case too, so it has also been fixed in this patch.", "id": 5440128, "time": "2011-04-29T18:58:00Z"}, {"id": 5440139, "time": "2011-04-29T19:01:31Z", "tags": [], "raw_text": "This is an updated version of my test program which now checks for results that should be congruent with zero (p mod p, and p^2 mod p), and adds tests for all of the NIST prime fields.", "bug_id": 653032, "creation_time": "2011-04-29T19:01:31Z", "is_private": false, "count": 10, "text": "Created attachment 529162\nC program to test field_mod.\n\nThis is an updated version of my test program which now checks for results that should be congruent with zero (p mod p, and p^2 mod p), and adds tests for all of the NIST prime fields.", "author": "osk@exegin.com", "creator": "osk@exegin.com", "attachment_id": 529162}, {"time": "2012-04-16T02:43:39Z", "id": 6224807, "raw_text": "Delegating unassigned reviews. Please reassign as appropriate. Thanks!", "bug_id": 653032, "creation_time": "2012-04-16T02:43:39Z", "tags": [], "is_private": false, "count": 11, "text": "Comment on attachment 529160\nPatch to P192, P256, and P521 mod functions.\n\nDelegating unassigned reviews. Please reassign as appropriate. Thanks!", "author": "jdinbox@gmail.com", "creator": "jdinbox@gmail.com", "attachment_id": 529160}, {"id": 6263517, "time": "2012-04-29T07:41:39Z", "tags": [], "bug_id": 653032, "creation_time": "2012-04-29T07:41:39Z", "raw_text": "Bob, could you review this? I do not have a strong understanding of this code.", "is_private": false, "text": "Comment on attachment 529160\nPatch to P192, P256, and P521 mod functions.\n\nBob, could you review this? I do not have a strong understanding of this code.", "count": 12, "author": "brian@briansmith.org", "creator": "brian@briansmith.org", "attachment_id": 529160}, {"id": 6274101, "time": "2012-05-02T20:48:54Z", "is_private": false, "tags": [], "raw_text": "Yes, I need to get my ECC book out to verify some things.\n\nSome general comments. I looks like the 192 problem is the failure to incorporate r1. I would prefer if the code used the MP_ADD_CARRY macros.\n\nFor 224, the 2 32 bit cases are identical. The problem is we need to zero out the top bits of in the 64 bit case. The compliment code accomplishes this.\n\nThe 521 bit case looks correct. (if r == p, then r needs to be zero).\n\nI'll do an official review once I bring in my ECC book.\n\nbob", "creation_time": "2012-05-02T20:48:54Z", "bug_id": 653032, "author": "rrelyea@redhat.com", "count": 13, "text": "Yes, I need to get my ECC book out to verify some things.\n\nSome general comments. I looks like the 192 problem is the failure to incorporate r1. I would prefer if the code used the MP_ADD_CARRY macros.\n\nFor 224, the 2 32 bit cases are identical. The problem is we need to zero out the top bits of in the 64 bit case. The compliment code accomplishes this.\n\nThe 521 bit case looks correct. (if r == p, then r needs to be zero).\n\nI'll do an official review once I bring in my ECC book.\n\nbob", "attachment_id": null, "creator": "rrelyea@redhat.com"}, {"text": "First, thanks for finding this, owen, and doing the work to come up with a patch.\n\n> A visual inspection of the final reduction code for P256 and P384 looks to be free of this bug\n> (they use mp_sub() rather than guess at what the high-order bits should be). The mod function\n> for P521 is completely different, and I can draw no parallels between the it and code for\n> smaller primes.\n\nThe 521, 192, and 244 bit curves have smaller number of component than the 256 and 384 bit curves, so it's worth doing the final subtraction \"by hand\". The bug in the 192 curve is the curve is:\n\n2^192-2^64-1, which means to do the final subtraction we need to subract 2^192-2^64-1. We do this by adding 2^64+1, except the code was not adding 2^64.\n\nFor the 244 bit curve we need to subtract 2^224-2^96+1. We correctly subtract the 1, but we only implicitly subtract the -2^96 in the 32 bit case (by zeroing the high bits of r1. In the 64 bit case we need to explicitly subtract the -2^96.\n\nFor the 521 bit case there is only one case where we can be >=2^521-1, and that is if we are exactly equal to it, which is the patch owen added.\n\nIn the 256 bit case, the has many more components so that it's easier (clearer, safer, and probably just as fast), to do an mp_sub.\n\n> And completely off topic; why does the code for P384 call mp_submod(), doesn't that\n> completely defeat the point of having an optimized mod function?\n\nIn the 384 bit case, this code has not been completely optimized notice that it's still doing full adds. In theory there should be some win. doing an mp_mod where the dividend is large compared to the divisor is more expensive than if it's small. Still the gain isn't likely great. I would be happy to review a patch that fixes this issue. (It might be interesting to compare doing a 384 'optimized' against a straight 384 prime field implementation.\n\nAnyway ownen's patch is correct. I would like to make a few changes that makes it clearer what was going on to the 192 and 244 changes. I'll attach something tomorrow.\n\nbob", "count": 14, "author": "rrelyea@redhat.com", "creator": "rrelyea@redhat.com", "attachment_id": null, "time": "2012-05-03T01:05:53Z", "id": 6275038, "creation_time": "2012-05-03T01:05:53Z", "bug_id": 653032, "raw_text": "First, thanks for finding this, owen, and doing the work to come up with a patch.\n\n> A visual inspection of the final reduction code for P256 and P384 looks to be free of this bug\n> (they use mp_sub() rather than guess at what the high-order bits should be). The mod function\n> for P521 is completely different, and I can draw no parallels between the it and code for\n> smaller primes.\n\nThe 521, 192, and 244 bit curves have smaller number of component than the 256 and 384 bit curves, so it's worth doing the final subtraction \"by hand\". The bug in the 192 curve is the curve is:\n\n2^192-2^64-1, which means to do the final subtraction we need to subract 2^192-2^64-1. We do this by adding 2^64+1, except the code was not adding 2^64.\n\nFor the 244 bit curve we need to subtract 2^224-2^96+1. We correctly subtract the 1, but we only implicitly subtract the -2^96 in the 32 bit case (by zeroing the high bits of r1. In the 64 bit case we need to explicitly subtract the -2^96.\n\nFor the 521 bit case there is only one case where we can be >=2^521-1, and that is if we are exactly equal to it, which is the patch owen added.\n\nIn the 256 bit case, the has many more components so that it's easier (clearer, safer, and probably just as fast), to do an mp_sub.\n\n> And completely off topic; why does the code for P384 call mp_submod(), doesn't that\n> completely defeat the point of having an optimized mod function?\n\nIn the 384 bit case, this code has not been completely optimized notice that it's still doing full adds. In theory there should be some win. doing an mp_mod where the dividend is large compared to the divisor is more expensive than if it's small. Still the gain isn't likely great. I would be happy to review a patch that fixes this issue. (It might be interesting to compare doing a 384 'optimized' against a straight 384 prime field implementation.\n\nAnyway ownen's patch is correct. I would like to make a few changes that makes it clearer what was going on to the 192 and 244 changes. I'll attach something tomorrow.\n\nbob", "tags": [], "is_private": false}, {"creator": "rrelyea@redhat.com", "attachment_id": 620796, "count": 15, "text": "Created attachment 620796\nC program to test field_mod. - Version 4\n\nCorrect error in the test for field_mod. The sqr operation isn't necessarily a sqr mod operation. The test will fail when the montgomery prime method is used.", "author": "rrelyea@redhat.com", "tags": [], "raw_text": "Correct error in the test for field_mod. The sqr operation isn't necessarily a sqr mod operation. The test will fail when the montgomery prime method is used.", "bug_id": 653032, "creation_time": "2012-05-03T18:48:56Z", "is_private": false, "id": 6277555, "time": "2012-05-03T18:48:56Z"}, {"time": "2012-05-03T18:49:21Z", "id": 6277558, "is_private": false, "creation_time": "2012-05-03T18:49:21Z", "bug_id": 653032, "raw_text": " clearing review field.", "tags": [], "author": "rrelyea@redhat.com", "text": "Comment on attachment 529160\nPatch to P192, P256, and P521 mod functions.\n\n clearing review field.", "count": 16, "attachment_id": 529160, "creator": "rrelyea@redhat.com"}, {"creator": "rrelyea@redhat.com", "attachment_id": 620797, "text": "Created attachment 620797\nPatch to P192, P224, and P521 mod functions\n\nHere's my perferred patch for the issue.", "count": 17, "author": "rrelyea@redhat.com", "tags": [], "raw_text": "Here's my perferred patch for the issue.", "creation_time": "2012-05-03T18:52:10Z", "bug_id": 653032, "is_private": false, "id": 6277573, "time": "2012-05-03T18:52:10Z"}, {"creator": "rrelyea@redhat.com", "attachment_id": 620797, "text": "Comment on attachment 620797\nPatch to P192, P224, and P521 mod functions\n\nOscar, can you verify that my changes are equivalent to yours.\n\nI found they passed both 64 and 32 bit versions of your test program.", "count": 18, "author": "rrelyea@redhat.com", "raw_text": "Oscar, can you verify that my changes are equivalent to yours.\n\nI found they passed both 64 and 32 bit versions of your test program.", "creation_time": "2012-05-03T18:55:50Z", "bug_id": 653032, "tags": [], "is_private": false, "time": "2012-05-03T18:55:50Z", "id": 6277590}, {"id": 6277609, "time": "2012-05-03T19:01:21Z", "author": "rrelyea@redhat.com", "count": 19, "text": "Also, I have some more info on both p384 and the effects of this patch on mozilla.\n\n1) Evidently the p384 code has is not used at all. p384 always uses the general montgomery prime field functions (probably because we determined it was faster than the unoptimized p384 fields). If someone wanted to supply a patch to optimize the p384 code, they would also have to  update ecgroup_fromNameAndHex() in ecl.c to use the optimized functions.\n\n2) even for p256 and p521, mozilla does not use the optimized curve functions. Mozilla always uses the general montgomery prime field functions for p384, p256, and p521 so there is not mozilla related security issue here.\n\nbob", "attachment_id": null, "is_private": false, "tags": [], "creator": "rrelyea@redhat.com", "bug_id": 653032, "creation_time": "2012-05-03T19:01:21Z", "raw_text": "Also, I have some more info on both p384 and the effects of this patch on mozilla.\n\n1) Evidently the p384 code has is not used at all. p384 always uses the general montgomery prime field functions (probably because we determined it was faster than the unoptimized p384 fields). If someone wanted to supply a patch to optimize the p384 code, they would also have to  update ecgroup_fromNameAndHex() in ecl.c to use the optimized functions.\n\n2) even for p256 and p521, mozilla does not use the optimized curve functions. Mozilla always uses the general montgomery prime field functions for p384, p256, and p521 so there is not mozilla related security issue here.\n\nbob"}, {"id": 6277618, "time": "2012-05-03T19:02:56Z", "tags": [], "raw_text": "> Oscar, can you verify that my changes are equivalent to yours.\n^Oscar^Owen\n\nbob", "creation_time": "2012-05-03T19:02:56Z", "bug_id": 653032, "is_private": false, "count": 20, "text": "> Oscar, can you verify that my changes are equivalent to yours.\n^Oscar^Owen\n\nbob", "author": "rrelyea@redhat.com", "creator": "rrelyea@redhat.com", "attachment_id": null}, {"tags": [], "creation_time": "2012-06-28T00:55:21Z", "bug_id": 653032, "raw_text": "Ping Owen, are you still interested in this bug?\n\nbob", "is_private": false, "id": 6429196, "time": "2012-06-28T00:55:21Z", "creator": "rrelyea@redhat.com", "attachment_id": null, "text": "Ping Owen, are you still interested in this bug?\n\nbob", "count": 21, "author": "rrelyea@redhat.com"}, {"text": "I have confirmed that Bob's patch is functionally equivalent to mine.", "count": 22, "author": "osk@exegin.com", "creator": "osk@exegin.com", "attachment_id": null, "id": 6494212, "time": "2012-07-21T17:44:39Z", "tags": [], "bug_id": 653032, "creation_time": "2012-07-21T17:44:39Z", "raw_text": "I have confirmed that Bob's patch is functionally equivalent to mine.", "is_private": false}, {"id": 6497133, "time": "2012-07-23T17:35:20Z", "author": "osk@exegin.com", "text": "Comment on attachment 620797\nPatch to P192, P224, and P521 mod functions\n\nReview of attachment 620797:\n-----------------------------------------------------------------\n\nThis patch is equivalent to mine. Looks good.", "count": 23, "attachment_id": 620797, "is_private": false, "tags": [], "creator": "osk@exegin.com", "creation_time": "2012-07-23T17:35:20Z", "bug_id": 653032, "raw_text": "Review of attachment 620797:\n-----------------------------------------------------------------\n\nThis patch is equivalent to mine. Looks good."}, {"is_private": false, "raw_text": "Checking in ecp_192.c;\n/cvsroot/mozilla/security/nss/lib/freebl/ecl/ecp_192.c,v  <--  ecp_192.c\nnew revision: 1.7; previous revision: 1.6\ndone\nChecking in ecp_224.c;\n/cvsroot/mozilla/security/nss/lib/freebl/ecl/ecp_224.c,v  <--  ecp_224.c\nnew revision: 1.8; previous revision: 1.7\ndone\nChecking in ecp_521.c;\n/cvsroot/mozilla/security/nss/lib/freebl/ecl/ecp_521.c,v  <--  ecp_521.c\nnew revision: 1.3; previous revision: 1.2\ndone", "bug_id": 653032, "creation_time": "2012-07-26T19:20:02Z", "tags": [], "time": "2012-07-26T19:20:02Z", "id": 6508825, "attachment_id": null, "creator": "rrelyea@redhat.com", "author": "rrelyea@redhat.com", "count": 24, "text": "Checking in ecp_192.c;\n/cvsroot/mozilla/security/nss/lib/freebl/ecl/ecp_192.c,v  <--  ecp_192.c\nnew revision: 1.7; previous revision: 1.6\ndone\nChecking in ecp_224.c;\n/cvsroot/mozilla/security/nss/lib/freebl/ecl/ecp_224.c,v  <--  ecp_224.c\nnew revision: 1.8; previous revision: 1.7\ndone\nChecking in ecp_521.c;\n/cvsroot/mozilla/security/nss/lib/freebl/ecl/ecp_521.c,v  <--  ecp_521.c\nnew revision: 1.3; previous revision: 1.2\ndone"}, {"tags": [], "raw_text": "Owen, thanks for the bug, patch and review.\n\nbob", "creation_time": "2012-07-26T19:20:27Z", "bug_id": 653032, "is_private": false, "id": 6508826, "time": "2012-07-26T19:20:27Z", "creator": "rrelyea@redhat.com", "attachment_id": null, "text": "Owen, thanks for the bug, patch and review.\n\nbob", "count": 25, "author": "rrelyea@redhat.com"}, {"time": "2012-07-26T21:22:57Z", "id": 6509377, "raw_text": "marking r+ based on owen's comments. Clearing wtc. Wan-Teh, you can still review this if you want to, but it's not necessary so I'm removing it as noice in your review list.\n\nbob", "creation_time": "2012-07-26T21:22:57Z", "bug_id": 653032, "tags": [], "is_private": false, "text": "Comment on attachment 620797\nPatch to P192, P224, and P521 mod functions\n\nmarking r+ based on owen's comments. Clearing wtc. Wan-Teh, you can still review this if you want to, but it's not necessary so I'm removing it as noice in your review list.\n\nbob", "count": 26, "author": "rrelyea@redhat.com", "creator": "rrelyea@redhat.com", "attachment_id": 620797}, {"time": "2012-07-26T21:37:33Z", "id": 6509440, "bug_id": 653032, "creation_time": "2012-07-26T21:37:33Z", "raw_text": "Review of attachment 620797:\n-----------------------------------------------------------------\n\n::: ecp_192.c\n@@ +123,4 @@\n>  \t\t\t\t\t(r0b == 0xffffffff)) ) {\n>  \t\t\t/* do a quick subtract */\n>  \t\t\tMP_ADD_CARRY(r0a, 1, r0a, 0, carry);\n> +\t\t\tMP_ADD_CARRY(r0b, carry, r0a, 0, carry);\n\n1. Should the third argument of this MP_ADD_CARRY call be r0b instead of r0a?\n\nI don't understand this patch, but I observed that we pass the same variable\nto all but three of the MP_ADD_CARRY calls in this file.  So this new MP_ADD_CARRY\ndoes not match that pattern.\n\n2. The roles of the second and fourth arguments to MP_ADD_CARRY seem interchangeable.\nIf so, it would look nicer to pass 0 as the second argument and 'carry' as the fourth\nargument, because the fourth argument is 'cin' (for \"input carry\").\n\nIn summary, I guess this new MP_ADD_CARRY call should be\n    MP_ADD_CARRY(r0b, 0, r0b, carry, carry);\n\nI found many existing MP_ADD_CARRY calls that match this pattern:\n    MP_ADD_CARRY(x, 0, x, carry, carry);", "tags": [], "is_private": false, "count": 27, "text": "Comment on attachment 620797\nPatch to P192, P224, and P521 mod functions\n\nReview of attachment 620797:\n-----------------------------------------------------------------\n\n::: ecp_192.c\n@@ +123,4 @@\n>  \t\t\t\t\t(r0b == 0xffffffff)) ) {\n>  \t\t\t/* do a quick subtract */\n>  \t\t\tMP_ADD_CARRY(r0a, 1, r0a, 0, carry);\n> +\t\t\tMP_ADD_CARRY(r0b, carry, r0a, 0, carry);\n\n1. Should the third argument of this MP_ADD_CARRY call be r0b instead of r0a?\n\nI don't understand this patch, but I observed that we pass the same variable\nto all but three of the MP_ADD_CARRY calls in this file.  So this new MP_ADD_CARRY\ndoes not match that pattern.\n\n2. The roles of the second and fourth arguments to MP_ADD_CARRY seem interchangeable.\nIf so, it would look nicer to pass 0 as the second argument and 'carry' as the fourth\nargument, because the fourth argument is 'cin' (for \"input carry\").\n\nIn summary, I guess this new MP_ADD_CARRY call should be\n    MP_ADD_CARRY(r0b, 0, r0b, carry, carry);\n\nI found many existing MP_ADD_CARRY calls that match this pattern:\n    MP_ADD_CARRY(x, 0, x, carry, carry);", "author": "wtc@google.com", "creator": "wtc@google.com", "attachment_id": 620797}, {"tags": [], "creator": "rrelyea@redhat.com", "creation_time": "2012-07-27T01:36:33Z", "bug_id": 653032, "raw_text": "> Should the third argument of this MP_ADD_CARRY call be r0b instead of r0a?\n\nyes\n\n> The roles of the second and fourth arguments to MP_ADD_CARRY seem interchangeable.\n\nyes, though your suggested change fits better. We are actually carrying rather than happening to add 1 if there is a carry.\n\nbob", "attachment_id": null, "is_private": false, "text": "> Should the third argument of this MP_ADD_CARRY call be r0b instead of r0a?\n\nyes\n\n> The roles of the second and fourth arguments to MP_ADD_CARRY seem interchangeable.\n\nyes, though your suggested change fits better. We are actually carrying rather than happening to add 1 if there is a carry.\n\nbob", "count": 28, "id": 6510257, "time": "2012-07-27T01:36:33Z", "author": "rrelyea@redhat.com"}, {"id": 6510262, "time": "2012-07-27T01:37:25Z", "is_private": false, "tags": [], "bug_id": 653032, "creation_time": "2012-07-27T01:37:25Z", "raw_text": "r- based on wtc's comments.\n\nI'm glad you reviewed this Wan-Teh.", "author": "rrelyea@redhat.com", "count": 29, "text": "Comment on attachment 620797\nPatch to P192, P224, and P521 mod functions\n\nr- based on wtc's comments.\n\nI'm glad you reviewed this Wan-Teh.", "attachment_id": 620797, "creator": "rrelyea@redhat.com"}, {"time": "2012-07-27T01:50:45Z", "id": 6510293, "raw_text": "> I don't understand this patch, but I observed that we pass the same variable\n> to all but three of the MP_ADD_CARRY calls in this file. \n\nyes, it's a bit tricky. What is going on here is a fast modulo reduction. The prime is 2^192 - 2^64 -1. The code above where we are is using a set of adds and shifts to reduce this number to a number that is 192 bits long. At this point we should already be less than 2^192 - 2^64 -1 except for some corner cases. If we hit this corner case, we need to subtract 2^192 - 2^64-1, we can do this quickly by adding the compliment 1 + 2^64. We know r2b, r2a, and r1b are all 0xfffff...ffff, and that there will be a carry out from r1a. The bug here was 2 fold: 1 we weren't carrying from r0a to r0b. Since r0a could be 0xffff.ffffff, this would give the wrong results. Also we weren't adding 1 to r1a (that is adding 2^64), and just assuming r1a was always zero, but there is one case (2^192-1) where r1a winds up as '1'.", "bug_id": 653032, "creation_time": "2012-07-27T01:50:45Z", "tags": [], "is_private": false, "count": 30, "text": "> I don't understand this patch, but I observed that we pass the same variable\n> to all but three of the MP_ADD_CARRY calls in this file. \n\nyes, it's a bit tricky. What is going on here is a fast modulo reduction. The prime is 2^192 - 2^64 -1. The code above where we are is using a set of adds and shifts to reduce this number to a number that is 192 bits long. At this point we should already be less than 2^192 - 2^64 -1 except for some corner cases. If we hit this corner case, we need to subtract 2^192 - 2^64-1, we can do this quickly by adding the compliment 1 + 2^64. We know r2b, r2a, and r1b are all 0xfffff...ffff, and that there will be a carry out from r1a. The bug here was 2 fold: 1 we weren't carrying from r0a to r0b. Since r0a could be 0xffff.ffffff, this would give the wrong results. Also we weren't adding 1 to r1a (that is adding 2^64), and just assuming r1a was always zero, but there is one case (2^192-1) where r1a winds up as '1'.", "author": "rrelyea@redhat.com", "creator": "rrelyea@redhat.com", "attachment_id": null}, {"is_private": false, "attachment_id": null, "tags": [], "creator": "wtc@google.com", "creation_time": "2012-07-27T17:57:58Z", "bug_id": 653032, "raw_text": "Bob: thank you for the explanation.  I believe I understand the problems with ecp_192.c now,\nexcept the need the for s_mp_clamp() call. But the s_mp_clamp() call seems harmless.\n\nJust to confirm my understanding: you said:\n    ..., but there is one case (2^192-1) where r1a winds up as '1'.\n\nIs that case r2 == r1 == r0 == 0xfffffffffffffffff?", "id": 6512140, "time": "2012-07-27T17:57:58Z", "author": "wtc@google.com", "count": 31, "text": "Bob: thank you for the explanation.  I believe I understand the problems with ecp_192.c now,\nexcept the need the for s_mp_clamp() call. But the s_mp_clamp() call seems harmless.\n\nJust to confirm my understanding: you said:\n    ..., but there is one case (2^192-1) where r1a winds up as '1'.\n\nIs that case r2 == r1 == r0 == 0xfffffffffffffffff?"}, {"creator": "rrelyea@redhat.com", "attachment_id": null, "count": 32, "text": "> I believe I understand the problems with ecp_192.c now,\n>except the need the for s_mp_clamp() call. But the s_mp_clamp() call seems harmless.\n\nclamp will update the mpi variable's length, dropping leading zeros. If your calculation leads to leading zeros you need to call clap (This is definately true in the case we are describing. It's true in other cases as well.\n\n> Is that case r2 == r1 == r0 == 0xfffffffffffffffff?\nyes, r0 is the least significant work, r1 is the next r2 is the most significant word. In the case where we have r0a r0b, the word size is half of the 64 bit word size, so r0b||r0a = r0.\n\nbob", "author": "rrelyea@redhat.com", "creation_time": "2012-07-27T22:55:24Z", "bug_id": 653032, "raw_text": "> I believe I understand the problems with ecp_192.c now,\n>except the need the for s_mp_clamp() call. But the s_mp_clamp() call seems harmless.\n\nclamp will update the mpi variable's length, dropping leading zeros. If your calculation leads to leading zeros you need to call clap (This is definately true in the case we are describing. It's true in other cases as well.\n\n> Is that case r2 == r1 == r0 == 0xfffffffffffffffff?\nyes, r0 is the least significant work, r1 is the next r2 is the most significant word. In the case where we have r0a r0b, the word size is half of the 64 bit word size, so r0b||r0a = r0.\n\nbob", "tags": [], "is_private": false, "time": "2012-07-27T22:55:24Z", "id": 6513189}]}}}