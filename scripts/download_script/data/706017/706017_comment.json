{"bugs": {"706017": {"comments": [{"is_private": false, "creator": "m_kato@ga2.so-net.ne.jp", "count": 0, "creation_time": "2011-11-29T09:09:50Z", "author": "m_kato@ga2.so-net.ne.jp", "text": "Created attachment 577514\ntest case v1", "tags": [], "time": "2011-11-29T09:09:50Z", "bug_id": 706017, "attachment_id": 577514, "raw_text": "", "id": 5878226}, {"raw_text": "This is great stuff! All our migration code needs more tests, this is a good start.", "attachment_id": null, "id": 5879283, "count": 1, "creator": "gavin.sharp@gmail.com", "is_private": false, "tags": [], "bug_id": 706017, "time": "2011-11-29T18:24:12Z", "text": "This is great stuff! All our migration code needs more tests, this is a good start.", "author": "gavin.sharp@gmail.com", "creation_time": "2011-11-29T18:24:12Z"}, {"text": "should make sure bug 706339 is covered, too :)", "tags": [], "bug_id": 706017, "time": "2011-11-30T02:27:58Z", "creation_time": "2011-11-30T02:27:58Z", "author": "gavin.sharp@gmail.com", "count": 2, "is_private": false, "creator": "gavin.sharp@gmail.com", "id": 5881020, "raw_text": "should make sure bug 706339 is covered, too :)", "attachment_id": null}, {"count": 3, "creator": "m_kato@ga2.so-net.ne.jp", "is_private": false, "tags": [], "time": "2011-12-02T01:31:34Z", "bug_id": 706017, "text": "Created attachment 578454\nv2", "author": "m_kato@ga2.so-net.ne.jp", "creation_time": "2011-12-02T01:31:34Z", "raw_text": "", "attachment_id": 578454, "id": 5887158}, {"author": "mak@mozilla.com", "creation_time": "2011-12-07T01:30:17Z", "time": "2011-12-07T01:30:17Z", "tags": [], "text": "I'll review this tomorrow, sorry for late, network bustages didn't help.\n\nAs a side note, even doing this kind of testing (that, just to be clear, is absolutely welcome!), we won't be able to catch regressions when other vendors will update their browsers. I suspect we'll always hit cases where handling a failure will be late, since we'll get a bug filed when users are already unable to migrate by some time.\nA possible thing we may do, could be to add telemetry for migration failures per browser vendor and keep an eye on it, seeing large increase of failures may mean something changed and we could maybe anticipate fixes.\nThoughts?", "creator": "mak@mozilla.com", "is_private": false, "id": 5896286, "attachment_id": null, "raw_text": "I'll review this tomorrow, sorry for late, network bustages didn't help.\n\nAs a side note, even doing this kind of testing (that, just to be clear, is absolutely welcome!), we won't be able to catch regressions when other vendors will update their browsers. I suspect we'll always hit cases where handling a failure will be late, since we'll get a bug filed when users are already unable to migrate by some time.\nA possible thing we may do, could be to add telemetry for migration failures per browser vendor and keep an eye on it, seeing large increase of failures may mean something changed and we could maybe anticipate fixes.\nThoughts?", "bug_id": 706017, "count": 4}, {"raw_text": "Review of attachment 578454:\n-----------------------------------------------------------------\n\nClearing, since this needs another iteration.\n\nI'm mostly thinking of ways to make this harness more modular, especially regarding multiple versions of the same browser.\nIssues:\n- we may have chrome11 and chrome 24 (guessing numbers) with different formats, and having to test both.\n- now that we will add ie, safari and opera, the head will blow up with setup and cleanup methods.\n\nA possible idea I was wondering about may be to do this:\n- call tests as test_browserversion_name.js, like test_chrome11_history.js\n- have needed data inside a browserversion named folder, like in chrome11/\n- inside the data folder have a head.js file doing any setup and cleanup needed\n- head_migration.js would extract chrome11 (or whatever name) from the current test name, loadSubscript chrome11/head.js into itself, register data files that are inside chrome11/, and proceed with the test.\n\nSo the structure would be like:\nchrome11/\n  head.js\n  History\nie10/\n  head.js\n  Whatever\nhead_migration.js\ntest_chrome11_history.js\ntest_ie10_history.js\n\nAn alternative may be the classic separation like tests/chrome11/, tests/ie10/... with a tests/head_common.js for shared stuff.\nwhat do you think?\n\n::: browser/components/migration/tests/unit/head_migration.js\n@@ +56,5 @@\n> +  let file = Services.dirsvc.get('ProfD', Ci.nsIFile);\n> +  file.append(\"places.sqlite\");\n> +  if (file.exists())\n> +    file.remove(false);\n> +} catch(ex) { dump(\"Exception: \" + ex); }\n\ns/dump/print/\n\n@@ +77,5 @@\n> +    },\n> +    QueryInterface: XPCOMUtils.generateQI([Ci.nsIDirectoryServiceProvider]),\n> +  });\n> +\n> +// setup google chrome profile from data\n\nplease make this a proper javadoc\n\n@@ +78,5 @@\n> +    QueryInterface: XPCOMUtils.generateQI([Ci.nsIDirectoryServiceProvider]),\n> +  });\n> +\n> +// setup google chrome profile from data\n> +function setup_chormeMigration() {\n\ntypo: chorme (also in all the call points)\n\n@@ +80,5 @@\n> +\n> +// setup google chrome profile from data\n> +function setup_chormeMigration() {\n> +  let fileFrom = do_get_file(\"data\");\n> +  let fileTo = fileFrom.clone();\n\nShould this copy to another folder? do_get_file afaict gives a nsIFile pointing to the in-tree content, we should never touch in-tree content for xpcshell-tests convention.\nI'd be fine with us making a temporary folder inside gProfD, it will go away magically when the profile is discarded by the harness, rather than forcing us to clean it up. may simplify some of the code here since each test has its own profile.\n\n@@ +93,5 @@\n> +    } catch (e) {\n> +    }\n> +    fileTo.append(\"Chrome\");\n> +    fileTo.append(\"User Data\");\n> +    fileTo.create(fileTo.DIRECTORY_TYPE, 0755);\n\noctals do warn, but you can use parseInt(\"0755\") to avoid that\n\n@@ +114,5 @@\n> +    fileTo.append(\"google-chrome\");\n> +    fileTo.create(fileTo.DIRECTORY_TYPE, 0755);\n> +  }\n> +\n> +  fileFrom.copyTo(fileTo, null);\n\nMay be safer to use copyToFollowingLinks, I think linux may be using some symlinks (don't remember correctly)\n\n::: browser/components/migration/tests/unit/test_chromeBookmarks.js\n@@ +45,5 @@\n> +];\n> +\n> +var gTestCount = 0;\n> +\n> +let observer = {\n\nnit: please don't mixup let and var\n\n@@ +70,5 @@\n> +  {\n> +    if (uri == null) {\n> +      // ignore for folder\n> +      return;\n> +    }\n\nwell, you may check title for folders, at least.\nYou can use itemType to differentiate the checks.\n\n@@ +91,5 @@\n> +\n> +function run_test() {\n> +  setup_chormeMigration();\n> +  Services.obs.addObserver(observer, \"Migration:Ended\", false);\n> +  PlacesUtils.bookmarks.addObserver(bmObserver, false);\n\nThis should be removed somewhere\n\n@@ +99,5 @@\n> +  do_check_eq(migrator.sourceExists, true);\n> +  do_check_eq(migrator.getMigrateData(null, false) & Ci.nsIBrowserProfileMigrator.BOOKMARKS,\n> +              Ci.nsIBrowserProfileMigrator.BOOKMARKS);\n> +  migrator.migrate(Ci.nsIBrowserProfileMigrator.BOOKMARKS, null, \"\");\n> +  run_next_test();\n\nrun_next_test makes sense when you use add_test, in this case a do_test_pending would make more sense\n\n::: browser/components/migration/tests/unit/test_chromeCookies.js\n@@ +53,5 @@\n> +\n> +    let cs = Cc[\"@mozilla.org/cookieService;1\"].getService(Ci.nsICookieService);\n> +\n> +    for (let i = 0; i < gTestList.length; i++) {\n> +      do_check_eq(cs.getCookieString(NetUtil.newURI(gTestList[i].uri), null, null), gTestList[i].value);\n\nwell, also cookies are asynchronous, but in this case I think it may work since they use a synchronous buffer hash and just write asynchronously.\n\n@@ +76,5 @@\n> +  do_check_eq(migrator.sourceExists, true);\n> +  do_check_eq(migrator.getMigrateData(null, false) & Ci.nsIBrowserProfileMigrator.COOKIES,\n> +              Ci.nsIBrowserProfileMigrator.COOKIES);\n> +  migrator.migrate(Ci.nsIBrowserProfileMigrator.COOKIES, null, \"\");\n> +  run_next_test();\n\nditto on do_test_pending\n\n::: browser/components/migration/tests/unit/test_chromeHistory.js\n@@ +62,5 @@\n> +      let node = root.getChild(i);\n> +      do_check_eq(node.uri, gTestList[i].uri);\n> +      do_check_eq(node.title, gTestList[i].title);\n> +      do_check_eq(node.time, gTestList[i].time);\n> +    }\n\nplease close the container.\n\nfwiw, you may have used a nsNavHistoryObserver here like you did for bookmarks...\nactually I'm not sure this works at all since history addition is asynchronous and doesn't look like you are really waiting for it, the observer approach may be better.\n\n@@ +84,5 @@\n> +  do_check_eq(migrator.sourceExists, true);\n> +  do_check_eq(migrator.getMigrateData(null, false) & Ci.nsIBrowserProfileMigrator.HISTORY,\n> +              Ci.nsIBrowserProfileMigrator.HISTORY);\n> +  migrator.migrate(Ci.nsIBrowserProfileMigrator.HISTORY, null, \"\");\n> +  run_next_test();\n\nditto on using do_test_pending unless you use add_test\n\n::: browser/components/migration/tests/unit/test_profile.js\n@@ +33,5 @@\n> + * and other provisions required by the GPL or the LGPL. If you do not delete\n> + * the provisions above, a recipient may use your version of this file under\n> + * the terms of any one of the MPL, the GPL or the LGPL.\n> + *\n> + * ***** END LICENSE BLOCK ***** */\n\nAs a side note, in case you don't know, in tests we can use the much shorter pd license http://www.mozilla.org/MPL/boilerplate-1.1/pd-c\nit's a more liberal license, so if you don't agree with it you don't have to use it, but it's an option.\n\n@@ +36,5 @@\n> + *\n> + * ***** END LICENSE BLOCK ***** */\n> +\n> +Cu.import(\"resource://gre/modules/NetUtil.jsm\");\n> +Cu.import(\"resource://gre/modules/PlacesUtils.jsm\");\n\nMove these to defineLazyModuleGetters in head_migration.js, so that any test will have them in scope.\n\n@@ +40,5 @@\n> +Cu.import(\"resource://gre/modules/PlacesUtils.jsm\");\n> +\n> +\n> +function run_test() {\n> +  // don't detect chrome since no profile\n\nAdding a multi-line comment at the top of each test file (after the license), explaining the test scope, would be really appreciated.\n\n@@ +41,5 @@\n> +\n> +\n> +function run_test() {\n> +  // don't detect chrome since no profile\n> +  cleanup_chromeMigration();\n\nfwiw, this should be handled by the head file, not by the test (do_register_cleanup inside setup_chromeMigration() would do that, but as I said I think we may not need cleanup better using folders)\n\n@@ +54,5 @@\n> +             createInstance(Ci.nsIBrowserProfileMigrator);\n> +\n> +  do_check_eq(migrator.sourceExists, true);\n> +\n> +  do_test_finished();\n\nI don't see a corresponding call to do_test_pending(), so this looks useless.", "attachment_id": 578454, "id": 5897426, "count": 5, "creator": "mak@mozilla.com", "is_private": false, "bug_id": 706017, "time": "2011-12-07T16:20:10Z", "tags": [], "text": "Comment on attachment 578454\nv2\n\nReview of attachment 578454:\n-----------------------------------------------------------------\n\nClearing, since this needs another iteration.\n\nI'm mostly thinking of ways to make this harness more modular, especially regarding multiple versions of the same browser.\nIssues:\n- we may have chrome11 and chrome 24 (guessing numbers) with different formats, and having to test both.\n- now that we will add ie, safari and opera, the head will blow up with setup and cleanup methods.\n\nA possible idea I was wondering about may be to do this:\n- call tests as test_browserversion_name.js, like test_chrome11_history.js\n- have needed data inside a browserversion named folder, like in chrome11/\n- inside the data folder have a head.js file doing any setup and cleanup needed\n- head_migration.js would extract chrome11 (or whatever name) from the current test name, loadSubscript chrome11/head.js into itself, register data files that are inside chrome11/, and proceed with the test.\n\nSo the structure would be like:\nchrome11/\n  head.js\n  History\nie10/\n  head.js\n  Whatever\nhead_migration.js\ntest_chrome11_history.js\ntest_ie10_history.js\n\nAn alternative may be the classic separation like tests/chrome11/, tests/ie10/... with a tests/head_common.js for shared stuff.\nwhat do you think?\n\n::: browser/components/migration/tests/unit/head_migration.js\n@@ +56,5 @@\n> +  let file = Services.dirsvc.get('ProfD', Ci.nsIFile);\n> +  file.append(\"places.sqlite\");\n> +  if (file.exists())\n> +    file.remove(false);\n> +} catch(ex) { dump(\"Exception: \" + ex); }\n\ns/dump/print/\n\n@@ +77,5 @@\n> +    },\n> +    QueryInterface: XPCOMUtils.generateQI([Ci.nsIDirectoryServiceProvider]),\n> +  });\n> +\n> +// setup google chrome profile from data\n\nplease make this a proper javadoc\n\n@@ +78,5 @@\n> +    QueryInterface: XPCOMUtils.generateQI([Ci.nsIDirectoryServiceProvider]),\n> +  });\n> +\n> +// setup google chrome profile from data\n> +function setup_chormeMigration() {\n\ntypo: chorme (also in all the call points)\n\n@@ +80,5 @@\n> +\n> +// setup google chrome profile from data\n> +function setup_chormeMigration() {\n> +  let fileFrom = do_get_file(\"data\");\n> +  let fileTo = fileFrom.clone();\n\nShould this copy to another folder? do_get_file afaict gives a nsIFile pointing to the in-tree content, we should never touch in-tree content for xpcshell-tests convention.\nI'd be fine with us making a temporary folder inside gProfD, it will go away magically when the profile is discarded by the harness, rather than forcing us to clean it up. may simplify some of the code here since each test has its own profile.\n\n@@ +93,5 @@\n> +    } catch (e) {\n> +    }\n> +    fileTo.append(\"Chrome\");\n> +    fileTo.append(\"User Data\");\n> +    fileTo.create(fileTo.DIRECTORY_TYPE, 0755);\n\noctals do warn, but you can use parseInt(\"0755\") to avoid that\n\n@@ +114,5 @@\n> +    fileTo.append(\"google-chrome\");\n> +    fileTo.create(fileTo.DIRECTORY_TYPE, 0755);\n> +  }\n> +\n> +  fileFrom.copyTo(fileTo, null);\n\nMay be safer to use copyToFollowingLinks, I think linux may be using some symlinks (don't remember correctly)\n\n::: browser/components/migration/tests/unit/test_chromeBookmarks.js\n@@ +45,5 @@\n> +];\n> +\n> +var gTestCount = 0;\n> +\n> +let observer = {\n\nnit: please don't mixup let and var\n\n@@ +70,5 @@\n> +  {\n> +    if (uri == null) {\n> +      // ignore for folder\n> +      return;\n> +    }\n\nwell, you may check title for folders, at least.\nYou can use itemType to differentiate the checks.\n\n@@ +91,5 @@\n> +\n> +function run_test() {\n> +  setup_chormeMigration();\n> +  Services.obs.addObserver(observer, \"Migration:Ended\", false);\n> +  PlacesUtils.bookmarks.addObserver(bmObserver, false);\n\nThis should be removed somewhere\n\n@@ +99,5 @@\n> +  do_check_eq(migrator.sourceExists, true);\n> +  do_check_eq(migrator.getMigrateData(null, false) & Ci.nsIBrowserProfileMigrator.BOOKMARKS,\n> +              Ci.nsIBrowserProfileMigrator.BOOKMARKS);\n> +  migrator.migrate(Ci.nsIBrowserProfileMigrator.BOOKMARKS, null, \"\");\n> +  run_next_test();\n\nrun_next_test makes sense when you use add_test, in this case a do_test_pending would make more sense\n\n::: browser/components/migration/tests/unit/test_chromeCookies.js\n@@ +53,5 @@\n> +\n> +    let cs = Cc[\"@mozilla.org/cookieService;1\"].getService(Ci.nsICookieService);\n> +\n> +    for (let i = 0; i < gTestList.length; i++) {\n> +      do_check_eq(cs.getCookieString(NetUtil.newURI(gTestList[i].uri), null, null), gTestList[i].value);\n\nwell, also cookies are asynchronous, but in this case I think it may work since they use a synchronous buffer hash and just write asynchronously.\n\n@@ +76,5 @@\n> +  do_check_eq(migrator.sourceExists, true);\n> +  do_check_eq(migrator.getMigrateData(null, false) & Ci.nsIBrowserProfileMigrator.COOKIES,\n> +              Ci.nsIBrowserProfileMigrator.COOKIES);\n> +  migrator.migrate(Ci.nsIBrowserProfileMigrator.COOKIES, null, \"\");\n> +  run_next_test();\n\nditto on do_test_pending\n\n::: browser/components/migration/tests/unit/test_chromeHistory.js\n@@ +62,5 @@\n> +      let node = root.getChild(i);\n> +      do_check_eq(node.uri, gTestList[i].uri);\n> +      do_check_eq(node.title, gTestList[i].title);\n> +      do_check_eq(node.time, gTestList[i].time);\n> +    }\n\nplease close the container.\n\nfwiw, you may have used a nsNavHistoryObserver here like you did for bookmarks...\nactually I'm not sure this works at all since history addition is asynchronous and doesn't look like you are really waiting for it, the observer approach may be better.\n\n@@ +84,5 @@\n> +  do_check_eq(migrator.sourceExists, true);\n> +  do_check_eq(migrator.getMigrateData(null, false) & Ci.nsIBrowserProfileMigrator.HISTORY,\n> +              Ci.nsIBrowserProfileMigrator.HISTORY);\n> +  migrator.migrate(Ci.nsIBrowserProfileMigrator.HISTORY, null, \"\");\n> +  run_next_test();\n\nditto on using do_test_pending unless you use add_test\n\n::: browser/components/migration/tests/unit/test_profile.js\n@@ +33,5 @@\n> + * and other provisions required by the GPL or the LGPL. If you do not delete\n> + * the provisions above, a recipient may use your version of this file under\n> + * the terms of any one of the MPL, the GPL or the LGPL.\n> + *\n> + * ***** END LICENSE BLOCK ***** */\n\nAs a side note, in case you don't know, in tests we can use the much shorter pd license http://www.mozilla.org/MPL/boilerplate-1.1/pd-c\nit's a more liberal license, so if you don't agree with it you don't have to use it, but it's an option.\n\n@@ +36,5 @@\n> + *\n> + * ***** END LICENSE BLOCK ***** */\n> +\n> +Cu.import(\"resource://gre/modules/NetUtil.jsm\");\n> +Cu.import(\"resource://gre/modules/PlacesUtils.jsm\");\n\nMove these to defineLazyModuleGetters in head_migration.js, so that any test will have them in scope.\n\n@@ +40,5 @@\n> +Cu.import(\"resource://gre/modules/PlacesUtils.jsm\");\n> +\n> +\n> +function run_test() {\n> +  // don't detect chrome since no profile\n\nAdding a multi-line comment at the top of each test file (after the license), explaining the test scope, would be really appreciated.\n\n@@ +41,5 @@\n> +\n> +\n> +function run_test() {\n> +  // don't detect chrome since no profile\n> +  cleanup_chromeMigration();\n\nfwiw, this should be handled by the head file, not by the test (do_register_cleanup inside setup_chromeMigration() would do that, but as I said I think we may not need cleanup better using folders)\n\n@@ +54,5 @@\n> +             createInstance(Ci.nsIBrowserProfileMigrator);\n> +\n> +  do_check_eq(migrator.sourceExists, true);\n> +\n> +  do_test_finished();\n\nI don't see a corresponding call to do_test_pending(), so this looks useless.", "author": "mak@mozilla.com", "creation_time": "2011-12-07T16:20:10Z"}]}}, "comments": {}}